<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="跨域,CORS,JSONP," />










<meta name="description" content="现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的 showUser()方法确实被执行了，所以，到这里我们可以对 JSONP 做一个简单总结：**JSONP 是一种利用 script 标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的 JavaScript，客户端需要事先定义好接收数据的方法，两者通过 callback 参数建立起联系，返回类似 callback">
<meta property="og:type" content="article">
<meta property="og:title" content="聊聊前端跨域的爱恨情仇">
<meta property="og:url" content="https://blog.feedscoin.com/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的 showUser()方法确实被执行了，所以，到这里我们可以对 JSONP 做一个简单总结：**JSONP 是一种利用 script 标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的 JavaScript，客户端需要事先定义好接收数据的方法，两者通过 callback 参数建立起联系，返回类似 callback">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhbqwfadj20to02sdfw.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhciom21j211q04lx2k.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhe1rnprj218u08sx6p.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhhcqa78j211s04nq3k.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhf0sls2j21h8090gn0.jpg">
<meta property="og:image" content="https://mdn.mozillademos.org/files/14293/simple_req.png">
<meta property="og:image" content="https://mdn.mozillademos.org/files/14289/prelight.png">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhfm5iprj21h60kcb2d.jpg">
<meta property="article:published_time" content="2019-02-26T07:03:35.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.234Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="跨域">
<meta property="article:tag" content="CORS">
<meta property="article:tag" content="JSONP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g0nhbqwfadj20to02sdfw.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/聊聊前端跨域的爱恨情仇/"/>





  <title>聊聊前端跨域的爱恨情仇 | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">聊聊前端跨域的爱恨情仇</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-26T07:03:35+00:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的 showUser()方法确实被执行了，所以，到这里我们可以对 JSONP 做一个简单总结：**JSONP 是一种利用 script 标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的 JavaScript，客户端需要事先定义好接收数据的方法，两者通过 callback 参数建立起联系，返回类似 callback({"name":"tom",“gender”:"male"})结构的数据，因此 JSONP 请求必然且只能是一个 GET 请求**;其中，JSONP 本质上是返回可以执行的 JS，其基本套路是 callback({"foo":"bar"})，利用了 HTML 中含 src 的属性天生具备跨域能力的“漏洞”，是一种相对"hack"的方案，要求预先定义好 callback，需要改造后端接口，仅支持最简单的 GET 请求;JSONP 实际上返回的是可以执行的 JavaScript，即 text/javascript，它和我们所使用的大多数 JavaScript 并无区别，所以，你可以想到，当我们把一个远程地址赋值给 script 标签的 src 属性时，它和我们引用 CDN 上的医院文件并无区别，这正是 JSONP 的秘密所在，显然它只支持 Get 方式，当我们想要支持更多方式的时候，我们需要的是 CORS，一起来看下面这段代码，我们首先来写一个简单的 API 接口：
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      

        <p>今天是过完春节以后的第二周啦，而我好像终于回到正常工作的状态了呢，因为突然间就对工作产生了厌倦的情绪，Bug 就像无底洞一样吞噬着我的脑细胞。人类就像一颗螺丝钉一样被固定在整部社会机器上，除了要让自己看起来像个正常人一样，还要拼命地让所有人都像个正常人一样。过年刚经历过被催婚的我，面对全人类近乎标准的“幸福”定义，大概就是我此刻这种状态。其实，除了想自己定义“幸福”以外，我还想自己定义“问题”，因为，这样就不会再有“Bug”了。言归正传，今天我想说的是<strong>前端跨域</strong>这个话题，相信读完这篇文章，你就会明白，这个世界上太多太多的问题，都和你毫无瓜葛。</p>
<h1 id="故事缘起"><a href="#故事缘起" class="headerlink" title="故事缘起"></a>故事缘起</h1><p>年前被安排去做一个 GPS 相关的需求，需要通过百度地图 API 来计算预计到达时间，这并不是一个有难点的需求，对吧？就在博主为此而幸灾乐祸的时候，一个非常醒目的错误出现在 Chrome 的控制台中，相信大家都见过无数次啦，大概是说我们的请求受到浏览器的同源策略的限制。那么，第一个问题，什么是同源策略呢？我们知道，一个 URL 通常有以下几部分组成，即协议、域名、端口和请求资源。由此我们就可以引申出同源的概念，当协议、域名和端口都相同时，就认为它们是在同一个域下，即它们同源。相反地，当协议、域名和端口中任意一个都不相同时，就认为它们在不同域下，此时就发生了跨域。按照排列组合，我们可以有以下常见的跨域场景：</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许跨域</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com/a.js">www.abc.com/a.js</a> vs <a target="_blank" rel="noopener" href="http://www.abc.com/b.js">www.abc.com/b.js</a></td>
<td>相同域名下的不同资源</td>
<td>允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com/1/a.js">www.abc.com/1/a.js</a> vs <a target="_blank" rel="noopener" href="http://www.abc.com/2/b.js">www.abc.com/2/b.js</a></td>
<td>相同域名下的不同路径</td>
<td>允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com:8080/a.js">www.abc.com:8080/a.js</a> vs <a target="_blank" rel="noopener" href="http://www.abc.com:8081/b.js">www.abc.com:8081/b.js</a></td>
<td>相同域名下的不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com/">http://www.abc.com</a> vs <a target="_blank" rel="noopener" href="https://www.abc.com/">https://www.abc.com</a></td>
<td>相同域名采用不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com/">http://www.abc.com</a> vs <a target="_blank" rel="noopener" href="http://wtf.abc.com/">http://wtf.abc.com</a></td>
<td>相同域名下的不同子域</td>
<td>不允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.abc.com/">http://www.abc.com</a> vs <a target="_blank" rel="noopener" href="http://www.xyz.com/">http://www.xyz.com</a></td>
<td>两个完全不同的域名</td>
<td>不允许</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://192.168.100.101/">http://192.168.100.101</a> va <a target="_blank" rel="noopener" href="http://www.wtf.com/">http://www.wtf.com</a></td>
<td>域名及其对应的 IP 地址</td>
<td>不允许</td>
</tr>
</tbody></table>
<p>那么，我们就不仅要问啦，现在微服务啊、RESTful 啊这些概念非常流行，在我们实际的工作中，调用第三方的 WebAPI 甚至 WebService，这难道不是非常合理的场景吗？前端的 Ajax，即 XMLHttpRequest，和我们平时用到的 RestSharp、HttpClient、OkHttp 等类似，都可以发起一个 Http 请求，怎么在客户端里用的好好的东西，到了前端这里就突然出来一个<strong>“跨域”</strong>的概念呢？这是因为从原理上来说，这些客户端都是受信的“用户”(<strong>好吧，假装是被信任的</strong>)，而浏览器的环境则是一个<strong>“开放”</strong>的环境。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhbqwfadj20to02sdfw.jpg" alt="URI_Syntax_Diagram"></p>
<p>举一个例子，你在家的时候，可以随意地把手插进自己的口袋，因为这是你的私有环境。可是当你在公共环境中时，你是不允许把手插进别人口袋的。所以，浏览器有“跨域”限制，本质上是为了保护用户的数据安全，避免危险地跨域行为。试想，没有跨域的话，我们带上 Cookie 就可以为所欲为了，不是吗？实际上，同源限制和 JavaScript 没有一丁点关系，因为它是 W3C 中的内容，是浏览器厂商要这样做的，我们的请求其实是被发出去了，而它的响应则被浏览器给拦截了，所以我们在控制台中看到“同源策略限制”的错误。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhciom21j211q04lx2k.jpg" alt="喜闻乐见的跨域拦截"></p>
<h1 id="十八般武艺"><a href="#十八般武艺" class="headerlink" title="十八般武艺"></a>十八般武艺</h1><p>好了，既然现在浏览器有这个限制，那为了客户着想，我们还是要去解决这个问题(对吧？)，虽然我至今想不明白，适配浏览器为什么会成为我们的工作之一[doge]。打开 Google 搜索“前端跨域”，于是发现了解决跨域问题的各种方案，这里选取最具代表性的 JSONP 和 CORS。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>首先，我们来说说 JSONP，什么是 JSONP 呢？我们知道，通常 RESTful 接口返回的都是 JSON，而 JSONP 返回的是一段可以执行的 JavaScript 代码，我们所需要的数据就被“包裹”在这段代码中，这就是 JSONP，即<strong>JSON Padding</strong>的得名由来。在实际应用中，服务的提供方会根据调用方传入的回调函数(callback)来组织返回数据，譬如<strong>callback({“name”:”tom”,“gender”:”male”})<strong>。这就说到一个点，</strong>并不是所有的 API 接口在调用的时候出现跨域问题，都可以通过 JSONP 的方式来解决，因为它需要后端来配合组织返回数据</strong>。这里我们以“不蒜子”这个静态博客中使用最多的访问量统计工具为例，通过查看页面源代码，我们了解到它是通过 JSONP 来返回数据的。为什么它要用这种方式来返回数据呢？其实，我们仔细想想就能明白其中的缘由，因为像 Hexo、Jekyll 这种静态博客大多都是没有后端服务支持的，所以，它要访问“不蒜子”的统计服务，就必然会存在跨域的问题啊！那怎么解决这个问题呢？当然是选择 JSONP 啦！这里我们以 Postman 调用不蒜子接口为例，可以发现它的返回值是下面这个样子：</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhe1rnprj218u08sx6p.jpg" alt="在Postman中调用不蒜子接口"></p>
<p>博主计划在接下来的时间里，迁移不蒜子的统计数据到 LeanCloud 上，届时博主会使用最喜欢的 Python，来抓取这些访问量数据，因为 JSONP 返回的都不是 JSON 数据，因此再处理这些数据的时候，需要用正则来匹配这些结果。为什么在前端领域没有这些问题呢，因为 JSONP 返回的是世界上最<strong>“任性”</strong>的语言——<strong>JavaScript</strong>，当然，这些会是下一篇甚至下下一篇里的内容啦。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>好了，下面我们说说 CORS 这种方案。CORS，即跨域资源共享，是一种利用 HTTP 头部信息访问不同域下的资源的机制。我们在前面提到过，发生跨域访问时，其实请求已经发出去了，但响应则被浏览器给拦截住了。那么，CORS 说白了就是它可以通过 HTTP 头部信息，告诉浏览器来自哪些域的请求可以被允许，来自哪些域的请求应该被禁止。如果说 JSONP 多少带着点“hack”的意味儿，那么 CORS 就可以说是被官方认可的跨域解决方案啦！这种方案需要启用新的 HTTP 头部字段，具体可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">这里</a>。</p>
<p>按照定义，浏览器会将 CORS 请求分为<strong>简单请求</strong>和<strong>非简单请求</strong>两类。对于简单请求，浏览器会对请求的头部进行“魔改”，即增加一个 Origin 字段，这样只要后端接口支持 CORS 跨域，就可以接收这些跨域请求，并做出回应，即在响应的头部信息中返回 Access-Control-Allow-Origin 等字段。而对于非简单请求，通常会先发出一个 OPTIONS 的“预检请求”，只有这个验证过程通过以后，主请求才会被发起。那么浏览器是怎么验证请求是否通过的呢？答案就是：检查<strong>Origin</strong>字段是否包含在<strong>Access-Control-Allow-Origin</strong>中。当验证不通过时，浏览器就会输出同源策略限制的错误。这就是 CORS，浏览器和服务端分别通过响应、请求的 HTTP 头部信息来<strong>“商量”</strong>要不要跨域。</p>
<h1 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h1><p>说了这么多关于“跨域”的话题，其实博主想说的是，没有银弹。这是一位前辈高人，曾经对博主反复说过的话。现在我们来看 JSONP，会发现它本质上是利用了浏览器的<strong>“漏洞”</strong>。为什么这样说呢？因为在浏览器中，<strong>所有具备 src 属性的 HTML 都是可以跨域的，譬如 script、img、iframe、link 这四个标签，我们赖以生存的 CDN 加速、图床、插件等等都是基于这一“漏洞”的产物</strong>。所以，很多人问为什么$.ajax 可以跨域，但原生的 XMLHttpRequest 则不可以呢？因为 jQuery 实际上把 JSONP 做成了一种语法糖，这就就会给人一种 ajax 可以跨域的错觉。</p>
<h2 id="JSONP？其实就是-JS"><a href="#JSONP？其实就是-JS" class="headerlink" title="JSONP？其实就是 JS"></a>JSONP？其实就是 JS</h2><p>JSONP 实际上返回的是可以执行的 JavaScript，即 text&#x2F;javascript，它和我们所使用的大多数 JavaScript 并无区别，所以，你可以想到，当我们把一个远程地址赋值给 script 标签的 src 属性时，它和我们引用 CDN 上的医院文件并无区别，这正是 JSONP 的秘密所在，显然它只支持 Get 方式，当我们想要支持更多方式的时候，我们需要的是 CORS，一起来看下面这段代码，我们首先来写一个简单的 API 接口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET api/user/5?callback=</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> id, <span class="built_in">string</span> callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> userInfo = UserInfoService.Find(x =&gt; x.UserId == id);</span><br><span class="line">    <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) <span class="keyword">return</span> NotFound();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(callback))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回JSON</span></span><br><span class="line">        Response.ContentType = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Json(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回JSPNP</span></span><br><span class="line">        Response.ContentType = <span class="string">&quot;application/javascript&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Content(<span class="string">$&quot;<span class="subst">&#123;callback&#125;</span>(<span class="subst">&#123;JsonConvert.SerializeObject(userInfo)&#125;</span>)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，写完这个接口以后，我们首先来尝试在前端页面中调用这个接口，为了尽可能地减少依赖，我们这里用最新 Fetch API 来代替$.ajax()，毕竟现在都是 2019 年了呢，Github 和 Bootstrap 相继宣布从代码中移除 jQuery。大家都知道，原生的 xhr 和 Date 对象一样，简直难用得要命，而这一切在新的 Fetch API 下，会变得非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于Fecth API调用JSONP</span></span><br><span class="line"><span class="attr">showUserByFetch</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">&quot;https://localhost:5001/api/user/1&quot;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">          <span class="title function_">showUser</span>(user);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，就算使用最新的 Fetch API，浏览器还是会因为同源限制策略而拦截我们的请求</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhhcqa78j211s04nq3k.jpg" alt="浏览器中再次出现同源限制错误"></p>
<p>那么，试试用 JSONP 的思路来解决这个问题。注意到，为了兼容 JSONP 方式调用，我们在 API 接口中增加了一个 callback 参数，这个参数实际上就是预先在客户端中定义好的方法的名字啦！既然 JSONP 返回的是可执行的 JavaScript，那么我们在页面里增加一个 Script 标签好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://localhost:5001/api/user/1?callback=showUser&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>其中，showUser 是一个预先定义好的 JS 函数，其作用是输出用户信息到页面上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示用户信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showUser</span>(<span class="params">user</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;jsonp-result&#x27;</span>);</span><br><span class="line">  result.<span class="property">innerText</span> = <span class="string">&#x27;用户ID：&#x27;</span> + user.<span class="property">uid</span> + <span class="string">&quot;, 姓名：&quot;</span> + user.<span class="property">name</span> + <span class="string">&#x27;, 性别：&#x27;</span> + user.<span class="property">gender</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以注意到，在控制台中输出了我们期望的结果，这说明页面中定义的 showUser()方法确实被执行了，所以，到这里我们可以对 JSONP 做一个简单总结：<strong>JSONP 是一种利用 script 标签实现跨域的方案，它需要对后端接口进行适当改造以返回可以执行的 JavaScript，客户端需要事先定义好接收数据的方法，两者通过 callback 参数建立起联系，返回类似 callback({“name”:”tom”,“gender”:”male”})结构的数据，因此 JSONP 请求必然且只能是一个 GET 请求</strong>。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhf0sls2j21h8090gn0.jpg" alt="通过Script标签调用JSONP"></p>
<p>既然通过 Script 标签可以调用一个 JSONP 接口，那么我们不妨试试动态创建 Script 标签，然后你就会发现这两种方式的效果是一样的，都可以调用一个 JSONP 接口，前提是 JS 中已经存在 showUser()方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建scipt调用JSONP</span></span><br><span class="line"><span class="attr">showUserByDynamic</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">      script.<span class="property">src</span> = <span class="string">&quot;https://localhost:5001/api/user/1?callback=showUser&quot;</span>; </span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>事实上，jQuery 中针对 JSONP 的支持正是基于这种原理，虽然 jQuery 的时代终将过去，可我相信这些背后的原理永远不会过时。顺着这个思路，我们不妨来看看 jQuery 中是如何实现 JSONP 的，以下代码可以在<a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/edit/master/src/ajax/script.js">这里</a>找到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind script tag hack transport</span></span><br><span class="line">jQuery.<span class="title function_">ajaxTransport</span>(<span class="string">&quot;script&quot;</span>,</span><br><span class="line"><span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This transport only deals with cross domain or forced-by-attrs requests</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">crossDomain</span> || s.<span class="property">scriptAttrs</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> script, callback;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">send</span>: <span class="keyword">function</span>(<span class="params">_, complete</span>) &#123;</span><br><span class="line">                script = <span class="title function_">jQuery</span>(<span class="string">&quot;&lt;script&gt;&quot;</span>).<span class="title function_">attr</span>(s.<span class="property">scriptAttrs</span> || &#123;&#125;).<span class="title function_">prop</span>(&#123;</span><br><span class="line">                    <span class="attr">charset</span>: s.<span class="property">scriptCharset</span>,</span><br><span class="line">                    <span class="attr">src</span>: s.<span class="property">url</span></span><br><span class="line">                &#125;).<span class="title function_">on</span>(<span class="string">&quot;load error&quot;</span>, callback = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">                    script.<span class="title function_">remove</span>();</span><br><span class="line">                    callback = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (evt) &#123;</span><br><span class="line">                        <span class="title function_">complete</span>(evt.<span class="property">type</span> === <span class="string">&quot;error&quot;</span> ? <span class="number">404</span> : <span class="number">200</span>, evt.<span class="property">type</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use native DOM manipulation to avoid our domManip AJAX trickery</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script[<span class="number">0</span>]);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">abort</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">                    <span class="title function_">callback</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以注意到，它和我们这里的思路一致，即动态创建一个 script 标签，然后设置其 src 属性为目标地址，当其加载完成或者加载失败时，就会从页面的 DOM 节点中删除该标签，因为数据已经通过指定的 callback 处理过了。jQuery 甚至可以替我们生成对应的 callback 函数，例如，在这里我们可以这样使用 jQuery 来实现 JSONP 跨域，具体使用细节这里不再深究：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于$.ajax()调用JSONP</span></span><br><span class="line"><span class="attr">showUserByAjax</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;http://localhost:5000/api/user/1&quot;</span>,</span><br><span class="line">            <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">            <span class="attr">jsonp</span>: <span class="string">&quot;callback&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">                <span class="title function_">showUser</span>(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="CORS，跨域新标准"><a href="#CORS，跨域新标准" class="headerlink" title="CORS，跨域新标准"></a>CORS，跨域新标准</h2><p>相对 JSONP 来说，CORS 实现起来就非常简单啦，因为主流的 Web 框架中几乎都提供了 CORS 的支持，因为 CORS 可以实现除了 GET 以外的譬如 POST、PUT 等请求，所以，它比 JSONP 这种”Hack“的方式有更为广阔的适用性，而且随着 Web 标准化的不断推荐，目前 CORS 可以说是官方主推的跨域方案。这里我们以.NET Core 为例来讲解 CORS 跨域。</p>
<p>CORS，即同源资源共享，其实早在 ASP.NET 时代，这一机制就已经得到了支持，现在我们以.NET Core 来讲，无非是希望大家放下历史包袱，在跨平台的新道路上轻装上阵。好了，在.NET Core 中我们有两种 CORS 方案，一种是在 Startup 类中以全局配置的方式注入到整个中间件管道中，一种是以特性的方式在更小的粒度上控制 CORS。这其实和之前配置路由的思路相近，即我们可以配置全局的路由模板，同样可以在 Controller 和 Action 级别上定义路由。在这里，我们先定义两种 CORS 策略，AllowAll 和 AllowOne，并以此来测试 CORS 实际的使用效果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CORS策略：简单粗暴一刀流</span></span><br><span class="line"> services.AddCors(opt=&gt;&#123;</span><br><span class="line">    opt.AddPolicy(<span class="string">&quot;AllowAll&quot;</span>, builder =&gt; &#123;</span><br><span class="line">        builder.AllowAnyOrigin();</span><br><span class="line">        builder.AllowAnyHeader();</span><br><span class="line">        builder.AllowAnyMethod();</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CORS策略：允许指定域</span></span><br><span class="line">services.AddCors(opt=&gt;&#123;</span><br><span class="line">    opt.AddPolicy(<span class="string">&quot;AllowOne&quot;</span>, builder =&gt; &#123;</span><br><span class="line">        builder.WithOrigins(<span class="string">&quot;http://localhost:8888&quot;</span>)</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowAnyMethod()</span><br><span class="line">            .WithExposedHeaders(<span class="string">&quot;X-ASP-NET-Core&quot;</span>,<span class="string">&quot;X-UserName&quot;</span>)</span><br><span class="line">            .AllowCredentials();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以注意到，在全局范围内应用 AllowAll 以后，我们的后端接口将支持来自任意域&#x2F;端口的跨域访问，这意味着我们之前必须使用 JSONP 来跨域的地方，现在都可以直接发起跨域请求。到底是不是和我们想得一样呢？答案啊，那必须是肯定的啊！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">EnableCors(<span class="string">&quot;AllowOne&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserController</span>:<span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们来测试在 UserController 上应用局部的 CORS 请求，在这个实例中，我们指定只有来自 localhost:8888 的请求可以跨域，为此博主这里用 Python 临时开了一个服务器，本文中的前端页面，实际上就是运行在这个服务器上的。你知道我想说什么，“人生苦短，我用 Python”。因为我们这里返回的是 application&#x2F;json，所以它是一个非简单请求，这里复习一下简单请求与非简单请求。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>根据<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">MDN</a>中关于 CORS 的定义，若请求满足所有下述条件，则该请求可视为“简单请求”，简单请求意味着不会触发<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests">CORS 预检请求</a>：</p>
<ul>
<li>使用下列方法之一：GET、HEAD、POST。</li>
<li>Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：Accept、Accept-Language、Content-Language、Content-Type (需要注意额外的限制)、DPR、Downlink、Save-Data、Viewport-Width、Width。</li>
<li>Content-Type 的值仅限于下列三者之一：text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded。</li>
</ul>
<p><img src="https://mdn.mozillademos.org/files/14293/simple_req.png" alt="MDN中对简单请求的图解"></p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求和简单请求相反，即不满足简单请求中任一条件的请求都被成为非简单请求。非简单请求，相对简单请求多了一次<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests">CORS 预检请求</a>。其过程是，首先由浏览器自动发起一个 OPTION 请求，该请求中携带 HTTP 头部字段 Origin。在本例中，前端页面部署在<code>http://localhost:8888</code>服务器上，所以，它的 Origin 字段即为<code>http://localhost:8888</code>。接下来，服务端会返回 Access-Control-Allow-Origin&#x2F;Access-Control-Allow-Headers&#x2F;Access-Control-Allow-Methods 等字段，它对应我们后端定义的 AllowOne，注意到这里我们有两个自定义字段 X-ASP-NET-Core 和 X-UserName。在通过预检以后，我们在发起正式请求(本例中为 GET 请求)的时候，设置后端允许的源，即<code>http://localhost:8888</code>，这样就可以实现基于 CORS 的跨域请求啦！</p>
<p><img src="https://mdn.mozillademos.org/files/14289/prelight.png" alt="MDN中对非简单请求的图解"></p>
<p>所以，我们可以注意到，这里会有一个 OPTION 请求，即“预检请求”。对于 AllowOne 这个 CORS 策略而言，它允许来自 localhost:8888 的跨域请求，允许的请求方法有 GET、PUT、POST 和 OPTION，客户端必须携带一个自定义 HTTP 头：X-ASP-NET-Core。当这三个条件满足时，即表示通过“预检”。此时，服务端会返回 Access-Control-Allow-Origin&#x2F;Access-Control-Allow-Methods&#x2F;Access-Control-Allow-Headers 等字段。接下来，浏览器发起的正式请求会带上这些字段，并返回我们所需要的 JSON 数据，这就是 CORS 跨域的实际过程。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g0nhfm5iprj21h60kcb2d.jpg" alt="OPTION预检请求"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇文章主要梳理了目前前端跨域的两种主流方案(事实上，在奇葩的前端领域里，最不缺的就是解决方案)，即 JSONP 和 CORS。其中，JSONP 本质上是返回可以执行的 JS，其基本套路是 callback({“foo”:”bar”})，利用了 HTML 中含 src 的属性天生具备跨域能力的“漏洞”，是一种相对”hack”的方案，要求预先定义好 callback，需要改造后端接口，仅支持最简单的 GET 请求。而 CORS，是比较“官方”的跨域解决方案，其原理是利用 HTTP 头部字段对请求的来源进行检验，CORS 支持除 GET 以外的请求动词，在使用中间件的情况下，无需修改后端接口，可以在全局或者局部配置 CORS 跨域策略，对后端开发相对友好。自从接触前端领域，对这个领域里的“黑科技”、“骚操作”吐槽无数次了，不过，前后端分离过程中这些事情还是挺有意思的，对吧？好了，以上就是这篇博客里的全部内容了，欢迎大家吐槽！本文中的示例请从：<a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/dotnet-sse/blob/master/server/index.html">https://github.com/qinyuanpei/dotnet-sse/blob/master/server/index.html</a>这里来获取，谢谢大家！</p>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag"># 跨域</a>
          
            <a href="/tags/CORS/" rel="tag"># CORS</a>
          
            <a href="/tags/JSONP/" rel="tag"># JSONP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/8159b49a.html" rel="next" title="Window上更方便的软件安装方式 — Chocolatey">
                <i class="fa fa-chevron-left"></i> Window上更方便的软件安装方式 — Chocolatey
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/multi-currency-price/" rel="prev" title="商品价格的多币种方案">
                商品价格的多币种方案 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1460</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">895</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%85%E4%BA%8B%E7%BC%98%E8%B5%B7"><span class="nav-number">1.</span> <span class="nav-text">故事缘起</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E8%88%AC%E6%AD%A6%E8%89%BA"><span class="nav-number">2.</span> <span class="nav-text">十八般武艺</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSONP"><span class="nav-number">2.1.</span> <span class="nav-text">JSONP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CORS"><span class="nav-number">2.2.</span> <span class="nav-text">CORS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9"><span class="nav-number">3.</span> <span class="nav-text">没有银弹</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSONP%EF%BC%9F%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF-JS"><span class="nav-number">3.1.</span> <span class="nav-text">JSONP？其实就是 JS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CORS%EF%BC%8C%E8%B7%A8%E5%9F%9F%E6%96%B0%E6%A0%87%E5%87%86"><span class="nav-number">3.2.</span> <span class="nav-text">CORS，跨域新标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.1.</span> <span class="nav-text">简单请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.2.</span> <span class="nav-text">非简单请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
