<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="微博,朴素贝叶斯,文本分类," />










<meta name="description" content="在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助 Python 中的图表模块完成了数据的可视化工作;我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法;按照传统">
<meta property="og:type" content="article">
<meta property="og:title" content="基于新浪微博的男女性择偶观数据分析(下)">
<meta property="og:url" content="https://blog.feedscoin.com/2018/03/17/%E5%9F%BA%E4%BA%8E%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E7%9A%84%E7%94%B7%E5%A5%B3%E6%80%A7%E6%8B%A9%E5%81%B6%E8%A7%82%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%8B/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助 Python 中的图表模块完成了数据的可视化工作;我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法;按照传统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://7wy477.com1.z0.glb.clouddn.com/20180321003843372-tf.png">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziz094tgjj205g01c0sh.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziywyea29j204h0180hg.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziyuiggemj20k50h2ab0.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziybbp76cj20d506x74o.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziy7xiyh5j20zk0hb74m.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fziy58l22cj20hs0b4t8w.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fzixyyw9tyj20hs0dct90.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fz05o1va6mj20hs0dc3yt.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fz05l9vxiaj20hs0dcmxg.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fz05eth452j20zk0hbq3c.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1fz020n6gpfj20hs0b4dgo.jpg">
<meta property="article:published_time" content="2018-03-17T07:28:40.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.206Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="微博">
<meta property="article:tag" content="朴素贝叶斯">
<meta property="article:tag" content="文本分类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://7wy477.com1.z0.glb.clouddn.com/20180321003843372-tf.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/2018/03/17/基于新浪微博的男女性择偶观数据分析-下/"/>





  <title>基于新浪微博的男女性择偶观数据分析(下) | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2018/03/17/%E5%9F%BA%E4%BA%8E%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E7%9A%84%E7%94%B7%E5%A5%B3%E6%80%A7%E6%8B%A9%E5%81%B6%E8%A7%82%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">基于新浪微博的男女性择偶观数据分析(下)</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-17T15:28:40+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助 Python 中的图表模块完成了数据的可视化工作;我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法;按照传统主题提取模型，文本分类问题被拆分为**特征工程**和**分类器**两个部分，其中，**特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类**
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      

        <p>各位朋友，大家好，我是 Payne，欢迎大家关注我的博客。我的博客地址是：<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/">https://qinyuanpei.github.io</a>。对于今天这篇文章的主题，相信经常关注我博客的朋友一定不会陌生。因为在 2017 年年底的时候，我曾以此为题写作了一篇文章：<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a>。这篇文章记录了我当时脑海中闪烁着的细微想法，即当你发现一件事物背后是由哲学或者心理学这类玄奥的科学在驱动的时候，不妨考虑使用数学的思维来让一切因素数量化，我想这是最初数据分析让我感兴趣的一个原因。因为当时对文本的处理了解得非常粗浅，所以在第一次写作这篇文章的时候，实际的工作不过是在分词后绘制词云而已。等到我完成对微信好友信息的数据分析以后，我意识到微博这里其实可以继续发掘。关于微信好友信息的数据分析，可以参考这篇文章：<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/posts/2805694118/">基于 Python 实现的微信好友数据分析</a>。在这样的想法促使下，便有了今天这篇文章，因为工作关系一直没有时间及时整理出来，希望这篇文章可以带给大家一点启示，尤其是在短文本分类方面，这样我就会非常开心啦！:slightly_smiling_face:</p>
<h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>关于故事背景，我在 <a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/posts/1386017461/">基于新浪微博的男女择偶观数据分析(上)</a> 这篇文章中说得非常清楚啦。起因就是我想知道，男性和女性在选择伴侣的时候，到底更为关注哪些因素？在对微信好友信息进行数据分析的时候，我们可以非常直接地确定，譬如性别、签名、头像、位置这四个不同的维度，这是因为我们处理的是结构化的数据。什么是结构化的数据呢？一个非常直观的认识是，这些数据可以按照二维表的方式组织起来。可对于微博这样一个无结构的文本数据类型，我们除了对词频、词性等因素做常规统计分析以外，好像完全找不到一个合理有效的方案，因为我们很容易就明白一件事情，即：<strong>在短短的 140 个字符中，人类语言的多样性被放大到淋漓尽致</strong> 。为了将种种离散的信息收敛在一个统一的结构里，我们必须为这些文本构建一种模型，并努力使这种模型可以量化和计算。我们通过词云对微博进行可视化分析，更多是针对词频的一种分析方法，这种方法虽然可以帮助我们找出关键字，可是因为最初写作这篇文章时，对数据分析领域相关知识知之甚少，而且在分析的过程中没有考虑停用词，所以我认为在文本分类或者是主题提取层面上，我们都需要一种更好的方法。</p>
<h1 id="常见的技术方法"><a href="#常见的技术方法" class="headerlink" title="常见的技术方法"></a>常见的技术方法</h1><p>这篇文章涉及的领域称为<strong>文本分类</strong>或者<strong>主题提取</strong>，而针对微博、短信、评论等这类短文本的分类，则被称为<strong>短文本分类</strong>。为什么要进行文本分类呢？第一，<strong>提取出潜在主题以后可以帮助我们做进一步的分析</strong>。譬如博主这里想要从相亲类微博中分析男性和女性的择偶观，首先要解决的就是主题建模问题，因为在择偶过程中要考虑的因素会非常多，我们到底要选取哪些因素来分析呢？这些因素在特定领域中被称为特征，所以文本分类的过程伴随着特征提取。第二，<strong>短文本数据通常只有一个主题，看起来这是在简化我们的分析过程，实则传统的基于文档的主题模型算法在这里难以适用。</strong>因为这类主题模型算法都假定一篇文档中含有多个主题，而我们分析的是群体现象，这种个体上的差异必须设法将其统一于一体，比如美元和$属于同一个主题，我们需要一种策略来对其进行整合。</p>
<p>传统主题提取模型通常由<strong>文本预处理</strong>、<strong>文本向量化</strong>、<strong>主题挖掘</strong>和<strong>主题表示</strong>等多个流程组成，每个流程都会有多种处理方法，不同的组合方法会产生不同的建模结果。目前，人们在传统主题提取模型的基础上，发展起了以<strong>CNN</strong>和<strong>RNN</strong>为代表的深度学习方法，在这里我们依然关注传统主题提取模型，因为这个领域对博主而言是个陌生的领域，这里我们更多的是关注传统主题提取模型。按照传统主题提取模型，文本分类问题被拆分为<strong>特征工程</strong>和<strong>分类器</strong>两个部分，其中，<strong>特征工程的作用是将文本转化为计算机可以理解的格式，并提供强特征表达能力，即特征信息可以用以分类，而分类器基本上是统计学相关的内容，其作用是根据特征对数据进行分类</strong>。下面来简单介绍下常见的技术方法。</p>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>特征工程覆盖了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个流程。文本预处理通常指<strong>分词</strong>和<strong>去除停用词</strong>这两个过程，可以说分词是自然语言处理的基本前提。特征提取实际上囊括两个部分，即特征项的选择和特征项权重的计算。选择特征项的基本思路是：根据某个评价指标对原始数据进行排序，然后从中选择分数最高的评价指标，同时过滤掉其余的评价指标。通常可以选择的评价指标有<strong>文档频率</strong>、<strong>互信息</strong>、<strong>信息增益</strong>等，而特征权重的计算主要是经典的<strong>TF-IDF</strong>算法及其扩展算法。文本表示是指将文本预处理后转化为计算机可以理解的格式，是决定分类效果最重要的部分。传统做法是使用<strong>词袋模型(BOW)<strong>或者</strong>向量空间模型(VSM)<strong>，比如</strong>Word2Vec</strong>就是一个将词语转化为向量的相关项目。因为向量模型完全忽视文本的上下文，所以为了弥补这种技术上的不足，业界同时使用基于语义的文本表示方法，比如常见的<strong>LDA</strong>语义模型。</p>
<h2 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h2><p>分类器主要是统计学里的分类方法，基本上大部分的机器学习方法都在文本分类领域有所应用，比如最常见的<strong>朴素贝叶斯算法(Naive Bayes)<strong>、</strong>KNN</strong>、<strong>支持向量机(SVM)<strong>、</strong>最大熵(MaxEnt)<strong>、</strong>决策树</strong>和<strong>神经网络</strong>等等。简单来说，假设我们所有的数据样本可以划分为训练集和测试集。首先，分类器可以在训练集上执行分类算法以生成分类模型；其次，分类器可以通过分类模型对测试集进行预测以生成预测结果；最后，分类器可以计算出相关的评价指标以评估分类的效果。这里最常用的两个评价指标是<strong>准确率</strong>和<strong>召回率</strong>，前者关注的是数据的准确性，后者关注的是数据的全面性。</p>
<h1 id="TF-IDF-与朴素贝叶斯"><a href="#TF-IDF-与朴素贝叶斯" class="headerlink" title="TF-IDF 与朴素贝叶斯"></a>TF-IDF 与朴素贝叶斯</h1><p><strong>TF-IDF</strong>(term frequency–inverse document frequency)是一种被用于信息检索与数据挖掘的统计学方法，常常被用来评估某个字词对于一个文件集或者是一个语料库中的一份文档的重要程度。在特征工程这里我们提到，特征工程中主要通过特征权重来对数据进行排序和分类，因此<strong>TF-IDF</strong>本质上是一种加权技术。<strong>TF-IDF</strong>的主要思想是：字词的重要性与它在文件中出现的次数成正比上升，与此同时与它在语料库中出现的频率成反比下降。这句话是什么意思呢？如果某个词或者短语在一篇文章中出现的频率(即<strong>TF</strong>)较高，并且在其它文章中出现的频率(即<strong>IDF</strong>)较低，那么就可以人为这个词或者短语可以作为一个特征，具备较好的类别区分能力，因此适合用来作为分类的标准。<strong>TF-IDF</strong>实际上是 TF * IDF，即 TF(term frequency，词频)与 IDF(inverse document frequency，逆文档频率)的乘积，具体我们通过下面的公式来理解：<br><img src="http://7wy477.com1.z0.glb.clouddn.com/20180321003843372-tf.png" alt="term frequency，词频"><br>显然，这里的 TF 表示某一词条在文档中出现的频率。再看 IDF:<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziz094tgjj205g01c0sh.jpg" alt="inverse document frequency，逆文档频率"><br>这里的 D 表示语料库中文档的数目，而分母表示的是含有指定词的文档的数目，这里两者求商后取对数即可得到 IDF。需要注意的是，当该词语不在语料库中时，理论上分母会变成 0，这将导致计算无法继续下去，因此为了修正这一错误，我们在分母上加 1，这样就可以得到 IDF 更为一般的计算公式。按照这样的思路，我们将两段文本分完词以后，分别计算每一个词的 tf-idf 并按照 tf-idf 对其进行排序，然后选取前 N 个元素作为其关键字，这样我们就获得了两个 N 维向量，按照向量理论的相关知识，两个向量间的夹角越小，其相关性越显著，这就是文本相似度判断的常规做法，在这个过程中，我们覆盖到了<strong>文本预处理</strong>、<strong>特征提取</strong>和<strong>文本表示</strong>三个过程，相信大家会对这个过程有更好的理解。</p>
<p>好了，那么什么是特征呢？这里计算出来的 tf-idf 实际上就是一组特征，这个特征是上下文无关、完全基于频率分析的结果，现在这些结果都是计算机可以处理的数值类型，所以特征工程要做的事情，就是从这些数值中分析出某一种规律出来。譬如，我们通过分析大量的气象资料，认为明天有 80%的概率会下雨，那么此时下雨的概率 0.8 就可以作为一个特征值，在排除干扰因素的影响以后，我们可以做一个简单的分类，如果下雨的概率超过 0.8 即认为明天会下雨，反之则不会下雨。这是一个接近理想的二值化模型，在数学中我们有一种概率分布模型称为 0-1 分布，即一件事情只有两个可能，如果该事件会发生的概率为 p，则该事件不会发生的概率为 1-p。如果所有的问题都可以简化到这种程度，我相信我们会觉得这个世界枯燥无比，因为一切非黑即白、非此即彼，这会是我们所希望的世界的样子吗？<br>为什么在这里我要提到概率呢？因为这和我们下面要提到的朴素贝叶斯有关。事实上，朴素贝叶斯的理论基础，正是我们所熟悉的条件概率。根据概率的相关知识，我们有以下公式，即全概率公式：P(A|B) &#x3D; P(AB)&#x2F;P(B)。我们对 A 和 B 进行交换，同理可得：P(B|A) &#x3D; P(A&#x2F;B)&#x2F;P(A)。由此我们即得到了贝叶斯公式：<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziywyea29j204h0180hg.jpg" alt="贝叶斯公式"><br>所以，朴素贝叶斯本质上是一种基于概率理论的分类算法。我们知道条件概率成立的前提是各个事件都是独立的，因此在朴素贝叶斯算法中假设所有特征间都是独立的，可当我们逐渐地了解这个世界，就会明白这个世界并不是非黑即白、非此即彼的，甚至一件事情会受到来自方方面面的因素影响，就像我们从前学习物理的时候喜欢用控制变量法一样，总有一天你会明白当时的想法太天真。朴素贝叶斯算法中的“朴素”，通常被翻译为 Naive，而这个词就是表示天真的意思，这正是朴素贝叶斯的名称由来，它简单粗暴地认为各个特征间是相互独立的，有人认为这种假设是相当不严谨的，所以相当排斥这种分类的理论，所幸朴素贝叶斯在实际应用中分类效果良好，尤其是在解决垃圾邮件过滤这类问题上，所以到今天为止，朴素贝叶斯依然是一个相当经典的分类算法，它是一个根据给定特性&#x2F;属性，基于条件概率为样本赋予某个类别标签的模型。</p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>好了，讲述这些理论知识实在是一件苦差事，因为让读者了解一套新的知识，远远比让自己了解一套新的知识容易，所以在描述这些理论的时候，我努力地避免给大家留下晦涩深奥地印象，可这样难免会让读者觉得我不太专业。可是，谁让我们生活在一个被无数前辈开垦过地世界里呢？作为一个资深的“调包侠”，这些理论我们能理解多少算多少，最终我们需要的只是一个库而已，所以在正式进入下面的内容时，我们首先来梳理侠整体数据分析的思路，这样我们就能对整个过程有一个相对感性的认识了。关于如何从新浪微博抓取数据，这个我们在<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>有详细的介绍，这里不再重复阐述，所有数据我们都存储在数据库里，下面的图示不再展示关于数据库的细节：<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziyuiggemj20k50h2ab0.jpg" alt="特征分析流程图"><br>简单来讲，这是一个有监督的、使用二元分类的特征提取过程。这里的语料库是由人工进行编制的文本资料，语料库的好坏将直接影响到分类的效果。比如说，我们希望提取的特征是陕西省的地理信息，那么我们就需要准备一个，由陕西省所辖的所有地级市组成的文本文件，这里为了方便后续处理，我们建议每行存放一个短文本信息。</p>
<p>接下来，我们会从数据库中读取所有的数据，然后进行预处理操作，这里的预处理是指分词和去除停用词，停用词表是从网络上下载的，然后根据我们自己的需要再在基础上进行添加，我们会选取前 20 个词语作为关键词，这里使用了结巴分词的相关接口，其算法原理正是 tf-idf。我们会使用这 20 个关键词，和语料库中每一个主题下的内容进行比较，这里的相似度由 SnowNLP 提供支持，其计算结果是一个 20 维的向量，我们对向量进行归一化后，如果其向量中所有维度的值的最大值&gt;&#x3D;0.95，则认为该文本和这一主题相关，因此该主题的权重会增加 1，否则会继续计算下一个文本的相似度。</p>
<p>我们汇总所有主题的权重，即可统计出各个主题出现的频率。比如我们这里关注 A、B、C 三个主题，而经过计算这三个主题各自出现的频率为 0.1、0.8 和 0.1，所以我们这里可以理解为：这里有 80%的把握认为文本和 B 主题有关，由此我们选取出了分类的特征，这里我们使用一个元组来表示特征，其表示为([0.1,0.8,0.1],”B”)。依次类推，我们就获得了全部的特征信息。接下来，我们使用 nltk 中提供的朴素贝叶斯分类器对内容进行分类，训练集和测试集合各占 50%，最终通过准确度来评估整个分类的效果。</p>
<h2 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h2><p>特征分析的难点主要在特征的提取，在这里我们通过不同主题的频率来选取特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildFeatures</span>(<span class="params">sentence,document</span>):</span><br><span class="line">    tokens = jieba.analyse.extract_tags(sentence)</span><br><span class="line">    tokens = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x.strip() <span class="keyword">not</span> <span class="keyword">in</span> stopwords, tokens))</span><br><span class="line">    features = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (subject,contents) <span class="keyword">in</span> document.items():</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            <span class="keyword">if</span>(similarText(tokens,content)):</span><br><span class="line">                <span class="keyword">if</span>(subject <span class="keyword">in</span> features):</span><br><span class="line">                    features[subject]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    features[subject]=<span class="number">1</span></span><br><span class="line">    total = <span class="built_in">sum</span>(features.values())</span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> features.keys():</span><br><span class="line">        features[subject] = features[subject] / total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特征归一化</span></span><br><span class="line">    <span class="keyword">for</span> subject <span class="keyword">in</span> subjects:</span><br><span class="line">        <span class="keyword">if</span>(subject <span class="keyword">not</span> <span class="keyword">in</span> features.keys()):</span><br><span class="line">            features[subject] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测结果</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(features.values())</span><br><span class="line">    suggest_subject = <span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (key,value) <span class="keyword">in</span> features.items():</span><br><span class="line">        <span class="keyword">if</span>(value == max_value):</span><br><span class="line">            suggest_subject = key</span><br><span class="line">    <span class="keyword">return</span> features, suggest_subject</span><br></pre></td></tr></table></figure>
<p>其中，stopwords 我们从一个指定文件中读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopwords = <span class="built_in">open</span>(<span class="string">&#x27;stopwords.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>).readlines()</span><br></pre></td></tr></table></figure>
<p>这里有一个计算句子和主题相似度的方法 similarText()，其定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本相似度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarText</span>(<span class="params">tokens,content</span>):</span><br><span class="line">    snow = SnowNLP(tokens)</span><br><span class="line">    similar = snow.sim(content)</span><br><span class="line">    norm = math.sqrt(<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*x,similar)))</span><br><span class="line">    <span class="keyword">if</span>(norm == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    similar = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x/norm,similar)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(similar)&gt;=<span class="number">0.95</span></span><br></pre></td></tr></table></figure>
<p>我们通过下面的代码来构建特征，以及使用朴素贝叶斯分类器进行分类，核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">analyseFeatures</span>():</span><br><span class="line">    rows = loadData()</span><br><span class="line">    document = loadDocument(subjects)</span><br><span class="line">    features = [buildFeatures(row[<span class="number">0</span>],document) <span class="keyword">for</span> row <span class="keyword">in</span> rows]</span><br><span class="line">    length = <span class="built_in">len</span>(features)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;数据集: &#x27;</span> + <span class="built_in">str</span>(length))</span><br><span class="line">    cut_length = <span class="built_in">int</span>(length * <span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;训练集: &#x27;</span> + <span class="built_in">str</span>(cut_length))</span><br><span class="line">    train_set = features[<span class="number">0</span>:cut_length]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试集: &#x27;</span> + <span class="built_in">str</span>(length - cut_length))</span><br><span class="line">    test_set = features[cut_length:]</span><br><span class="line">    classifier = nltk.NaiveBayesClassifier.train(train_set)</span><br><span class="line">    train_accuracy = nltk.classify.accuracy(classifier,train_set)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;准确度: &#x27;</span> + <span class="built_in">str</span>(train_accuracy))</span><br><span class="line"></span><br><span class="line">    counts = Counter(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>],test_set))</span><br><span class="line">    <span class="keyword">for</span> key, count <span class="keyword">in</span> counts.items():</span><br><span class="line">        freq = count/<span class="built_in">len</span>(test_set)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主题&lt;&#123;0&#125;&gt;: &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(key,freq))</span><br></pre></td></tr></table></figure>
<p>下面是特征提取相关的结果，因为最近对语料库进行了调整，所以准确度只有 92%，用一位前辈的话说，数据分析就像炼丹，在结果没有出来以前，没有人知道答案会是什么。这里使用的是 nltk 内置的朴素贝叶斯分类器，而 nltk 是一个自然语言处理相关的库，感兴趣的朋友可以自行了解，这里推荐一本书：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/27057666/">《NLTK 基础教程(用 NLTK 和 Python 库构建机器学习应用)》</a>。下图中展示了各个主题在整个微博文本中所占的比重：</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziybbp76cj20d506x74o.jpg" alt="特征提取及其分类效果"></p>
<h2 id="年龄分布"><a href="#年龄分布" class="headerlink" title="年龄分布"></a>年龄分布</h2><p>对于男女性的年龄分布，我们通过正则来提取微博中年龄相关的数值，然后统计不同年龄出现的频数，并将其绘制为柱形统计图，相关代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">analyseAge</span>(): </span><br><span class="line">    ages = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;2&#125;\年|\d&#123;2&#125;\岁&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(matches)&gt;<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">match</span> = matches[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">u&#x27;年&#x27;</span> <span class="keyword">in</span> <span class="keyword">match</span>):</span><br><span class="line">                now = datetime.datetime.now().year</span><br><span class="line">                birth = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(re.findall(<span class="string">r&#x27;\d&#x27;</span>,<span class="keyword">match</span>)))</span><br><span class="line">                ages.append(now - <span class="number">1900</span> - birth)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ages.append(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(re.findall(<span class="string">r&#x27;\d&#x27;</span>,<span class="keyword">match</span>))))</span><br><span class="line">    ages = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;<span class="number">10</span> <span class="keyword">and</span> x&lt;<span class="number">40</span>, ages))</span><br><span class="line">    freqs = Counter(ages).items()</span><br><span class="line">    freqs = <span class="built_in">sorted</span>(freqs,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="literal">False</span>)</span><br><span class="line">    freqs = <span class="built_in">dict</span>(freqs)</span><br><span class="line">    drawing.bar(<span class="string">&#x27;男女性择偶观数据分析:年龄分布&#x27;</span>,freqs,<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;人数&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>通过图表，我们可以发现：择偶年龄重点集中在 24~28 岁之间，并且整个年龄区间符合正态分布。每年过年的时候，我们都会听到年轻人被催婚的声音，甚至作为一个单身的人，每一个节日都像是我们的忌日，因为无论在哪里，你都可以被秀恩爱或者被撒狗粮。“哪有人会喜欢孤独呢？不过是不喜欢失望”，当这句话出现在我的 Kindle 屏幕上，出现在村上春树的《挪威的森林》里，我突然有种扎心的感觉。有一天，当我不在视爱情为必需品时，我突然意识到生命里有太多比感情重要的事情。我不希望我们因为一句年龄到了就去结婚，如果人生的一切都有期限都要按部就班，那么为什么我们不能平静地面对衰老和死亡呢？人天生起点就是不一样的，所以你不必努力去迎合别人定制的标准，就像学生时代大家面对的是同一张考卷，有的人交卷交得早，有的人交卷交得晚，有的人考试成绩好，有的人考试成绩差，可这不过是一场考试而已，不是吗？如果我的时间不能浪费在我喜欢的人身上，我宁愿永远将时间浪费在自己的身上，除了生与死以外，结婚和繁衍并不是必答题，我可以不结婚啊，一如我可以交白卷啊！<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziy7xiyh5j20zk0hb74m.jpg" alt="男女性择偶观数据分析:年龄分布"></p>
<h2 id="性别组成"><a href="#性别组成" class="headerlink" title="性别组成"></a>性别组成</h2><p>性别组成，我们主要从微博中的关键字入手，因为这些微博明确了择偶的是男嘉宾还是女嘉宾，我们通过这些特征就可以分析出男女性别比例。相关代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">analyseSex</span>():</span><br><span class="line">    rows = loadData()</span><br><span class="line">    sexs = &#123;<span class="string">&#x27;male&#x27;</span>:<span class="number">0</span>, <span class="string">&quot;female&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">u&#x27;男嘉宾[向右]&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">&#x27;male&#x27;</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">u&#x27;女嘉宾[向右]&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line">            sexs[<span class="string">&#x27;female&#x27;</span>]+=<span class="number">1</span></span><br><span class="line">    drawing.pie(<span class="string">&#x27;男女性择偶观数据分析:男女性别比例&#x27;</span>,sexs,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>通过下面的图表，我们可以非常直观地看到，男性数量是超过女性数量的，两者比例接近 1.38:1。这和目前中国的实际基本相符，考虑到人们有更多的相亲渠道可以选择，我认为实际的比例应该会更大，媒体称适婚男性比女性多出 3000 万，性别比例的失衡难免会让男生找不到对象。可找不着对象有什么关系呢？人生短短一世，活着时候能见到最多不过四世同堂，血缘关系并不能让后辈替你完成未竟之事，当一个离开了这个世界，它与世界的关联就变得微乎其微，时间会让记忆逐渐模糊直至遗忘，你无法将这点微弱的安全感寄托在某一个人身上，人生而有涯，而知无涯，能在这个世界里流传下去的只有思想，我不想和任何人去攀比，因为生而为人，我很抱歉。<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fziy58l22cj20hs0b4t8w.jpg" alt="男女性择偶观数据分析:男女性别比例"></p>
<h2 id="身高分布"><a href="#身高分布" class="headerlink" title="身高分布"></a>身高分布</h2><p>身高分布，同样采用关键字匹配的方式实现，不同的是，择偶者通常会在微博中给出自己的身高以及对伴侣期望的身高，由此我们对微博中的身高进行了提取，分别获得了男性、女性身高分布及其身高差分布。这是我最开始研究这个问题的初衷，现在的结果印证了当时的想法，我内心其实是特别开心的，这正是为什么要花时间和精力写这篇文章的原因所在。这里，相关的代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 身高分布</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyseHeight</span>():</span><br><span class="line">    heights = []</span><br><span class="line">    rows = loadData()</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;1\d&#123;2&#125;|\d&#123;1&#125;\.\d&#123;1,2&#125;|\d&#123;1&#125;\米\d&#123;2&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        matches = pattern.findall(text)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(matches)&gt;<span class="number">1</span>):</span><br><span class="line">            matches = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(re.findall(<span class="string">r&#x27;\d&#x27;</span>,x))),matches)</span><br><span class="line">            matches = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&lt;<span class="number">190</span> <span class="keyword">and</span> x&gt;<span class="number">150</span>, matches))</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">len</span>(matches)&gt;<span class="number">1</span>):</span><br><span class="line">                height = &#123;&#125; </span><br><span class="line">                height[<span class="string">&#x27;male&#x27;</span>] = <span class="built_in">max</span>(matches)</span><br><span class="line">                height[<span class="string">&#x27;female&#x27;</span>] = <span class="built_in">min</span>(matches)</span><br><span class="line">                heights.append(height)</span><br><span class="line">    <span class="comment"># 男性身高分布</span></span><br><span class="line">    male_heights = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&#x27;male&#x27;</span>],heights))</span><br><span class="line">    male_heights = Counter(male_heights).items()</span><br><span class="line">    male_heights = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(male_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="literal">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">&#x27;男女性择偶观数据分析:男性身高分布&#x27;</span>,male_heights,<span class="string">&#x27;身高&#x27;</span>,<span class="string">&#x27;人数&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 女性身高分布</span></span><br><span class="line">    female_heights = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&#x27;female&#x27;</span>],heights))</span><br><span class="line">    female_heights = Counter(female_heights).items()</span><br><span class="line">    female_heights = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(female_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="literal">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">&#x27;男女性择偶观数据分析:女性身高分布&#x27;</span>,female_heights,<span class="string">&#x27;身高&#x27;</span>,<span class="string">&#x27;人数&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 男女身高差分布</span></span><br><span class="line">    substract_heights = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="string">&#x27;male&#x27;</span>]-x[<span class="string">&#x27;female&#x27;</span>],heights))</span><br><span class="line">    substract_heights = Counter(substract_heights).items()</span><br><span class="line">    substract_heights = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(substract_heights,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse = <span class="literal">False</span>))</span><br><span class="line">    drawing.bar(<span class="string">&#x27;男女性择偶观数据分析:男女身高差分布&#x27;</span>,substract_heights,<span class="string">&#x27;身高差&#x27;</span>,<span class="string">&#x27;人数&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>虽然女生都希望男生 180 以上，据说这样可以举高高、有安全感，可是作为一个成年人，我们必须勇敢地打破这种不切实际的幻想，因为身高和外貌都是父母给我们的，那些基因里决定的东西，往往是我们无法通过后天努力来弥补的。如果可以的话，我希望自己再长高 5 厘米，可如果我再无法长高，我希望你能接受现在的我，接受一个人身高上的缺陷，和接受一个人人性中的缺点，在我看来是一模一样的。可人类最大的问题， 就在于愿意相信自己眼睛看到的，耳朵听到的，并且这是两个人建立联系的前提，人家愿意了解你有趣的灵魂，前提是你有一副好看的皮囊，人类啊，说到底是一种比较高级的动物而已，就像动物用皮毛、肤色去吸引同类一样，如你所见，男生平均身高其实只有 175 而已！<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fzixyyw9tyj20hs0dct90.jpg" alt="男女性择偶观数据分析:男性身高分布"></p>
<p>女性的身高通常不会被作为筛选条件，正如社会群体通常都是对男性提出各种要求一样，两个同等条件下的男、女性，人们理所当然地对男性提出了更高的要求，可其实大家都是母亲十月怀胎而来，同样地都在这个世界里生活了 20 多年。所以这个世界上有太多地问题，其实都是人们自己造成的。比如女性一定要找一个穿高跟鞋后还要比她高的男性，而男性一定要找一个身高上和他相差不大的女性，男性的身高不足 175，同女性的身高不足 165 一样，都是人们眼中比较尴尬的身高，可你看这图表中女性的平均身高是 160，那么，就让大家一起尴尬吧，不知道当年小平爷爷和拿破仑将军的夫人心里是怎么想的啦！<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fz05o1va6mj20hs0dc3yt.jpg" alt="男女性择偶观数据分析:女性身高分布"></p>
<p>最初我研究这个问题的时候，我发现微博上有好多身高不足 160 的女性，要求伴侣期望身高都是 175 以上，作为一个身高只有 170 的男生，我感到绝望和悲伤啊，后来和一位朋友聊天，他说他觉得我连 170 都没有，我想说人类为什么要这般奇怪，譬如体重一定要说得比实际轻、身高一定要说得比实际高、年龄一定要说得比实际小……难道这样不感觉累吗？那么到底有多少人希望两个人的身高差超过 20 厘米呢？网络上流传的所谓最萌身高差到底萌不萌呢？你看孟德尔通过豌豆杂交试验来研究遗传问题，两个身高差超过 20 厘米的人的后代，平均下来难道不是只有 170 吗？图表表明，男女性之间最佳的身高差是 15 厘米。<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fz05l9vxiaj20hs0dcmxg.jpg" alt="男女性择偶观数据分析:男女身高差分布"></p>
<h2 id="地理分布"><a href="#地理分布" class="headerlink" title="地理分布"></a>地理分布</h2><p>因为在这些微博中会出现相亲者的地理信息，所以我们整理了陕西省各县市的名称作为关键字，试图分析出这些相亲者的地理分布，这里我们简单绘制了一个柱形图，相关代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地区分析</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anslyseLocation</span>():</span><br><span class="line">    freqs = &#123; &#125;</span><br><span class="line">    citys = [<span class="string">u&#x27;西安&#x27;</span>,<span class="string">u&#x27;铜川&#x27;</span>,<span class="string">u&#x27;宝鸡&#x27;</span>,<span class="string">u&#x27;咸阳&#x27;</span>,<span class="string">u&#x27;渭南&#x27;</span>,<span class="string">u&#x27;延安&#x27;</span>,<span class="string">u&#x27;汉中&#x27;</span>,<span class="string">u&#x27;榆林&#x27;</span>,<span class="string">u&#x27;安康&#x27;</span>,<span class="string">u&#x27;商洛&#x27;</span>]</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> citys:</span><br><span class="line">            <span class="keyword">if</span>(city <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(city <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[city]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[city]=<span class="number">1</span></span><br><span class="line">    drawing.bar(<span class="string">&#x27;地区分布图&#x27;</span>,freqs,<span class="string">&#x27;地区&#x27;</span>,<span class="string">&#x27;人数&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>这里的结果令人出戏，因为西安作为陕西省的省会城市，在所有地区中一骑绝尘。考虑到在这些微博中”西安”存在干扰，所以这个结果并不是非常严谨，不能作为一个有效的分析指标，而且这里存在同义词，比如”本地”和”土著”其实都表示西安，而我们统计的时候并没有考虑这种情况，所以这里绘制的地区分布图表，大家看看就好啦！<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fz05eth452j20zk0hbq3c.jpg" alt="男女性择偶观数据分析:地区分布图"></p>
<h2 id="星座分布"><a href="#星座分布" class="headerlink" title="星座分布"></a>星座分布</h2><p>这里为什么要分析星座呢？理论上来讲，我是不大相信这些东西的，可当你经历的事情多了以后，你就会下意识地认为这些东西说得很对，我想古代的占卜算卦基本上是同样的东西，其实世间好多事情之间应该是没有直接的联系的，无非是在千百年的历史积淀中，逐渐地形成了一套建立在经验上的理论体系，这就像我们今天所追捧的机器学习，我们有千百年的历史长河去收集数据，每一个相信这些理论的人都是一个数据样本，这些理论体系通过不断地训练和模拟，逐渐可以正确地预测某些事情，让我们相信万事万物间存在某种联系。可即便如此，人类依旧免不了对各种事物存在偏见，比如星座中经常无辜躺枪的处女座、双子座和天蝎座，人类最擅长的认知方式，就是用一个群体现象来预测个人现象，可讽刺的是朴素贝叶斯就是这样的思想，所以这里我们简单地统计了下各种星座的频数分布：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 星座分析</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyseStar</span>():</span><br><span class="line">    stars = [<span class="string">&#x27;白羊&#x27;</span>,<span class="string">&#x27;金牛&#x27;</span>,<span class="string">&#x27;双子&#x27;</span>,<span class="string">&#x27;巨蟹&#x27;</span>,<span class="string">&#x27;狮子&#x27;</span>,<span class="string">&#x27;处女&#x27;</span>,<span class="string">&#x27;天秤&#x27;</span>,<span class="string">&#x27;天蝎&#x27;</span>,<span class="string">&#x27;射手&#x27;</span>,<span class="string">&#x27;摩羯&#x27;</span>,<span class="string">&#x27;水瓶&#x27;</span>,<span class="string">&#x27;双鱼&#x27;</span>]</span><br><span class="line">    freqs = &#123;&#125;</span><br><span class="line">    rows = loadData()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        text = row[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">            <span class="keyword">if</span>(star <span class="keyword">in</span> text):</span><br><span class="line">                <span class="keyword">if</span>(star <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">                    freqs[star]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    freqs[star]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> star <span class="keyword">in</span> stars:</span><br><span class="line">        <span class="keyword">if</span>(star <span class="keyword">not</span> <span class="keyword">in</span> freqs.keys()):</span><br><span class="line">            freqs[star] = <span class="number">0</span></span><br><span class="line">    freqs = Counter(freqs).items()</span><br><span class="line">    freqs = <span class="built_in">dict</span>(freqs)</span><br><span class="line">    drawing.pie(<span class="string">&#x27;男女性择偶观数据分析:星座分布&#x27;</span>,freqs,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>这个结果相对客观些，因为 12 个星座基本上平分秋色啦，并不存在某种星座独领风骚的情况，简直是人与自然的大和谐了呢？<br><img src="https://ww1.sinaimg.cn/large/4c36074fly1fz020n6gpfj20hs0b4dgo.jpg" alt="男女性择偶观数据分析:星座分布"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇文章写到这里，我其实已经非常疲惫啦，因为这篇文章的<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/posts/1386017461/">上篇</a>与下篇中间相隔了差不多三个月，而且我写作上篇的时候，并没有打算写这一篇文章出来，再者两篇文章写作时的心境完全不同，所以现在写完这篇文章，终于有种如释重负的感觉，一来没有因拖延症而放弃这篇文章，二来为了了解相关的理论以及训练数据花费大量精力，我必须对自己的过去有一个总结，这是我今年年初给自己制定的目标，不管有没有喜欢我，我总要去做这些事情，不是因为我想要证明什么或者做给谁看，而是我认为这件事情比某些事情有趣而且重要。这篇文章首先承接上文，交待故事的背景，即为什么要做这样的数据分析；然后我们简单介绍了文本分类的常用的技术方法，主要以特征工程和分类器为主；接下来我们介绍了两个经典的理论：tf-idf 和朴素贝叶斯，这是本文文本分类的理论基础；在数据分析这部分，我们对特征、年龄、性别、身高、地区和星座等进行了分析，并借助 Python 中的图表模块完成了数据的可视化工作。好啦，以上就是这篇文章的全部内容啦，欢迎大家积极留言和评论，晚安！</p>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%BE%AE%E5%8D%9A/" rel="tag"># 微博</a>
          
            <a href="/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" rel="tag"># 朴素贝叶斯</a>
          
            <a href="/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/" rel="tag"># 文本分类</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/15/2018-03-15-alibaba-history/" rel="next" title="阿里巴巴的发展史 - 读《阿里铁军》">
                <i class="fa fa-chevron-left"></i> 阿里巴巴的发展史 - 读《阿里铁军》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/18/2018-03-18-tencent-history/" rel="prev" title="腾讯爸爸的历史 - 读《腾讯传》">
                腾讯爸爸的历史 - 读《腾讯传》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1451</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%85%E4%BA%8B%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">故事背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">常见的技术方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">特征工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B1%BB%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">分类器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TF-IDF-%E4%B8%8E%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF"><span class="nav-number">3.</span> <span class="nav-text">TF-IDF 与朴素贝叶斯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">特征分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E9%BE%84%E5%88%86%E5%B8%83"><span class="nav-number">4.2.</span> <span class="nav-text">年龄分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E5%88%AB%E7%BB%84%E6%88%90"><span class="nav-number">4.3.</span> <span class="nav-text">性别组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BA%AB%E9%AB%98%E5%88%86%E5%B8%83"><span class="nav-number">4.4.</span> <span class="nav-text">身高分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E7%90%86%E5%88%86%E5%B8%83"><span class="nav-number">4.5.</span> <span class="nav-text">地理分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%9F%E5%BA%A7%E5%88%86%E5%B8%83"><span class="nav-number">4.6.</span> <span class="nav-text">星座分布</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

</body>
</html>
