<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="AOP,Castle,Dynamic Proxy," />










<meta name="description" content="顺着这样的思路，如果我们可以把 ChannelFactory 注入到 RealProxy 中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的 WCF 服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：;现在，我们来考虑 WCF">
<meta property="og:type" content="article">
<meta property="og:title" content="又见 AOP 之基于 RealProxy 实现 WCF 动态代理">
<meta property="og:url" content="https://blog.feedscoin.com/%E5%8F%88%E8%A7%81AOP%E4%B9%8B%E5%9F%BA%E4%BA%8ERealProxy%E5%AE%9E%E7%8E%B0WCF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="顺着这样的思路，如果我们可以把 ChannelFactory 注入到 RealProxy 中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的 WCF 服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：;现在，我们来考虑 WCF">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g2wasftjc2j20dl0b6t8z.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g2wad7ddv6j20tn09bt9o.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g2w7brst4dj20rm0eqgmc.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g2w85svbrfj20rp0eqq41.jpg">
<meta property="article:published_time" content="2019-05-10T08:27:50.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.196Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="AOP">
<meta property="article:tag" content="Castle">
<meta property="article:tag" content="Dynamic Proxy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/4c36074fly1g2wasftjc2j20dl0b6t8z.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/又见AOP之基于RealProxy实现WCF动态代理/"/>





  <title>又见 AOP 之基于 RealProxy 实现 WCF 动态代理 | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E5%8F%88%E8%A7%81AOP%E4%B9%8B%E5%9F%BA%E4%BA%8ERealProxy%E5%AE%9E%E7%8E%B0WCF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">又见 AOP 之基于 RealProxy 实现 WCF 动态代理</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-10T08:27:50+00:00">
                2019-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  顺着这样的思路，如果我们可以把 ChannelFactory 注入到 RealProxy 中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的 WCF 服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：;现在，我们来考虑 WCF，WCF 需要通过 ChannelFactory 来创建和释放，而这恰恰是代理类所做的事情，就像下面的代码一样，我们通常会把所有的 WCF 集中配置在一个地方，并通过构造 Binding 和终结点地址来创建一个 WCF 服务，在调用服务的过程中，会对调用时间、异常信息等进行记录，这其实和我举的第一个例子完全一致，那么我们能不能用 RealProxy 来实现这些功能呢;首先，我们定义一个简单的接口 ICalculator，它含有加、减、乘、除四种基本运算，我们希望记录每个方法调用的参数、结果和执行时间，因此通过 RealProxy 对现有类型 CalculatorService 进行代理，并动态地创建代理对象来供调用方使用，下面给出关键代码：
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      

        <p>最近一直在研究 Mongodb 和 ElasticSearch 之间同步数据的问题，苦于到目前为止，并没有取得任何实质性的进展。偶尔“趁得浮生半日闲暇”，看一看 Web API 设计方面的书籍，和前辈交流下项目中的历史遗留问题，最为直观的感受就是，这个世界上任何方案的最终落地，都经过理想和现实的无数次挣扎，比如我们希望迁移项目到.NET Core 平台上，初步分析大概有将近 1000 多个无法兼容的地方，维持现状固然可以保证整个项目的稳定，可如果真到了不得不升级的地步，面临的问题可能会越来越多，所谓“凡事预则立，不预则废”，早一点准备总是好的。既然说到里历史问题，那么，今天这篇文章就来说一说，基于 RealProxy 实现 WCF 动态代理。</p>
<h1 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h1><p>在我们的业务系统中，对内是使用 WCF 来进行相互通信的，而对外则是使用 Web API 来进行数据交换。关于 RPC 还是 REST 的争论由来已有，严格地来说，两者没有绝对的高下之分，从风格上而言，RPC 倾向于让接口映射到一个方法上，而 REST 则倾向于让接口映射到一个资源上。从我们实际的使用情况来看，REST 在系统中应用得并不是很完美，因为大多数情况下，我们实现的仅仅是 HTTP+JSON 这样一种协议组合，因此业务系统中存在着大量的 WCF 接口供系统内部调用。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g2wasftjc2j20dl0b6t8z.jpg" alt="内部服务调用示意图"></p>
<p>最早的时候，是通过 T4 模板来生成针对某个接口的代理类，而代理类中通常封装了 ChannelFactory 的创建、释放等等 WCF 相关的代码，实际应用中还会对 WCF 接口的异常进行捕获、记录日志、统计调用时间等，因此早期的 T4 模板实际上承担了生成代理类的职责。虽然业务的不断推进，接口中加入的新方法越来越多，导致具体业务类中的代码越来越多，动辄出现单个文件中代码行数达 3000 行以上，与此同时，每当 WCF 接口中增加了新方法，就不得不在其相关的代理类中增加代理方法。坦白地讲，就是增加一个看起来差不多的方法，因为你依然要处理 ChannelFactory 的创建、释放、异常处理、日志记录等等的工作。</p>
<p>其实，WCF 可以直接生成客户端代码，因为每个 WCF 的服务都可以以 WebService 服务的形式暴露出来，而只要是 WebService，总可以通过 WSDL 生成一个代理类。不过这显然不利于团队间的协作，更不利于服务终结点配置的集中化，更失去了异常处理、日志记录等等这些“通用”工作的可能性。T4 应该可以基于“工作”，可显然大家觉得手写比生成要来得更容易些，所以，这个故事最终演变成这样一个局面，我们不得不通过局部类(Partial Class)的方式来开辟新的类文件。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g2wad7ddv6j20tn09bt9o.jpg" alt="系统中充斥着大量类似的代码"></p>
<p>那么，说了这么多，从一个历史遗留问题入手，它真正的痛点在哪里呢？在我看来，主要有两点：第一，是手写代理类的“此恨绵绵无绝期”，明明就是对接口的简单封装，看起来是增加一个代理方法，其实最多就是复制黏贴，因为代理方法的核心代码就是调用接口，而剩下的都是重复的“服务型”代码；第二，是异常处理、日志记录的“哀鸿遍野”，同核心代码交织在一起，一遍又一遍的“重复”，为什么不考虑让它统一地去处理呢？难道每个人都抄着同一段代码，这样就实现了某种意义上的复用吗？</p>
<h1 id="RealProxy-介绍"><a href="#RealProxy-介绍" class="headerlink" title="RealProxy 介绍"></a>RealProxy 介绍</h1><p>既然像我这样懒惰的人，不愿意像别人一样手写代理类，那么我的思路又是什么呢？显然，从这篇文章的题目，你就可以看出，我这里要说的是动态代理，原来的代理类同样属于代理，它是在编译时期间生成了一个代理类，我们以为在调用这个代理类，可其实真正去工作的是 ChannelFactory，这种方式称之为“静态代理”。如果你了解过设计模式，应该会知道相对应的代理模式，这里不再展开开来讲这这个设计模式，可以明确的是，动态代理就是在运行时期间动态创建一个代理对象的实例，它可以完全模拟被代理对象的行为，而我们的目的，就是要和手写的代理类永远地说再见！</p>
<p>好了，下面隆重介绍本文的主角——RealProxy。相信大家一定听说过 AOP，即所谓的面向切面编程。它可以让我们在某一个所针对的横切面编程，并讲这种功能应用到所有相同的横切面上。譬如对方法级别的横切面增加拦截器，那么所有的方法都可以在执行前后具备相同的逻辑，典型的如日志记录、指定操作前的检验等等。而 RealProxy 类恰恰提供最基本的代理功能，它是一个抽象类，必须通过重写其 Invoke()方法并添加新功能来继承，该类位于 System.Runtime.Remoting.Proxies 命名空间中，通过重写 Invoke()方法，我们就可以在被代理对象调用前后插入相关逻辑，而通过 GetTransparentProxy()方法，则可以返回实际的代理对象。所以，通过这个原理，我们就可以在运行时期间，动态创建出指定类型的实例。这里，我们从一个简单的例子来开始，以帮助大家更好的理解 RealProxy。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorService</span> : <span class="title">ICalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 * n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">double</span> n1, <span class="built_in">double</span> n2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们定义一个简单的接口 ICalculator，它含有加、减、乘、除四种基本运算，我们希望记录每个方法调用的参数、结果和执行时间，因此通过 RealProxy 对现有类型 CalculatorService 进行代理，并动态地创建代理对象来供调用方使用，下面给出关键代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorServiceProxy</span> : <span class="title">RealProxy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Server.Service.ICalculator _calculator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CalculatorServiceProxy</span>(<span class="params">Server.Service.ICalculator calculator</span>) :</span></span><br><span class="line"><span class="function">            <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(Server.Service.ICalculator</span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            _calculator = calculator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IMessage <span class="title">Invoke</span>(<span class="params">IMessage message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> methodCall = message <span class="keyword">as</span> IMethodCallMessage;</span><br><span class="line">            <span class="keyword">var</span> methodInfo = methodCall.MethodBase <span class="keyword">as</span> MethodInfo;</span><br><span class="line">            <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> serviceName = _calculator.GetType().Name;</span><br><span class="line">            <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;调用&#123;0&#125;服务的&#123;1&#125;方法开始...&quot;</span>, serviceName, methodName);</span><br><span class="line">                <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methodCall.ArgCount; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    argsInfo.Add(methodCall.GetArgName(i), methodCall.Args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前传入参数:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">                <span class="keyword">var</span> result = methodInfo.Invoke(_calculator, methodCall.InArgs);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;当前返回值:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnMessage(result, <span class="literal">null</span>, <span class="number">0</span>, methodCall.LogicalCallContext, methodCall);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(</span><br><span class="line">                    <span class="string">&quot;调用&#123;0&#125;服务的&#123;1&#125;方法失败,失败原因：&#123;2&#125;&quot;</span>, </span><br><span class="line">                    serviceName, methodName, ex.Message</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(</span><br><span class="line">                    <span class="string">&quot;调用&#123;0&#125;服务的&#123;1&#125;方法结束,共耗时&#123;2&#125;秒&quot;</span>, </span><br><span class="line">                    serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds</span><br><span class="line">                );</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，最核心的代码是在 Invoke()方法中，在这里我们增加了我们想要的功能，但这些功能丝毫不会影响到 CalculatorService，当我们通过构造函数给 RealProxy 传入被代理对象后，它就会对被代理对象的特定方法进行拦截，这里实际上就是加、减、乘、除四个方法。OK，到现在为止，这些都是我们的想像而已，具体我们实现执行结果来看。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceProxy = <span class="keyword">new</span> CalculatorServiceProxy(<span class="keyword">new</span> CalculatorService());</span><br><span class="line"><span class="keyword">var</span> calculator = (ICalculator)serviceProxy.GetTransparentProxy();</span><br><span class="line">calculator.Add(<span class="number">12</span>, <span class="number">24</span>);</span><br><span class="line">calculator.Subtract(<span class="number">36</span>, <span class="number">10</span>);</span><br><span class="line">calculator.Multiply(<span class="number">12</span>, <span class="number">35</span>);</span><br><span class="line">calculator.Divide(<span class="number">36</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>现在，我们可以说，刚刚所说的一切都是真的，因为我们真的创建了一个 ICalculator 接口的实例，它真的记录了每个方法调用的参数、结果和执行时间。</p>
<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g2w7brst4dj20rm0eqgmc.jpg" alt="RealPrxoy牛刀小试"></p>
<h1 id="WCF-动态代理"><a href="#WCF-动态代理" class="headerlink" title="WCF 动态代理"></a>WCF 动态代理</h1><p>现在，我们来考虑 WCF，WCF 需要通过 ChannelFactory 来创建和释放，而这恰恰是代理类所做的事情，就像下面的代码一样，我们通常会把所有的 WCF 集中配置在一个地方，并通过构造 Binding 和终结点地址来创建一个 WCF 服务，在调用服务的过程中，会对调用时间、异常信息等进行记录，这其实和我举的第一个例子完全一致，那么我们能不能用 RealProxy 来实现这些功能呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceInfo</span>&lt;<span class="title">TService</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ChannelFactory _channelFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceInfo</span>(<span class="params">ChannelFactory channelFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _channelFactory = channelFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TService Service &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_channelFactory != <span class="literal">null</span>)</span><br><span class="line">            _channelFactory.Close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo&lt;TService&gt; <span class="title">FindService</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ChannelFactory&lt;TService&gt; channelFactory = <span class="keyword">new</span> ChannelFactory&lt;TService&gt;(_binding, _endpointAddress);</span><br><span class="line">    <span class="keyword">var</span> serviceInfo = <span class="keyword">new</span> ServiceInfo&lt;TService&gt;(channelFactory);</span><br><span class="line">    serviceInfo.Service = channelFactory.CreateChannel();</span><br><span class="line">    <span class="keyword">return</span> serviceInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>顺着这样的思路，如果我们可以把 ChannelFactory 注入到 RealProxy 中，就可以在接口调用过程中记录相关信息，这样我们就可以关注调用本身，因为所有的我们不想写的代码，现在全部都由代理类接管了，更重要的是，所有通过这种方式调用的 WCF 服务，都可以以一种统一而简洁的方式去处理，永远不用担心因为某个人忘记写代理方法而出现问题，下面给出整个实现的关键代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicServiceProxy</span>&lt;<span class="title">TService</span>&gt; : <span class="title">RealProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Binding _binding;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> EndpointAddress _endpointAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicServiceProxy</span>(<span class="params">Binding binding, EndpointAddress endpointAddress</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(TService</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">        _binding = binding;</span><br><span class="line">        _endpointAddress = endpointAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicServiceProxy</span>(<span class="params">Binding binding, <span class="built_in">string</span> serviceUrl</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">this</span>(<span class="params">binding, <span class="keyword">new</span> EndpointAddress(serviceUrl</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IMessage <span class="title">Invoke</span>(<span class="params">IMessage message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceInfo = FindService();</span><br><span class="line">        <span class="keyword">var</span> methodCall = message <span class="keyword">as</span> IMethodCallMessage;</span><br><span class="line">        <span class="keyword">var</span> methodInfo = methodCall.MethodBase <span class="keyword">as</span> MethodInfo;</span><br><span class="line">        <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">        <span class="keyword">var</span> serviceName = serviceInfo.Service.GetType().Name;</span><br><span class="line">        <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;RealProxy调用&#123;0&#125;服务&#123;1&#125;方法开始...&quot;</span>, serviceName, methodName);</span><br><span class="line">            <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methodCall.ArgCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                argsInfo.Add(methodCall.GetArgName(i), methodCall.Args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;RealProxy当前传入参数:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">            <span class="keyword">var</span> result = methodInfo.Invoke(serviceInfo.Service, methodCall.InArgs);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;RealProxy当前返回值:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnMessage(result, <span class="literal">null</span>, <span class="number">0</span>, methodCall.LogicalCallContext, methodCall);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(</span><br><span class="line">                <span class="string">&quot;RealProxy调用&#123;0&#125;服务&#123;1&#125;方法失败,失败原因：&#123;2&#125;&quot;</span>, </span><br><span class="line">                serviceName, methodName, ex.Message</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            serviceInfo.Close();</span><br><span class="line">            Console.WriteLine(</span><br><span class="line">                <span class="string">&quot;调用&#123;0&#125;服务&#123;1&#125;方法结束,共耗时&#123;2&#125;秒&quot;</span>, </span><br><span class="line">                serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds</span><br><span class="line">            );</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 WCF 服务端的实现，我们依然使用 ICalculator 这个接口，需要注意的是为其添加[ServiceContract]和[OperationContract]标签，在这个例子中，我们共有 CalculatorService 和 MessageService 两个服务，为了简化这个实例，我们采用 BasicHttpBinding 的方式进行绑定，并为其指定各自的终结点地址。可以注意到，现在我们的动态代理实现了和原来代理类一样的效果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binding = <span class="keyword">new</span> BasicHttpBinding();</span><br><span class="line"><span class="keyword">var</span> serviceUrl = <span class="string">&quot;http://localhost:8502/Calculator.svc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> calculator = ServiceProxyFactory.CreatePorxy&lt;Server.Service.ICalculator&gt;(binding, serviceUrl);</span><br></pre></td></tr></table></figure>

<p><img src="https://ww1.sinaimg.cn/large/4c36074fly1g2w85svbrfj20rp0eqq41.jpg" alt="通过RealPrxoy动态代理WCF服务"></p>
<p>在调用 WCF 的时候，因为超时、网络等原因造成的调用异常，此时，我们可以为 WCF 添加异常处理相关的标签，而相应地，我们可以在异常中对异常的种类进行判断和处理，以便于及时地关闭 ChannelFactory，因为如果它不能正确地关闭，会导致后续的通信出现问题，而这恰好是当初的代理类想要解决的问题，考虑到创建 ChannelFactory 是需要付出一定的性能代价的，因此，可以适当地考虑对 ChannelFactory 进行缓存，而这恰好是原来业务中的一个盲点。</p>
<h1 id="Castle-DynamicProxy"><a href="#Castle-DynamicProxy" class="headerlink" title="Castle.DynamicProxy"></a>Castle.DynamicProxy</h1><p>通过 RealProxy，我们已经实现了 WCF 服务的动态代理，这里介绍第二种方式，即 Castle.DynamicProxy，Castle 和 AspectCore、Unity 等项目一样，提供了 AOP 相关的能力，可以让我们对接口、虚方法、类等进行拦截。Castle 中的动态代理使用的是透明代理，而.NET Remoting 的动态代理必须继承自 MarshalByRefObject。博主暂时没有搞清楚，这两种是否属于同一种技术上的实现，作为延伸，我们来一起看看如何使用 Castle 中的 DynamicProxy 实现类似的功能，首先我们定义一个拦截器，它需要实现 IInterceptor 接口中的 Intercept()方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Intercept</span>(<span class="params">IInvocation invocation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serviceInfo = FindService();</span><br><span class="line">    <span class="keyword">var</span> methodInfo = invocation.Method;</span><br><span class="line">    <span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line">    <span class="keyword">var</span> serviceName = serviceInfo.Service.GetType().Name;</span><br><span class="line">    <span class="keyword">var</span> methodName = methodInfo.Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;CastleProxy调用&#123;0&#125;服务&#123;1&#125;方法开始...&quot;</span>, serviceName, methodName);</span><br><span class="line">        <span class="keyword">var</span> argsInfo = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">        <span class="keyword">var</span> parameters = methodInfo.GetParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; invocation.Arguments.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            argsInfo.Add(parameters[i].Name, invocation.Arguments[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前传入参数:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(argsInfo));</span><br><span class="line">        <span class="keyword">var</span> result = methodInfo.Invoke(serviceInfo.Service, invocation.Arguments);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123; </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前返回值:&#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(result));</span><br><span class="line">            invocation.ReturnValue = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">&quot;CastleProxy调用&#123;0&#125;服务&#123;1&#125;方法失败,失败原因：&#123;2&#125;&quot;</span>, </span><br><span class="line">            serviceName, methodName, ex.Message</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        serviceInfo.Close();</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">&quot;CastleProxy调用&#123;0&#125;服务&#123;1&#125;方法结束,共耗时&#123;2&#125;秒&quot;</span>, </span><br><span class="line">            serviceName, methodName, DateTime.Now.Subtract(startTime).TotalSeconds</span><br><span class="line">        );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们通过 ProxyGenerator 来生成新的代理类，我们需要告诉 ProxyGenerator 要创建的类型是什么，是一个接口还是类，以及要应用哪一个拦截器。这里我们用到的方法是 CreateInterfaceWithoutTarget()，它在这里的作用就是动态创建 ICalculator 接口的代理类。而通过查看 Castle 的 API，我们会发现它可以在以下几种情况下创建某个类型的实例。首先是 CreateInterfaceWithoutTarget()这个方法，当你希望创建一个接口的代理而又不想提供具体的实现时可以使用。其次是 CreateInterfaceProxyWithTarget()这个方法，当你希望创建一个接口的代理同时又有提供具体实现时使用可以使用。接下来，是 CreateInterfaceProxyWithTargetInterface()这个方法，它的命名看起来让人感到迷惑，甚至在某种角度来看，它和 CreateInterfaceProxyWithTarget()这个方法还有点相似，其实。这两者最大的不同就是：后者允许你将调用目标替换为目标接口的不同实现。这种在实际场景中使用得不多，从 Castle 官方的使用场景来看，唯一用到这种技术的是 Castle.Facilities，它可以和 Windsor 这样的容器整合在一起使用，这个时候调用者就可以把 WCF 服务当作一个普通接口来使用，果然，大家都想到这一点，英雄所见略同啊，哈哈。好了，下面我们来看具体的代码实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProxyGenerator generator = <span class="keyword">new</span> ProxyGenerator();</span><br><span class="line"><span class="keyword">var</span> interceptor = <span class="keyword">new</span> CastleServicePorxy&lt;ICalculator&gt;(binding, serviceUrl);</span><br><span class="line"><span class="keyword">var</span> calculator = (ICalculator)generator.CreateInterfaceProxyWithoutTarget(<span class="keyword">typeof</span>(ICalculator),interceptor);</span><br></pre></td></tr></table></figure>




<h1 id="迁移至-NET-Core"><a href="#迁移至-NET-Core" class="headerlink" title="迁移至.NET Core"></a>迁移至.NET Core</h1><p>其实，我对 WCF 是不太感冒的，因为第一个字母 W 表明，它是一个只能运行在 Windows 平台的产物，现在依然有大量的 Web Service 存在，如果可以让我像使用普通接口一样使用 WCF 接口，我还是非常愿意去使用它的，毕竟系统中有大量依赖 WCF 的东西。可话又说回来，现在到.NET Core 这个版本，微软并没有把 WCF 的服务端移植到.NET Core 上，仅仅是提供了客户端调用的支持，或许还是因为 WCF 里有太多平台相关的东西吧！如果希望自己的.NET 应用可以跨平台，越早摆脱这些 Windows 平台东西越好，譬如 IIS、SQLServer 等等。不过我这里想说的是，RealProxy 在.NET Core 中有类似的实现，我们可以用下面这种方式来进行迁移，当然，如果你直接 Castle 就更没有问题啦！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvokeSerice</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Proxy</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> DispatchProxy.Create&lt;T, InvokeProxy&lt;T&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvokeProxy</span>&lt;<span class="title">T</span>&gt; : <span class="title">DispatchProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Type type = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokeProxy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="keyword">typeof</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Invoke</span>(<span class="params">MethodInfo targetMethod, <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 在这里实现拦截逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客再次让大家领略了 AOP 的魅力，通过动态代理来创建相关的服务接口，让我们逐渐摆脱了手写代理类的深渊。本文主要分享了两种动态代理的实现方式，一种是基于.NET Remoting 的 RealProxy，一种是基于 Castle 的 DynamicProxy。两种方式在使用上是非常相近的，通过这种方式。我们实现了 WCF 服务创建细节的隐藏，调用者不再需要去关心 ChannelFactory 相关的底层细节，可以像使用普通接口一样调用 WCF 服务，并且可以用一种统一的方式去记录调用相关的细节、对异常进行处理等等。早期的 T4 模板本质上是一种静态代理的方式，其缺点是难以适应快速迭代的变化，必须人手编写代理方法，而通过动态代理，这一切只需要写一次就好了，从而做到了真正意义上的“一次编写，到处运行”，这就是所谓的面向横切面编程的思路。关于 Castle 动态代理更多的应用场景，以及 Castle.Facilities 相关的内容，大家可以从各自的文档中去了解，以上就是这篇博客的全部内容了。</p>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AOP/" rel="tag"># AOP</a>
          
            <a href="/tags/Castle/" rel="tag"># Castle</a>
          
            <a href="/tags/Dynamic-Proxy/" rel="tag"># Dynamic Proxy</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019-05-08-the-origin-of-brands-book-summary/" rel="next" title="分化的力量 - 读《品牌的起源》">
                <i class="fa fa-chevron-left"></i> 分化的力量 - 读《品牌的起源》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/38-%E6%B7%B1%E5%9C%B3%E6%B5%99%E6%B1%9F%E8%8F%9C%E6%8E%A2%E5%AF%BB/" rel="prev" title="深圳浙江菜探寻">
                深圳浙江菜探寻 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1458</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">890</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%85%E4%BA%8B%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">故事背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RealProxy-%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">RealProxy 介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WCF-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">WCF 动态代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Castle-DynamicProxy"><span class="nav-number">4.</span> <span class="nav-text">Castle.DynamicProxy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%81%E7%A7%BB%E8%87%B3-NET-Core"><span class="nav-number">5.</span> <span class="nav-text">迁移至.NET Core</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
