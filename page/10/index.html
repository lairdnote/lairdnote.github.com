<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/10/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/10/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/hg-hooks.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/hg-hooks.html" itemprop="url">Hg hooks 实践历程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-16T16:00:00+00:00">
                2022-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><blockquote>
<aside> 💬 提交代码前记得 lint</aside>
<aside> 💬 又有人没跑测试就提交代码</aside>
<aside> 💬 project-config 有改动，麻烦 yarn setup 一下</aside>
</blockquote>
<p>相信使用 Hg 的同学们已经非常熟悉上面这几句话了，我们每次在提交或者拉取代码时总需要手动执行某些命令，实在繁琐。</p>
<p>但现在已经 2022 年了，难道就没有更好的解决方法吗？</p>
<p>有的，我们知道，在 Git 有个东西叫做 hooks（钩子），可以在特定事件发生之前或之后执行特定动作。</p>
<p>同样的，Hg 也有 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/wiki/hook">hooks</a>，不过并不像 Git 一样生态蓬勃发展，也没有太多现有的开源工具可供大家使用。</p>
<p>本文就来介绍一下我们从 0 到 1 的 Hg hooks 实践过程，同时也希望能够起到抛砖引玉的作用。</p>
<h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在没有引入 Hg hooks 之前，我们常常会面对几种情况：</p>
<ol>
<li>有同学在提交代码时忘记执行 <code>yarn lint</code>、<code>yarn test</code></li>
<li>修改了 <code>project-config</code> 的常量，却忘记通知大家，或者有人错过了这条信息。</li>
</ol>
<p>这都有可能会导致其他小伙伴拉取代码后，发现页面上的某个功能突然异常，花费一段时间排查才发现原来是没有执行 <code>yarn setup</code>。</p>
<p>可能有部分同学会想到，那我自定义一个命令在提交或者拉取代码时自动做这件事不就好了吗？</p>
<p>比如这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn lint &amp;&amp; hg commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hg pull --update &amp;&amp; yarn setup</span><br></pre></td></tr></table></figure>

<p>这样也不是不行，但是会存在一些问题：</p>
<ol>
<li>由于每个人的拉取代码的命令不一样，如果项目开发流程发生变化，则每个人都需要同步修改</li>
<li>有些同学习惯使用图形化界面，比如 SourceTree、vscode-hg 等，则无法自定义操作命令</li>
</ol>
<p>因此，我们另辟蹊径，寻找更好的解决方案。</p>
<h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>我们最主要想解决的问题就是：</p>
<ol>
<li>在提交代码前自动执行 <code>yarn lint</code>、<code>yarn test</code>，不通过则直接终止提交。</li>
<li>在拉取代码后，检测到如果 project-config 目录发生改动，则自动执行 <code>yarn setup</code>。</li>
<li>还有更多：<ol>
<li>检查 commit message 规范</li>
<li>统一代码的格式化风格</li>
</ol>
</li>
</ol>
<p>这些都可以通过 Hg hooks 解决，所以开始之前，我们先对 Hg hooks 做一个简单的认识。</p>
<h3 id="Hg-hooks-介绍"><a href="#Hg-hooks-介绍" class="headerlink" title="Hg hooks 介绍"></a>Hg hooks 介绍</h3><p>Hg hooks 能做什么，这次再介绍一遍：<strong>它可以在特定事件发生之前或之后执行特定动作。</strong></p>
<p>特定事件，指的就是我们在对 Hg 仓库进行操作时的一些钩子，比如提交前（precommit）、提交后（commit），可以在这里查看全部 hooks 列表：<a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/hgrc">hooks</a>。</p>
<p>下面介绍一下如何使用 hook，我们可以通过以下两个文件进行配置：</p>
<ol>
<li><code>~/.hgrc</code>：全局的，将对所有 hg 仓库起作用。</li>
<li>项目根目录的 <code>.hg/hgrc</code> ：仅对当前仓库起作用。</li>
</ol>
<p>比如我们想要实现一个简单的需求：在提交代码前进行 <code>yarn lint</code>。</p>
<p>首先编辑 <code>.hg/hgrc</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hooks</span>]</span><br><span class="line"><span class="string">precommit</span> <span class="string">=</span> <span class="string">./bin/hooks/precommit.sh</span> <span class="comment"># 这个路径是相对于项目根目录的</span></span><br></pre></td></tr></table></figure>

<p>然后编写脚本 <code>bin/hooks/precommit.sh</code>（也可以使用 python）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">yarn lint</span><br><span class="line"></span><br><span class="line"><span class="comment"># lint 没有通过直接退出</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这里需要特别指出，之所以需要重新声明 <code>PATH</code> 变量：</p>
<ol>
<li>hooks 脚本的运行环境取决于同学提交代码的地方，比如通过 SourceTree 提交，由于环境不一样，就可能会出现 <code>yarn: command not found</code> 的报错，参见：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22883197/git-command-not-found-in-the-custom-action-for-sourcetree">‘Git Command Not found’ in the custom action for SourceTree - Stack Overflow</a>。</li>
<li>每个同学安装 hg 的方式可能不一样，有通过 brew、pip、甚至自己手动编译的，它们的可执行文件路径不一样。<ul>
<li>可以通过 <code>which hg</code> 查看这个命令的可执行文件路径。</li>
</ul>
</li>
</ol>
<p>这样，一个简单的 hook 就配置完成了，这时候提交代码就会触发 <code>precommit.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;ci: precommit hooks&quot;</span></span><br><span class="line"></span><br><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br></pre></td></tr></table></figure>

<p>当 hook 脚本的 exit code 不为 0 的时候，则会终止当前的 Hg 操作，对于某些具有事务性的 hook（e.g. pretxncommit），还会自动进行回滚。</p>
<p>可以通过以下链接对 Hg hooks 进行更深入地学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/wiki/hookExamples">hookExamples</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/wiki/Usefulhooks">Usefulhooks</a></li>
<li><a target="_blank" rel="noopener" href="http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html">Chapter 10. Handling repository events with hooks (red-bean.com)</a></li>
</ul>
<h3 id="Hg-hooks-实践"><a href="#Hg-hooks-实践" class="headerlink" title="Hg hooks 实践"></a>Hg hooks 实践</h3><h4 id="提交代码前（precommit）"><a href="#提交代码前（precommit）" class="headerlink" title="提交代码前（precommit）"></a>提交代码前（precommit）</h4><p>这里需要用到的 hook 是 precommit，它的运行时机在提交之前，exit code 非 0 时将终止提交。</p>
<p> <code>precommit.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要 lint 的项目</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram&#x27;</span></span><br><span class="line">    <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    <span class="string">&#x27;core&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否修改该项目，无则跳过 lint</span></span><br><span class="line">    has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;app&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$app</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">    yarn &amp;&amp; yarn lint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lint 是否报错，是则直接退出脚本</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对当前修改或新增的文件批量进行 prettier 格式化</span></span><br><span class="line">hg status | grep -E <span class="string">&quot;^(M|A).*.(js|json|wxss)$&quot;</span> | sed <span class="string">&#x27;s|^M||g; s|^A||g&#x27;</span> | xargs ./node_modules/.bin/prettier --write &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>比较浅显易懂，由于是 Monorepo 架构，所以仅针对当前改动的子项目执行 <code>yarn lint</code> ，当 lint 不通过时终止提交；然后仅对当前变更的文件做 prettier 格式化，并且忽略这行命令的输出和错误。</p>
<p>ps：其实这里的 prettier 机制有点问题，原本的目的是仅格式化当前提交的文件，但 Hg 没有 staging area 的概念，故只能粗暴处理，如果有更好的解决方法欢迎指教。</p>
<ul>
<li>hg commit 可以只提交指定的部分文件，所以是有 changed files 和 commited files 两个概念，但是没有找到办法获取 commited files，参见：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24565802/mercurial-pre-commit-hook-how-to-tell-apart-changed-and-committed-files">Mercurial pre-commit hook: How to tell apart changed and committed files - Stack Overflow</a></li>
<li>另一种思路：使用 pretxncommit 钩子，就可通过 $Hg_NODE 变量拿到当前 commit 的信息，但缺点是 pretxncommit 阶段将不能再对文件进行改动，则格式化后需要重新提交一遍。</li>
</ul>
<p>随着版本迭代，在 precommit 钩子中增加了检测 utils、test 目录改动则自动执行单元测试 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改以下文件需要执行单元测试</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram/utils miniprogram/test&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">dir</span>=(<span class="variable">$app</span>)</span><br><span class="line">    pass=0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;dir[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 判断是否修改工具方法、测试用例，无则跳过</span></span><br><span class="line">        has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;d&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 同一个项目只执行一次</span></span><br><span class="line">        [ <span class="variable">$pass</span> -eq 1 ] &amp;&amp; <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$d</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line">        yarn &amp;&amp; yarn <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># test 是否报错，是则直接退出脚本</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        pass=1</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> -</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="拉取代码后（changegroup）"><a href="#拉取代码后（changegroup）" class="headerlink" title="拉取代码后（changegroup）"></a>拉取代码后（changegroup）</h4><p>主要想解决的问题是：当拉取代码后，检测到 project-config 目录发生变更，则执行 <code>yarn setup</code>。</p>
<p>首先要解决第一点，如何获取从远端拉取代码所改动的文件？有下面几种方法：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://backend.bolt80.com/hgdoc/hg-incoming.html">hg incoming</a>：显示远端中的新 commit</p>
<ul>
<li>缺点：该方法只是显示新的 commit，后面仍需要再进行一次 pull 才能将新 commit 拉取下来，导致拉取代码时间翻倍。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://backend.bolt80.com/hgdoc/hg-pull.html">hg pull</a>：在拉取代码之后、进行 update 或 rebase 之前，通过 <code>hg log</code> 对比本地 head 和 远端拉取下来的 head。</p>
</li>
<li><p>hooks：</p>
<ol>
<li>update：工作目录发生改变时，所以只要进行提交、储藏、切换分支都会触发，<strong>不考虑</strong>。</li>
<li>incoming：每一个新的 commit 被传入时都会触发一次，过于频繁，<strong>不考虑</strong>。</li>
<li>changegroup：在 push、pull、unbundle 时都会触发，但多个 commit 被传入也只会触发一次，<strong>可考虑</strong>。</li>
<li>还有一些不太满足的 hooks 不一一介绍了。</li>
</ol>
</li>
</ol>
<p>在一开始，我们曾尝试使用第二种方法解决该问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    no_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改动文件</span></span><br><span class="line">    regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本次 pull 变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">    has_change=$(hg <span class="built_in">log</span> --verbose -r .:tip | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参考 hg update --rebase 的实现，先尝试 rebase，如果不需要 rebase，则直接 update</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/35327163/what-is-the-rebase-command-used-in-hg-pull-rebase</span></span><br><span class="line">    <span class="comment"># @link：https://www.mercurial-scm.org/repo/hg/file/tip/hgext/rebase.py#l2172</span></span><br><span class="line">    has_rebase=$(hg rebase -b . -d <span class="string">&#x27;last(branch(.))&#x27;</span> | grep <span class="string">&quot;nothing to rebase&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_rebase</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg update</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        yarn setup</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$no_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法可以很好地工作，它可以满足：</p>
<ul>
<li>拉取代码时自动储藏、恢复本地改动</li>
<li>当两端都同时修改 project-config 时，可以 update 或者 rebase 后再统一 <code>yarn setup</code></li>
</ul>
<p>后来发现使用 changegroup  hook 配合 <code>hg log</code> 一样可以解决问题，于是就有了 <code>changegroup.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改动文件</span></span><br><span class="line">regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本次变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line"><span class="comment"># @see：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">has_change=$(hg <span class="built_in">log</span> -v -r <span class="variable">$Hg_NODE</span>: | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> $(hg root) || <span class="built_in">exit</span> 1</span><br><span class="line">    yarn setup</span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p> 因此 <code>hgpl</code> 可以精简成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    has_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull --rebase</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commit-message-检查（pretxncommit）"><a href="#commit-message-检查（pretxncommit）" class="headerlink" title="commit message 检查（pretxncommit）"></a>commit message 检查（pretxncommit）</h4><p>使用 pretxncommit 钩子可对当前提交信息进行检查，如检查 commit message：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">shelve_user=<span class="string">&quot;shelve@localhost&quot;</span></span><br><span class="line"></span><br><span class="line">commit_user=$(hg tip --template &#123;user&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 hg shelve 也会触发 pretxncommit 钩子，所以要进行忽略</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$commit_user</span>&quot;</span> == <span class="string">&quot;<span class="variable">$shelve_user</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">commit_message=$(hg tip --template &#123;desc&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[msg] <span class="variable">$commit_message</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$commit_message</span>&quot;</span> | ./node_modules/.bin/commitlint</span><br></pre></td></tr></table></figure>

<h2 id="铁器时代？"><a href="#铁器时代？" class="headerlink" title="铁器时代？"></a>铁器时代？</h2><p>这个标题之所以打上一个问号，是因为该方案仍在 POC 阶段，尚未落地实施，但也可作为一个对未来的展望。</p>
<p>迄今为止，我们的 Hg hooks 已经能够满足大部分场景了，那还存在些什么问题呢？</p>
<p>相信不少同学已经发现这样操作会存在有一个很明显的问题，那就是：hooks 配置如何同步？</p>
<p>我们知道 <code>.hg</code> 目录是不会加入版本控制的，这是非常合理且必要的，因为 hooks 本身是一些权限极高的可执行脚本，所以出于安全考虑（你也不想你 clone 一个仓库后，它会自动执行某些你不想执行的命令），<strong>因此是不会有任何一个 VSC 会将 hooks 加入版本控制的。</strong></p>
<p>可是这就会导致：</p>
<ol>
<li>假如项目新增了一个 hook，需要通知项目成员同步修改本地的 hooks 配置。</li>
<li>新成员加入项目，需要手动配置 hooks。</li>
</ol>
<p>如果这个问题不能得到解决，那归根到底还是无法绕过通知项目成员手动操作的过程。</p>
<p>所幸，以上问题在 Git 中同样存在，并且已经有很多非常成熟的方案，如： <a target="_blank" rel="noopener" href="https://github.com/typicode/husky">huksy</a>、<a target="_blank" rel="noopener" href="https://pre-commit.com/">pre-commit</a> 。</p>
<p>那有没有人在 Hg 生态上解决这个问题呢？粗略找到了两个：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/TobiasTimm/husky-hg">husky-hg</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/theylom/tdog-husky-hg">tdog-husky-hg</a>（前者的 fork</li>
</ol>
<p>都是基于 husky <a target="_blank" rel="noopener" href="https://github.com/tobiastimm/husky-hg/commit/fcd100f4f1a7bdf04c05f51ddd80af9f87687ddc#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519R2">v0.14.3</a> 改造的，最后提交时间都在三年前（2019），然而 husky 现在已经迭代到 <a target="_blank" rel="noopener" href="https://github.com/typicode/husky/releases/tag/v7.0.4">v7</a> 版本了，这 3 年间经过无数迭代，使用方式和实现原理都发生翻天覆地的变化，于是我们决定基于 husky v7 自行改造。</p>
<p>但是在此之前，我们先了解一下 Git 如何配置 hooks：</p>
<ol>
<li>在以前的 Git 版本中，如果要配置一个 hooks 则需要在 <code>.git/hooks</code> 目录新增一个 hook 同名的可执行文件，并且出于前面说的安全考虑， <code>.git</code>  目录是不会被加入版本控制的，<strong>因此也存在上面所说的问题</strong>。</li>
<li>在 Git v2.9 以后，支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，项目成员只需要在第一次配置 core.hooksPath 即可，后续增删 hooks 都可直接使用。</li>
</ol>
<p>因为 Git 支持 core.hooksPath ，所以 husky 直接采用了新的实现原理重构：</p>
<ol>
<li><p>在 huksy v4 的时候，由于 Git hooks 目录无法被加入版本控制，它们是这样解决这个问题的：</p>
<ol>
<li>在初始化的时候就在 <code>.git/hooks</code> 目录预先创建所有的 hooks 可执行文件，然后在 hooks 文件中执行定义在 <code>package.json</code> 中的 hooks 命令。</li>
<li>这样很显然可以解决 hooks 无法同步的问题，但是这个实现原理也被不少人诟病，见 <a target="_blank" rel="noopener" href="https://github.com/typicode/husky/issues/260">#260</a> 。</li>
</ol>
</li>
<li><p>由于 Git v2.9 的升级，在 husky v7 中使用了新的实现方式：</p>
<ol>
<li>将 hooks 可执行文件存放在一个可以被进行版本控制的目录（默认是 <code>.husky</code>），然后初始化的时候只需要配置  core.hooksPath 即可。</li>
</ol>
</li>
</ol>
<p>显然，v7 的实现方式更加方便快捷了，除此之外，它们的使用方式也有很大的不同：</p>
<ol>
<li>在 v4 中，通过在 <code>package.json</code>  中配置 <code>husky</code> 字段来定义 hooks。</li>
<li>在 v7 中，<strong>它不再仅限于 Node.js 项目</strong>，可以直接通过 CLI 的方式进行配置，参见：<a target="_blank" rel="noopener" href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</li>
</ol>
<p>在深入了解背后的实现原理后，我们得出了结论：</p>
<ol>
<li>v4 版本的代码<strong>有较多历史包袱，不利于改造，故基于 v7 版本修改</strong>。</li>
<li>但 v7 版本的实现方式对 Hg 并不完全适用，所以需要继续沿用 v4 的部分实现方式，所以这样设计：<ol>
<li>将 hooks 脚本存放在可被版本控制的 <code>.husky</code> 目录</li>
<li>但不通过预注册所有的 hooks 的方式，而是采用按需配置，初始化时根据 <code>.husky</code> 的 hooks 可执行文件列表注入 hooks 配置。<ol>
<li>比如在 Node.js 项目中可以通过 npm 的 <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/using-npm/scripts#prepare-and-prepublish">prepare</a> 钩子来自动初始化。</li>
</ol>
</li>
</ol>
</li>
<li>因此，使用方式与 husky <a target="_blank" rel="noopener" href="https://typicode.github.io/husky/">文档</a> 中基本一致。<ol>
<li><code>husky install</code>、<code>husky add .husky/pre-commit</code></li>
</ol>
</li>
</ol>
<p>以上的心路历程、改造进展可以通过这个 <a target="_blank" rel="noopener" href="https://github.com/gd4Ark/husky/pull/1">PR</a> 查看，感兴趣的同学可自行尝试：</p>
<ol>
<li>clone 项目，安装依赖，执行 npm link。</li>
<li>参考  husky <a target="_blank" rel="noopener" href="https://typicode.github.io/husky/">文档</a> 进行使用。</li>
</ol>
<h2 id="背后的一些二三事"><a href="#背后的一些二三事" class="headerlink" title="背后的一些二三事"></a>背后的一些二三事</h2><p>最后分享一些我们在实践 Hg hooks 时的小插曲。</p>
<h3 id="一个隐藏字符引发的前端事故"><a href="#一个隐藏字符引发的前端事故" class="headerlink" title="一个隐藏字符引发的前端事故"></a>一个隐藏字符引发的前端事故</h3><p>有一天下午，在群里收到这么一个反馈：</p>
<img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191549957.jpg"  alt="2471647676117_.pic" style="margin-left: 0;" />

<p>点开大图一看，好家伙！赫然一个「口」字就这么明目张胆地贴在页面的左下角，看它「浓眉大眼」的。</p>
<p>到底是哪里出了问题呢？</p>
<p>仔细看清楚，才发现它其实不是一个「口」字，而是「□」，学名叫做 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E8%99%9A%E7%BC%BA%E5%8F%B7">虚缺号</a>，通俗地讲就是一个特殊字符。</p>
<p>于是打开对应的代码文件，果然一个红底白色 BS 字符引入眼帘：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204042021847.png"></p>
<h4 id="这是-VSCode-的锅？"><a href="#这是-VSCode-的锅？" class="headerlink" title="这是 VSCode 的锅？"></a>这是 VSCode 的锅？</h4><p>在网上有一番搜寻后，发现早就已经有不少人遇到过这个问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/wangduanduan/wangduanduan.github.io/issues/158">vscode控制字符引起的问题以及解决思路</a></li>
<li><a target="_blank" rel="noopener" href="https://jiangxiaokun.com/css/2018/11/15/ghost_chars/">隐藏字符引发的血案</a></li>
</ul>
<p>看下他们提供的复现过程：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191703719.gif" alt="hmmm"></p>
<p>直接说下这个 Bug 的结论：</p>
<ol>
<li>VSCode 开启 webview 的情况下，使用中文输入法时按下退格键，就会导致出现退格符。</li>
<li>VSCode 底层是 Electron，Electron 底层用的 chromium，这个 BUG 是 chromium 的。</li>
<li>该 BUG 已经在 VSCode v1.4.0 得到修复，参见这个 <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode/issues/37114#issuecomment-544236959">issue</a>。</li>
</ol>
<p>但既然该问题在 2019 年已经修复，那为什么在 2022 年的今天还会出现这个退格符呢？</p>
<p>由于已经复现不了，根源追求也就只能不了了之，但影响又如此之大，所以我们应该怎么去规避它呢？</p>
<h4 id="规避方案"><a href="#规避方案" class="headerlink" title="规避方案"></a>规避方案</h4><h5 id="利用-VSCode-扩展自动删除"><a href="#利用-VSCode-扩展自动删除" class="headerlink" title="利用 VSCode 扩展自动删除"></a>利用 VSCode 扩展自动删除</h5><p>有一个 VSCode 扩展 <a target="_blank" rel="noopener" href="https://github.com/satokaz/vscode-bs-ctrlchar-remover">Remove backspace control character</a> 专门用于解决此类问题，安装后我们只需要在 setting.json 添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;[wxml]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;satokaz.vscode-bs-ctrlchar-remover&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>即可在保存代码的时候自动移除这些特殊的隐藏字符。</p>
<p>实现方式主要是通过正则去匹配这类隐藏字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm</span><br></pre></td></tr></table></figure>

<p>在这里查看所有字符的介绍：<a target="_blank" rel="noopener" href="https://www.techonthenet.com/unicode/chart.php">Unicode</a>，本文所出现的 BS 正是 [\u0008]，也就是退格符。</p>
<h5 id="提交代码前自动删除"><a href="#提交代码前自动删除" class="headerlink" title="提交代码前自动删除"></a>提交代码前自动删除</h5><p>更好的方式是：我们可以在 precommit 钩子自动做这件事：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.wxml&quot;</span> -<span class="built_in">exec</span> perl -i -p -e <span class="string">&quot;s/[\x08]//g&quot;</span> &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行命令的 time total</span></span><br><span class="line">0.10s user 0.80s system 93% cpu 0.953 total</span><br></pre></td></tr></table></figure>

<h3 id="让-vscode-hg-提交代码时显示-ESLint-报错的规则"><a href="#让-vscode-hg-提交代码时显示-ESLint-报错的规则" class="headerlink" title="让 vscode-hg 提交代码时显示 ESLint 报错的规则"></a>让 vscode-hg 提交代码时显示 ESLint 报错的规则</h3><p>起因是某位同学反映在 vscode-hg 提交代码的时候，无法显示 ESLint 校验不通过的规则提示：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203201415448.png" alt="image-20220320141520784"></p>
<p>通常我们提交代码时，如果 yarn lint 不通过，会输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br><span class="line"></span><br><span class="line">/Users/4ark/project/helper/404.js</span><br><span class="line">  9:7  error  <span class="string">&#x27;a&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"></span><br><span class="line">✖ 1 problem (1 error, 0 warnings)</span><br><span class="line"></span><br><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure>

<p>而 vscode-hg 只输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure>

<p>不过经测试在 VSCode 中进行 Git 代码提交时并不存在该问题，所以猜测是 vscode-hg 这个扩展的原因。</p>
<p>于是抱着怀疑的态度看一下源码，发现果然如此：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hg.ts#L620</span></span><br><span class="line"><span class="keyword">if</span> (options.<span class="property">logErrors</span> !== <span class="literal">false</span> &amp;&amp; result.<span class="property">stderr</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;result.stderr&#125;</span>\n`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只输出了 stderr，但是 ESLint 的规则输出是 stdout。</p>
<p>于是我们为了更好地使用 Hg hooks，让它支持了输出 ESLint 规则，见 <a target="_blank" rel="noopener" href="https://github.com/mrcrowl/vscode-hg/issues/185">#185</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们在实践 Hg hooks 过程的一些经历和心得，未必是最佳解决方案，正如文本开头所说，撰写本文的目的是希望能起到抛砖引玉的作用，与大家一起进一步的深入探讨。</p>
<p>对于本文的实践思路、代码实现有任何的意见和建议，都请不吝指教。</p>
<p>最后感谢大家的阅读。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-03-12-central-bank/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-03-12-central-bank/" itemprop="url">央行是干嘛的 - 读《金融的本质》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-12T12:35:36+00:00">
                2022-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/financial-crisus.jpg" class="">

<h2 id="一、序"><a href="#一、序" class="headerlink" title="一、序"></a>一、序</h2><p>最近读完了<a target="_blank" rel="noopener" href="https://item.jd.com/12169610.html#none">《金融的本质》</a>，作者是美国的央行—-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%94%E9%82%A6%E5%82%A8%E5%A4%87%E7%B3%BB%E7%BB%9F">美联储</a>的前主席 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%AC%C2%B7%E4%BC%AF%E5%8D%97%E5%85%8B">伯南克</a> 。</p>
<p>伯南克任职期间为 06 ~ 14 年，他任期内美国及全球爆发了严重的经济危机，而他通过降低利率、量化宽松，以及承担最后贷款人职责等手段，有效降低了经济危机对美国的影响。</p>
<p>以下是我的一些笔记。</p>
<h2 id="二、央行的使命"><a href="#二、央行的使命" class="headerlink" title="二、央行的使命"></a>二、央行的使命</h2><p>央行是一个特殊的机构，在伯南克看来，央行主要有两大使命：</p>
<ul>
<li>1、保持经济的稳定增长</li>
<li>2、维持金融的稳定</li>
</ul>
<p>这里面，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%8F%E6%B5%8E/403149">经济</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D">金融</a>的差别困扰了我一阵子，原来它俩不是一个意思：</p>
<ul>
<li>经济一般是人类的价值创造过程。所以“保持经济的稳定增长”主要就是指 GDP 能够持续增长，保证就业率，同时维持低通胀。</li>
<li>金融是指对经济活动中对资金本身的一些“交易”，比如银行、证券、保险、债券。所以”金融稳定”就是指各种借贷关系是正常的，没有大面积的违约。</li>
</ul>
<p>那央行有什么特殊的技能，能够达成这两个使命呢？这主要靠国家赋予它的两个特殊的权力：</p>
<ul>
<li>1、制定经济活动中各种规则的能力。比如：调节利率、存款保证金比例、中期借贷便利（MLF）等等。</li>
<li>2、承担最后贷款人责任，为各种金融资产兜底。</li>
</ul>
<p>下面我展开说说我对这两个职责的理解。</p>
<h2 id="三、保持经济的稳定增长"><a href="#三、保持经济的稳定增长" class="headerlink" title="三、保持经济的稳定增长"></a>三、保持经济的稳定增长</h2><p>经济衰退肯定是不好的，因为经济衰退情况下会有大量的失业，通货紧缩。在通货紧缩的时候，因为钱升值了，借贷的人就会发现钱越来越值钱，但是他以前借的 100 万还是需要还 100 万，相当于他的债务内在价值越来越高。这种现象会使得大家更不愿意花钱，带动整体经济进一步下滑。</p>
<h3 id="3-1-降低利率"><a href="#3-1-降低利率" class="headerlink" title="3.1 降低利率"></a>3.1 降低利率</h3><p>面对经济衰退，央行通常的办法就是降低利率，同时减少社会融资成本。美国 08 年经济危机，美联储为了减少社会融资成本，把长期利率降成了 0%。</p>
<h3 id="3-2-量化宽松"><a href="#3-2-量化宽松" class="headerlink" title="3.2 量化宽松"></a>3.2 量化宽松</h3><p>然后美国施行了多轮的量化宽松政策，具体的做法是购买了大量的国债。大量的国债被购买后，市场上流通的债券就只剩利率更低的企业债等产品，这样就可以带动社会各种借贷的利率下降，从而刺激经济活动。</p>
<p>在本书中，伯南克否认量化宽松政策是“直接印钱”（书中第132页），因为：</p>
<ul>
<li>钱是从存款保证金余额中借出来的。</li>
<li>量化宽松主要购买的是国债，国债到期后可以将本金及利息收回。</li>
</ul>
<p>但是，量化宽松到期后能不能把钱全部收回，也取决于到时的政府财政状态，如果经济没有好转，大家还是缺钱，这样就只能到期继续购买国债，相当于往市场中注入了收不回来的现金。</p>
<h3 id="3-3-直接印钱"><a href="#3-3-直接印钱" class="headerlink" title="3.3 直接印钱"></a>3.3 直接印钱</h3><p>刺激经济的手段还有直接印钱。</p>
<p>印来的钱可以直接发给大家。比如：2020 年，美国总统特朗普的 2 万亿美元的财政刺激计划里面，就有 2500 亿发给了个人。其中年收入低于 7.5 万美元的单身人员将获得 1200 美元。</p>
<p>印来的钱也可以用来加大基础建设投资，我国面对 08 年金融危机时提出的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E4%B8%87%E4%BA%BF%E6%8A%95%E8%B5%84%E8%AE%A1%E5%88%92">四万亿投资计划</a> 就是这样的例子。</p>
<p>基础建设的投资可以带动上下游产业，从而把印出来的钱转变成大家的工资，进而刺激消费。但是这种行为多少还是会带来一定程度的通货膨胀。我为此专门查了一下中国的 CPI 数据，当时 CPI 在 08 年上升到 5.9%，但是后面迅速回落了，可见政府对价格的调整做得还是挺好的。</p>
<img src="/images/china-cpi.jpg" class="">


<h3 id="3-4-对面经济泡沫"><a href="#3-4-对面经济泡沫" class="headerlink" title="3.4 对面经济泡沫"></a>3.4 对面经济泡沫</h3><p>经济过热也是不好的，如果央行觉得经济泡沫太多，就会想办法抑制投资，给经济降温。常见的办法就是刺激经济的逆操作：加息，提高存款保证金，退出量化宽松政策等。</p>
<h3 id="3-5-CPI-多少是合适的"><a href="#3-5-CPI-多少是合适的" class="headerlink" title="3.5 CPI 多少是合适的"></a>3.5 CPI 多少是合适的</h3><p>书中关于这个有不少讨论，但并没有提供详细的精算过程。核心就是：既要保证为波动留够安全边际，保证不会通缩；又要不能太高，带来泡沫。最终实践出来的物价稳定的低通胀率是 2%。</p>
<p>拿这个标准来看，中国过去 5 年做得都是比较优秀的，除了疫情等原因外，中国在 16 - 19年的 CPI 都稳定在 2% 左右。</p>
<img src="/images/china-cpi-2.jpg" class="">

<h2 id="四、最后贷款人"><a href="#四、最后贷款人" class="headerlink" title="四、最后贷款人"></a>四、最后贷款人</h2><p>最后贷款人是一种安全机制，让大家可以安心地把钱放在各种金融机构中。</p>
<p>我稍微展开解释一下：</p>
<blockquote>
<p>银行收到大家的存款后，其实是会借贷给需要的企业或个人，大家的存款很多是短期的，而借贷很多是长期的。比如我自己的房贷，就是 30 年的，但是我存在银行的定期，大多是一年期的。这就造成了资金的错配。</p>
<p>资金的错配使得如果大家都到银行挤兑的话，银行是不可能拿出那么多现金来的。如果银行为了强行付钱来快速变卖资产或债务，就会造成资产价格的下降，进一步冲击经济。</p>
<p>所以，央行就承担起最后贷款人的责任，当真的发生挤兑的时候，央行可以直接拿银行的资产当作抵押，为银行提供现金。</p>
</blockquote>
<p>以上只是一种理论情况。当你相信央行会行使最后贷款人责任的时候，你就建立了资金的安全感，从而挤兑行为就不会发生了。</p>
<p>在实操中，国内确实出现过银行倒闭的现象：2020 年<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%85%E5%95%86%E9%93%B6%E8%A1%8C">包商银行</a> 破产，央行就承担起了最后贷款人责任，为民众的存款提供保障。</p>
<p>但是根据<a target="_blank" rel="noopener" href="http://www.gov.cn/zhengce/content/2015-03/31/content_9562.htm">《存款保险条例》</a>，存款保险实行限额偿付，最高偿付限额为人民币 50 万元。所以超过 50 万以上的存款还是无法赔付。个人如果有大量的存款，可以考虑分散到多家银行中。</p>
<p>另外保险和理财产品大多数是银行代销，其实并不属于银行的自营业务，在发生风险的时候，也无法按照《存款保险条例》赔付。</p>
<p>比如之前大量的 P2P 理财产品暴雷，就不能指望央行来承担最后贷款人责任。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>作为独立机构，央行的使命是维持经济和金融稳定，保证就业率和低通胀率。它通过调节利率、调节存款保证金、逆回购、调节 MLF、购买国债、增发货币、承担最后贷款人等方式来实现以上目标。</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul>
<li>经济的定义：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%8F%E6%B5%8E/403149">https://baike.baidu.com/item/%E7%BB%8F%E6%B5%8E/403149</a></li>
<li>金融的定义：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D">https://zh.wikipedia.org/wiki/%E9%87%91%E8%9E%8D</a></li>
<li>量化宽松的定义：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%87%8F%E5%8C%96%E5%AE%BD%E6%9D%BE/9019987">https://baike.baidu.com/item/%E9%87%8F%E5%8C%96%E5%AE%BD%E6%9D%BE/9019987</a></li>
<li>中央人民政府网站公布的核心经济数据：<a target="_blank" rel="noopener" href="http://www.gov.cn/shuju/hgjjyxqk/detail.html?q=1">http://www.gov.cn/shuju/hgjjyxqk/detail.html?q=1</a></li>
<li>四万亿投资计划：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E4%B8%87%E4%BA%BF%E6%8A%95%E8%B5%84%E8%AE%A1%E5%88%92">https://zh.wikipedia.org/wiki/%E5%9B%9B%E4%B8%87%E4%BA%BF%E6%8A%95%E8%B5%84%E8%AE%A1%E5%88%92</a></li>
<li>常听到的“MLF操作”，对我们到底有啥影响: <a target="_blank" rel="noopener" href="https://m.21jingji.com/article/20210522/herald/ff87816c4132382ef27b46127121c1a1.html">https://m.21jingji.com/article/20210522/herald/ff87816c4132382ef27b46127121c1a1.html</a></li>
<li>逆回购：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E5%9B%9E%E8%B4%AD/2612290">https://baike.baidu.com/item/%E9%80%86%E5%9B%9E%E8%B4%AD/2612290</a></li>
<li>《存款保险条例》: <a target="_blank" rel="noopener" href="http://www.gov.cn/zhengce/content/2015-03/31/content_9562.htm">http://www.gov.cn/zhengce/content/2015-03/31/content_9562.htm</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-weekly" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/weekly-04.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/weekly-04.html" itemprop="url">周刊第4期：独立思考</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-11T16:00:00+00:00">
                2022-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="本周做了啥"><a href="#本周做了啥" class="headerlink" title="本周做了啥"></a>本周做了啥</h2><p>给日常使用的 <a target="_blank" rel="noopener" href="https://github.com/mrcrowl/vscode-hg">vscode-hg</a> 扩展提了两个没什么技术含量的 PR，顺便蹭了一个 contributor：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mrcrowl/vscode-hg/pull/184">docs: typo lineAnnotationEnabled option</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mrcrowl/vscode-hg/pull/185">feat: output stdout</a></li>
</ul>
<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote>
<p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p>
</blockquote>
<h3 id="useMemo-和-useCallback-之间的深入比较"><a href="#useMemo-和-useCallback-之间的深入比较" class="headerlink" title="useMemo 和 useCallback 之间的深入比较"></a><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">useMemo 和 useCallback 之间的深入比较</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">《A Deep Dive Comparison Between useMemo And useCallback》 | Technical Blog</a></em></p>
<ul>
<li>它们的目的：都是通过缓存提高性能，避免组件重复渲染</li>
<li>相似之处：<ul>
<li>用法一致：与所有 hooks 一样，只能在组件的顶层调用</li>
<li>接收的参数一致：第一个为函数，第二个为依赖项</li>
<li>功能一致：返回缓存过的值，检测到依赖性发生时重新计算并缓存</li>
</ul>
</li>
<li>区别：<ul>
<li>它们表面上没有真正的区别</li>
<li>它们的内部实现也基本一致</li>
<li>使用场景的区别：<code>useCallback</code> 缓存函数，而 <code>useMemo</code> 缓存其它类型</li>
<li>实现原理的区别：<code>useCallback</code> 是缓存函数本身，而 <code>useMemo</code> 是缓存函数的返回值。</li>
</ul>
</li>
</ul>
<p>以下是它们的实现方式：</p>
<ul>
<li>useCallback</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>useMemo</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初级开发人员如何为新团队提供价值"><a href="#初级开发人员如何为新团队提供价值" class="headerlink" title="初级开发人员如何为新团队提供价值"></a><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">初级开发人员如何为新团队提供价值</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">《How You As a Junior Developer Can Immediately Provide Value When Joining a Team》 | Technical Blog</a></em></p>
<ul>
<li><strong>初级开发人员并不意味着不能提供价值：</strong>相反，初级开发人员可以给团队带来很多东西。</li>
<li><strong>质疑现状：</strong>如果一个团队长期合作，人们会开始接受彼此的缺点，习惯于某种风格和工作方式，也就会陷入舒适区，这可能会使团队停滞不前。所以你需要保持批判性，寻找团队懒惰、坏习惯、效率低下或者可以改进的地方，并且付诸行动去改变现状。</li>
<li><strong>新鲜血液：</strong>任何一个项目组都不可能每时每刻使用最新的技术、工具，可能会使得团队成员没有动力跟上最先进的技术，陷入一种恶性循环之中。你作为一个团队的新成员，可能你反而会在当前领域了解更多最先进的技术和工具，从而打破团队的恶性循环。</li>
<li><strong>意识到团队沟通的问题：</strong>长期合作的团队可能面临习惯现有的沟通方式，会自动忽略对方的缺陷，导致缺乏真正的沟通。而你能够意识到这些问题，并帮助团队提高这方面的效率。</li>
<li><strong>挑战团队现有的知识</strong>：每个团队内部都有一些的解决方案或流程，并且习惯于此，而你可以提出更多潜在的替代方案，帮助团队寻找更优的解决方案。</li>
</ul>
<h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>作为一名初级开发人员可能认为自己只能负责最简单的一部分业务，并没有意识到自己能给团队带来这么多价值，但其实你可以通过你作为一个新成员的位置，去发现你刚加入的团队一些不好的习惯，通过正确的心态和行动去改变现状。</p>
<h3 id="你的代码不必完美无缺"><a href="#你的代码不必完美无缺" class="headerlink" title="你的代码不必完美无缺"></a><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">你的代码不必完美无缺</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">《Your Code Doesn’t Have to Be Perfect》 | Technical Blog</a></em></p>
<p>作者通过一段经历，讲述他在实现某个功能时，由于想要实现最佳的解决方案，一开始就花费了大量的时间去进行完美的设计、抽象和封装，结果一个星期的时间没有任何真正的业务产出。</p>
<p>以下是作者一些教训：</p>
<ul>
<li><strong>不要从开始就重构：</strong>不需要刚开始就寻找最优的实现方式，这会让你过早地陷入到某个细节当中，把大量的时间花费在无意义的抽象中。</li>
<li><strong>复制粘贴还不错：</strong>我们应该坚持 DRY（不要重复你自己），但这不应该是起点，而是最终目标。可以在刚开始时通过复制粘贴实现功能，但这不意味着它就是最终上线的代码，而是在这个功能工作之后，再通过重构来提高代码质量。</li>
<li><strong>真正的重构需要适当的知识：</strong>通过改进现有的代码会使你的重构过程更加高效，因为这时候你已经掌握了更多的信息，可以更好地了解哪些代码是有意义的抽象。</li>
</ul>
<h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>每个开发者都经历过这个阶段，想要一开始就设计好所有的细节、编写最完美的代码，但这是不可能的，所有代码都是经过不断地重构。你的代码不必在一开始就完美无缺，在生产项目中更是如此，毕竟不存在没有 deadline 的项目，只要懂得这个道理，你的工作效率会大大提高。</p>
<h3 id="关于编写可读代码的最重要的事情"><a href="#关于编写可读代码的最重要的事情" class="headerlink" title="关于编写可读代码的最重要的事情"></a><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">关于编写可读代码的最重要的事情</a></h3><p>原文地址：<a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">《The Most Important Thing I Learned About Writing Readable Code》</a></p>
<p>编写代码时最重要的是可读性，一段难以理解的代码，即使你已经知道它的目的，你也很难理解它。所以编写具有可读性的代码是非常必要的。</p>
<p>已经有非常多的经典书籍在探讨这个话题，例如：</p>
<ul>
<li>《代码大全》</li>
<li>《重构》</li>
<li>《代码整洁之道》</li>
</ul>
<p>本文作者之前也写过几篇关于代码可读性的文章，不过我认为大部分已经是老生常谈了：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.logrocket.com/write-more-readable-react-code/">《如何编写更具可读性的 React 代码》</a></p>
<ul>
<li><strong>代码长度：</strong>更短的代码通常更容易阅读，但有时候并非如此。所以要根据场景，代码并不是越短越好。</li>
<li><strong>代码分组：</strong>将特定上下文的代码组合在一起，使得阅读性更高。React 的自定义组件、Hook 就是做这件事情。</li>
<li><strong>复杂的 JavaScript 结构：</strong>不是所有人都完全熟悉 JavaScript 的语言特性，如果依赖某些特性的固定或隐式行为，会使某些对 JavaScript 不太熟悉的开发人员难以理解这些代码。作者还特地拿 <code>Array.reduce</code> 来举了个例子，认为使用 <code>Array.reduce</code> 虽然可以让代码更加紧凑，但内部需要跟踪太多细节，如果直接使用 <code>for-loop</code> 会使代码更具有可读性。</li>
<li><strong>条件运算符 &amp;&amp;：</strong>这种短路的隐式行为没有 if-else 的可读性高。</li>
<li><strong>一次处理多种情况：</strong>例如在同一个 <code>useEffect</code> 处理多个 deps，会使代码更加混乱。</li>
<li><strong>变量命名：</strong>计算机两大难题之一，这个命题有点大。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/6-concrete-tips-that-will-make-your-react-pull-requests-easier-to-review/">《6 个技巧使你的 PR 更容易被 Review》</a></p>
<ul>
<li><strong>PR 的用途</strong>：Why、How</li>
<li><strong>分享视觉变化的屏幕截图</strong>：根据代码变更很难想象视觉的变化，所以展示一个截图可以帮助 Reviewer 更快地知道界面变化。</li>
<li><strong>列出功能要求</strong>：列出你想要实现的功能预期，否则很难通过代码上下文去预测你的实现是否正确、或者还有更优的解决方案。</li>
<li><strong>列出新的依赖</strong>：如果新增了依赖，你是如何决定采用哪一个库的。</li>
<li><strong>避免复杂的代码实现</strong></li>
<li><strong>提供有关如何 Review 的其他说明</strong>：告诉 Reviewer 从哪里开始 Review。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.chakshunyu.com/blog/this-is-my-10-questions-react-code-reviewing-routine/">《帮助你对 React 代码进行 Review 的 10 个问题》</a></p>
<ul>
<li>代码是否正常工作？</li>
<li>我明白了发生了什么吗？</li>
<li>代码是否可读？</li>
<li>组件或 Hook 是否做得太多？</li>
<li>这必须是组件或者 Hook 吗？</li>
<li>这个 API 设计可以简化吗？</li>
<li>有测试吗？</li>
<li>测试有意义吗？</li>
<li>这个功能的辅助功能方面如何？</li>
<li>是否更新了相应的文档？</li>
</ul>
</li>
</ul>
<p>但作者认为有一件更重要的事情被忽略了，那就是：<strong>沟通。</strong></p>
<p>每个人对于「代码是否具有可读性」的理解都不一样，所以日常中经常会出现下面这种对话：</p>
<ul>
<li>“你觉得这段代码非常难以阅读，但我认为它很容易。”</li>
<li>“我不同意，我经常使用这种实现方式，但理解它并没有难度。”</li>
<li>“使用这种方式实现，而不是你提供的那种方式实现，意味着我们不需要担心 xxx，可以使代码更短。”</li>
</ul>
<p>这种回答并非完全没有道理的，但它们都有共同点：<strong>他们之所以不同意使用这种实现会使代码可读性更差，是因为他们觉得自己能够理解这样的代码。</strong></p>
<p>的确，他们确实非常熟悉这段代码是如何工作的，但他们搞错了一件事：<strong>他们认为我是因为理解不了这段代码，才觉得这段代码难以阅读。</strong></p>
<p>然而事实并非如此，因为问题的根本在于：<strong>代码的可读性与你无关，而是与其他人有关，准确地说，是与未来接手这段代码的人有关，甚至这个人很可能就是六个月后的自己。</strong></p>
<p>所以，你要为他们编写具有可读性的代码。</p>
<h4 id="个人思考-2"><a href="#个人思考-2" class="headerlink" title="个人思考"></a>个人思考</h4><p>首先我需要说明，我并不认同作者提到的「 <code>for-loop</code> 可读性比 <code>Array.reduce</code> 好」这个结论，我认为 <code>Array.reduce</code> 与 <code>forEach</code>、<code>map</code> 这些标准方法并无不同，不是 JavaScript 的糟粕，甚至是精华部分；另外 <code>Array.reduce</code>  真正需要考虑的细节也不多，只要熟悉递归思想，它其实很好理解。</p>
<p>除此之外的大部分观点我都是非常认同的，特别是本文讲到的「沟通」二字。我曾待过一个团队，当时合并代码前是需要两人交叉 Review 的，也遇到过几次关于「这样实现的可读性好不好」的问题展开讨论，基本都是各执一词，往往这种时候都需要一个第三者来进行判断，由这个人决定采用哪一种实现。</p>
<p>还记得有一次更离谱，某位同学酷爱使用位运算符，他对此给出的理由是：这样实现会使代码更快。</p>
<p>首先我并不认同这种说法，因为他没有给出专业的对比分析，即便这是真的，但在我们负责的这种 Web 项目中，这种速度的提升简直是可以忽略不计的，所以我就「可读性」本身这件事与他讨论，结果他开始和我解释这个位运算符是如何工作的，这位同学就犯了上面提到的问题，其实我不是不理解位运算符如何工作，我还曾写过一篇《<a target="_blank" rel="noopener" href="https://4ark.me/post/learn-bitwise-operators.html">深入理解按位操作符</a>》的文章，我只是单纯认为不应该在项目中使用位运算符罢了。</p>
<h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.aisixiang.com/">爱思想</a>：华语圈内最具原创性和思想性的公益纯学术网站，有人文社科各领域、人品和作品均有一定高度的学者的大量访谈记录、论文等，可帮助你提高独立思考的能力。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.allhistory.com/">全历史</a>：在全历史 App 或网站里，你可以按照时间轴、关系图谱、时间地图查看各国，各个历史时期的历史相关内容。</p>
</li>
<li><p>在信息爆炸的今天，充斥着大量的虚假信息，这里推荐一些事实核查网站帮助你快速辨别信息真伪：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://chinafactcheck.com/">有据</a></li>
<li><a target="_blank" rel="noopener" href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li>
<li><a target="_blank" rel="noopener" href="https://www.politifact.com/">PolitiFact</a></li>
<li><a target="_blank" rel="noopener" href="https://www.truthorfiction.com/">Truth or Fiction</a></li>
<li><a target="_blank" rel="noopener" href="https://www.factcheck.org/">FactCheck.org</a></li>
<li><a target="_blank" rel="noopener" href="https://factcheck.afp.com/">Fact Check</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-03-10-china-revolution-insight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-03-10-china-revolution-insight/" itemprop="url">理解改革开放 - 读《置身事内》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-10T15:04:38+00:00">
                2022-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="一、序"><a href="#一、序" class="headerlink" title="一、序"></a>一、序</h2><p>最近看完了一本讲中国政府与经济发展的书，叫<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35546622/">《置身事内》</a>，作者是复旦大学经济学院副教授兰小欢。</p>
<p>这本书一开始看就停不下来了。原来过去几十年，中国遇到了这么多发展问题，中央政府通过不停地改革试错，摸着石头过河，保证了中国经济的持续发展。</p>
<p>了解完当时的背景，“置身事内”之后，你很容易就理解各种政策背后的原因了，有一种恍然大悟的感觉。</p>
<p>以下是一些笔记。</p>
<h2 id="二、从财政包干到分税制"><a href="#二、从财政包干到分税制" class="headerlink" title="二、从财政包干到分税制"></a>二、从财政包干到分税制</h2><p>书中详细介绍了国内改革开放后，做得比较成功的经济改革。</p>
<p>第一次改革，是 1985 年开始的财政包干制度。不同于之前的大锅饭，全国各地搞承包责任制，提高生产积极性。</p>
<p>大锅饭因为干好干坏一个样，极大地损害了大家的劳动积极性。所以很容易就想到了通过多劳多得来刺激大家的积极性。</p>
<p>但这样的制度落地，其实也是不容易的。因为当年这种行为被左派指责为走资本主义。邓小平的用“不管黑猫白猫，抓到耗子就是好猫”来鼓励大家尝试，让大家把重点放到如何有效改善人民的生活水平上。</p>
<p>于是，在 20 世纪 80 年代，农村搞土地承包，城市搞企业承包，政府搞财政承包。</p>
<p>在那个年代，财政包干制度有效促进了经济发展。但是到了 90 年代，承包制的问题开始凸显：</p>
<ul>
<li>承包制让地方收入越来越大，中央缺钱。</li>
<li>地方有隐匿收入的动力。通过计划外收入，违规减税等方式将企业利润留给自己，不分给中央。</li>
<li>因为地方企业所得税归地方，造成地方保护主义盛行，不利于构建全国统一市场。</li>
</ul>
<p>以上的问题主要是体现在增值税和企业所得税。具体的改革如下：</p>
<ul>
<li>1994 年进行了增值税的改革。增值税以前由地方独占，改成中央 75%，地方 25%。并且中央通过“返还”保证不比以前少。</li>
<li>2002 年进行了企业所得税改革。地方企业税收以前归地方，现在改成中央 60%，地方 40%。中央通过“返还”过渡。</li>
</ul>
<p>分税制是 20 世纪 90 年代推行的根本性改革之一，也是最为成功的改革之一。改革扭转了“两个比重”不断下滑的趋势：</p>
<ul>
<li>中央占全国预算收入的比重从改革前的 22％ 一跃变成 55%，并长期稳定在这一水平；</li>
<li>国家预算收入占 GDP 的比重也从改革前的 11％ 逐渐增加到了 20％ 左右。</li>
</ul>
<p>最近正值两会召开，从政府工作报告中，我们能看到 2021 年的国家预算收入 20 万亿，占 114 万亿 GDP 的 17%。可见分税制改革一直有效地保证着国家预算收入的稳定。</p>
<p>经济改革一直在持续，书中没有提到的是：在 2016 年，为了避免重复多次计税，减轻制造业的税赋压力，国家将营业税改为增值税，同时将增值税的分成改成中央和地方各 50%，进一步刺激经济健康发展。</p>
<h2 id="三、从分税制到土地财政"><a href="#三、从分税制到土地财政" class="headerlink" title="三、从分税制到土地财政"></a>三、从分税制到土地财政</h2><p>全国预算收入是不包括卖地收入，卖地收入被统计在政府性基金收入中，从《2021年财政收支情况》来看，2021 年有 8.7 万亿的国有土地出让收入。</p>
<p>分税制改革使得中央有钱了，但是地方却很缺钱。这个时候，1998 年的两项改革：取消福利分房和地方政府垄断国有土地出让，使得卖地收入成为地方政府的主要收入来源。</p>
<p>土地财政使得中国加速向城镇化方向发展，同时地方政府可以通过廉价出让工业用地来招商引资，刺激经济、增加税收、解决就业。</p>
<p>因为地方政府需要刺激经济，通过卖地获得的收入，可以通过政府主导的投资，来达成招商引资的目标，带动经济进一步增长。所以，地方政府可以深入介入经济活动中。书中举了京东方等企业的故事，说明政府对于集中力量发展重点产业的优势。</p>
<p>类似的例子我们不断地可以见到，比如特斯拉落户上海的超级工厂，就是一次成功的政府主导的招商引资，带动新能源上下游产业链成长的案例。</p>
<h2 id="四、中国的政治架构"><a href="#四、中国的政治架构" class="headerlink" title="四、中国的政治架构"></a>四、中国的政治架构</h2><p>书中还介绍了中国的政治架构：党委、政府、人大、政协。从中央到省、市、县层层复制同样的架构。党委领导政府、政府具体施政、人大决定法律、政协提意见和建议。</p>
<p>最近北京在开“两会”，就是指全国的人民代表大会和政治协商会议。人大班子每 5 年换届一次，现在是到了第十三届，而人大会议每年开一次，今年（2022年）是第五次会议。</p>
<p>党委和政府的官员通常都是交叉任职，但是又不是绝对的人事重合关系。你可以理解成两个大的不完全相交的圆。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>中国改革开放几十年来取得了空前的成功，离不开我们在经济发展上的不断创新和改进。</p>
<p>《置身事内》介绍了中国发展中的历次经济政策调整以及带来的效果，让读者能够理解并且认同到改革的巨大价值。</p>
<p>本书不但有助于大家理解各种经济运行的原理，也有助于理解中国特色社会主义经济环境下，各种改革如何落地。</p>
<p>如果再对比上过去几十年别的国家的经济发展速度，本书还能让读者建立起较强的民族自信和自豪感。因为照搬美国发展模式的一些国家（比如乌克兰），事实证明发展得并不顺利。</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><p>从本书出发，我也查了一些政府网站的资料，一并分享给大家：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.stats.gov.cn/tjsj/ndsj/2018/html/zb07.htm">《全国预算收入定义》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.npc.gov.cn/npc/c30834/202008/08bd6bb3168e4916a2da92ac68771386.shtml">《我国的中央和地方财政关系》 </a></li>
<li><a target="_blank" rel="noopener" href="http://gks.mof.gov.cn/tongjishuju/202201/t20220128_3785692.htm">《2021年财政收支情况》 </a></li>
<li><a target="_blank" rel="noopener" href="https://finance.sina.cn/2019-03-21/detail-ihtxyzsk9155411.d.html?vt=4&pos=108">《全国土地收入去年6.5万亿 钱都花去哪了？》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.chinatax.gov.cn/n810341/n810765/n812171/n812680/c1190924/content.html">《中华人民共和国消费税暂行条例》</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022/63-%E5%8C%85%E4%B8%80%E9%A1%BF%E8%8A%B9%E8%8F%9C%E9%A5%BA%E5%AD%90%E8%A7%A3%E8%A7%A3%E9%A6%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/63-%E5%8C%85%E4%B8%80%E9%A1%BF%E8%8A%B9%E8%8F%9C%E9%A5%BA%E5%AD%90%E8%A7%A3%E8%A7%A3%E9%A6%8B/" itemprop="url">包一顿芹菜饺子解解馋</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-09T05:00:00+00:00">
                2022-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>鉴于近日疫情严峻，我就尽量减少了外出。这几天吃多了外卖，也不得不考虑换换口味了。超市买的速冻饺子大多是韭菜、白菜馅的，不禁让我十分怀念家里妈妈包的芹菜猪肉馅饺子了。所以就在网上买了芹菜、硬豆腐、梅肉、饺子皮准备自己包一顿饺子解解馋（为了减少外出，买菜也网购了，倒也挺方便的）。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2022/63-%E5%8C%85%E4%B8%80%E9%A1%BF%E8%8A%B9%E8%8F%9C%E9%A5%BA%E5%AD%90%E8%A7%A3%E8%A7%A3%E9%A6%8B/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-3-6-videocover/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-3-6-videocover/" itemprop="url">电脑上如何给视频设置封面？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-06T15:26:00+00:00">
                2022-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7hH8NbkZ2YT-FOVdSdPHPA">效率工具指南</a>」<br>文&#x2F;彭宏豪    </p>
<p>Hello 各位好，我是小豪。   </p>
<p>用过剪映 App 剪过视频的朋友，可能会留意到时间轴最前面的「<strong>设置封面</strong>」，使用这个功能，可以给视频自定义封面。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/img096e1d8351a31.jpeg" alt="IMG_096E1D8351A3-1"></p>
<p>在当下信息爆炸的时代，视频封面就像是一个人的颜值，好的封面会有更高的回头率，对应到视频或者其他媒介上，就意味着会有更高的打开率或者播放量。   </p>
<p>所以，如果你想让自己的视频有更高的曝光，设置一个好看的<strong>视频封面</strong>，其重要性不言而喻。</p>
<p>如果你是在手机上剪视频，使用剪映 App 内置的这个功能，就可以很方便地自定义视频封面。   </p>
<p>但如果是换到电脑上，「似乎」就没有很方便地给视频设置封面的工具。  </p>
<p>似乎确实是似乎，不用怀疑，能看到这篇文章，说明我已经找到方法啦。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/16465779024433.jpg"></p>
<p>今天这篇文章，介绍 个在电脑上给视频设置封面的方法。    </p>
<h2 id="Mac-电脑自带功能"><a href="#Mac-电脑自带功能" class="headerlink" title="Mac 电脑自带功能"></a>Mac 电脑自带功能</h2><p>右击想要自定义封面的视频，点击「<strong>显示简介</strong>」，打开视频的属性面板。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/16465780869183.jpg"></p>
<p>打开属性面板后，将封面直接拖拽到属性面板左上角的缩略图，就可以替换掉视频原来默认的封面了。   </p>
<p>在 Mac 上更换视频封面，就是这么简单。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/geng-huan-shi-pin-feng-mian.gif" alt="更换视频封面"></p>
<h2 id="快剪辑"><a href="#快剪辑" class="headerlink" title="快剪辑"></a>快剪辑</h2><p>上面的方法仅适用于苹果电脑，对于使用 Windows 系统的朋友，可以使用另外一个软件——由 360 推出的「<strong>快剪辑</strong>」。  </p>
<p>说到快剪辑，还得提到另外一个熟悉的名字——爱剪辑。</p>
<p>可以这么说，在剪映还没推出电脑版之前，很多人应该都用过这个傻瓜式的剪辑软件，快剪辑应该就是看到爱剪辑火得一塌糊涂之后，顺势推出的（快剪辑上线时间 2017 年）。    </p>
<p>说回正事，快剪辑在导出视频的环节，有一个可<strong>编辑视频封面</strong>的选项，如下图所示，使用这个功能，也可以为视频自定义封面。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/kuai-jian-ji-she-zhi-shi-pin-feng-mian.png" alt="快剪辑设置视频封面"></p>
<p>值得一提的是，<strong>快剪辑只有 Windows 版本</strong>，Mac 用户无法使用。      </p>
<h2 id="剪映电脑版"><a href="#剪映电脑版" class="headerlink" title="剪映电脑版"></a>剪映电脑版</h2><p>上面介绍的两个方法，还是不够完美，每一个方法都只能在一个平台上使用。   </p>
<p>这里介绍一个终极解决方法，使用剪映电脑版。   </p>
<p>没记错的话，剪映电脑版最开始并没有设置视频封面的功能。   </p>
<p>不过，今晚在写文章之前，我重新打开剪映，意外地发现电脑版也有了和 App 一样的功能。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/16465795068903.jpg"></p>
<p>视频封面可以来自视频中的某一帧，也可以是从本地导入的图片，导入之后，还可以使用剪映的「编辑」功能，给封面套上内置的模板，让封面变得更好看一些。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/16465796493150.jpg"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/03/06/16465798344893.jpg"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-03-06-fast-count-ability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-03-06-fast-count-ability/" itemprop="url">学会快速地估算</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-06T03:20:01+00:00">
                2022-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="一、从决策说起"><a href="#一、从决策说起" class="headerlink" title="一、从决策说起"></a>一、从决策说起</h2><p>这个世界上，任何决策都会有支持它的理由和反对它的理由。而如果你把这些理由都写到纸上的话，你会发现一开始很难做决策。</p>
<p>为了做出好的决策，你首先就会给这些理由赋予权重。通过权重，你就能做减法，把相对不重要的因素给忽略掉，关注核心的矛盾。</p>
<p>一个好的决策，就是关注到核心问题后的权衡。而估算，可以帮助我们快速收集决策因素。</p>
<h2 id="二、如何快速估算"><a href="#二、如何快速估算" class="headerlink" title="二、如何快速估算"></a>二、如何快速估算</h2><p>要拥有快速估算能力，需要：</p>
<ul>
<li>有拆分的能力，能够抽象出核心的计算路径。</li>
<li>有创新的能力，能够用更合适的角度来描述问题。</li>
<li>有公式化的能力，用一个公式简化所有计算。</li>
</ul>
<p>下面我用管理供应链遇到的一些场景给大家展开举例。</p>
<h3 id="2-1-印刷成本的估算"><a href="#2-1-印刷成本的估算" class="headerlink" title="2.1 印刷成本的估算"></a>2.1 印刷成本的估算</h3><p>假设我们需要分析供应链印刷品的价格。</p>
<p>首先，我们可以进行成本的拆分。通过研究，我们可以把价格拆分为原料价格、印刷工价、运输费用等。而印刷的工价又可以拆分为各种工序的工价。如果某些成本占比很小，那么你就可以忽略它。比如印刷品送货前的仓储费用很小，就可以忽略掉。</p>
<p>接着我们可以分析不同印量，不同工艺下面，主要的各项成本的占比。我们发现原料成本和工价成本加起来占到成本项的 90% 以上，那么我们就可以直接将印刷品的成本简化成:<br><code>成本 = 原料成本 + 工价</code>。</p>
<p>如果进一步我们发现二者的成本基本上大概一样，那我们就可以把成本简化为:<br><code>成本 = 原料成本 x 2</code>。</p>
<p>然后我们要有办法快速计算原料成本。</p>
<p>印刷品的原料成本传统的计算方式是：</p>
<ul>
<li>先计算需要用多少纸，然后折算成令，然后再计算每令的价格。</li>
<li>每令的价格是通过每吨的价格除以纸张每平米克重，再乘以每令纸的面积。</li>
</ul>
<p>这样的计算过程，使得你不用计算器很难快速算出来。通过观察，我们发现不同克重的纸张在采购的时候基本价格都集中在 6000 元每吨左右，所以我们可以简单地简化：<br><code>每克纸的价格 = 6000 / 1000 kg = 6000 / 1000000 g = 0.006 元</code></p>
<p>之后，我们如果要计算一个印刷品的成本，我们可以将公式简化为：<br><code>成本 = 克重 * 0.006 * 2</code> 即可。</p>
<p>那克重如何快速获得呢？很简单，放到称上称一下，或者拿手简单掂量一下，就会有一个快速的估计出来。</p>
<p>接下来我们要把这个公式“通用化”，可以看到，成本公式里面有两个系数是会变化的：</p>
<p>系数一：纸张每克成本。在上面这个公式中，该值是 0.006。这个对不同的印刷品其实不太一样，而且纸张价格会波动，造成计算偏差。比如白卡纸去年最高的时候超过了 1万一吨。所以我们可以根据实际的品类，来调整纸张每克的成本。如果在白卡纸1万一吨的时候，如果是一个白卡纸为主要原料的产品，它的成本速算公式中的每克成本就应该从 0.006 改为 0.01 。</p>
<p>系数二：纸张与工价的成本比例。不同品类的产品，纸张与工价的比例其实不太一样。比如手工类比较多的印刷品，其纸张与工价的成本比例可能不是 1:1，可能是 1:2。这样，在速算的时候，系数 2 就应该调整为 3，这样估算的时候才相对准确。</p>
<p>所以，对于某一个印刷品类，一个相对通用的成本速算的公式应该是：<br><code>成本 = 产品克重 * 纸张每克单价 * (1 + 工价成本占比/纸张成本占比)</code></p>
<h3 id="2-2-运输成本的估算"><a href="#2-2-运输成本的估算" class="headerlink" title="2.2 运输成本的估算"></a>2.2 运输成本的估算</h3><p>再拿运输的成本估算举例。运输涉及不同的计算方式，有按托算的，有按立方米计算的，不同的车能够装的托数也不太一样，造成估算困难。</p>
<p>但是如果我们把各种托数、公里数的信息放到一张表里面做人肉拟合，就会发现 <code>一托一公里一块钱</code> 可以很快估算出成本信息。</p>
<p>然后在这个基准上，把比较近的（例如 100 公里以内的），成本乘个 1.5 左右的系数；把比较远的（例如 1500 公里以上的），成本乘个 0.5 左右的系数，就可以很快估算出大概的成本。</p>
<h3 id="2-3-组装工序的成本估算"><a href="#2-3-组装工序的成本估算" class="headerlink" title="2.3 组装工序的成本估算"></a>2.3 组装工序的成本估算</h3><p>供应链的组装工序很复杂，每次报价都很乱，我们也搞不明白各个环节是不是真的要那么多钱。</p>
<p>直到有一个供应商介绍了一种方法，特别简单：供应商说，你自己把这个东西拆下来组装一遍，看看要花多少时间组装，我们就按那个时间来估算组装费用。</p>
<p>大家一听都觉得好，因为组装产线肯定比单个人做效率高，如果我们简单用单个人做的时间，再算上工人的每小时平均工资，就可以很快估算出这个费用，比拆分工序简单快捷多了。</p>
<h3 id="2-4-注塑成本的估算"><a href="#2-4-注塑成本的估算" class="headerlink" title="2.4 注塑成本的估算"></a>2.4 注塑成本的估算</h3><p>注塑成本最初我们也搞不太明白，也是一个供应商教我们，直接拿秤称重量。</p>
<p>就像纸张那样，我们可以通过重量来估算原料的成本，然后通过简单地统计各种注塑件原料成本与工费的比例，就可以列出几套速算公式出来。</p>
<h3 id="2-5-公司估值的毛估估"><a href="#2-5-公司估值的毛估估" class="headerlink" title="2.5 公司估值的毛估估"></a>2.5 公司估值的毛估估</h3><p>公司的估值计算也是一门学问，大家通过财报很难获得很精确的价值计算模型，所以只能估算。</p>
<p>有人用市盈率算，有人用市销率算，有人用现金流折现算，有人用对标公司算，总之都是为了决策而快速获得核心数据的办法。</p>
<p>算得不精确没关系，大差不差就行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>快速估算可以让我们的决策变快。面对问题，我们需要抽象出问题的关键因素，构建出一个简单的公式模型，这样才能让计算变得简单，方便我们决策。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-weekly" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/weekly-03.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/weekly-03.html" itemprop="url">周刊第3期：持续折腾</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-05T16:00:00+00:00">
                2022-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><p>之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://4ark.me/post/git-tips.html">Git tips</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://4ark.me/post/hg-tips.html">Hg tips</a>》</li>
</ul>
<h2 id="折腾-iTerm2-tmux"><a href="#折腾-iTerm2-tmux" class="headerlink" title="折腾 iTerm2 + tmux"></a>折腾 iTerm2 + tmux</h2><p>很早之前就安装了 tmux，但是苦于一直记不住命令，也就没有坚持用。</p>
<p>不过其实 iTerm2 已经整合了 tmux，可以将 tmux 的各种命令操作映射到 iTerm2 本身的快捷键操作中，这可以大大降低 tmux 的学习成本，于是花了点时间折腾、以及 iTerm2 的外观调整，整体效果是这样的：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203050038886.png?imageMogr2/format/webp"></p>
<p>主要参考以下这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://toutiao.io/posts/q86tnu/preview">iTerm2 整合 Tmux 利器</a></li>
<li><a target="_blank" rel="noopener" href="https://haidong.dev/iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/">iTerm2 设置详解</a></li>
</ul>
<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote>
<p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p>
</blockquote>
<h3 id="解剖-Netflix"><a href="#解剖-Netflix" class="headerlink" title="解剖 Netflix"></a><a target="_blank" rel="noopener" href="https://lanzhiheng.com/posts/no-rule-in-netflix">解剖 Netflix</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://lanzhiheng.com/posts/no-rule-in-netflix">《解剖 Netflix - 全美员工满意度最高的企业》 | Step By Step</a></em></p>
<p>这是本文作者从一本叫做《零规则》的书的笔记，主要讲述一家名为 Netflix 的科技公司的经营传奇。</p>
<p>这家公司是全美员工满意度最高的公司，而「零规则」这几个字，也正是 Netflix 的核心文化之一。</p>
<p>下面就来讲讲 Netflix 的不同之处：</p>
<ul>
<li><p>「零规则」并不是完全没有规则：「零规则」不代表 Netflix 是一家毫无规则的公司，它也有解雇员工的准则，而且可能比其他公司都要狠，甚至连 CEO 都能被解雇；它的零规则指的是它不会花时间制定考勤、打卡、费用报销、上班时长等细则，因为 Netflix 相信自己招聘的肯定是最出色的员工，否则，他们也无法在如此严苛的岗位筛选中存活下来。</p>
</li>
<li><p>行业的最高薪资：只招揽最优秀的人才，并且没有固定的涨薪幅度，而是鼓励员工出去面试，根据拿到的 offer 给予对应的涨幅。</p>
</li>
<li><p>同事不是家人：许多企业会宣称我们是一个大家庭、同事们都是家人。而 Netflix 认为同事是合作伙伴，而不是家人，因为如果在公司里大家都以家人相称反而会导致不能作出正确的决策。</p>
</li>
<li><p>以 Netflix 最大利益为考量：Netflix 采用树形的决策模式，底层员工不需要凡事去请示上司，因为自己才是决定这件事的最佳人选，Netflix 认为员工不会因为这个决定让自己蒙羞。</p>
</li>
<li><p>无休假规定也没有固定的工作时长：如果一个人用工作时长的一半就完成了他的工作，剩下的时间他选择阳光海滩。而另一个人每天加班加点，超时工作才能把事情做完，果断给第一个人加工资。</p>
</li>
<li><p>信息透明：没有「报喜不报忧」的潜规则，Netflix 认为自家员工都是成年人，有能力辨别什么能说什么不能说。</p>
</li>
</ul>
<h3 id="在生产环境中使你的-npm-i-速度提升-50"><a href="#在生产环境中使你的-npm-i-速度提升-50" class="headerlink" title="在生产环境中使你的 npm i 速度提升 50%"></a><a target="_blank" rel="noopener" href="https://shanyue.tech/frontend-engineering/npm-install.html">在生产环境中使你的 npm i 速度提升 50%</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://shanyue.tech/frontend-engineering/npm-install.html">《在生产环境中使你的 npm i 速度提升 50%》 | 山月行</a></em></p>
<ul>
<li>选择时延低的 <code>registry</code>，需要企业技术基础建设支持</li>
<li><code>NODE_ENV=production</code>，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)</li>
<li><code>CI=true</code>，npm 会在此环境变量下自动优化</li>
<li>结合 CI 的缓存功能，充分利用 <code>npm cache</code></li>
<li>使用 <code>npm ci</code> 代替 <code>npm i</code>，既提升速度又保障应用安全性</li>
</ul>
<h3 id="浅析-Web-录屏技术方案与实现"><a href="#浅析-Web-录屏技术方案与实现" class="headerlink" title="浅析 Web 录屏技术方案与实现"></a><a target="_blank" rel="noopener" href="https://www.zoo.team/article/webrtc-screen">浅析 Web 录屏技术方案与实现</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.zoo.team/article/webrtc-screen">《浅析 Web 录屏技术方案与实现》 | zoo</a></em></p>
<ul>
<li><p>有感录屏：</p>
<ul>
<li><p>有感录屏一般指通过获得用户的授权或者通知用户接下来的操作将会被录制成视频，并且在录制过程中，用户有权关闭中断录屏。即无论在录屏前还是录屏的过程中，用户都始终能够决定录屏能否进行。</p>
</li>
<li><p>实现方式：WebRTC。</p>
</li>
</ul>
</li>
<li><p>无感录屏</p>
<ul>
<li><p>无感录屏指在用户无感知的情况，对用户在页面上的操作进行录制。实现上与有感录制区别在于，无感录制通常是利用记录页面的 DOM 来进行录制。常见的有 canvas 截图绘制视频和 rrweb 录制等方案。</p>
</li>
<li><p>实现方式：</p>
<ol>
<li>canvas</li>
<li>rrweb</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>rrweb 的话只是对 SPA 场景比较好，但对于 微前端&#x2F;Iframe 场景，它基于 DOM 的回溯就会失效从而失去其录制功能，加上整个 rrweb 链路代码实现复杂度较高，个人认为能用 WebRTC 还是走 RTC 实现比较好。</p>
<h3 id="如何为你的问题获得有用的答案"><a href="#如何为你的问题获得有用的答案" class="headerlink" title="如何为你的问题获得有用的答案"></a><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">如何为你的问题获得有用的答案</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">《How to get useful answers to your questions》 | Julia Evans</a></em></p>
<ol>
<li>问一个模糊或未明确指定的问题时，可能出现的问题：<ol>
<li>这个人首先解释一堆我已经知道的东西</li>
<li>这个人解释了一些我不知道的事情，但我认为这些事情与我的问题无关</li>
<li>这个人开始给出相关的解释，但使用我不理解的术语，所以我仍然最终感到困惑</li>
</ol>
</li>
<li>通过问「是否」的问题，可以更快地得到有用的信息。</li>
<li>如果别人做了一个漫长而无关紧要的解释，可以直接打断</li>
<li>不接受没有回答你的问题的答案</li>
</ol>
<h3 id="谈谈在SQL语句中的优化技巧"><a href="#谈谈在SQL语句中的优化技巧" class="headerlink" title="谈谈在SQL语句中的优化技巧"></a><a target="_blank" rel="noopener" href="https://qq52o.me/696.html">谈谈在SQL语句中的优化技巧</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://qq52o.me/696.html">《谈谈在SQL语句中的优化技巧》 | qq52o</a></em></p>
<p>此文一共列了 30 个优化技巧，内容已经比较精炼了，这里我就不一一列出，有兴趣直接进原文阅读。</p>
<h3 id="求职时的常见错误"><a href="#求职时的常见错误" class="headerlink" title="求职时的常见错误"></a><a target="_blank" rel="noopener" href="https://1byte.io/resume-mistakes/">求职时的常见错误</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://1byte.io/resume-mistakes/">《求职时的常见错误》 | 1 Byte</a></em></p>
<ul>
<li>细节：对待简历要认真，一个连简历都不重视细节的人，可想而知在工作中有多马虎。</li>
<li>精通：慎重「精通」二字，除非你有自信比面试官更熟悉它。</li>
<li>面试：遇到不会的难题，不要轻易放弃，面试官想要看到的是你如何解决问题。</li>
</ul>
<h3 id="如何在-Emacs-里做所有事"><a href="#如何在-Emacs-里做所有事" class="headerlink" title="如何在 Emacs 里做所有事"></a><a target="_blank" rel="noopener" href="https://1byte.io/how-to-do-everything-in-emacs/">如何在 Emacs 里做所有事</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://1byte.io/how-to-do-everything-in-emacs/">《如何在 Emacs 里做所有事》| 1 Byte</a></em></p>
<p>Emacs 简直堪称是一个操作系统，之前有研究过使用 Emacs 下面的 Org-mode 插件来做我的内容管理系统，但是折腾了一下觉得太难上手了，于是转向使用 Notion。</p>
<p>而本文中的视频就展示了 Emacs 的 Org-mode 强大，有兴趣可以看看。</p>
<h3 id="小程序单元测试最佳实践"><a href="#小程序单元测试最佳实践" class="headerlink" title="小程序单元测试最佳实践"></a><a target="_blank" rel="noopener" href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">小程序单元测试最佳实践</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">《小程序单元测试最佳实践》 | wxsm’s pace</a></em></p>
<ul>
<li><p>启动很慢！至少需要 30 秒；因为每个不同的测试文件都需要单独启动并连接一遍实例。</p>
<ul>
<li>共享同一个全局实例（×），不起作用。</li>
<li>将所有测试用例放在单文件中共享实例（×），运行一次需要等到所有测试跑完才能看到结果。</li>
<li>不通过 launch，直接 connect 到现有窗口（√），只在第一次会比较慢。</li>
</ul>
</li>
<li><p>通过 navigateTo 这类方法跳转很慢：通过点击页面元素的方式触发会比较快。</p>
</li>
</ul>
<h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>去年年初的时候也曾尝试过在项目中推动微信小程序的 E2E 自动化测试，当时把此文所提到的坑都踩过一遍、连最后选择的解决方案都是一样的。</p>
<p>之前也有在  Web 项目实践过的 E2E 测试（用的是 Cypress），体验比微信小程序的自动化测试好一万倍不止。不过回头想想，像微信小程序这样不伦不类的产物，本来就是恶心开发者的，还扯什么开发体验呢？</p>
<h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://polypane.app/css-specificity-calculator">CSS Specificity Calculator</a>：CSS 选择器优先级计算，帮助你快速计算你的 CSS 选择器优先级。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/2nthony/blogkit">Blogkit</a>：一个朋友的开源项目，利用 Notion API 驱动，将 Notion 作为博客的后台数据库，目前已经支持分发到内置的静态网站以及语雀。</p>
<ul>
<li>btw，自从 Notion 开放 API 依赖，将 Notion 作为博客后台数据库的 idea 就层出不穷，并且已经有不少人付诸实践，比如这里还有一个：<a target="_blank" rel="noopener" href="https://www.coryetzkorn.com/blog/how-the-notion-api-powers-my-blog">How the Notion API Powers My Blog</a>。 虽然我个人也很喜欢使用 Notion 作为我的资料库，但目前仍没有打算基于它来做博客。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://coderwall.com/">Coderwall</a>：一个开发人员社区的开发和设计技巧、工具和项目，可以从上面学到很多技巧，包括但不限于：Shell、Git、JavaScript、CSS 等。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-3-5-wechat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-3-5-wechat/" itemprop="url">加微信时，如何快速亮出你的二维码｜快捷指令</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-05T09:36:00+00:00">
                2022-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/q_TzSSkkJDg8Q8QS6rP2KQ">效率工具指南</a>」，欢迎关注<br>文&#x2F;彭宏豪    </p>
<p>Hello 各位好，这里是效率工具指南。<br>我是小豪。   </p>
<p>在线下和别人面基时，往往会有一个加微信的环节。   </p>
<p>正所谓，动作要快，（亮码）姿势要帅。   </p>
<p>所以今天的问题是，如何快速亮出自己的二维码，加上心仪女生的微信呢？       </p>
<p>下面分享两个快速亮码的小技巧：   </p>
<h2 id="轻点两下手机背面"><a href="#轻点两下手机背面" class="headerlink" title="轻点两下手机背面"></a>轻点两下手机背面</h2><p>轻点两下手机背面，就能快速呼出二维码，实际效果见下面👇的 Gif 动图：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/imb8aah0c.GIF" alt="IMB_8AAh0C"></p>
<p>这个快速亮码的小技巧，需要用到 iPhone 的两个功能：快捷指令 + 轻点背面。   </p>
<p>先在微信上打开个人二维码的页面，截取一张图片；   </p>
<p>截取后手机左下角会出现一个截图的<strong>缩略图</strong>，点击缩略图，会显示下图的页面：   </p>
<p>点击左上角的「完成」按钮，在弹出的菜单选择「存储到“文件”」，将截图保存到「我的 iPhone」中。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1954.PNG" alt="IMG_1954"></p>
<p>打开快捷指令 App，点击「所有快捷指令」页面右上角的加号 + ，创建一个新的快捷指令。   </p>
<p>新的快捷指令顶部需要填入一个<strong>名称</strong>，你可以命名为「微信二维码」。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1958.PNG" alt="IMG_1958"></p>
<p>点击「添加操作」，在弹出的面板搜索「文件」，点击下方的「文件」选项。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1965.PNG" alt="IMG_1965"></p>
<p>添加「文件」变量后，点击文件两个字，在「我的 iPhone」中找到刚截取的微信二维码并打开。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1970.PNG" alt="IMG_1970"></p>
<p>接着点击底部的「搜索 App 和操作」，搜索「<strong>显示结果</strong>」，点击下方返回的「显示结果」。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1967.PNG" alt="IMG_1967"></p>
<p>完成以上两步操作后，这个新的快捷指令就算创建好了，如下图：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1963.PNG" alt="IMG_1963"></p>
<p>打开 iPhone 上的系统设置，搜索「轻点」，点击下方返回的「<strong>触控</strong>」，将页面滑动到底部，选择「<strong>轻点背面</strong>」。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1976.PNG" alt="IMG_1976"></p>
<p>⚠️ 注意：轻点背面是 <strong>iOS 14</strong> 新增的功能，如果你没有看到这个选项，请先查看一下手机系统是否 iOS 14。   </p>
<p>此外，这个功能对<strong>手机型号</strong>也有限制，从网上反馈的情况来看，iPhone 8 Plus 之后的手机，都可以用上这个功能。   </p>
<p>点击「轻点两下」，可以看到轻点两下 iPhone 背面可以触发的多个操作，在里面找到我们刚刚创建的快捷指令「微信二维码」。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1978.PNG" alt="IMG_1978"></p>
<p>到这里，就完成了轻点两下手机背面、快速打开微信二维码的全部设置，可以轻点一下测试实际的效果（点开下方的视频号查看）：  </p>
<h2 id="3D-Touch-快速打开"><a href="#3D-Touch-快速打开" class="headerlink" title="3D Touch 快速打开"></a>3D Touch 快速打开</h2><p>如果你觉得前面的方法，前期设置起来还是有些麻烦，可以使用下面这种更为便捷的操作——<strong>3D Touch</strong>。      </p>
<p>长按微信图标，稍等一小小会，微信会弹出一个快捷菜单，点击其中的「我的二维码」，也可以快速打开个人微信二维码。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/26/img1942.JPEG" alt="IMG_1942"></p>
<p>之前一直有传闻说，苹果可能会取消 3D Touch 功能，不过到目前为止还能使用，就暂且用着吧。   </p>
<h2 id="扫码加入我在知识星球上创建的社群「效率工具指南」"><a href="#扫码加入我在知识星球上创建的社群「效率工具指南」" class="headerlink" title="扫码加入我在知识星球上创建的社群「效率工具指南」"></a>扫码加入我在知识星球上创建的社群「效率工具指南」</h2><p>如果你觉得本文帮到了你，想支持我做得更好，欢迎戳下方图片，加入我的知识星球。     </p>
<p>关于社群「效率工具指南」的介绍，可以查看我在语雀文档上发布的文档：<a target="_blank" rel="noopener" href="https://www.yuque.com/penghonghao/af0aai/glwrg2dl0dqlegi6?singleDoc#">知识星球「效率工具指南」简介</a>    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2023/11/25/48844555552858t1-2.JPG"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<h2 id="订阅我在竹白上创建的-Newsletter"><a href="#订阅我在竹白上创建的-Newsletter" class="headerlink" title="订阅我在竹白上创建的 Newsletter"></a>订阅我在竹白上创建的 Newsletter</h2><p>如果对你有帮助的话，别忘了点击下方的链接，订阅我的 Newsletter，之后发布了新的内容，就能第一时间收到通知啦～  </p>
<p><a target="_blank" rel="noopener" href="https://penghh.zhubai.love/">👉在竹白上订阅效率工具指南</a>         </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/git-tips.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/git-tips.html" itemprop="url">Git tips</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-01T16:00:00+00:00">
                2022-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="批量删除-git-分支"><a href="#批量删除-git-分支" class="headerlink" title="批量删除 git 分支"></a>批量删除 git 分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a | grep -e <span class="string">&quot;fix/&quot;</span> | xargs git branch -D</span><br></pre></td></tr></table></figure>

<h2 id="批量添加匹配文件到暂存区"><a href="#批量添加匹配文件到暂存区" class="headerlink" title="批量添加匹配文件到暂存区"></a>批量添加匹配文件到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s -uall | grep .vue | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs git add</span><br></pre></td></tr></table></figure>

<h2 id="按最后提交日期排序所有远程分支"><a href="#按最后提交日期排序所有远程分支" class="headerlink" title="按最后提交日期排序所有远程分支"></a>按最后提交日期排序所有远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv --<span class="built_in">sort</span>=-committerdate</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5188320/how-can-i-get-a-list-of-git-branches-ordered-by-most-recent-commit">How can I get a list of Git branches, ordered by most recent commit?</a></p>
<h2 id="更好的-git-log"><a href="#更好的-git-log" class="headerlink" title="更好的 git log"></a>更好的 git log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="列出另外一个分支没有的提交"><a href="#列出另外一个分支没有的提交" class="headerlink" title="列出另外一个分支没有的提交"></a>列出另外一个分支没有的提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry -v branch-A branch-B</span><br></pre></td></tr></table></figure>

<h2 id="clone-特定分支"><a href="#clone-特定分支" class="headerlink" title="clone 特定分支"></a>clone 特定分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b develop git@github.com:user/myproject.git</span><br></pre></td></tr></table></figure>

<h2 id="递归移动文件夹"><a href="#递归移动文件夹" class="headerlink" title="递归移动文件夹"></a>递归移动文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bar/&#123;,.&#125;* .</span><br></pre></td></tr></table></figure>

<h2 id="列出特定分支的记录"><a href="#列出特定分支的记录" class="headerlink" title="列出特定分支的记录"></a>列出特定分支的记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p branch-name</span><br></pre></td></tr></table></figure>

<h2 id="查看特定文件的-git-记录"><a href="#查看特定文件的-git-记录" class="headerlink" title="查看特定文件的 git 记录"></a>查看特定文件的 git 记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -- filename</span><br></pre></td></tr></table></figure>

<h2 id="修改-git-提交为任何人"><a href="#修改-git-提交为任何人" class="headerlink" title="修改 git 提交为任何人"></a>修改 git 提交为任何人</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -c user.name=<span class="string">&quot;NEW NAME&quot;</span> -c user.email=<span class="string">&quot;new_email@gmail.com&quot;</span> commit --amend --<span class="built_in">date</span>=<span class="string">&quot;Tue Nov 20 03:00 2018 +0100&quot;</span> --author=<span class="string">&quot;NEW NAME &lt;new_email@gmail.com&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看当前所有子目录的-git-状态"><a href="#查看当前所有子目录的-git-状态" class="headerlink" title="查看当前所有子目录的 git 状态"></a>查看当前所有子目录的 git 状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 1 -mindepth 1 -<span class="built_in">type</span> d -<span class="built_in">exec</span> sh -c <span class="string">&#x27;(echo &#123;&#125; &amp;&amp; cd &#123;&#125; &amp;&amp; git status -s &amp;&amp; echo)&#x27;</span> \\;</span><br></pre></td></tr></table></figure>

<h2 id="创建-git-归档时忽略某些目录"><a href="#创建-git-归档时忽略某些目录" class="headerlink" title="创建 git 归档时忽略某些目录"></a>创建 git 归档时忽略某些目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cvfz app.tar.gz --exclude <span class="string">&quot;.git/*&quot;</span> --exclude <span class="string">&quot;.git&quot;</span> app/</span><br></pre></td></tr></table></figure>

<h2 id="列出未发布的-commit"><a href="#列出未发布的-commit" class="headerlink" title="列出未发布的 commit"></a>列出未发布的 commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> @&#123;u&#125;..</span><br></pre></td></tr></table></figure>

<h2 id="在所有-commit-中寻找代码"><a href="#在所有-commit-中寻找代码" class="headerlink" title="在所有 commit 中寻找代码"></a>在所有 commit 中寻找代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all | xargs git grep</span><br></pre></td></tr></table></figure>

<h2 id="找到一个文件是何时被删掉的"><a href="#找到一个文件是何时被删掉的" class="headerlink" title="找到一个文件是何时被删掉的"></a>找到一个文件是何时被删掉的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --diff-filter=D -- path/to/file</span><br></pre></td></tr></table></figure>

<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branch</span><br></pre></td></tr></table></figure>

<h2 id="让-git-可以递归调用"><a href="#让-git-可以递归调用" class="headerlink" title="让 git 可以递归调用"></a>让 git 可以递归调用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.git <span class="string">&#x27;!git&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="revert-cherry-pick"><a href="#revert-cherry-pick" class="headerlink" title="revert cherry-pick"></a>revert cherry-pick</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -p --onto SHA^ SHA</span><br></pre></td></tr></table></figure>

<h2 id="永久删除文件"><a href="#永久删除文件" class="headerlink" title="永久删除文件"></a>永久删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter <span class="string">&#x27;rm -rf my_folder/my_file&#x27;</span> HEAD</span><br></pre></td></tr></table></figure>

<h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink = <span class="string">&quot;!f() &#123; echo &quot;</span>https://$(git config --get remote.origin.url | grep --color=never -o -E <span class="string">&#x27;github.com[:/][^\\.]+&#x27;</span> | sed s/\\:/\\\\//)/commit/$(git rev-parse @&#123;u&#125;)<span class="string">&quot;; &#125;; open <span class="subst">$(f)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="仅忽略本地副本的文件更改"><a href="#仅忽略本地副本的文件更改" class="headerlink" title="仅忽略本地副本的文件更改"></a>仅忽略本地副本的文件更改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged &lt;file&gt;</span><br><span class="line"></span><br><span class="line">git update-index --no-assume-unchanged &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="忽略已跟踪的文件"><a href="#忽略已跟踪的文件" class="headerlink" title="忽略已跟踪的文件"></a>忽略已跟踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="获取当前分支名称"><a href="#获取当前分支名称" class="headerlink" title="获取当前分支名称"></a>获取当前分支名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-color 2&gt; /dev/null | sed -e <span class="string">&#x27;/^[^*]/d&#x27;</span> -e <span class="string">&#x27;s/* \(.*\)/\1/&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看某个版本的目录树"><a href="#查看某个版本的目录树" class="headerlink" title="查看某个版本的目录树"></a>查看某个版本的目录树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD~5:hello.txt</span><br><span class="line"></span><br><span class="line">git show awesome-feature:app/models</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/hg-tips.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/hg-tips.html" itemprop="url">Hg tips</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-01T16:00:00+00:00">
                2022-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h2><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>Hg 本身支持简写，如：</p>
<ul>
<li>hg status &#x3D;&gt; hg st</li>
<li>hg shelve &#x3D;&gt; hg she</li>
<li>hg unshelve &#x3D;&gt; hg unshe</li>
<li>hg update &#x3D;&gt; hg up</li>
<li>hg commit &#x3D;&gt; hg ci</li>
<li>hg diff &#x3D;&gt; hg d</li>
</ul>
<p>也可以通过下面几种方式来自定义想要的别名。</p>
<h4 id="方式一：hg-alias"><a href="#方式一：hg-alias" class="headerlink" title="方式一：hg alias"></a>方式一：hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">amend = commit --amend</span><br><span class="line">br = branch</span><br><span class="line">brs = branches</span><br><span class="line">wip = !<span class="variable">$HG</span> addremove &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="variable">$HG</span> ci -m <span class="string">&quot;--wip-- [skip ci]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg amend</span><br><span class="line">&gt; hg br</span><br><span class="line">&gt; hg brs</span><br><span class="line">&gt; hg wip</span><br></pre></td></tr></table></figure>

<h4 id="方式二：bash-alias"><a href="#方式二：bash-alias" class="headerlink" title="方式二：bash alias"></a>方式二：bash alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> hgst=<span class="string">&quot;hg status&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hgd=<span class="string">&quot;hg diff&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hga=<span class="string">&quot;hg add&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgst</span><br></pre></td></tr></table></figure>

<h4 id="方式三：bash-function"><a href="#方式三：bash-function" class="headerlink" title="方式三：bash function"></a>方式三：bash function</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgpl</span><br></pre></td></tr></table></figure>

<h4 id="方式四：bash-function-hg-alias"><a href="#方式四：bash-function-hg-alias" class="headerlink" title="方式四：bash function + hg alias"></a>方式四：bash function + hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">pl = !<span class="built_in">source</span> ~/.bash_profile &amp;&amp; hgpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg pl</span><br></pre></td></tr></table></figure>

<h3 id="复制其它分支的-commit"><a href="#复制其它分支的-commit" class="headerlink" title="复制其它分支的 commit"></a>复制其它分支的 commit</h3><p>假设我们有多个分支在并行开发，在 A 分支做了某些改动，希望把这些改动也应用到 B 分支。</p>
<p>这时候可以用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/graft">graft</a> 命令将这个 commit 从别的分支复制到当前分支，类似于 Git  <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-cherry-pick">cherry-pick</a> 功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg brs</span><br><span class="line">feature/v1                     6:f8528de0eb4c</span><br><span class="line">feature/v1.1                   5:288d0414598d</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -G --style compact</span><br><span class="line">@  6[tip]:1   f8528de0eb4c   2021-12-14 13:04 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-04</span><br><span class="line">|</span><br><span class="line">| o  5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-03</span><br><span class="line">| |</span><br><span class="line">| o  4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-02</span><br><span class="line">| |</span><br><span class="line">| o  3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-00</span><br><span class="line">| |</span><br><span class="line">| o  2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">|/     feat: feature-v1.1-00</span><br><span class="line">|</span><br><span class="line">o  1   431a3844a58c   2021-12-14 12:54 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-01</span><br><span class="line">|</span><br><span class="line">o  0   5d35d7d5baf8   2021-12-14 12:53 +0800   4Ark</span><br><span class="line">     feat: feature-v1</span><br></pre></td></tr></table></figure>

<p>feature&#x2F;v1.1 分支是基于 feature&#x2F;v1 创建的，目前两个分支都分别提交了一些东西，我们希望将 feature&#x2F;1.1 的最后一个提交（5:288d0414598d）复制到 feature&#x2F;1 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg update feature/v1</span><br><span class="line">&gt; hg graft -r 5</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r tip --style compact</span><br><span class="line">7[tip]   42cf5e6dfe1e   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br></pre></td></tr></table></figure>

<h4 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制单个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个，但有一个例外</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2::5 and not 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整个分支作为一个提交复制过来，如果要编辑提交信息将 -r 改成 --edi</span></span><br><span class="line">&gt; hg graft -r feature/v1.1 --base <span class="string">&quot;ancestor(&#x27;feature/v1.1&#x27;,&#x27;feature/v1&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果在 graft 过程中有冲突，可以解决后使用 <code>hg graft --continue</code> 继续进行，或者使用 <code>hg graft --abort</code> 终止本次操作。</p>
<h3 id="同一个仓库链接到多个目录（worktree）"><a href="#同一个仓库链接到多个目录（worktree）" class="headerlink" title="同一个仓库链接到多个目录（worktree）"></a>同一个仓库链接到多个目录（worktree）</h3><p>如果熟悉 git 的同学应该知道 git 有一个 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-worktree">worktree</a> 命令，它可以将多个目录链接同一个仓库，并且可以在各自的目录下切换到不同的分支，特别适合以下场景：</p>
<ol>
<li>并行开发：在两个不同的分支上开发，不需要频繁回来地切换。</li>
<li>快速试验、修复：在开发中需要验证、或修复某个 BUG，但不想影响现有的工作目录，就可以在新的工作目录中进行开发。</li>
<li>代码迁移合并：假如 A 分支和 B 分支版本区别过大，无法直接使用 <code>graft</code>，这时候就可以从新的工作目录中直接拷贝文件。</li>
</ol>
<p>其实 hg 也有类似的命令，那就是 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/wiki/ShareExtension">share</a>，需要先开启扩展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc </span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">share =</span><br></pre></td></tr></table></figure>

<p>然后这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg share xxx-project project-v2</span><br><span class="line">&gt; <span class="built_in">cd</span> project-v2</span><br><span class="line">&gt; hg up feature/xxx</span><br></pre></td></tr></table></figure>

<h2 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h2><p style="color: red; font-weight: bold;">注意：以下操作请谨慎执行，除非有特别声明，否则均只能操作未发布的提交。</p>

<h3 id="撤销前一次提交"><a href="#撤销前一次提交" class="headerlink" title="撤销前一次提交"></a>撤销前一次提交</h3><p>如果提交后发现某个文件忘记添加了，可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/rollback">rollback</a> 进行回滚：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;feat: do something&quot;</span></span><br><span class="line">&gt; hg rollback </span><br></pre></td></tr></table></figure>

<p>该操作会把最后一次 commit 移除，但这个 commit 的改动仍在。</p>
<h3 id="回滚某个-commit"><a href="#回滚某个-commit" class="headerlink" title="回滚某个 commit"></a>回滚某个 commit</h3><p>如果想要回滚某个 commit，可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/backout">backout</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚最后一个提交</span></span><br><span class="line">&gt; hg backout -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交</span></span><br><span class="line">&gt; hg backout -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交，但先不提交（推荐使用这种方式）</span></span><br><span class="line">&gt; hg backout -r 9487 --no-commit</span><br></pre></td></tr></table></figure>

<p>效果就和 <code>git revert</code> 一样。</p>
<h3 id="撤销某个-commit-及其后代"><a href="#撤销某个-commit-及其后代" class="headerlink" title="撤销某个 commit 及其后代"></a>撤销某个 commit 及其后代</h3><p>如果想要撤销某个 commit 及以后的所有改动，可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/strip">strip</a>，需要先开启扩展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">strip =</span><br></pre></td></tr></table></figure>

<p>然后这样使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除单个</span></span><br><span class="line">&gt; hg strip -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个</span></span><br><span class="line">&gt; hg strip -r 9487 9488</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 commit，但保留改动</span></span><br><span class="line">&gt; hg strip -r 9487--keep</span><br></pre></td></tr></table></figure>

<p>注意：该操作不属于修改历史，可用于已发布的 commit。</p>
<h3 id="修改前一次提交"><a href="#修改前一次提交" class="headerlink" title="修改前一次提交"></a>修改前一次提交</h3><p>如果我们在提交一次 commit 后，想要修改 commit 信息，或者想要再做一些改动，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: first commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改一下</span></span><br><span class="line">&gt; hg commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="修改前-N-次提交"><a href="#修改前-N-次提交" class="headerlink" title="修改前 N 次提交"></a>修改前 N 次提交</h3><p>如果要支持更复杂的修改历史操作，我们可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/wiki/HisteditExtension">histedit</a> 扩展，类似于 <code>git rebase -i</code>，使用它能够实现：</p>
<ul>
<li>修改某个 commit 的 commit 信息</li>
<li>移除某个提交</li>
<li>合并多次提交</li>
<li>等等..</li>
</ul>
<p>需要在 <code>.hgrc</code> 开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">histedit =</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>每次修改后 changeset 都会改变。</li>
</ul>
<p>假设，我们现在有下面几个提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg <span class="built_in">log</span> -b . --style compact</span><br><span class="line"></span><br><span class="line">5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br><span class="line"></span><br><span class="line">4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-02</span><br><span class="line"></span><br><span class="line">3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br><span class="line"></span><br><span class="line">2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br></pre></td></tr></table></figure>

<p>如果只是修改最后一个 commit 信息，我们可以使用 <code>hg commit --amend</code>，如果要修改前几个的 commit 信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要修改倒数第三个的 commit 信息</span></span><br><span class="line">&gt; hg histedit 8719f541d5d8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑内容：</span></span><br><span class="line">pick 8719f541d5d8 3 feat: feature-v1.1-00</span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br><span class="line"><span class="comment"># Edit history between 8719f541d5d8 and 288d0414598d</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commits are listed from least to most recent</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can reorder changesets by reordering the lines</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but allow edits before making new commit</span></span><br><span class="line"><span class="comment">#  m, mess = edit commit message without changing commit content</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  b, base = checkout changeset and apply further changesets from there</span></span><br><span class="line"><span class="comment">#  d, drop = remove commit from history</span></span><br><span class="line"><span class="comment">#  f, fold = use commit, but combine it with the one above</span></span><br><span class="line"><span class="comment">#  r, roll = like fold, but discard this commit&#x27;s description and date</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据描述，如果我们只是想要修改 commit 信息，我们可以直接在这里改：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ mess 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">	pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">	pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure>

<p>但是如果想要修改这个 commit 的改动内容，比如新增一个文件，我们改成这样：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">	pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">	pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure>

<p>这时候就可以改动文件内容，最后再进行提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&#x27;new&#x27;</span> &gt; new-file.txt</span><br><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: feat: feature-v1.1-00(changed)&quot;</span></span><br><span class="line">created new <span class="built_in">head</span></span><br><span class="line"></span><br><span class="line">&gt; hg histedit --<span class="built_in">continue</span> <span class="comment"># 你也可以使用 hg histedit --abort 来终止本次操作</span></span><br></pre></td></tr></table></figure>

<p>如果要移除某个 commit：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ drop 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">	pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">	pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure>

<p>如果要合并多个 commit，并且保留所有提交信息：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	pick 8719f541d5d8 3 feat: feature-v1.1-00  # 只能合并到第一个 commit</span><br><span class="line"><span class="deletion">- pick d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="deletion">- pick 288d0414598d 5 feat: feature-v1.1-03</span></span><br><span class="line"><span class="addition">+ fold d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="addition">+ fold 288d0414598d 5 feat: feature-v1.1-03</span></span><br></pre></td></tr></table></figure>

<p>如果要合并多个 commit，并且不保留提交信息（直接采用第一个 commit 信息），只需要将 <code>fold</code> 改成 <code>roll</code>。</p>
<h2 id="查找历史"><a href="#查找历史" class="headerlink" title="查找历史"></a>查找历史</h2><h3 id="查看-commit-的信息"><a href="#查看-commit-的信息" class="headerlink" title="查看 commit 的信息"></a>查看 commit 的信息</h3><p>使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/log">log</a> 命令某个提交的信息，通常我们使用 source tree 能够满足大部分日常需求。</p>
<p>但 log 还支持很多高阶操作，这里举几个最常使用的，推荐配合别名使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支的的 log</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -b .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更清晰地查看 log 历史</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --template <span class="string">&quot;&#123;label(&#x27;custom.rev&#x27;, rev)&#125;\t&#123;label(&#x27;custom.node&#x27;,node|short)&#125; &#123;label(&#x27;custom.phase&#x27;,phase)&#125; \t&#123;label(&#x27;custom.age&#x27;,date|age)&#125;\t&#123;desc|firstline&#125; &#123;label(&#x27;custom.user&#x27;, author|user)&#125; &#123;label(&#x27;custom.branch&#x27;,branch)&#125; &#123;label(&#x27;custom.tag&#x27;,tags)&#125; &#123;label(&#x27;custom.book&#x27;,bookmarks)&#125;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个提交的信息以及文件改动</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -p -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息</span></span><br><span class="line">&lt; hg <span class="built_in">log</span> package.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息（包括删除）</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --remove package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个目录的改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -M src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看多个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 -L package2.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看未发布的提交</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r <span class="string">&quot;draft()&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="查看某个文件每一行的最后改动者"><a href="#查看某个文件每一行的最后改动者" class="headerlink" title="查看某个文件每一行的最后改动者"></a>查看某个文件每一行的最后改动者</h3><p>可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/annotate">annotate</a> 命令查看文件中每一行的最后改动者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg annotate -ulc package.json</span><br></pre></td></tr></table></figure>

<p>ps：该命令还有另一个别名 blame。</p>
<h3 id="二分法定位出问题的-commit"><a href="#二分法定位出问题的-commit" class="headerlink" title="二分法定位出问题的 commit"></a>二分法定位出问题的 commit</h3><p>如果想知道哪一次代码提交引入了错误，可以使用 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/bisect">bisect</a> 命令。</p>
<p>具体操作看阮一峰老师的这篇文章： <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">《git bisect 命令教程》</a> 。</p>
<h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><h3 id="diff-tool-差异对比工具"><a href="#diff-tool-差异对比工具" class="headerlink" title="diff tool 差异对比工具"></a>diff tool 差异对比工具</h3><p>使用一个称手的 diff 工具可帮助你提高很多效率，比如：</p>
<ul>
<li>快速对比两个版本的差异</li>
<li>快速对比两个文件、文件夹的差异</li>
</ul>
<p>我个人使用 <a target="_blank" rel="noopener" href="https://www.scootersoftware.com/index.php">Beyond Compare</a>，不过这个软件略贵，也可以使用其它同类工具，例如：<a target="_blank" rel="noopener" href="https://apps.kde.org/en/kdiff3">KDiff3</a>、<a target="_blank" rel="noopener" href="https://winmerge.org/">WinMergeU</a>、<a target="_blank" rel="noopener" href="https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge">P4Merge 等。</a></p>
<p>下面以 Beyond Compare 为例进行配置，其实基本大同小异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line"><span class="comment"># uncomment the lines below to enable some popular extensions</span></span><br><span class="line"><span class="comment"># (see &#x27;hg help extensions&#x27; for more info)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">extdiff =</span><br><span class="line">hgext.extdiff =</span><br><span class="line"></span><br><span class="line">[extdiff]</span><br><span class="line">cmd.bcomp = bcomp</span><br><span class="line">opts.bcomp = -leftreadonly -solo</span><br><span class="line"></span><br><span class="line">[merge-tools]</span><br><span class="line">bcomp.executable = Applications/Beyond Compare.app/Contents/MacOS/bcomp</span><br><span class="line">bcomp.priority=-1</span><br><span class="line">bcomp.args=<span class="variable">$local</span> <span class="variable">$other</span> <span class="variable">$base</span> /mergeoutput=<span class="variable">$output</span> /ro /lefttitle=<span class="built_in">local</span> /centertitle=base /righttitle=other /outputtitle=merged /automerge /reviewconflicts /solo</span><br><span class="line">bcomp.premerge=False</span><br><span class="line">bcomp.regname=ExePath</span><br><span class="line">bcomp.gui=True</span><br><span class="line">bcomp.diffargs=/lro /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /righttitle=<span class="string">&#x27;$clabel&#x27;</span> /solo /expandall <span class="variable">$parent</span> <span class="variable">$child</span></span><br><span class="line">bcomp.diff3args=<span class="variable">$parent1</span> <span class="variable">$parent2</span> <span class="variable">$child</span> /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /centertitle=<span class="string">&#x27;$clabel&#x27;</span> /righttitle=<span class="string">&#x27;$plabel2&#x27;</span> /solo /ro</span><br><span class="line">bcomp.dirdiff=True</span><br><span class="line">bcomp.binary=True</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比某个版本与当前工作区</span></span><br><span class="line">&gt; hg bcomp -r 9816 -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本、分支</span></span><br><span class="line">&gt; hg bcomp -r 9646 -r 9677</span><br><span class="line">&gt; hg bcomp -r default -r 9677</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本的某个文件、文件夹</span></span><br><span class="line">&gt; hg bcomp -r 9552 -r 9553 filepath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个文件夹</span></span><br><span class="line">&gt; bcomp dir-a dir-b</span><br></pre></td></tr></table></figure>



<p>Beyond Compare 还支持三路比较、合并，就是比较 A 版本、B 版本、C 版本（两者共同祖先），不过要支持这个功能价格就更贵了。</p>
<h3 id="vscode-hg"><a href="#vscode-hg" class="headerlink" title="vscode-hg"></a>vscode-hg</h3><p>在使用 VSCode 的同学，推荐使用 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=mrcrowl.hg">vscode-hg</a> 这个扩展，可支持大部分 hg 操作。</p>
<p>如果遇到 Mercurial installation not found. 报错 ，在 settings.json 添加配置并重启：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;hg.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/homebrew/bin/hg&quot;</span> <span class="comment">// 可通过 which hg 查看 hg 的可执行脚本路径</span></span><br></pre></td></tr></table></figure>

<p>另外推荐开启  <code>hg.lineAnnotationEnabled</code> ，即可轻松查看当前文件每一行最后改动，类似于 GitLens 扩展。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-28-chrome/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-28-chrome/" itemprop="url">安利两个浏览器插件</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-28T13:45:00+00:00">
                2022-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386844&auto=1&height=66"></iframe></div>       

<p>Hello 各位好，我是小豪。  </p>
<p>以前我是一个插件控，时不时就会给浏览器装各种插件。  </p>
<p>当然，插件在提升浏览器或上网体验的同时，也会加重电脑的运行负担。如果你的电脑运行内存比较大，那请随意。  </p>
<p>今天想介绍 2 个最近刚安装的浏览器插件，一个是标签页搜索 &amp; 管理，一个是标签页美化。</p>
<h2 id="Omni"><a href="#Omni" class="headerlink" title="Omni"></a>Omni</h2><p>Omni，是前阵子在 Product Hunt 上非常火的浏览器插件，可用来搜索浏览器书签、历史记录以及管理标签页。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460528834249.jpg"></p>
<p>在使用浏览器的过程中，许多人可能有过这么一种经历：</p>
<p>当浏览器打开了太多的标签页，如下图，所有标签页顶部原先显示的<strong>页面名称</strong>，都会被「挤压」得只剩下一个图标，以至于我们都分不清哪个是哪个。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460533257042.jpg"></p>
<p>而有了 Omni 插件，你可以像使用苹果上的聚焦搜索或是 Windows 上的 PowerToys 那样，在浏览器中呼出一个<strong>搜索框</strong>，如下图，以搜索的方式查找你打开的标签页。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460521472184.jpg"></p>
<p>默认呼出 Omni 搜索框的方式，点击浏览器右上角的 Omni 插件图标。</p>
<p>当然这种默认的呼出方式，既不够快，也不够优雅。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460539914953.jpg"></p>
<p>我们可以自定义呼出 Omni 搜索框的快捷键，方法如下： </p>
<p>在 Chrome 浏览器地址栏输入 <code>chrome://extensions/shortcuts</code> 并按下回车，打开扩展程序的快捷键设置页面，找到 Omni 插件。   </p>
<p>点击输入框右侧的编辑按钮，按照提示，设置呼出 Omni 搜索框的快捷键，例如我在 Mac 上设置的快捷键为 Ctrl + O。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460537842769.jpg"></p>
<p>接着去到非浏览器设置页面的标签页，按下刚设置的快捷键，就能快速呼出 Omni 搜索框了。   </p>
<p>除了搜索标签页，Omni 还有另外一些附加功能，如下图，可以通过内置的命令实现一些<strong>快捷操作</strong>：  </p>
<ul>
<li>发送一份邮件</li>
<li>创建一个新的 Notion 页面   </li>
<li>创建一个谷歌表格   </li>
<li>创建一个谷歌文档   </li>
<li>创建一个表单     </li>
<li>发布一条推特</li>
<li>……</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460545287349.jpg"></p>
<p>Omni 目前似乎只上架到了 Chrome Web Store，暂未上架 Edge 插件商店，想用的朋友，自行前往谷歌商店搜索安装吧。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460551202601.jpg"></p>
<h2 id="iTab"><a href="#iTab" class="headerlink" title="iTab"></a>iTab</h2><p>iTab，一个标签页美化插件，安装之后，可以取代浏览器默认的标签页，效果如下。  </p>
<p>iTab 最大的特色在于，<strong>加入了 iOS 上的小组件的设计</strong>，让它在众多标签页美化插件中显得与众不同，而且拖动小组件可以重新调整小组件的位置。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/28/16460552728542.jpg"></p>
<p>剩下的功能就和其他浏览器美化插件相似，就不过多介绍了。   </p>
<p>iTab 官网：<br><a target="_blank" rel="noopener" href="https://itab.link/">https://itab.link/</a>   </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-weekly" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/weekly-02.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/weekly-02.html" itemprop="url">周刊第2期：珍惜和平</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-26T16:00:00+00:00">
                2022-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="俄乌战争"><a href="#俄乌战争" class="headerlink" title="俄乌战争"></a>俄乌战争</h2><p>这是一个技术、踩坑记录、日常吐槽的博客，我本不想给它蒙上太多政治色彩，但原谅我实在是憋不住了。</p>
<p>2022年2月24号，俄罗斯入侵乌拉克，与此同时，国内的媒体出现了铺天盖地的假信息、在微博、抖音上网友们更是发表了各种极度令人恶心的言论，让我备受震撼。</p>
<p>你们到底有没有意识到，这可是战争，是要死很多人的！或许你们认为这不关你的事、或许你们认为这只是开开玩笑、又或许你们认为这本就是一场正义的战争。</p>
<p>每个人都可以有自己的政治立场，但我希望你们积点口德，不要拿这种事情来口嗨。</p>
<p>我想在此引用几句在网上看到的几句话，也正是我想说的：</p>
<blockquote>
<p>我们，强烈反对俄罗斯对乌克兰发动的战争。无论俄罗斯有千种理由，万般借口，以武力入侵一个主权国家都是对以联合国宪章为基础的国际关系准则的践踏，是对现有国际安全体系的破坏。<br /><br>我们，坚决支持乌克兰人民保家卫国的行动。我们担忧俄罗斯的武力行为将导致欧洲乃至整个世界局势的动荡，引发更大范围的人道主义灾难。<br /><br>我们，强烈呼吁俄罗斯政府和普京总统停止战争，用谈判解决纠纷。强权不仅会使文明进步的成果和国际正义的原则毁于一旦，还会给俄罗斯民族带来巨大的耻辱和灾难。<br /><br>和平始于人心的渴望。我们，反对不义战争。</p>
</blockquote>
<blockquote>
<p>没有任何一个战争的挑衅者，值得歌颂。<br /><br>也没有任何一个战争的发起者，值得赞扬。<br /><br>民族主义在现实世界值得提倡，但沦为民粹时就会反噬自己。<br /><br>宏大叙事是审美的一种需要，但如果全民歌颂将让集体万劫不复。<br /></p>
</blockquote>
<p>根据 The Kyiv Independent 报道，下面是目前双方的战损情况：</p>
<div style="display: flex;">
    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142093.jpeg">
    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142529.jpeg">
</div>

<p>这一串数字的背后，是无数家庭的血和泪！</p>
<p>请珍惜来之不易的和平，任何为战争欢呼的人都是傻逼！</p>
<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote>
<p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p>
</blockquote>
<h3 id="Yes-I-can-connect-to-a-DB-in-CSS"><a href="#Yes-I-can-connect-to-a-DB-in-CSS" class="headerlink" title="Yes, I can connect to a DB in CSS"></a><a target="_blank" rel="noopener" href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">Yes, I can connect to a DB in CSS</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">《Yes, I can connect to a DB in CSS》 | kamelåså</a></em></p>
<p><img src="https://www.leemeichin.com/img/yes-i-can-connect-to-a-db-in-css/tweet.jpg"></p>
<blockquote>
<p>招聘人员会说：</p>
<p>我们正在寻找可以使用 CSS 连接到数据库的人。</p>
</blockquote>
<p>这能做到吗？是的，这篇文章的作者就做到了。</p>
<p>首先需要了解两个东西：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini">CSS Houdini</a>：可以通过 JavaScript 访问并控制 CSS 模型，其最大的特点就是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/PaintWorklet">PaintWorklet</a>，它可以以编程方式生成一个图像，也与我们所熟悉的 Canvas 类似。</li>
<li><a target="_blank" rel="noopener" href="https://sql.js.org/">sql.js</a>：它是一个 JS 库，允许你在浏览器中创建并查询一个关系型数据库，使用一个存储在浏览器内的虚拟数据库文件，所以数据的存储和修改都不是持久化的；不过它还支持将 SQLite 编译成 Wasm，也就意味着可以在浏览器访问现有的 SQLite 数据库文件。</li>
</ul>
<p>做法就是：在 JS 中通过 Houdini 获取 CSS 变量，然后传递给 SQLite 的 DB 实例。</p>
<p>最终效果看这里：<a target="_blank" rel="noopener" href="https://sqlcss.xyz/">https://sqlcss.xyz</a></p>
<h3 id="我为什么说-Vim-比-VSCode-更好用"><a href="#我为什么说-Vim-比-VSCode-更好用" class="headerlink" title="我为什么说 Vim 比 VSCode 更好用"></a><a target="_blank" rel="noopener" href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">我为什么说 Vim 比 VSCode 更好用</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">《Why Vim is better than VSCode》 | Sean</a></em></p>
<p>随着微软开始全面拥抱开源世界，推出了一个又一个大型开源项目，例如 VSCode，就已经在代码编辑器中占据了一个重要的位置，并且随着 <a target="_blank" rel="noopener" href="https://github.com/features/codespaces">Codespaces</a> 和 <a target="_blank" rel="noopener" href="https://github.com/gitpod-io/openvscode-server">Open VSCode Server</a> 的推出，可以轻松在浏览器上进行远程开发。</p>
<p>除此之外，微软还开源了一个项目叫做 <a target="_blank" rel="noopener" href="https://github.com/xtermjs/xterm.js/">xterm.js</a>，用于 VSCode 的终端，这也让浏览器实现终端功能变得更加简单。</p>
<p>作者认为相比于 VSCode，还是 Vim更胜一筹，因为它轻巧快熟，可以在服务器上通过 SSH 写代码，所有事情都可以在终端中完成，可移植性和可配置性都非常高，并且基于 xterm.js 也可以轻松实现在浏览器上使用 Vim 进行远程开发。</p>
<p>它并不像很多人想象得那么难以上手，它甚至让代码写起来就像打游戏一样，因为它的控制方式与游戏相似，都是通过各种命令的组合操作。</p>
<p>大多数命令有两个、三个或四个部分。三部分结构的一个版本是这样的：操作符（operator）-文本对象（text object）-动作（motion）。</p>
<p>操作符包括删除（delete）、更改（change）、视觉选择（visual select）和替换（replace），每次选一个使用。</p>
<p>所以可以这样组合：</p>
<ul>
<li>di’ —— 删除（delete）“单引号”内（inside）的内容。</li>
<li>da” —— 删除“双引号”周围（around）的内容。</li>
<li>dit —— 删除 html 标签（tag）内的内容。</li>
<li>ci[ —— 改变（change）[方括号] 内的内容。</li>
</ul>
<h5 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h5><p>对于 Vim，我一直在想要学习、放弃之间反复横跳，以至于到现在也只会一些简单的编辑，没有感受过 Vim 命令组合的强大。</p>
<p>但此文只是举了几个例子，就让我更加了解 Vim 的命令组合，重新燃起我想要学习 Vim 的热情。</p>
<h2 id="CSS-not-伪类选择器已支持复杂参数"><a href="#CSS-not-伪类选择器已支持复杂参数" class="headerlink" title="CSS :not()伪类选择器已支持复杂参数"></a><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">CSS :not()伪类选择器已支持复杂参数</a></h2><p><em>原文地址：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">《CSS :not()伪类选择器已支持复杂参数》 | 张鑫旭</a></em></p>
<p>新特性：</p>
<ul>
<li>支持多个选择器：<code>:not(.a, .b)</code></li>
<li>权重的区别：无论 :not() 内部有多少个选择器，最终只计算 :not() 本身这一个标签选择器</li>
</ul>
<h2 id="Facebook-工程师文化独特之处"><a href="#Facebook-工程师文化独特之处" class="headerlink" title="Facebook 工程师文化独特之处"></a><a target="_blank" rel="noopener" href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">Facebook 工程师文化独特之处</a></h2><p><em>原文地址：<a target="_blank" rel="noopener" href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">《Facebook 工程师文化独特之处》 | Cat Chen</a></em></p>
<p>作者在 Facebook 工作了 7 年，结合 Facebook 之前和之后的其它公司的经验， 本文就分享了一些作者觉得属于 Facebook 的独特文化的地方。</p>
<ul>
<li>工程师对产品结果负责任<ul>
<li>工程师考评不只看技术，从高级工程师开始，考评主要看对产品结果的产出</li>
<li>假如产品的留存率没有得到提高，则工程师、产品经理的考评都会得到惩罚</li>
<li>鼓励下属自行定义「什么叫做成功」，而不是告诉下属「做什么才能成功」</li>
</ul>
</li>
<li>基础架构被视为内部产品<ul>
<li>基础架构在公司内部推广</li>
</ul>
</li>
<li>救火比防火更容易获得回报<ul>
<li>如果你做的事无法量化，即便它是非常有用的，公司也会认为这是无意义的</li>
<li>举个例子：如果在小镇未发生火灾前，即便消防队长在背后默默做了很多事情防范，大家也不会认为这是你的功劳；相反，只有在发生过一次非常严重的火灾后，你做的事才能体现价值。</li>
<li>这就是为什么 Facebook 内部那么多问题处于起火状态，因为不起火就没有救火英雄。</li>
</ul>
</li>
</ul>
<h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://npm.runkit.com/">NPM RunKit</a>：直接在浏览器中尝试任何 npm 软件包，如果你也曾有过与我一样的经历，想尝试一下某个库的运行结果，由于无法直接在浏览器 console 中运行，最终只能选择在项目内随便找个地方运行的话，那就可以试试这个工具，非常简单快捷，只需在 url 后面补上你想要的 npm 包名，如 <a target="_blank" rel="noopener" href="https://npm.runkit.com/dayjs">dayjs</a>。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-26-apptips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-26-apptips/" itemprop="url">近期值得关注的 App</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-26T13:37:00+00:00">
                2022-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于公众号「效率工具指南」<br>文&#x2F;彭宏豪   </p>
<p>Hello 大家好，我是小豪。   </p>
<p>好久不见，来一期这个公众号的传统艺能「近期值得关注的 App」，本期想介绍 3 个工具，一个是介绍过很多次的 Notion，两个是最近才用上的新工具，希望对你有帮助。  </p>
<h2 id="Notion-网页版导出-Markdown"><a href="#Notion-网页版导出-Markdown" class="headerlink" title="Notion 网页版导出 Markdown"></a>Notion 网页版导出 Markdown</h2><p>用 Notion 来记学习笔记，当一个页面记录的内容过多，通过点击目录来实现内容的跳转，会遇到<strong>卡顿</strong>的情况——点击后停留一小会、才能跳到对应的部分。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458805639428.jpg"></p>
<p>除了卡顿，Notion 客户端没有像飞书文档一样的<strong>侧边目录</strong>，这对在 Notion 中阅读长文档的人来说，非常痛苦。  </p>
<p>基于这两个原因，我萌生了<strong>把原先存放在 Notion 中的长文档导出到别的软件</strong>的想法。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458810403409.jpg"></p>
<p>从 Notion 中导出文档，我首选了 Markdown 格式，不为别的，就是希望文档从一个地方迁移到另外一个地方，格式不会错乱。  </p>
<p>很久之前用 Notion 自带的导出 Markdown  的功能，会遇到图片丢失的问题，那时候为了解决这个问题，还需要借助外部的工具，例如之前介绍过的浏览器插件「简悦」。  </p>
<p>不过今天我又试用了 <strong>Notion 网页版导出 Markdown</strong> 的功能，这次给我很大的惊喜：图片竟然没有丢失，而且渲染出来的富文本样式也很完美。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458817566839.jpg"></p>
<p>网页版 Notion 导出 Markdown，会得到一个压缩包，解压后可以得到一个 md 文件和文件夹，文件夹中存放了文档中插入的图片。  </p>
<p>我试过用两个不同的编辑器（VS Code 和 MWeb）打开这个 md 文件，文档里的图片都能正常显示。  </p>
<p>喜大普奔，<strong>从 Notion 中导出 Markdown，再也不需要借助任何第三方工具了</strong>，Notion 又行了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458818022195.jpg"></p>
<h2 id="Here"><a href="#Here" class="headerlink" title="Here"></a>Here</h2><p>Here，是 Mac 上一个有点像是 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649882151&idx=1&sn=970d4b52a1974edad439e7766c89091a&chksm=83abfa0ab4dc731c16f214e3cdf4f85c5850e98f657f2181ded8cfce63efb46b6a2e582609b7&token=1423371312&lang=zh_CN#rd">uTools</a> 的应用，按下 Option + 空格键，可以呼出下图的搜索框。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458714832443.jpg"></p>
<p>点击右侧的圆形按钮，会显示 Here 内置的一些小工具（插件），可用来查看现在的天气、电脑网速、电池状态、汇率。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458716559396.jpg"></p>
<p>如果觉得插件数量太少，可以打开 Here 的偏好设置，切换到「插件」页面，启用未开启的插件，或是从 Here 官网下载更多插件。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458722856715.jpg"></p>
<p>切换到「捷径」页面，还可以看到它内置的一些小游戏，例如下图来自 Chrome 的彩蛋——<strong>小恐龙</strong>，按下空格键就能直接开始游戏；另外一个游戏：2048。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458718058641.jpg"></p>
<p>Here 右上角还提供了一个查看「<strong>剪贴板历史</strong>」的功能，可以查看你之前复制到剪贴板的所有内容，包含文本和图片，这个功能可以取代之前介绍过的付费剪贴板工具 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649918947&idx=1&sn=6137a4554ce7d2aa003545cb22128035&chksm=83a889ceb4df00d8619fc8882141a4d465ea328b1012652641256423f5a6fa2c2386c6bf1cbb&token=1423371312&lang=zh_CN#rd">PasteNow</a>。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458720112046.jpg"></p>
<p>剪贴板历史记录顶部有一个搜索框，输入关键字可以找到相关的剪贴板记录。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458762739771.jpg"></p>
<p>最后，Here 还有一个小功能，在程序坞显示插件图标，如下图，我选择在程序坞上显示 Here 的天气插件。</p>
<p>这样一来，每次我想查看气温的时候，直接看程序坞的天气图标就好，而不需要按前面说的——呼出搜索框，点击右侧的圆形按钮，打开插件面板（查看天气）——进行一系列操作。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458770951007.jpg"></p>
<p>Here 官网：<br><a target="_blank" rel="noopener" href="https://here.app/">https://here.app/</a>  </p>
<p>首次使用 Here，可能需要用到「邀请码」，可以前往下方的页面获取邀请码：</p>
<p><a target="_blank" rel="noopener" href="https://here.app/release-notes">https://here.app/release-notes</a>   </p>
<h2 id="更高效地移动文件"><a href="#更高效地移动文件" class="headerlink" title="更高效地移动文件"></a>更高效地移动文件</h2><p>用 Mac 的过程中，可能会有这样的需求：将多个文件从一个文件夹📁移动到另外一个文件夹。</p>
<p>我之前的做法是，在打开 Finder 访达的情况下，按下 <strong>Command + T</strong> 新建一个标签页，在新标签页中打开目标文件夹，接着在起始文件夹选中多个待转移的文件，将它们拖拽到目标文件夹。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458796530476.jpg"></p>
<p>这个做法没啥毛病，但少数时候操作不慎，本来已经拖拽到目标文件夹的文件，还是会回到起始文件夹（用文字描述不太直观，但有过类似经验的朋友应该能体会）。   </p>
<p>这里推荐一个帮我们更高效地转移文件的工具：<strong>Dropover - 更加容易拖放文件</strong></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458800036506.jpg"></p>
<p>安装软件后，选中一个想要转移的文件并<strong>长按鼠标左右晃动</strong>，文件旁边会出现一个小抽屉，这是一个文件暂存区，将想要移动的多个文件拖拽到小抽屉中，再一次性移动，使用体验更好。</p>
<p>软件可免费下载，免费试用 14 天，到期后需要购买才能继续使用，买断制，25 元。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/26/16458795114809.jpg"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-weekly" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/weekly-01.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/weekly-01.html" itemprop="url">周刊第1期：搬新家了</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-19T16:00:00+00:00">
                2022-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="我为什么要写周刊"><a href="#我为什么要写周刊" class="headerlink" title="我为什么要写周刊"></a>我为什么要写周刊</h2><p>前几天特地写了篇文章来分享一下我为什么要办这个周刊：《<a href="/post/weekly-idea.html">我为什么要写周刊</a>》。</p>
<h2 id="我搬新家了"><a href="#我搬新家了" class="headerlink" title="我搬新家了"></a>我搬新家了</h2><p>在去年《<a href="/post/2021-summary.html">2021 年度总结</a>》有提到，我曾有过一段开小电动车上班的时光，通勤时间极短，幸福感倍高，但由于公司地址搬迁，就再也没有享受过这样的日子了，即便后来跳槽到新公司，通勤时间缩短了一半，但也要 40 分钟左右的通勤时间，所以，在租房合同到期后，我决定搬到公司附近。</p>
<p>但搬家真的好累，而且广州这几天连续不断地下雨，心情也变得烦躁起来，搬家过程不太顺利，期间还遗漏了物品在楼下没带上车，幸好楼下的邻居平时关系比较好，愿意帮我保管，第二天又跑回去拿。</p>
<p>但从明天开始就可以享受极短通勤距离的好处，想想还是蛮开心的。</p>
<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote>
<p>一些我本周阅读过的好文章、以及我的总结和启发；非常建议你阅读原文，而不是只看这些摘要，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错误的。</p>
</blockquote>
<h3 id="我对-Svelte-的看法"><a href="#我对-Svelte-的看法" class="headerlink" title="我对 Svelte 的看法"></a><a target="_blank" rel="noopener" href="https://lutaonan.com/blog/svelte/">我对 Svelte 的看法</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://lutaonan.com/blog/svelte/">《我对 Svelte 的看法》 | Randy’s Blog</a></em></p>
<p>简单来说 Svelte 是一个在编译时实现了 Reactivity (反应式) 的框架。</p>
<p>如何不用 <code>defineProperty</code> 实现 Reactivity：</p>
<ol>
<li>只要在每次赋值的时候，手动执行 <code>update</code> 方法</li>
<li>Svelte 在编译阶段自动帮我们做了这件事</li>
<li>Svelte 使用了一个 <code>label</code> 语法（$:），实现类似于 Vue 的 <code>computed</code> 功能。</li>
</ol>
<p>Svelte 的跨组件通讯：</p>
<ul>
<li>通过在变量名前面加一个 $ 实现自动订阅<ul>
<li>不是黑魔法，只是针对 $ 开头的变量自动转换成 <code>subscribe</code></li>
</ul>
</li>
</ul>
<p>Svelte 所有功能都在编译阶段完成，并且可以写更少的代码，它相对于 React 和 Vue 更简单，不需要学太多额外的 API 和新语法。</p>
<p>目前的适用场景：</p>
<ul>
<li>适用做来做活动页。</li>
</ul>
<h5 id="我的启发"><a href="#我的启发" class="headerlink" title="我的启发"></a>我的启发</h5><p>学习一个框架或者一个语言，并不一定非要把它用到生产上才算真的有用。更多地是因为想看看在面对同一个问题的时候，不同的人解决问题的思路是怎样的，从而帮助我们提高自己的视野，这才是学习框架和语言真正的魅力。</p>
<h3 id="Svelte-的异步更新实现原理"><a href="#Svelte-的异步更新实现原理" class="headerlink" title="Svelte 的异步更新实现原理"></a><a target="_blank" rel="noopener" href="https://lutaonan.com/blog/how-svelte-set-state-works/">Svelte 的异步更新实现原理</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://lutaonan.com/blog/how-svelte-set-state-works/">《Svelte 的异步更新实现原理》 | Randy’s Blog</a></em></p>
<p>如何异步更新：<strong>将所有导致 UI 更新的操作统一放到一个微任务里执行。</strong></p>
<p>Svelte 的实际做法：</p>
<ol>
<li>一个组件会被编译成一个 fragment</li>
<li>更新操作通过 <code>$$invalidate</code> 包裹</li>
<li>触发 <code>schedule_update()</code> ，通知框架需要被更新，框架会维护一个 <code>dirty_components</code> 数组。</li>
<li>在微任务更新时会统一遍历 <code>dirty_components</code> 数组里的任务，触发组件的更新方法。</li>
</ol>
<h3 id="开发模式-“Development-Mode”-是如何工作的？"><a href="#开发模式-“Development-Mode”-是如何工作的？" class="headerlink" title="开发模式 “Development Mode” 是如何工作的？"></a><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">开发模式 “Development Mode” 是如何工作的？</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">《开发模式 “Development Mode” 是如何工作的？》 | Dan Abramov</a></em></p>
<p><code>process.env.NODE_ENV</code> 实际上是一个常量，在构建时会被替换成一个字符串，所以判断条件最终是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In development:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;development&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">true</span></span><br><span class="line">  doSomethingDev(); // 👈</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In production:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;production&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">false</span></span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd(); // 👈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上判断条件会被「死码消除」给优化，不被执行的代码将被移除。</p>
<p>但是，如果写成这样，则不会奏效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mode = <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (mode !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  // 🔴 not guaranteed to be eliminated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 JavaScript 并没有智能到这种程度。</p>
<h5 id="我的启发-1"><a href="#我的启发-1" class="headerlink" title="我的启发"></a>我的启发</h5><p>以前看 Vue 源码的时候发现很多文件都会重复好几次这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;something error message&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常好奇为什么不重构成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">warn</span> = (<span class="params">condition, message</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// something.js</span></span><br><span class="line"><span class="title function_">warn</span>(xxx, <span class="string">&#x27;something error message&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>现在知道为什么了，因为前者被「死码消除」后，所有相关代码都会被移除，</p>
<p>而后者，相当于调用了一个空的 <code>warn</code> 方法。</p>
<p>但没想到在 Vue3 中已经这么做了：<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/blob/main/packages/compiler-core/src/errors.ts#L16">defaultOnWarn</a>。</p>
<p>延伸阅读：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041469096">高效实现框架和 JS 库瘦身</a></p>
<h3 id="通俗易懂的代数效应"><a href="#通俗易懂的代数效应" class="headerlink" title="通俗易懂的代数效应"></a><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">通俗易懂的代数效应</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">《通俗易懂的代数效应》 | Dan Abramov</a></em></p>
<p>代数效应是什么：</p>
<ul>
<li>类似于 try…catch 语法，无论我们在多少层里面 throw 一个错误，外层的 catch 都能捕获到。</li>
<li>如果内层的 throw 还可以接受从 catch 发送的数据，这就是代数效应。</li>
<li>使用 async、await 的缺点是我们内部定义了 async、则会影响该函数底部所有的调用者。</li>
</ul>
<p>React 中的代数效应：</p>
<ul>
<li>JS 并没有一个类似于 try…handle 的语法，但仅在 React 内部可以通过其它方式实现类似的效果。</li>
<li>典型的场景是：某个组件的渲染是异步的，需要等数据请求返回后再回过来继续渲染。</li>
</ul>
<h3 id="防御性-CSS"><a href="#防御性-CSS" class="headerlink" title="防御性 CSS"></a><a target="_blank" rel="noopener" href="https://ishadeed.com/article/defensive-css/">防御性 CSS</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://ishadeed.com/article/defensive-css/">《防御性 CSS》 | ishadeed</a></em></p>
<ol>
<li>确保 flex 布局能够换行</li>
<li>确保文字过长时的间距以及换行处理</li>
<li>防止图片被拉伸或压缩</li>
<li>弹窗锁定滚动</li>
<li>CSS 变量回退</li>
<li>尽量使用 min-height 固定宽度和高度</li>
<li>确保重置 <code>background-repeat</code></li>
<li>使用 <code>gap</code> 设置 flex 布局间距</li>
<li>给图片设置一个 background-color，以确保图片上方的文字能够正常显示</li>
<li>使用 <code>overflow: auto</code></li>
<li>图片 <code>object-fit: cover</code></li>
<li>分组选择器只要有一个无效，则所有选择器不生效</li>
</ol>
<h5 id="我的启发-2"><a href="#我的启发-2" class="headerlink" title="我的启发"></a>我的启发</h5><p>了解常用的防御性 CSS ，可以避免很多开发中没有意识到的问题。</p>
<h3 id="SSR、SSG、ISR、DPR-有什么区别？"><a href="#SSR、SSG、ISR、DPR-有什么区别？" class="headerlink" title="SSR、SSG、ISR、DPR 有什么区别？"></a><a target="_blank" rel="noopener" href="http://www.yyyweb.com/5407.html">SSR、SSG、ISR、DPR 有什么区别？</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="http://www.yyyweb.com/5407.html">《SSR、SSG、ISR、DPR 有什么区别？》 | 前端里</a></em></p>
<ul>
<li>CSR（Client Side Rendering）: 客户端渲染<ul>
<li>缺点：SPA 应用不利于 SEO</li>
</ul>
</li>
<li>SSR（Server Side Rendering）: 服务端渲染<ul>
<li>优点：利于 SEO</li>
<li>缺点：需要更多的服务器计算资源和运维成本</li>
</ul>
</li>
<li>SSG（Static Site Generation）: 静态网站生成<ul>
<li>常年不变的直接生成为静态页面，页面中的动态内容使用 CSR</li>
<li>缺点：对于网页数量极多的页面，生成一次需要花费很长时间</li>
</ul>
</li>
<li>ISR（Incremental Site Rendering）: 增量式网站渲染<ul>
<li>关键性页面预渲染，缓存至 CDN；非关键性页面先显示 fallback，再使用 CSR渲染，并且缓存至 CDN</li>
<li>缺点：需要先显示 fallback 内容，用户体验不好</li>
</ul>
</li>
<li>DPR（Distributed Persistent Rendering）: 分布式持续渲染<ul>
<li>基于 ISR 的基础上去除 fallback，并且使用「按需构建器」来响应未渲染的页面</li>
</ul>
</li>
</ul>
<h3 id="不优雅的-React-Hooks"><a href="#不优雅的-React-Hooks" class="headerlink" title="不优雅的 React Hooks"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455317250">不优雅的 React Hooks</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455317250">《不优雅的 React Hooks》 | 蚂蚁 RichLab 前端团队</a></em></p>
<p>「奇怪的」规矩：</p>
<ul>
<li>命名：react hooks 要求 hooks 命名以 use 开头，作者觉得破坏了语义，应该以 _ 或者 $ 开头</li>
<li>调用时序：react hooks 区分不同的 state 是通过 hooks 的调用顺序，在内部维护一个链表，这个做法是相对简单粗暴的，所以这就是为什么 hooks 不能条件分支中使用，作者认为这种要求完全需要依赖开发者的经验或者 lint 工具，并不符合直觉。</li>
<li>useRef 的「排除万难」：useRef 仅在组件 mount 阶段初始化，后面 update 时引用同一个变量，但是作者这样多少有点违反 react hooks 的设计初衷，也即 useRef 并不函数式。</li>
</ul>
<p>有缺陷的生命周期：</p>
<ul>
<li>构造时：Class Component 和 Function Component 之间存在一个很大的区别，那就是后者每次 re-render 时都在重新调用自身，所以它并没有 constructor 来做某些仅执行一次的操作。</li>
<li>设计混乱的 useEffect：它实际上只监听能够触发 re-render 的变量，也就是 state，但是它接受的参数 deps 又不做任何限制，很难不让人认为是设计缺陷。</li>
</ul>
<p>useCallback：</p>
<ul>
<li>性能问题？无限套娃✓：使用 useCallback 是为了解决每次渲染都会创建一个新的回调函数，从而导致重新渲染的问题，但是使用 useCallback 也会引发一个更大的问题，那就是当useCallback之前存在依赖关系时，它们的引用维护也变得复杂。调用某个函数时要小心翼翼，你需要考虑它有没有引用过时的问题，如有遗漏又没有将其加入依赖数组，就会产生 Bug。</li>
</ul>
<p>小结：</p>
<ul>
<li>本文没有鼓吹 Class Component 拒绝使用 React Hooks 的意思，反而是希望通过细致地比对二者，从而更深入理解 Hooks。</li>
<li>React Hooks 的各种奇怪之处，也正是潜在症结之所在。</li>
<li>在 Hooks 之前，Function Component 都是 Stateless 的，小巧、可靠但功能有限。Hooks 为 Function Component 赋予了 State 能力并提供了生命周期，使 Function Component 的大规模使用成为了可能。</li>
<li>Hooks 的「优雅」来自向函数式的致敬，但useRef的滥用让 Hooks 离「优雅」相去甚远。</li>
<li>大规模实践 React Hooks 仍然有诸多问题，无论是从语义理解抑或是封装的必要性。</li>
<li>创新不易，期待 React 官方之后会有更好的设计吧。</li>
</ul>
<h3 id="DevTools-实现原理"><a href="#DevTools-实现原理" class="headerlink" title="DevTools 实现原理"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">DevTools 实现原理</a></h3><p><em>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">《DevTools 实现原理》 | vivo 互联网浏览器内核团队</a></em></p>
<p>DevTools 架构：</p>
<ul>
<li>Chrome：TCP + CDP<ul>
<li>CDP（Chrome DevTools Protocol） 本质上是一个 JSON 协议，目前使用 Puppeteer 实现</li>
</ul>
</li>
<li>使用 WebSocket</li>
<li>Android：利用 ADB forward 端口转发能力连接 PC 和 Android 的网络访问</li>
</ul>
<p>内核实现</p>
<ul>
<li>Server 层，用于接收外部网络发过来的操作请求。</li>
<li>Agent 层，对于 Server 层发过来的请求，进行拆解，根据操作的类型不同，再分发给不同的 Agent 来处理。</li>
<li>Session 层，Session 是对不同的业务模块进行了一层抽象。过了 Session 层后，将会进入不同的业务模块，可以到达 V8， Blink 等。</li>
<li>业务层，就是具体的功能模块，比如 V8 模块，主要负责 JavaScript 的调试相关能力的支撑。</li>
</ul>
<h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://devtool.tech/tree">Tree 树形目录可视化生成器</a>：我们都知道 <code>tree</code> 这个命令，可以打印输出现有目录的树形结构，但现实中还存在一种情况，那就是需要输出并不存在的目录结构，这种需求在写开发设计文档时尤为常见，所以除了构造一个临时的目录，还可以使用这个工具直接生成树形目录结构。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.z-lib.org/">Z-Library</a>：世界上最大的数字图书馆，在这里可以找到大量的电子书籍，格式包括：pdf、epub、mobi 等，对于我这种不爱看实体书的人来说，简直是神器。但需要注意每天一个 ip 会限制下载数量，未注册用户是 5 次，注册用户是 10 次，当然也可以通过捐赠来提高下载次数的限制。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.iizhi.cn/">毕方铺</a>：网盘搜索神器，个人认为是所有网盘搜索神器中最好的一个，所有资源都为用户自愿分享，下载需要耗费金币，你也可以上传你想要的分享的资源，别人购买你就能获取金币，当然到达一定金币后就可以提现。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://createfeed.fivefilters.org/index-mergefeeds.php?url%5B%5D=https://medium.com/feed/tag/open-source&max=20&order=feed">Feed Creator</a>：制作 RSS 源的工具，包括网页生成 RSS、合并多个 RSS 等功能；相信有些同学知道 <a target="_blank" rel="noopener" href="https://docs.rsshub.app/">RSSHub</a> 这个开源项目，显然这个项目更加强大，但并不是所有场景都需要用到 RSSHub，这时候就可以使用 Feed Creator。分享一下我个人会在什么场景下使用 Feed Creator 而不是 RSSHub：对于某些访问需要科学上网的网站，我们可以直接通过它生成一个国内可以直接访问的 RSS 源。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">Microsoft 的 Rust 入门教程</a>：要说这两年前端最新的技术莫过于 Rust 了，大量的前端基础设施都通过 Rust 重写了一遍，哪怕笔者这种学不动的人也需要学一些 Rust 的知识，但无奈一直没有找到满意的 Rust 教程，前段时间听闻微软出了一个 Rust 教程，第一次打开后就直接跟着学了两个星期，根本停不下来，真心不错。xdm，Rust 学起来吧！</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022/62-%E6%A0%B8%E9%85%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%AC%AC%E4%B8%89%E9%92%88%E7%96%AB%E8%8B%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/62-%E6%A0%B8%E9%85%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%AC%AC%E4%B8%89%E9%92%88%E7%96%AB%E8%8B%97/" itemprop="url">核酸检测与第三针疫苗</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-18T15:00:00+00:00">
                2022-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%A7%82%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">观点</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>最近香港的疫情又开始激增了，日增数量已经发展到千余人。这其实也是意料之中的，毕竟一直以来港府应对疫情的措施就是看着好像认真在防疫，但是仔细深究又感觉啥都没做。相比澳门，香港这边无论是政府还是资本家们，想着要和内地通关，盯着的一直是日增的人数，似乎只要日增人数下降到一定水平了就能通关了。但是好像从没有（或者说不愿意）思考是不是要普筛、要不要以清零为目标进行防疫隔离。</p>
<p><img src="https://cos.pinlyu.com/posts/2022/62-China_experience.webp#550x" alt="希望港府认真学习"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2022/62-%E6%A0%B8%E9%85%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%AC%AC%E4%B8%89%E9%92%88%E7%96%AB%E8%8B%97/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/gRPC-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/gRPC-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" itemprop="url">gRPC 流式传输极简入门指南</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-18T01:34:36+00:00">
                2022-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>最近一直在研究 gRPC 的 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">ServerReflection</a>，顾名思义，这是 gRPC 里提供的反射接口，当你需要获取某个接口的描述信息，或者是希望动态调用 gRPC 的时候，这一切就会变得非常有用，如果你经常使用 <a target="_blank" rel="noopener" href="https://github.com/fullstorydev/grpcui/">gRPC UI</a> 这款工具来调试 gRPC 接口，那么，你一定会注意到一件事情，即它要求服务端必须支持 ServerReflection API，而这一点在 ASP.NET Core 中已经得到支持，对此感兴趣的朋友可以参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/test-tools?view=aspnetcore-6.0#set-up-grpc-reflection">官方文档</a>。当然，这并不是我想表达的重点(我就知道)。重点是什么呢？在使用 ServerReflection API 的过程中，我发现它采用了 gRPC 双向流的方式来进行交互，在过去的日子里，我研究过诸如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events">Server-Sent Events</a> 等等服务器推送的技术，我意识到这是一个非常接近的技术，所以，今天这篇文章，我们来一起聊聊 gRPC 中的流式传输。</p>
<h1 id="从-HTTP-2-说起"><a href="#从-HTTP-2-说起" class="headerlink" title="从 HTTP&#x2F;2 说起"></a>从 HTTP&#x2F;2 说起</h1><p>首先，我想说，流式传输并不是一个新的概念，这一切就好像，即使你从来没有听过流媒体的概念，可这并不妨碍你追剧、刷短视频，隐隐然有种“不识庐山真面目，只缘身在此山中”的感觉。随着网络带宽和硬件水平的不断提升，越来越多的云服务变得像水、电、天然气一样寻常，以此作喻，流式传输，就像你打开水龙头，此时，水就会源源不断地流出来，并且可以做到随用随取。因此，流式传输实际上就是指通过网络传输媒体，例如音频、视频等的技术统称，服务器可以连续地、实时地向客户端发送数据，而客户端不必等所有数据发送完就可以访问这些数据。按照实现方式的不同，流式传输可以分为 <code>实时流式传输</code> 和 <code>顺序流式传输</code> 两种，前者通常指<code>RTP/RTCP</code>，典型的场景是直播；后者通常是指由 Nginx、Apache 等提供支持的顺序下载。</p>
<p><img src="/gRPC-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/HTTP_1.1_vs_HTTP_2.0.png" alt="HTTP/1.1 vs HTTP/2"></p>
<p>如果你对 HTTP&#x2F;2 有一定了解的话，就会知道它最为人所知的特性是多路复用。在 HTTP&#x2F;1.1 的时代，同一个时刻只能对一个请求进行处理或者响应，换句话说，下一个请求必须要等当前请求处理完才能继续进行，与此同时，浏览器为了更快地加载页面资源，对同一个域名下的请求并发数进行了限制，所以，你会注意到一个有趣的现象，部分网站会使用多个 CDN 加速的域名，而这正是为了规避浏览器的这一限制，HTTP&#x2F;1.1 时代，可以称为“半双工模式”。到了 HTTP&#x2F;2 的时代，多路复用的特性让一次同时处理多个请求成为了现实，并且同一个 TCP 通道中的请求不分先后、不会阻塞，是真正的“全双工通信”。一个和本文更贴近的概念是流，HTTP&#x2F;2 中引入了流(Stream) 和 帧(Frame) 的概念，当 TCP 通道建立以后，后续的所有操作都是以流的方式发送的，而二进制帧则是组成流的最小单位，属于协议层上的流式传输。</p>
<h1 id="gRPC-中的流式传输"><a href="#gRPC-中的流式传输" class="headerlink" title="gRPC 中的流式传输"></a>gRPC 中的流式传输</h1><p>OK，现在我们正式开始 gRPC 流式传输的话题。首先，对于一个 gRPC 接口而言，它的起源是 Protobuf 定义。所以，一个最为直观的认识是从 Protobuf 定义入手：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> SimplePing(PingRequest) <span class="keyword">returns</span> (PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ClientStreamPing(stream PingRequest) <span class="keyword">returns</span> (PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ServerStreamPing(PingRequest) <span class="keyword">returns</span> (stream PingReply)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> BothStreamPing(stream PingRequest) <span class="keyword">returns</span> (stream PingReply)</span>;</span><br></pre></td></tr></table></figure>

<p>可以注意到，相比普通的 RPC 方法(UnaryCall)，采用流式传输的 gRPC 接口，主要是多了一个<code>stream</code>关键字。当该关键字修饰参数时，表示这是一个客户端流式的 gRPC 接口；当该参数修饰返回值时，表示这是一个服务器端流式的 gRPC 接口；当该关键字同时修饰参数和返回值时，表示这是一个双向流式的 gRPC 接口。作为类比，双向流式的 gRPC 接口，约等于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket</a>，即客户端、服务器端都可以以流的形式收&#x2F;发数据；服务器端流式的 gRPC 接口，约等于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events">Server-Sent Events</a>，即服务器端以流的形式发数据。同理，客户端流式的 gRPC 接口，即客户端以流的的形式发数据。</p>
<p>我为什么会突然对这个话题产生兴趣呢？个人以为，主要有两个原因：其一，是工作中使用流式传输的机会不多，即使遇到数据量特别大的场合，大家想到的一定是修改 gRPC 数据传输的大小，而不是采用流式传输的做法；其二，是我注意到像 <a target="_blank" rel="noopener" href="https://istio.io/">Istio</a>、<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a>、<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/">Nacos</a> 等项目，内部都是用 gRPC 作为通信协议，当你需要实现一个控制平面的时候，你会发现那里有大量的流式 gRPC 接口等着你去实现。此前，我有一点关乎 gRPC 的想法，譬如动态地为 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">gRPC-JSON Transcoder</a> 生成配置信息、利用 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">ServerReflection</a> 扩展 Swagger 等等，毫无疑问，这一切都需要你去了解 gRPC 的流式传输，一组重要的 API 是 <code>IAsyncStreamReader&lt;T&gt;</code> 和 <code>IAsyncStreamReader&lt;T&gt;</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、调用 ServerReflection 获取 gRPC 服务</span></span><br><span class="line"><span class="keyword">var</span> callResult = _serverReflectionClient.ServerReflectionInfo(</span><br><span class="line">    deadline: deadline, </span><br><span class="line">    cancellationToken: cancellationToken</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义一个 Task 来解析服务端响应的流</span></span><br><span class="line"><span class="keyword">var</span> resolveServiceListTask = Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">await</span> callResult.ResponseStream.MoveNext(cancellationToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> service <span class="keyword">in</span> callResult.ResponseStream.Current.ListServicesResponse.Service)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(service.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、客户端以流的方式写入参数</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> ServerReflectionRequest() &#123; ListServices = <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.WriteAsync(request);</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、客户端以流的方式读出结果</span></span><br><span class="line"><span class="keyword">await</span> resolveServiceListTask;</span><br></pre></td></tr></table></figure>

<p>如图所示，你大概可以理解 gRPC 流式传输的运作过程，<code>RequestStream</code> 实现了 <code>IAsyncStreamWriter&lt;T&gt;</code> 接口，负责流的写入，调用 <code>CompleteAsync()</code> 方法时表示数据已经写完；<code>ResponseStream</code> 实现了 <code>IAsyncStreamReader&lt;T&gt;</code> 接口，负责流的读取，典型的迭代器模式，如果你听说过 C# 8.0 里的异步流(AsyncStream)，就应该会知道，它属于可枚举类(Enumerable)异步变体，我相信，<code>MoveNext()</code> 和 <code>Current</code> 就不需要再做多余的解释啦，哈哈！</p>
<h2 id="客户端流"><a href="#客户端流" class="headerlink" title="客户端流"></a>客户端流</h2><p>对于客户端流式 gRPC 接口而言，客户端负责写入流，服务器端负责读取流，所以，<code>ClientStreamPing()</code> 会生成下面的方法签名，这里是一个简单的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;PingReply&gt; <span class="title">ClientStreamPing</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    IAsyncStreamReader&lt;PingRequest&gt; requestStream, </span></span></span><br><span class="line"><span class="params"><span class="function">    ServerCallContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 IAsyncStreamReader&lt;T&gt; 中读取流并放入队列</span></span><br><span class="line">    <span class="keyword">var</span> requestQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">await</span> requestStream.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        requestQueue.Enqueue(requestStream.Current.RequestId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队列中取出数据并返回</span></span><br><span class="line">    <span class="keyword">if</span> (requestQueue.TryDequeue(<span class="keyword">out</span> <span class="keyword">var</span> requestId))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PingReply() &#123; RequestId = requestId, Message = <span class="string">&quot;OK&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PingReply() &#123; RequestId = <span class="built_in">string</span>.Empty, Message = <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，客户端对应实现如下，继续沿用 <code>IAsyncStreamWriter&lt;T&gt;</code> 的套路：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callResult = heartBeatClient.ClientStreamPing();</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.WriteAsync(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">    RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"><span class="keyword">var</span> reply = <span class="keyword">await</span> callResult.ResponseAsync;</span><br></pre></td></tr></table></figure>

<h2 id="服务器端流"><a href="#服务器端流" class="headerlink" title="服务器端流"></a>服务器端流</h2><p>服务器端的流式 gRPC，意味着服务端会通过 <code>IAsyncStreamWriter&lt;T&gt;</code> 以流的方式写入数据：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task <span class="title">ServerStreamPing</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">     PingRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">     IServerStreamWriter&lt;PingReply&gt; responseStream, </span></span></span><br><span class="line"><span class="params"><span class="function">     ServerCallContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    responseStream.WriteAsync(<span class="keyword">new</span> PingReply() &#123; </span><br><span class="line">        RequestId = request.RequestId, </span><br><span class="line">        Message = <span class="string">&quot;OK&quot;</span> </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，客户端还是像使用普通方法一样调用即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reply = heartBeatClient.ServerStreamPing(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">    RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h2><p>一旦我们熟悉了这个套路，理解双向流就再没有什么难度，客户端和服务器端都用 <code>IAsyncStreamWriter&lt;T&gt;</code> 和  <code>IAsyncStreamWriter&lt;T&gt;</code> 进行读写即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="keyword">var</span> requestQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">await</span> requestStream.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    requestQueue.Enqueue(requestStream.Current.RequestId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写数据</span></span><br><span class="line"><span class="keyword">while</span> (requestQueue.TryDequeue(<span class="keyword">out</span> <span class="keyword">var</span> requestId))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> PingReply() &#123; </span><br><span class="line">        RequestId = requestId, </span><br><span class="line">        Message = <span class="string">&quot;OK&quot;</span> </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，客户端采用类似的做法，这里我们发 10 次心跳看看：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  写数据</span></span><br><span class="line"><span class="keyword">var</span> callResult = heartBeatClient.BothStreamPing();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> callResult.RequestStream.WriteAsync(<span class="keyword">new</span> PingRequest() &#123; </span><br><span class="line">        RequestId = GetCurrentTimeStamp().ToString() </span><br><span class="line">    &#125;);</span><br><span class="line">    Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> callResult.RequestStream.CompleteAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">await</span> callResult.ResponseStream.MoveNext(CancellationToken.None))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> reply4 = callResult.ResponseStream.Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以得到下面的结果：</p>
<p><img src="/gRPC-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/gRPC-Streaming.png" alt="gRPC 双向流效果演示"></p>
<p>个人感觉，这个可以用在那些需要做双向通信的场合，譬如心跳检测、数据看板、日志监控等等，坦白来讲，相对于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events">Server-Sent Events</a> 等等服务器推送技术，gRPC 的双向流优势并不显著，唯一的优势可能是 HTTP&#x2F;2 多路复用带来的性能上的提升。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>最近的状态一直不太好，因为工作中的琐事消耗了大量精力。因而，这篇平淡如白开水般的线性叙事，委实不能被称之为一篇博客，而这大概就是我这段时间的真实写照。作为一名双子座，我的好奇心常常引导着我去关注那些意外的收获，就像 gRPC 里的流式传输，本质上因为我想通过  <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">ServerReflection</a> 为 gRPC 构建一份 Swagger 风格的 API 文档，这个工作目前还有些悬而未决的问题。当然，在这个过程中，大致搞懂了如何去动态调用一个 gRPC 接口，因为 <a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/FluentGrpc.Gateway">FluentGrpc.Gateway</a> 目前依赖 gRPC 生成客户端代码，或者说这种建立在动态链接库上的方案有一定的缺陷。类似地，工作中发现 Envoy 的 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">gRPC-JSON Transcoder</a> 插件，需要手动配置每一个 gRPC 服务，开始琢磨怎么能让这个过程更智能一点，发现需要 Envoy 的 xDS API、了解控制平面，这种感觉就像在挖一口井，能不能看到水我不知道，每一铲子下去都有意外收获，这种探险的感觉非常有趣，唯一的平衡点在于，主动的发现永远都会比被动的接受花更多的时间。这篇流水账主要介绍了 gRPC 里流式传输，即客户端流、服务器端流和双向流，如果你足够有心，不妨回过头看看这篇文章 <a href="/posts/1679688265/">ASP.NET Core gRPC 拦截器的使用技巧分享</a>，我相信你会有不一样的感悟，好了，这就是全部的内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022/2022-02-18-install-docker-on-apple-silicon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/2022-02-18-install-docker-on-apple-silicon/" itemprop="url">为什么在 Apple Silicon 上装 Docker 这么难</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-17T16:00:00+00:00">
                2022-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>最近公司的很多同事都换上了搭载 M1 Pro 或 M1 Max 的新款 MacBook Pro，虽然日常使用的软件如 Chrome、Visual Studio Code 和 Slack 都已经适配得很好了，但面对 Docker 却犯了难。</p>
<p>众所周知，Docker 用到了 Linux 的两项特性：namespaces 和 cgroups 来提供隔离与资源限制，因此无论如何在 macOS 上我们都必须通过一个虚拟机来使用 Docker。</p>
<p>在 2021 年 4 月时，Docker for Mac（Docker Desktop）<a target="_blank" rel="noopener" href="https://www.docker.com/blog/released-docker-desktop-for-mac-apple-silicon/">发布了</a> 对 Apple Silicon 的实验性支持，它会使用 QEMU 运行一个 ARM 架构的 Linux 虚拟机，默认运行 ARM 架构的镜像，但也支持运行 x86 的镜像。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2022/docker-for-mac.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.qemu.org/docs/master/about/index.html">QEMU</a> 是一个开源的虚拟机（Virtualizer）和仿真器（Emulator），所谓仿真器是说 QEMU 可以在没有来自硬件或操作系统的虚拟化支持的情况下，去模拟运行一台计算机，包括模拟与宿主机不同的 CPU 架构，例如在 Apple Silicon 上模拟 x86 架构的计算机。而在有硬件虚拟化支持的情况下，QEMU 也可以使用宿主机的 CPU 来直接运行，减少模拟运行的性能开销，例如使用 macOS 提供的 <code>Hypervisor.Framework</code>。</p>
<p>Docker for Mac 其实就是分别用到了 QEMU 的这两种能力来在 ARM 虚拟机上运行 x86 镜像，和在 Mac 上运行 ARM 虚拟机。</p>
<p>Docker for Mac 确实很好，除了解决新架构带来的问题之外它还对文件系统和网络进行了映射，容器可以像运行在本机上一样访问文件系统或暴露网络端口到本机，几乎感觉不到虚拟机的存在。但 LeanCloud 加入 TapTap 之后已经不是小公司了，按照 Docker Desktop 在 2021 年 8 月推出的 <a target="_blank" rel="noopener" href="https://www.docker.com/blog/updating-product-subscriptions/">新版价格方案</a>，我们每个人需要支付至少 $5 每月的订阅费用。倒不是我们不愿意付这个钱，只是我想要找一找开源的方案。</p>
<p>之前在 Intel Mac 上，我们会用 Vagrant 或 minikube 来创建虚拟机，它们底层会使用 VirtualBox 或 HyperKit 来完成实际的虚拟化。但 VirtualBox 和 HyperKit 都没有支持 Apple Silicon 的计划。实际上目前开源的虚拟化方案中只有 QEMU 对 Apple Silicon 有比较好的支持，QEMU 本身只提供命令行的接口，例如 Docker for Mac 调用 QEMU 时的命令行参数是这样：</p>
<pre><code>/Applications/Docker.app/Contents/MacOS/qemu-system-aarch64 -accel hvf \
-cpu host -machine virt,highmem=off -m 2048 -smp 5 \
-kernel /Applications/Docker.app/Contents/Resources/linuxkit/kernel \
-append linuxkit.unified_cgroup_hierarchy=1 page_poison=1 vsyscall=emulate \
panic=1 nospec_store_bypass_disable noibrs noibpb no_stf_barrier mitigations=off \
vpnkit.connect=tcp+bootstrap+client://192.168.65.2:61473/f1c4db329a4a520d73a79eaa1360de7be7d09948a1ac348b04c8e01f6f6eb2c9 \
console=ttyAMA0 -initrd /Applications/Docker.app/Contents/Resources/linuxkit/initrd.img \
-serial pipe:/var/folders/12/_bbrd4692hv8r9bx_ggw5kp80000gn/T/qemu-console1367481183/fifo \
-drive if=none,file=/Users/ziting/Library/Containers/com.docker.docker/Data/vms/0/data/Docker.raw,format=raw,id=hd0 \
-device virtio-blk-pci,drive=hd0,serial=dummyserial -netdev socket,id=net1,fd=3 -device virtio-net-device,netdev=net1,mac=02:50:00:00:00:01 \
-vga none -nographic -monitor none
</code></pre>
<p>为了实际使用 QEMU 进行开发，我们需要一个使用上更友好的封装，能够自动配置好 Docker 和 Kubernetes（或者至少方便编写像 Vagrantfile 一样的脚本），提供类似 Docker for Mac 的网络映射和文件映射，于是我找到了 Lima。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lima-vm/lima">Lima</a> 自称是 macOS 上的 Linux 子系统（macOS subsystem for Linux），它使用 QEMU 运行了一个 Linux 虚拟机，其中安装有 rootless 模式的 containerd，还通过 SSH 提供了文件映射和自动的端口转发。</p>
<p>但为什么是 containerd 而不是 Docker 呢？随着容器编排平台 Kubernetes 如日中天，社区希望将运行容器这个关键环节进行标准化，让引入 Docker 之外的其他容器运行时更加容易，于是 <a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">推出了 Container Runtime Interface</a> (CRI)。containerd 就是从 Docker 中拆分出的一个 CRI 的实现，相比于 Docker 本体更加精简，现在也交由社区维护。</p>
<p>因此如 Lima 这样新的的开源软件会更偏好选择 containerd 来运行容器，因为组件更加精简会有更好的性能，也不容易受到 Docker 产品层面变化的影响。nerdctl 是与 containerd 配套的命令行客户端（<code>nerd</code> 是 <code>containerd</code> 的末尾 4 个字母），用法与 docker 或 docker-compose 相似（但并不完全兼容）。</p>
<p>所谓 <a target="_blank" rel="noopener" href="https://rootlesscontaine.rs/">rootless</a> 则是指通过替换一些组件，让容器运行时（containerd）和容器都运行在非 root 用户下，每个用户都有自己的 containerd，这样绝大部分操作都不需要切换到 root 来进行，也可以减少安全漏洞的攻击面。</p>
<p>但我们希望能在本地运行完整的 rootful 模式的 dockerd 和 Kubernetes 来尽可能地模拟真实的线上环境，好在 Lima 提供了丰富的 <a target="_blank" rel="noopener" href="https://github.com/lima-vm/lima/blob/master/pkg/limayaml/default.yaml">自定义能力</a>，我基于社区中的一些脚本（<a target="_blank" rel="noopener" href="https://github.com/lima-vm/lima/blob/master/examples/docker.yaml">docker.yaml</a> 和 <a target="_blank" rel="noopener" href="https://github.com/afbjorklund/lima/blob/minikube/examples/minikube.yaml">minikube.yaml</a>）实现了我们的需求，而且这些自定义的逻辑都被以脚本的形式写到了 yaml 描述文件中，只需一条命令就可以创建出相同的虚拟机。</p>
<pre><code>~ ❯ limactl start docker.yaml
? Creating an instance &quot;docker&quot; Proceed with the default configuration
INFO[0005] Attempting to download the image from &quot;https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-arm64.img&quot;
INFO[0005] Using cache &quot;/Users/ziting/Library/Caches/lima/download/by-url-sha256/ae20df823d41d1dd300f8866889804ab25fb8689c1a68da6b13dd60a8c5c9e35/data&quot;
INFO[0006] [hostagent] Starting QEMU (hint: to watch the boot progress, see &quot;/Users/ziting/.lima/docker/serial.log&quot;)
INFO[0006] SSH Local Port: 55942
INFO[0006] [hostagent] Waiting for the essential requirement 1 of 5: &quot;ssh&quot;
INFO[0039] [hostagent] Waiting for the essential requirement 2 of 5: &quot;user session is ready for ssh&quot;
INFO[0039] [hostagent] Waiting for the essential requirement 3 of 5: &quot;sshfs binary to be installed&quot;
INFO[0048] [hostagent] Waiting for the essential requirement 4 of 5: &quot;/etc/fuse.conf to contain \&quot;user_allow_other\&quot;&quot;
INFO[0051] [hostagent] Waiting for the essential requirement 5 of 5: &quot;the guest agent to be running&quot;
INFO[0051] [hostagent] Mounting &quot;/Users/ziting&quot;
INFO[0051] [hostagent] Mounting &quot;/tmp/lima&quot;
INFO[0052] [hostagent] Forwarding &quot;/run/lima-guestagent.sock&quot; (guest) to &quot;/Users/ziting/.lima/docker/ga.sock&quot; (host)
INFO[0092] [hostagent] Waiting for the optional requirement 1 of 1: &quot;user probe 1/1&quot;
INFO[0154] [hostagent] Forwarding TCP from [::]:2376 to 127.0.0.1:2376
INFO[0304] [hostagent] Forwarding TCP from [::]:8443 to 127.0.0.1:8443
INFO[0332] [hostagent] Waiting for the final requirement 1 of 1: &quot;boot scripts must have finished&quot;
INFO[0351] READY. Run `limactl shell docker` to open the shell.
INFO[0351] To run `docker` on the host (assumes docker-cli is installed):
INFO[0351] $ export DOCKER_HOST=tcp://127.0.0.1:2376
INFO[0351] To run `kubectl` on the host (assumes kubernetes-cli is installed):
INFO[0351] $ mkdir -p .kube &amp;&amp; limactl cp minikube:.kube/config .kube/config
</code></pre>
<p>我还发现了另外一个基于 Lima 的封装 —— <a target="_blank" rel="noopener" href="https://github.com/abiosoft/colima">Colima</a>，默认提供 rootful 的 dockerd 和 Kubernetes，但 Colima 并没有对外暴露 Lima 强大的自定义能力，因此我们没有使用，但对于没那么多要求的开发者来说，也是一个更易用的选择。</p>
<p>在默认的情况下，Lima 中的 Docker 在 Apple Silicon 上只能运行 ARM 架构的镜像，但就像前面提到的那样，我们可以使用 QEMU 的模拟运行的能力来运行其他架构（如 x86）的容器。<code>qemu-user-static</code> 是一个进程级别的模拟器，可以像一个解释器一样运行其他架构的可执行文件，我们可以利用 Linux 的一项 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binfmt_misc">Binfmt_misc</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Binfmt_misc">中文版</a>）的特性让 Linux 遇到特定架构的可执行文件时自动调用 <code>qemu-user-static</code>，这种能力同样适用于容器中的可执行文件。</p>
<p>社区中也有 <a target="_blank" rel="noopener" href="https://dbhi.github.io/qus/">qus</a> 这样的项目，对这些能力进行了封装，只需执行一行 <code>docker run --rm --privileged aptman/qus -s -- -p x86_64</code> 就可以让你的 ARM 虚拟机魔法般地支持运行 x86 的镜像。</p>
<pre><code>/usr/bin/containerd-shim-runc-v2
\_ /qus/bin/qemu-x86_64-static /usr/sbin/nginx -g daemon off;
    \_ /qus/bin/qemu-x86_64-static /usr/sbin/nginx -g daemon off;
    \_ /qus/bin/qemu-x86_64-static /usr/sbin/nginx -g daemon off;
    \_ /qus/bin/qemu-x86_64-static /usr/sbin/nginx -g daemon off;
    \_ /qus/bin/qemu-x86_64-static /usr/sbin/nginx -g daemon off;
</code></pre>
<blockquote>
<p>使用 qus 运行 x86 镜像的进程树如上，所有进程（包括创建出的子进程）都自动通过 QEMU 模拟运行。</p>
</blockquote>
<p>回到题目中的问题，因为 Docker 依赖于 Linux 内核的特性，所以在 Mac 上必须通过虚拟机来运行；Apple Silicon 作为新的架构，虚拟机的选择比较受限，因为有些镜像并不提供 ARM 架构的镜像，所以有时还有模拟运行 x86 镜像的需求；Docker Desktop 作为商业产品，有足够的精力来去解决这些「脏活累活」，但它在这个时间点选择不再允许所有人免费使用；开源社区中新的项目都希望去 Docker 化，用 containerd 取代 dockerd，但这又带来了使用习惯的变化并且可能与线上环境不一致。因为这些原因，目前在 Apple Silicon 上安装 Docker 还是需要花一些时间去了解背景知识的，但好在依然有这些优秀的开源项目可供选择。</p>
<p>虽然 <a target="_blank" rel="noopener" href="https://developer.taptap.com/product-intro/cloud-engine">云引擎</a> 也是基于 Docker 等容器技术构建的，但云引擎力图为用户提供开箱即用的使用体验而不必自己配置容器环境、编写构建脚本、收集日志和统计数据。如果想得到容器化带来的平滑部署、快速回滚、自动扩容等好处但又不想花时间配置，不如来试试云引擎。</p>
<p>其他参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/">https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-16-designtools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-16-designtools/" itemprop="url">打工人/新媒体小编/设计师常用工具整理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-16T08:26:00+00:00">
                2022-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/d6VxS3u0T5sCkU3jlCaCAQ">效率工具指南</a>」<br>作者&#x2F;彭宏豪      </p>
<p>Hello 各位好，这里是效率工具指南。<br>我是小豪。  </p>
<p>古话说「术业有专攻」，说的是每个人专攻一个方向就好了，但在如今啥都「卷」的当下，一个人不会多一点技能，好像就混不下去了。  </p>
<p>具体到<strong>工作中做一张图</strong>，以前是设计师才要干的活，现在好像是个岗位就会有要求：  </p>
<blockquote>
<p>熟练掌握 PS 的使用（事实上我只精通 PS 的安装与卸载）   </p>
</blockquote>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449984297049.jpg"></p>
<p>回到<strong>如何做一张图</strong>的问题上，今天的这篇文章将从以下几方面做出一些回答：   </p>
<ul>
<li>获取灵感</li>
<li>设计作品 &amp; 素材管理工具 </li>
<li>素材下载<ul>
<li>图标 icon</li>
<li>字体</li>
</ul>
</li>
</ul>
<h2 id="获取灵感"><a href="#获取灵感" class="headerlink" title="获取灵感"></a>获取灵感</h2><p>做一张图的工作流，和新媒体小编存在着共性：都需要寻找灵感，一个是寻找设计灵感，一个是寻找文章选题及切入角度。  </p>
<p>对于设计灵感，国内外有很多设计相关的网站：  </p>
<ul>
<li>Behance</li>
<li>Dribbble  </li>
<li>Pinterest  </li>
<li>站酷  </li>
<li>花瓣</li>
</ul>
<p>这些网站对许多设计师来说，应该非常熟悉，就不过多介绍了。</p>
<h3 id="浏览器插件-Muzli"><a href="#浏览器插件-Muzli" class="headerlink" title="浏览器插件 Muzli"></a>浏览器插件 Muzli</h3><p>下面介绍一个聚合了多个设计网站内容的浏览器插件 Muzli： </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449917315769.jpg"></p>
<p>安装插件后，它会替换掉浏览器默认的标签页，在你未进行搜索操作时，页面中央会显示来自不同设计网站的作品。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449899776063.jpg"></p>
<p>点击左下角的编辑按钮，打开左侧的编辑面板，可自由选择要查看的设计网站。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449901958964.jpg"></p>
<p>将鼠标指针置于网站图标左侧，指针会变成一个小抓手，长按左键拖拽可改变网站上下的顺序，你可以将优先级更高的网站排在列表的前排。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449911927235.jpg"></p>
<p>初次使用插件 Muzli，可以选择你想在标签页看到的内容，不局限于设计作品，还可以浏览：  </p>
<ul>
<li>科技 &amp; 代码   </li>
<li>新闻 &amp; 商业   </li>
<li>文化</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449849538168.jpg"></p>
<p>Muzli 官网：<br><a target="_blank" rel="noopener" href="https://muz.li/">https://muz.li/</a>   </p>
<h2 id="设计作品-素材管理工具"><a href="#设计作品-素材管理工具" class="headerlink" title="设计作品 &amp; 素材管理工具"></a>设计作品 &amp; 素材管理工具</h2><p>看完别人的设计作品，为了方便后续查找和参考，最好还是要将它们保存起来。  </p>
<p>设计作品 &amp; 素材管理工具，主要有两类，一类是采集到在线网站的画板，例如花瓣、Pinterest，一类是采集到本地的管理软件。   </p>
<p>花瓣采集插件：<a target="_blank" rel="noopener" href="https://faq.huaban.com/faq/huaban-plugin-install/">https://faq.huaban.com/faq/huaban-plugin-install/</a>   </p>
<p>Pinterest 采集插件：<a target="_blank" rel="noopener" href="https://help.pinterest.com/zh-hans/article/save-pins-with-the-pinterest-browser-button">https://help.pinterest.com/zh-hans/article/save-pins-with-the-pinterest-browser-button</a>    </p>
<p>本地的设计作品 &amp; 素材管理工具：  </p>
<ul>
<li>Eagle（macOS + Windows）</li>
<li>Picsee（macOS）👉👉 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649919416&idx=1&sn=a27dc29eda0beb241e45217292987758&chksm=83a88b95b4df028359fd8cf6775093d207c9570f5fe42452f1796b9e54e9ad1314240fa57c14&token=879990072&lang=zh_CN#rd">戳这里了解 Picsee</a></li>
</ul>
<h2 id="图标-Icon"><a href="#图标-Icon" class="headerlink" title="图标 Icon"></a>图标 Icon</h2><p>有时在制作图片的时候，需要用到一些 <strong>App 图标</strong>作为素材。  </p>
<p>例如我之前做过的一个剪映加字幕的视频封面，需要用到剪映 App 的图标。   </p>
<p>直接从搜索引擎找 App 的图标，尤其是国内产品的图标，并不太好找，而且找到的图标清晰度一般都不高。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449931282248.jpg"></p>
<p>这里介绍两个获取 App 图标的实用技巧：   </p>
<h3 id="在线网站-HQ-Icon"><a href="#在线网站-HQ-Icon" class="headerlink" title="在线网站 HQ Icon"></a>在线网站 HQ Icon</h3><p>输入 App 名称，网站就会返回对应的应用图标，且提供了两种图标分辨率——512px 和 1024px，用起来非常方便。  </p>
<p>HQ Icon 网址：<br><a target="_blank" rel="noopener" href="https://icon.yukonga.top/">https://icon.yukonga.top/</a>      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449936377283.jpg"></p>
<h3 id="快捷指令-App-获取应用图标"><a href="#快捷指令-App-获取应用图标" class="headerlink" title="快捷指令 App 获取应用图标"></a>快捷指令 App 获取应用图标</h3><p>前面获取图标的方法适用于所有用户，下面的这种方法，只对拥有 iPhone 或 iPad 设备的用户可用。  </p>
<p>之前发布过一篇介绍 iPhone 上的快捷指令 App 的文章，介绍过一个获取 App 图标的快捷指令「应用图标抓取」：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449944232564.jpg"></p>
<p>错过或忘记的朋友，可以戳下面的文章：  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649911233&idx=1&sn=ae14d222f9847022b35923abe005c872&chksm=83a86becb4dfe2fac78fc6060ec5d5b0e6d863453adc1cd9939a5f32bf53785a04d8b1717cd0&token=879990072&lang=zh_CN#rd">手机自带的多功能百宝箱，没人用真的太可惜了。</a>   </p>
<h3 id="其他图标-Icon-网站"><a href="#其他图标-Icon-网站" class="headerlink" title="其他图标 Icon 网站"></a>其他图标 Icon 网站</h3><p>前面介绍的两种获取 App 图标的方法，得到的图片都可以称为<strong>位图</strong>，位图的优点在于色彩丰富，细节清晰，但它也存在一个弊端：<strong>放大后容易失真</strong>。</p>
<p>与位图相对的图像格式，被称为<strong>矢量图</strong>，它是一种经过多倍放大后，仍能保持原有清晰度的图形格式，广泛应用于 logo 或插画设计中，常见的矢量格式有 svg、eps 和 ai。  </p>
<p>前几天整理了 13 个下载图标的网站（<strong>主要为矢量图标</strong>），制作成了下面的思维导图。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/tu-biao-wang-zhan-shi-liang-tu-biao.png" alt="图标网站 矢量图标"></p>
<p>获取上面的思维导图链接 🔗，可点击下方的公众号卡片「效率工具指南」，在后台回复【图标】即可。  </p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="字体下载"><a href="#字体下载" class="headerlink" title="字体下载"></a>字体下载</h3><p>优先推荐各位使用免费可商用的字体，不管是自己的个人项目，还是公司内做的事情，以免之后引来不必要的纠纷。   </p>
<p>免费可商用的字体：  </p>
<ul>
<li>思源黑体&#x2F;思源宋体     </li>
<li>阿里巴巴普惠体（推荐）</li>
<li>优设标题黑体   </li>
<li>江西拙楷</li>
</ul>
<p>下载免费字体，可以去下图的网站「<strong>猫啃网</strong>」，网站提供了<strong>单个字体的下载链接</strong>，没有把所有免费字体打包在一起，节约下载时间。    </p>
<p>更重要的是，下载字体没套路，不需要关注公众号，不需要转发文章在后台返截图。     </p>
<p>猫啃网：<br><a target="_blank" rel="noopener" href="https://www.maoken.com/all-fonts">https://www.maoken.com/all-fonts</a>   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449817535106.jpg"></p>
<h3 id="识别字体"><a href="#识别字体" class="headerlink" title="识别字体"></a>识别字体</h3><p>除了下载字体，有时我们在海报上看到一个好看的字体，想知道字体的名称，但又联系不上设计师，该怎么办呢？  </p>
<p>介绍两款识别字体的工具，用起来非常简单：将想要识别的字体截图保存下来，再上传到下面的网站，一般就能找到字体的名称。   </p>
<p>求字体网：识别中文字体<br><a target="_blank" rel="noopener" href="https://www.qiuziti.com/">https://www.qiuziti.com/</a></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449827148956.jpg"></p>
<p>WhatTheFont：识别英文字体<br><a target="_blank" rel="noopener" href="https://www.myfonts.com/WhatTheFont/">https://www.myfonts.com/WhatTheFont/</a></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449826661344.jpg"></p>
<h3 id="字体版权查询"><a href="#字体版权查询" class="headerlink" title="字体版权查询"></a>字体版权查询</h3><p>不确定想使用的字体是否可商用，可以使用下面的字体版权查询工具，输入字体名称，看网站返回的结果是否为「免费可商用」？   </p>
<p>360 查字体：<br><a target="_blank" rel="noopener" href="https://fonts.safe.360.cn/">https://fonts.safe.360.cn/</a>      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449828927180.jpg"></p>
<p>如果这个网站的数据库不包含你想查询的字体，最稳妥的办法，还是去到字体的官网查看相关文档，或者通过社交平台私信字体的作者。   </p>
<p>还有一点需要说明的是，有些字体网站虽然把某款字体归为「免费可商用」，但在实际使用还是存在一些坑的：  </p>
<p>以「锐字潮牌真言体」为例，它确实可以免费商用，但在未经书面授权的情况下，字体不能用于软件、游戏、数字出版物、拍照、视频剪辑、图片编辑等场景中。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/16449838473752.jpg"></p>
<p>关于免费字体隐藏的一些坑，还可以参考 B 站 Up 主 @doyoudo 出的一期视频：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/16/img1827.PNG" alt="IMG_1827"></p>
<p>今天的分享暂时就到这里，下次有时间且了解了更多东西之后，再看看能不能出第二篇吧。    </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-14-notion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-14-notion/" itemprop="url">将 Notion 打造成 RSS 阅读器｜Notion 新鲜玩法 + 2</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-14T10:14:00+00:00">
                2022-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于「效率工具指南」<br>文&#x2F;彭宏豪</p>
<p>Hello 各位好，这里是效率工具指南。<br>我是小豪。  </p>
<p>距离上一次分享 Notion 相关的内容，已经过去两个多月了。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448284903084.jpg"></p>
<p>老实说现在对 Notion 的关注大不如前了，没有及时去跟进 Notion 更新了哪些功能。  </p>
<p>但 Notion 依旧还是有不少吸引人的地方，譬如今天要介绍的这两个 Notion 玩法（案例）：  </p>
<ul>
<li>将 Twitter 动态保存到 Notion   </li>
<li>将 Notion 变成 RSS 阅读器</li>
</ul>
<h2 id="将-Twitter-动态保存到-Notion"><a href="#将-Twitter-动态保存到-Notion" class="headerlink" title="将 Twitter 动态保存到 Notion"></a>将 Twitter 动态保存到 Notion</h2><p>说这个话题之前，还要提另外一件事情：  </p>
<p>用过微博的人，可能都有这么一种经历，在一条精彩微博的评论区，会看见许多人都在评论「@我的印象笔记」。  </p>
<p>不懂这种行为含义的人，第一次见到评论区整齐划一地都在评论相同的内容，搞不好还以为他们在进行某种行为艺术。   </p>
<p>实际上评论 @我的印象笔记，是评论的用户希望把微博内容保存到自己的笔记账户中，可能是收藏就等于看了，或者后期在查找内容的时候，方便随时调出。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448294930761.jpg"></p>
<p>如果你和我一样，已经弃用了印象笔记，换到了 Notion，但还是有「剪藏」网络内容的需求，可以使用之前介绍过的插件：  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649918366&idx=1&sn=5c1c25ce464c3d84b02a9833c406c3b4&chksm=83a88fb3b4df06a5e9b48059e82b4f785015427abd337b66c0c7a72315e9906da44dfff329da&token=2093409823&lang=zh_CN#rd">Notion搭配这2个剪藏插件，才是真正All in one</a>     </p>
<p>上文介绍的两款插件，对剪藏长文章来说，非常方便，但如果是剪藏社交媒体上的内容，例如 Twitter，就有点大材小用了。  </p>
<p>在 Twitter 上有一位开发者 @Abdulhade Ahmad 开发了将 Twitter 动态保存到 Notion 的机器人 @SaveToNotion，它的用法和 @我的印象笔记 非常相似：  </p>
<p>在想保存的 Twitter 动态下方，评论 @SaveToNotion，并带上标签 #tweet 或者 #thread，程序就会自动将 Twitter 动态保存到你的 Notion 中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448307156606.jpg"></p>
<p>配置方法：  </p>
<p>关注推特账号 @SaveToNotion</p>
<p>在浏览器打开 Notion 页面 <a target="_blank" rel="noopener" href="https://t.co/lqgK7KQ9BA">https://t.co/lqgK7KQ9BA</a> ，将页面复制(Duplicate)到自己的 Notion 账户中</p>
<p>向推特账号 SaveToNotion 私信 <code>/connect</code> ，机器人会返回一个链接，点击链接进行授权   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448308818074.jpg"></p>
<p>授权时选择我们刚复制的 Notion 页面「Tweets」  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448309198519.jpg"></p>
<p>完成授权后，推特账号 SavetoNotion 会给我们发送一条「连接成功」的消息   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448310121365.jpg"></p>
<p>完成上面操作后，你就可以将你喜欢的 Twitter 动态保存到 Notion 中啦。  </p>
<p>Twitter 动态保存到 Notion 的效果如下，会带有动态内容、作者名称、剪藏的时间、推特动态原始链接。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448312639194.jpg"></p>
<h2 id="将-Notion-变成-RSS-阅读器"><a href="#将-Notion-变成-RSS-阅读器" class="headerlink" title="将 Notion 变成 RSS 阅读器"></a>将 Notion 变成 RSS 阅读器</h2><p>有些朋友可能对 RSS 并不熟悉，了解 RSS 可以参考我之前写过的一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904885&idx=1&sn=4cf0407adfa94e0e855ca3a5bc3bda20&chksm=83a852d8b4dfdbce023212961dfb446fc4fd8a8e595ea762ad8711602dd9c551811cdff19ca6&token=2093409823&lang=zh_CN#rd">算法当道，我们只能被动接收算法投喂的内容吗? | RSS</a>    </p>
<p>简言之，通过 <strong>RSS 订阅链接 + RSS 阅读器</strong>，我们可以很方便地在一个软件中获取来自多个作者、多个博客甚至是多个平台的内容，减少我们在多个应用或平台间来回切换的时间。   </p>
<p>将 Notion 变成 RSS 阅读器，需要用到一个项目 <strong>NotionFeed</strong>。  </p>
<p>NotionFeed 官网：<br><a target="_blank" rel="noopener" href="https://notion-feed.com/">https://notion-feed.com/</a>   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448320315656.jpg"></p>
<p>NotionFeed 提供的 Notion 模板中有两个数据库：  </p>
<ul>
<li>订阅源管理：添加或管理 RSS 订阅链接   </li>
<li>文章：查看 RSS 订阅链接获取到的内容</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448321494245.jpg"></p>
<p>目前我在订阅源管理中添加了 4 个 RSS 链接，每当它们更新了内容，就可以在「文章」数据库查看更新的内容，如下图所示。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448325609065.jpg"></p>
<p>我将自己的 Hexo 博客的 RSS 订阅链接(<a target="_blank" rel="noopener" href="https://www.penghh.fun/atom.xml)%E4%B9%9F%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%BA%86%E5%85%B6%E4%B8%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%AF%8F%E5%BD%93%E6%88%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%86%85%E5%AE%B9%E4%B9%9F%E4%BC%9A%E8%A2%AB%E6%8A%93%E5%8F%96%E5%88%B0">https://www.penghh.fun/atom.xml)也添加到了其中，这样每当我更新博客，博客的内容也会被抓取到</a> Notion 的数据库中，相当于在 Notion 也做了多一重的备份。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448327065723.jpg"></p>
<p>NotionFeed 的使用方法，可以参考项目作者写的配置教程，配置起来不会有难度，这里就不展开了。   </p>
<p>初次在 Notion 中添加 RSS 订阅链接，要多等一点时间，才能看到程序抓取到足够多的内容。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/14/16448321041786.jpg"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><a class="extend next" rel="next" href="/page/11/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
