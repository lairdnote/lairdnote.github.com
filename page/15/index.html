<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/15/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/15/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" itemprop="url">ASP.NET Core 搭载 Envoy 实现微服务的负载均衡</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-05T14:49:47+00:00">
                2021-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>如果说，我们一定要找出一个词来形容这纷繁复杂的世界，我希望它会是熵。有人说，熵增定律是宇宙中最绝望的定律，<strong>所谓熵，即是指事物混乱或者无序的程度。在一个孤立系统下，熵是不断在增加的，当熵达到最大值时，系统就会出现严重混乱，直至最终走向死亡</strong>。从某种意义上来讲，它揭示了事物结构衰退的必然性，甚至于我们的人生，本来就是一场对抗熵增的旅程。熵增的不可逆性，正如时光无法倒流一般，古人说，“覆水难收”正是这个道理。同样地，当我们开始讨论微服务的划分&#x2F;编写&#x2F;治理的时候，当我们使用服务网格来定义微服务架构的时候……我们是否有意或者无意的增加了系统中的熵呢？<strong>一个孤立的系统尚且会因为熵增而最终走向死亡，更何况是相互影响和制约的复杂系统呢？</strong>现代互联网企业都在追求4个9(即99.99%)的高可用，这意味着年平均停机时长只有52.56分钟。在此之前。我们介绍过重试和熔断这两种故障转移的策略，而今天我们来介绍一种更朴素的策略：负载均衡。</p>
<h1 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h1><blockquote>
<p>负载均衡，即<code>Load Banlancing</code>，是一种计算机技术，用来在多个计算机(计算机集群)、网络连接、CPU、磁盘驱动器或其它资源中分配负载，以达到<strong>最优化资源使用、最大化吞吐率、最小化响应时间、避免过载的目的</strong>。</p>
</blockquote>
<p>我们可以注意到，在这个定义中，使用负载均衡技术的直接原因是<strong>避免过载</strong>，而根本原因则是为了<strong>优化资源使用</strong>，确保<strong>最大吞吐量</strong>、<strong>最小响应时间</strong>。所以，这本质上是一个局部最优解的问题，而具体的手段就是”多个”。有人说，技术世界不过是真实世界的一个镜像，联系生活中实际的案例，我们发现负载均衡比比皆是。譬如车站在面对春运高峰时增加售票窗口，银行通过多个业务窗口来为客户办理业务……等等。这样做的好处显而易见，可以大幅度地减少排队时间，增加”窗口”这个行为，在技术领域我们将其称为：<strong>水平扩展</strong>，因为有多个”窗口”，发生单点故障的概率就会大大降低，而这正是现在软件追求的三”高”：高性能、高可用、高并发。</p>
<p><img src="https://i.loli.net/2021/07/05/jymw8KCeEgROcZN.png" alt="银行柜员窗口示意图"></p>
<p>每次坐地铁经过小寨，时常听到地铁工作人员举着喇叭引导人们往不同的出口方向走动。此时，工作人员就是一个负载均衡器，它要做的就是避免某一个出口人流量过载。<strong>从熵的角度来看，人流量过载，意味着无序&#x2F;混乱状态加剧，现代社会通过道德和法律来对抗熵增，人类个体通过自律来对抗熵增。</strong>有时候，我会忍不住去想，大人与小孩儿愈发内卷的恶性竞争，除了给这个世界带来更多的熵以外，还能带来什么？<strong>如果参考社会达尔文主义的理论，在这个弱肉强食的世界里，增加熵是人为的选择，而同样的，你亦可以选择”躺平”。</strong></p>
<p><img src="https://i.loli.net/2021/07/05/hIAUw8JHkjWnxm6.png" alt="负载均衡器示意图"></p>
<p>OK，将思绪拉回到负载均衡，它所做的事情，本质上就是控制信息或者说流量流动的方向。一个网站，以集群的方式对外提供服务，你只需要输入一个域名，它就可以把请求分发到不同的机器上面去，而这就是所谓的负载均衡。目前，负载均衡器从种类上可以分为：基于<code>DNS</code>、基于<code>MAC</code>地址(二层)、基于<code>IP</code>(三层)、基于<code>IP</code>和<code>Port</code>(四层)、基于<code>HTTP</code>(七层)。</p>
<p><img src="https://i.loli.net/2021/07/04/giY1R8PVZB9JdWQ.jpg" alt="OSI七层模型与TCP/IP五层模型"></p>
<p>譬如，博主曾经参与过伊利的项目，它们使用的就是一个四层的负载均衡器：F5。而像更常见<code>Nginx</code>、<code>HAProxy</code>，基本都是四层和七层的负载均衡器，而<code>Envoy</code>就厉害了，它可以同时支持三&#x2F;四&#x2F;七层。负载均衡器需要配合负载均衡算法来使用，典型的算法有：<strong>轮询法</strong>、<strong>随机法</strong>、<strong>哈希法</strong>、<strong>最小连接数法</strong>等等，而这些算法都可以结合加权算法引出新的变式，这里就不再一一列举啦。</p>
<h1 id="Envoy中的负载均衡"><a href="#Envoy中的负载均衡" class="headerlink" title="Envoy中的负载均衡"></a>Envoy中的负载均衡</h1><p>通过上一篇博客，我们已经了解到，<code>Envoy</code>中一个<code>HTTP</code>请求的走向，大致会经历：客户端、侦听器(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>)、终结点(<strong>Endpoints</strong>)、服务(<strong>ervices</strong>)这样几个阶段。其中，一个集群可以有多个终结点(<strong>Endpoints</strong>)。所以，这里天然地就存在着负载均衡的设计。因为，负载均衡本质上就是告诉集群，它应该选择哪一个终结点(<strong>Endpoints</strong>)来提供服务。而之所以我们需要负载均衡，一个核心的原因，其实是因为我们选择了分布式。</p>
<p><img src="https://i.loli.net/2021/07/02/k2DhXMudnibrzgt.png" alt="Envoy架构图：负载均衡器连接集群和服务"></p>
<p>如果类比<code>RabbitMQ</code>、<code>Kafka</code>和<code>Redis</code>，你就会发现，这些产品中或多或少地都会涉及到主(<strong>Leader</strong>)、从(<strong>Follower</strong>)以及推举Leader的实现，我个人更愿意将其看作是更广义的负载均衡。最直观的，它可以分担流量，简称<strong>分流</strong>，不至于让某一台服务器满负荷做运行。其次，它可以作为故障转移的一种方案，<strong>人生在世，多一个B计划，就多一种选择。同样地，多一台服务器，就多一分底气</strong>。最后，它可以指导某一个产品或者功能的推广，通过给服务器设置不同的权重，在必要的时候，将流量局部地导入某一个环境，腾讯和阿里这样的大厂，经常利用这种方式来做<strong>灰度测试</strong>。</p>
<p><code>Envoy</code>中支持常用的负载均衡算法，譬如：ROUND_ROBIN(轮询)、LEAST_REQUEST(最少请求)、RING_HASH(哈希环)、RANDOM(随机)、MAGLEV(磁悬浮)、CLUSTER_PROVIDED等等。因为一个集群下可以有多个终结点，所以，在<code>Envoy</code>中配置负载均衡，本质上就是在集群下面增加终结点，而每个终结点则会对应一个服务，特殊的点在于，这些服务可能是通过同一个<code>Dockerfile</code>或者<code>Docker</code>镜像来构建的。所以，一旦理解了这一点，<code>Envoy</code>的负载均衡就再没有什么神秘的地方。例如，下面的代码片段展示了，如何为<code>WeatherService</code>这个集群应用负载均衡：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="comment"># Weather Service</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">  <span class="comment"># ROUND_ROBIN(轮询）</span></span><br><span class="line">  <span class="comment"># LEAST_REQUEST(最少请求)</span></span><br><span class="line">  <span class="comment"># RING_HASH(哈希环)</span></span><br><span class="line">  <span class="comment"># RANDOM(随机)</span></span><br><span class="line">  <span class="comment"># MAGLEV(磁悬浮)</span></span><br><span class="line">  <span class="comment"># CLUSTER_PROVIDED</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>是不是觉得特别简单？我想说，也许是<code>Envoy</code>更符合人的直观感受一些，理解起来本身没有太大的心智负担。最近看到一个缓存设计，居然还要依赖<code>Kafka</code>，使用者为了使用缓存这个功能，就必须先实现三个丑陋的委托，这就是所谓的心智负担，违背人类的直觉，使用缓存为什么要了解<code>Kafka</code>？到这里，你大概就能了解利用<code>Envoy</code>实现负载均衡的思路，首先是用同一个<code>Dockerfile</code>或者<code>Docker</code>镜像启动多个不同容器(服务)，然后将指定集群下面的终结点指定不同的服务，再告诉集群要用哪一种负载均衡策略即可。</p>
<h1 id="邂逅-ASP-NET-Core"><a href="#邂逅-ASP-NET-Core" class="headerlink" title="邂逅 ASP.NET Core"></a>邂逅 ASP.NET Core</h1><p>OK，说了这么多，这里我们还是用<code>ASP.NET Core</code>写一个例子。可以预见到的是，我们需要一个<code>Envoy</code>网关，一个<code>ASP.NET Core</code>的服务。这里，我们还是用<code>Docker-Compose</code>来编排这些服务，下面是对应的<code>docker-compose.yaml</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">weatherservice1:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line">  <span class="attr">weatherservice2:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8084:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>而对于<code>Envoy</code>来说，主要的工作是维护集群下的终结点信息这块儿。其实，这段配置在本文的上一节就出现过啦，你有多少个服务实例，就配置多少个终结点，请求落在哪一个实例上，就交给<code>Envoy</code>来决定好啦。故而，这里我们不再做更多的解释：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/api/w&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/Weather</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">weatherservice</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># Weather Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/tmp/admin_access.log</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span> &#123; <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>, <span class="attr">port_value:</span> <span class="number">9091</span> &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>docker compose up</code>启动容器，我们可以注意到熟悉的<code>ASP.NET Core</code>的身影，这意味着，我们需要的服务都成功地跑起来了。简单调用下API看看，果然，可以正确地返回结果呢(逃……果然，我是一个喜新厌旧的人，自打用了<code>Encoy</code>以后，再不想用<code>Nginx</code>来做类似的事情(逃……</p>
<p><img src="https://i.loli.net/2021/07/04/lBIAyPZnSxiD3M8.png" alt="通过管理接口查看集群的请求情况"></p>
<p>好了，如何验证我们选择的负载均衡策略呢？这是一个问题。不知道大家还记不记得<code>Envoy</code>的管理接口，它里面可以统计请求的次数，所以，我们只要看看两个服务各自请求了多少次里有好啦！这里以<code>RANDON</code>这个策略为例：</p>
<p><img src="https://i.loli.net/2021/07/04/1U8RgZxaVcOFiXK.png" alt="两个实例拥有不同的请求次数"></p>
<p>可以注意到，两个的请求次数果然是随机的呢？而如果我们换成是<code>ROUND_ROBIN</code>，你就会发现这两个数值一前一后相互追赶。选择哪一种负载均衡策略，这个按大家实际的场景去决定就好。我倒觉得，按最少请求数的策略会好一点。虽然计算机永远不知疲倦地接收人们的指令，可考虑能者多劳这种人类世界里的策略，本身充满道德绑架的意味，使用负载均衡，站在计算机的角度来看，这是避免计算机内卷的一种方案。所以啊，老板们，请不要逮着一个老实人就拼了命的剥削，多学学负载均衡算法，<strong>卓别林心目中的摩登时代，我一点都不期待，技术世界总告诉我们要严谨、冷静，可充满人情味的世界，同样值得你去热爱啊。</strong></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文结合物理学中的熵增定律引出了负载均衡这个话题，而<strong>负载均衡的本质，就是在多个计算机(计算机集群)、网络连接、CPU、磁盘驱动器或其它资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、避免过载的目的。</strong>对于这一点，我们可以结合现实生活中的”窗口”排队来理解。<strong>负载均衡可以和水平扩展完美结合，通过降低单点的故障率，来达到提升整个系统可用性的目的</strong>。接下来，我们介绍了常见的负载均衡器分类及其算法，<code>Envoy</code>中的负载均衡配置，并结合<code>ASP.NET Core</code>编写了一个实际的案例。好了，以上就是这篇博客的全部内容啦，如果大家对于熵增定律或者负载均衡器有任何的看法，欢迎大家在评论区留言，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-7-5-meituan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-7-5-meituan/" itemprop="url">美团《长期有耐心》读书摘录</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-05T14:00:00+00:00">
                2021-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2021-6-23 开始阅读<br>2021-7-5 读完</p>
<p>以下内容来自电子书《长期有耐心》 </p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>每天前进 30 公里（南极探险的故事）   </li>
<li>think big picture  </li>
<li>以客户为中心，长期有耐心</li>
</ul>
<p>艾伦·凯说过：预测未来最好的办法就是创造它。</p>
<p>王兴对环境的容忍度很高，基本不受外界的影响，但他最不能容忍的是数据错误。</p>
<p>2020 年 8 月 8 日，美团外卖日订单量突破 4000 万单</p>
<p>微软公司创始人比尔·盖茨有句名言：“每天早晨醒来，一想到所从事的工作和所开发的技术将会给人类生活带来的巨大影响和变化，我就会无比兴奋和激动。”</p>
<p>美团的定位从最初的社交和商务的交集，转向了移动和商务的交集</p>
<p>美团在“千团大战”中脱颖而出，很重要的一个因素，是抓住了移动互联网这一波红利。2011年，美团移动端收入占美团总业务比重仅为7%~8%左右，2012年达到了30%，2013年达到了70%，2014年超过了95%，移动端的发展趋势很明显。</p>
<p>要做到与互联网发展趋势紧密结合，还得有一个潜力巨大的行业来支撑，王兴选择了第三产业，也就是服务业。</p>
<p>我做一件事的标准是：有益、有趣、有利。</p>
<p>失败是可以被定义的，王兴说他看到过一个观点：我无法告诉你怎么获得成功，但失败是可以被定义的，你放弃之后就是失败了。如果你还没有放弃，那么你就还没有失败，就走在成功的路上。</p>
<p>王兴认为，CEO（首席执行官）的职责有三件：第一，设定公司目标和总体战略，并确保传达给相关执行者；第二，招募并留住最优秀的人才；第三，确保公司有足够现金。其他事情都应该找最专业的、最好的人来做。</p>
<p>传奇的团队：即使是后来饭否被关停的时候，王兴的团队都没有散，只走了两个人：一个独立开发者回老家了；另一个是张一鸣，去寻找其他的创业机会，后来创办了现在赫赫有名的今日头条、抖音。</p>
<p>两家科技巨头起家的业务：IBM是做磅秤、自动切肉机起家的，三星是做干鱼、蔬菜、水果出口业务的，如果用基因论，很难解释这两家公司未来的基因突变。</p>
<p>中国互联网商业模式的演变：</p>
<p>最早的门户展示广告，客户在新浪、搜狐等门户网站投广告，按展示次数付费</p>
<p>搜索推广，在百度、谷歌投放广告，按照点击率付费</p>
<p>团购营销，主要的客户是提供本地服务的商家，如餐馆、酒店、卡拉OK、足疗按摩店等。这些本地商家虽然规模比较小，但数量是千万量级的，它们都需要进行推广，按照效果付费</p>
<p>美团给自己的定位是本地服务的电子商务，跟所有电子商务一样，追求低成本、高效率。</p>
<p>王慧文在接受媒体采访时多次表达过，<strong>美团的本质，就是用科技来提升服务业的效率</strong>。</p>
<p>美团现任首席科学家夏华夏说过：我们要把复杂的事情简单化，简单的事情标准化，标准的事情流程化，流程的事情自动化。</p>
<p><strong>低毛利加上大规模，也会有很高的商业价值</strong>。所有<strong>零售本质</strong>都是这样，沃尔玛是这样的，亚马逊也是这样。</p>
<p>美团的业务涵盖：</p>
<ul>
<li>团购</li>
<li>外卖</li>
<li>酒旅</li>
<li>出行</li>
<li>充电宝</li>
<li>社区团购</li>
</ul>
<p>干嘉伟加入美团之前有过成体系的思考，从<strong>行业、老板、团队</strong>三个角度进行了综合衡量衡量，“我自己最主要思考了三个问题：</p>
<p>第一，这事儿大不大？<br>第二，王兴以后能不能排到互联网前十？<br>第三，他们是不是正好缺我？缺我？当时王兴找了我半年，我确实很犹豫。这三个问题思考完毕，我做了决定加入美团”。  </p>
<p>传统广告渠道：</p>
<ul>
<li>电视</li>
<li>公交</li>
<li>楼宇</li>
</ul>
<p>管理学大师德鲁克说过，企业的目的就是创造顾客。   </p>
<p>2010—2020年，美团成立的这十年，是中国互联网行业进入<strong>成熟期</strong>的十年。</p>
<p>在管理方面，王兴认为，管理的精髓不是一种科学，而是一种实践。</p>
<p>你对未来越有信心，就越有耐心。</p>
<p>“三高三低”的理念：</p>
<ul>
<li>高品质、低价格</li>
<li>高效率、低成本</li>
<li>高科技、低毛利</li>
</ul>
<p>2012 年 2 月份，美团推出猫眼电影（原名美团电影）<br>2013 年，美团又探索了外卖业务，这是美团的商业模式又一次更为深刻的进化，把美团的业务从消费者的<strong>到店消费</strong>场景，延伸到了<strong>在家消费</strong>的场景。  </p>
<p>在王兴看来，凡是还没有被互联网改变的行业，都即将被互联网改变。   </p>
<p>美团是服务业的平台，市场空间很大，但是，面临的困难与挑战也非常大，王兴认为，美团需要每天坚持前进 30 公里。  </p>
<p>2012年2月6日，美团年会在北大的百年讲堂举办，那天，王兴以“每天坚持前进30公里”为主题，做了一次精彩的演讲。王兴在演讲中以百年前<strong>南极探险</strong>的故事为例，指出美团需要“每天坚持前进30公里”的心态才能做好，只有持续改进的公司才能成为最后的赢家。   </p>
<h2 id="南极探险队的故事"><a href="#南极探险队的故事" class="headerlink" title="南极探险队的故事"></a>南极探险队的故事</h2><p>南极点是在地球的最南端，就应该是南纬90度的地方，通常探险从南纬82度开始，到了南极点还要顺利回去，这是2200多公里的路。有两个竞争团队，一个是来自挪威的阿蒙森团队，共5人；另一个是英国的斯科特团队，共17人。他们都想率先完成这个从来没有人完成过的事情，到达南极。”</p>
<p>两支探险队差不多都是1911年10月在南极圈的外围做好了准备，准备进行最后的冲刺。结果阿蒙森团队在两个多月后，也就是1911年12月15日，率先到达了南极点，插上了挪威国旗；而斯科特团队虽然出发时间差不多，而且人数还更多一些，可是他们晚到了一个多月。  </p>
<p>阿蒙森团队率先到达南极点之后，又顺利地返回了原来的基地。斯科特团队晚到了，他们没有获得荣誉。更糟糕的是，他们因为晚了，回去的路上天气非常差，路上不断有人掉队，最后没有一个人生还。   </p>
<p>通过阿蒙森团队和斯科特团队南极探险的故事，王兴做了总结，两个团队碰到的环境是差不多的，最后两个团队却有截然不同的结果，<strong>阿蒙森团队的成功经验，最后可以总结成一句话：不管天气好坏，坚持每天前进 30 公里</strong>。  </p>
<p>每天坚持前进30公里，这也是“长期有耐心”的体现。</p>
<h2 id="猫眼电影"><a href="#猫眼电影" class="headerlink" title="猫眼电影"></a>猫眼电影</h2><p>猫眼电影的创始人：徐梧。  </p>
<p>2019年年初，徐梧发了一条朋友圈：“公司对员工付出的最大成本，不是现金，不是Title（头衔），不是股权，而是<strong>机会</strong>。聪明的员工要学会识别这点。”</p>
<p>猫眼有独立的 App，不仅卖电影票、做团购、做在线选座、能查询影讯，还要让用户发影评、评分、交流。  </p>
<p>电影行业的单价在所有的行业里比较低，单以品类来看，它的拉新能力是最强的。  </p>
<p>电影<strong>相对比较标准、规范</strong>，每个影院都有专业的售票系统，IT化程度比较高。  </p>
<p>在2013年1月，我们发布了当时美团电影的3.0版，直接更名为猫眼电影。在团购的基础上，我们推出了“在线选座”这一新功能，这块的用户体验和沉淀涨势非常快。“在线选座”是猫眼电影很重要的一个功能。  </p>
<p>为了给新的品牌起名字，王兴还推荐了一本名叫《定位》的书给徐梧研读。经过多次讨论，最后终于定下“猫眼”这个名字。</p>
<p>徐梧将起名的方法论浓缩为六个字：<strong>好读、好记、独特</strong>。“什么叫好读？没有平翘舌音、前后鼻音这些难读的音，南方人、北方人都能读才算好读；好记，就是我跟你说一遍这个名字，你就能很容易记住；独特，就是要找一个相对低频的词，能够重写它的含义。”  </p>
<p>在起名字方面，美团的产品顾问马占凯（搜狗输入法之父）一直很有心得。猫眼的起名，马占凯曾重度参与。2018年，美团的生鲜超市“掌鱼生鲜”改名为“小象生鲜”，也是马占凯老师的建议。 </p>
<h2 id="三层四面分析法"><a href="#三层四面分析法" class="headerlink" title="三层四面分析法"></a>三层四面分析法</h2><p>看生意本身的机会有多大，是战略执行的第一步，可以用“三层四面分析法”。   </p>
<p>“四面”是所有生意都可以拆分成<strong>客户数、频次、客单价（收入）、货币化率</strong>；“三层”指<strong>市场现状、在线率和市场占有率</strong>。这个思考方向不见得最好，但比较保险，从上到下，没有因素重叠或者漏掉。  </p>
<p>以团购为例，团购的“四面”，用户数非常大、交易频次高、有一定客单价。当然，这个行业也存在一个问题，就是之前的货币化率非常低。再看“三层”，市场处于初期，在线率和市场占有率都很低，我就觉得那是一个大好的机会。  </p>
<p>三层，是指一个行业的市场总量、在线率和市场占有率，通俗点儿说，就是三个问题：这个行业总的蛋糕多大？互联网能够在这个蛋糕中获取多大的比率？公司能够在<strong>互联网化</strong>的这块蛋糕中占据多大比率？  </p>
<p>三层是从<strong>战略</strong>上思考这个市场有多大，从互联网的角度来竞争有多少优势，从而去推算值不值得做，如果做，做到怎样才算赢。  </p>
<p><strong>战术执行层面</strong>的“四面”，即<strong>用户量、订单量、收入和利润的增长策略</strong>。这四个元素之间存在着必然的联系，有用户量才可能有订单量，有订单量才可能产生收入，有收入的情况下才可能产生利润。  </p>
<p>在猫眼电影之前，消费者观影的路径是在时光网查影讯，在美团买票，在豆瓣评论。这个过程很痛苦。从用户的角度来说，猫眼电影一个地盘解决所有问题，满足了他们的需求，因此能带来高频使用。   </p>
<p>美团是做团购起家的，团购也是在线售票中的一种购买方式，虽然购买的过程还算便捷，但消费者还是需要<strong>用美团的团购券到影院现场兑换电影票，可能需要排队，而且选座也不是很方便</strong>。因此，在团购的基础上，猫眼电影推出了“在线选座”这一新功能，提升了用户体验，用户增长趋势非常明显。   </p>
<p>当<strong>自动取票机</strong>大规模铺开之后，购买热门影片的电影票要排几十米长队的现象彻底成为历史。  </p>
<p>线上，猫眼电影做好了产品，让用户实现<strong>在一个App实现查影讯、购票、发表评论</strong>的全部过程。线下，猫眼电影与各大影院合作，自动取票终端让用户取票更加方便。  </p>
<p>选片时有<strong>观影指南</strong>引导，判断时有<strong>社区</strong>交流参考，买票时有<strong>团购影票提供优惠</strong>，选座时有<strong>实时座位图</strong>快捷选定，影迷的基本需求已得到全面满足。  </p>
<h2 id="美团的价值观"><a href="#美团的价值观" class="headerlink" title="美团的价值观"></a>美团的价值观</h2><p>美团最初的价值观：“消费者第一，商家第二，员工第三，股东第四，王兴第五。”   </p>
<p>2013 年，美团更新了自己的价值观：以客户为中心、团队合作、拥抱变化、诚信、敬业、勤俭、学习成长。   </p>
<p>王兴在2011年发过一条微博：开会时一个年轻同事的一句话至今回荡在我耳边，当时大概是晚上12点，讨论接近尾声，需要有人整理会议纪要，涉及流程图的部分用visio画比较好。我问她会用visio吗，她毫不犹豫地说“我可以学”。这四个简单的字里有无穷的力量。   </p>
<h2 id="美团外卖"><a href="#美团外卖" class="headerlink" title="美团外卖"></a>美团外卖</h2><p>2013年11月，刚上线的美团外卖日订单量只有几单。2014年9月，日订单量峰值才到10万单。但两个月后，美团外卖日订单量峰值突破100万单。</p>
<p><strong>外卖业务把美团消费者的场景由到店延伸至到家</strong>，这是一个非常大的变化。服务链的延伸需要做好配送业务，这需要高额投入。   </p>
<p>在互联网上<strong>高频带动低频</strong>是一件比较自然的事情，所以我们会优先把大众高频的事情做好。我们的目标是解决几亿人的吃喝玩乐需求。   </p>
<p>外卖在<strong>校园</strong>业务基本稳定之后，又重点开拓<strong>白领市场</strong>，后来的事实证明，拿下了白领市场，并开展了配送服务，是美团后来获得成功的关键。  </p>
<p>2015 年，也是百度外卖形势最好的一年。美团与饿了么在兼顾校园市场与白领市场，但<strong>百度外卖只做白领市场</strong>。    </p>
<h2 id="美团酒店"><a href="#美团酒店" class="headerlink" title="美团酒店"></a>美团酒店</h2><p>相对来说，高星级酒店是美团的弱项，因为美团酒店的发展路径是<strong>从三、四线城市的同城住宿</strong>开始的，相对来说价位不高。    </p>
<p>美团采取了侧面进攻的方式。既然高星级酒店客房业务比较难进入，那就先帮高星级酒店的健身、餐饮<strong>周边业务提升营收</strong>。进入，那就先帮高星级酒店的健身、餐饮周边业务提升营收。餐饮也是高星级酒店的重要业务业务，像洲际酒店的餐饮收入占比50%，客房只占 40%。美团的优势在于更为综合全面的服务。      </p>
<h2 id="鸵鸟原理"><a href="#鸵鸟原理" class="headerlink" title="鸵鸟原理"></a>鸵鸟原理</h2><p>注意：这里是鸵鸟原理，而不是鸵鸟效应。</p>
<p>鸵鸟原理，即只有比别人有非常明显的优势时才具有竞争优势。  </p>
<p>当回顾变化的时候，我相信<strong>比尔·盖茨</strong>的话，他说得非常对，“<strong>人们总是倾向于高估两年能发生的变化，但是低估十年能发生的变化</strong>”，十年如此，五年也是如此。  </p>
<p>战略的核心是敢想，就必须 think big。我觉得很重要的是 think big picture。  </p>
<p>要定一个大目标，我们的关键是 think big picture，是去看到大格局是什么样的，自己在什么位置，扮演什么角色。    </p>
<h2 id="美团外卖更换-logo"><a href="#美团外卖更换-logo" class="headerlink" title="美团外卖更换 logo"></a>美团外卖更换 logo</h2><p>2015 年下半年，美团外卖换上了新的 LOGO，从一碗饭变成了一只萌萌的袋鼠，“<strong>美团外卖、送啥都快</strong>”这个口号，为越来越多的人所熟知。   </p>
<p>之前，美团外卖的LOGO是一碗饭，因为消费者点外卖的基础需求是餐饮，但是，随着消费者需求的增多，在美团外卖上面点水果、甜点饮品、鲜花、药品的消费者也越来越多，一碗饭已经承载不了美团外卖的全部功能。   </p>
<p>袋鼠“袋子大、囊括物品多、跑得快”的特点，与美团外卖品类丰富、配送速度快的定位一致，能够为消费者提供全面的选择、优质的体验。   </p>
<p>进行品牌升级之后，美团外卖原来的橙色改为黄色，大街小巷美团外卖骑手的制服颜色也改成了这个色调。   </p>
<h2 id="合并之年"><a href="#合并之年" class="headerlink" title="合并之年"></a>合并之年</h2><p>2015年是中国互联网的“合并之年”，滴滴和快的、58同城和赶集、美团和大众点评都是这一年合并的。  </p>
<p>在高速增长的新市场，资金不是最稀缺的，组织力也不是最稀缺的，<strong>最稀缺的是时间</strong>，错过了就不会再来了。   </p>
<p>2015 年 10 月 8 日，美团点评成立。美团和大众点评联合发布声明，正式宣布达成战略合作，双方共同成立一家新公司——美团点评。   </p>
<p>美团与大众点评合并之后，消费者<strong>到店消费</strong>这个场景的需求得到基本解决，接下来应该集中精力发展外卖、交通等新型业务。这些新业务的订单量远远超过了到店消费场景。   </p>
<h2 id="判断服务好坏的标准"><a href="#判断服务好坏的标准" class="headerlink" title="判断服务好坏的标准"></a>判断服务好坏的标准</h2><p>最简单的判断服务好坏的标准：<strong>是否愿意、放心地把它推荐给我们的家人</strong>？   </p>
<p>少谈一点颠覆，多谈一点创新。   </p>
<p>我们应该多谈一点创新，创新的最终目标是创造价值，降低行业运作成本，提高行业运作效率，提升用户体验。  </p>
<h2 id="互联网下半场"><a href="#互联网下半场" class="headerlink" title="互联网下半场"></a>互联网下半场</h2><p>下半场，就是“<strong>互联网+<strong>”，就是要通过互联网和生活服务各垂直行业的</strong>深度融合</strong>，服务于我国现代服务业的升级，以满足人们不断升级的消费需求。  </p>
<p>王兴认为，中国互联网“下半场”的重要特征，是<strong>人口红利</strong>和<strong>移动互联网红利</strong>的消失。  </p>
<p>智能手机的红利也已经过去，从小米手机创办的 2010 年开始算起，智能手机的销售数量每年都在急剧增长，最开始是每年翻倍增长，但到了 2016 年，<strong>智能手机的出货量</strong>只有 10% 左右的增长。   </p>
<p>从用户的角度来看，王兴认为，这个时候只有两条路：第一，去<strong>开拓海外市场</strong>，那里看起来似乎还有更多用户，但是，国际化是非常不容易的事情；第二，<strong>精耕细作</strong>，把现有的用户服务好，提升用户体验、增加用户黏性、提升 <strong>ARPU</strong> 值（<strong>每用户平均收入</strong>），让每个用户尽量创造更多的价值。  </p>
<p>从产业的角度来看，就需要互联网对产业的连接更加深入。王兴认为，简单的连接并不能创造价值，深度的连接并对产业进行改造，才能创造更大的价值。  </p>
<p>真正的“互联网+”，要做的是各个行业从上游到下游的产业互联网化，不是仅仅停留在最末端做营销、做交易那一小段，而是真正能够靠互联网和IT技术为各行各业的各个环节提升体验、提高效率、降低成本。    </p>
<p>美团在商业运营上的一个基本逻辑是高频打低频。  </p>
<p>高频服务靠补贴，低频服务靠广告。外卖、单车、打车等高频服务都是靠补贴做起来的，低频的服务补贴起不到作用。  </p>
<p>站在从产业创造价值的方向看，所有的产业与互联网的结合，主要的价值有两个：  </p>
<p>第一，为产业提供新的服务，带来更多的客户（<strong>我的理解就是连接</strong>）。像美团外卖的出现，就让餐饮商家增加了服务的范围范围，在不需要增加成本的情况下，让不出门的消费者也能享受到餐饮商家的服务。   </p>
<p>第二，为产业提高效率，降低成本。这里面，有非常大的改进空间。  </p>
<h2 id="企业最核心和稀缺的资源"><a href="#企业最核心和稀缺的资源" class="headerlink" title="企业最核心和稀缺的资源"></a>企业最核心和稀缺的资源</h2><p>干嘉伟回顾说，做实物团购是一件既轻松又赚钱的事情，但是，在资源和能力都有限的情况下，坚持做本地生活才是对的。<strong>一个企业最核心、最稀缺的资源不是钱，而是创始人的注意力</strong>。   </p>
<p>如果说，美团新推出的<strong>零售业务</strong>，与之前的商品团购有什么本质的区别，那就是<strong>更聚焦于与外卖业务的结合</strong>。   </p>
<h2 id="美团的两心"><a href="#美团的两心" class="headerlink" title="美团的两心"></a>美团的两心</h2><p>“以客户为中心”“长期有耐心”被称为美团的“两心”。  </p>
<p>美团的边界是什么？王兴的观点非常明确：不关注边界，只关注核心。</p>
<p>什么是核心？<br>——客户的需求就是核心。   </p>
<p>亚马逊业务无边界，综合来看，就是两个核心：一是增加客户的基数，一是增进与客户的联系。   </p>
<p>到了2016年之后，进入“下半场”的美团，探索的领域更多，比如实体生鲜超市“掌鱼生鲜”、美团充电宝、榛果民宿、美团打车等等。这些业务的探索，有些是成功的，有些是失败的，给外界的感觉，是“美团什么业务都想做”。但王兴认为，<strong>美团实际上只做一件事情，就是服务好客户</strong>，点外卖的、看电影的、旅游的、租车的，基本上是同一个群体。   </p>
<p>在媒体沟通会上，王兴回应外界对美团“四处树敌”的评价。王兴认为，竞争分两种：一种是足球的竞争，目标是把球踢进门；一种是拳击的竞争，目的是将对方打倒。美团属于第一种。  </p>
<h2 id="社会企业"><a href="#社会企业" class="headerlink" title="社会企业"></a>社会企业</h2><p>社会企业，即旨在解决社会问题、增进公众福利，而非追求自身利润最大化的企业。  </p>
<p>美团将秉承“<strong>帮大家吃得更好、生活更好</strong>”的企业使命，承担更多社会责任，带动就业发展，建设更加开放合作、与全社会协调发展的社会企业。   </p>
<p>企业有很多驱动的核心，有<strong>需求驱动、竞争驱动、战略驱动</strong>等，但我们认为在新阶段，美团是一个<strong>使命驱动</strong>的公司。   </p>
<p>在用户隐私保护方面，王兴透露，“预计2018年美团将投入1亿元用于保护用户隐私，比如消费者订外卖，不想让外卖骑手知道你的电话号码，那么有选项可以保护你的隐私，满足你的需求。<strong>隐私保护是我们认为非常重要的一个社会责任</strong>”。   </p>
<h2 id="美团的使命"><a href="#美团的使命" class="headerlink" title="美团的使命"></a>美团的使命</h2><p>第一版使命：美团的第一版使命，是 2013 年和第二版价值观一起宣布的，当时提出的使命是“连接人与商户”。    </p>
<p>美团的第二版使命，是 2016 年和第三版价值观一起宣布的，对第一版使命进行了迭代，是“连接人和服务，点亮美好生活”。   </p>
<p>王兴在2017年10月19日举办的媒体沟通会上宣布了美团的第三版使命是“帮大家吃得更好、生活更好”，英文版为“We help people eat better，live better”。  </p>
<h2 id="互联网的-A、B-面"><a href="#互联网的-A、B-面" class="headerlink" title="互联网的 A、B 面"></a>互联网的 A、B 面</h2><p>王慧文把整个互联网产业分成两类：A类是供给和履约在线上，B类是供给和履约在线下。  </p>
<p>王慧文认为，A 类产业如视频网站、直播、在线游戏等，代表性的公司是腾讯、爱奇艺、今日头条等，这类算是<strong>纯粹的互联网公司</strong>；B 类是供给和履约在线下的互联网产业，代表性的公司是淘宝、京东商城、美团、滴滴、携程等，用户可以通过互联网的方式在这些网站下单，但是，接收商品或者享受服务，那就需要用线下的方式来完成。   </p>
<p>王慧文认为，B 类可以再做一个划分，B1 类是以 SKU 为中心的供给，B2 类是以位置为中心的服务。   </p>
<p>A 类，供给和履约在线上，企业的核心能力体现在产品设计领域上，体现在用户理解上，体现在对于通信、社交以及内容的把握上。这部分的能力是 A 类企业共有的。  </p>
<p>B1 类里面，主要体现在对于品类的理解，对于供应链的理解，对于定价的理解，代表公司是淘宝。B2 类里面，如果盘点一下 B2 类的公司，总体来说，它们都有一个共有的特征，就是都有大规模的线下团队。<strong>是否有大规模的线下团队是 B1 类和 B2 类一个很大的差别</strong>。  </p>
<p>同时，B2 类的定位功能很重要，要把定位的速度做到最快、精准度做到最高。  </p>
<p>事实上，B2 这个领域是 2012 年到现在为止中国互联网打得最惨烈的圈：单车大战在这里面，打车大战在这里面，外卖大战在这里面。为什么打得这么激烈？这个行业刚刚起步，新的机会刚刚出现，<strong>大家对于机会的认知、产业的认知刚刚形成，核心能力非常相似</strong>。不仅仅核心能力相似，事实上场景也相似。核心能力导致大家场景会有很多交叉，这是没有办法的事情。     </p>
<p>B2 类还可以细分为四个场景：  </p>
<p>第一个场景：消费者不动，商家动（或者供应商动，履约动）。这个场景包括外卖、上门服务，典型的代表如美团外卖、饿了么、58 到家。<br>第二个场景：消费者动，商家不动。这是到店服务，典型的代表如美团、链家，以及爱彼迎等民宿供应商。<br>第三个场景：消费者动，供应商也动。这和交通相关，比如打车和共享单车。典型企业是滴滴、摩拜、优步，以及一些分时租车公司，美团也推出了交通的业务。<br>第四个场景：异地服务。比如异地的酒店、旅游、机票与火车票等服务，典型企业如携程、美团旅行等。  </p>
<h2 id="更大责任，更多耐心"><a href="#更大责任，更多耐心" class="headerlink" title="更大责任，更多耐心"></a>更大责任，更多耐心</h2><p>王兴在上市当天向全体员工发送了一封邮件《更大责任，更多耐心》：  </p>
<p>各位同学：</p>
<p>今天早上，公司在香港主板挂牌上市，我们迈入了一个新的发展阶段。</p>
<p>上市意味着成为一家公众公司，意味着承担更大的责任。作为平台型互联网企业，我们不能仅仅用法律、义务这样的底线来要求自己，而是要更加自觉、更加主动地承担社会责任，创造社会价值，构建一家社会企业。这需要我们每个人从每天的日常工作做起。我们要进一步加强科技创新，促进生活服务业供给侧升级，带动更多的就业，和方方面面一起，构建智慧城市，创造美好生活，践行我们公司的使命“帮大家吃得更好，生活更好”。</p>
<p>上市后我们需要更多耐心。我们经常说，要“长期有耐心”，对未来越有信心，对现在越有耐心。上市并不意味着耐心的结束，而是真正考验耐心的开始。上市本身从来不是我们的目标，只是公司成长过程中的一个里程碑。资本市场会有起伏，大家不需要太过关心短期的股价涨跌，而要时时刻刻致力于把自己的工作做好，为客户创造更大价值。从长期来看，我们所创造的价值最终会体现在我们的股价上。</p>
<p>感谢每一位同事，包括曾经为这份事业付出过的老战友；感谢每一位同事的家人；感谢我们的消费者、商户、外卖骑手、生态合作伙伴、投资人以及所有支持美团的人。</p>
<p><strong>我们每个人每次花钱，都是在为自己想要的生活投票。</strong>让我们一起努力，为了大家的信任，也为了我们自己。<strong>既往不恋，纵情向前</strong>！</p>
<p>王兴<br>2018年9月20日  </p>
<h2 id="苦练基本功"><a href="#苦练基本功" class="headerlink" title="苦练基本功"></a>苦练基本功</h2><p>王兴认为，从商业历史来看，绝大多数公司的失败不在于没掌握高难度动作，而是基本功出了问题。基本功就是业务和管理的基本动作，把基本功练好，就能产生巨大价值。  </p>
<p>通用的基本功：<strong>写备忘录、周报月报的写作、有效沟通技巧</strong></p>
<p>用备忘录取代 PPT，<strong>备忘录能将工作用严密逻辑表述清楚，是一种很好的回顾方式，也方便阅读者更深刻理解工作的策略和进展</strong>。    </p>
<h2 id="每个人的三笔钱"><a href="#每个人的三笔钱" class="headerlink" title="每个人的三笔钱"></a>每个人的三笔钱</h2><p>干嘉伟和很多员工分享成长经验的时候，讲过每个人有三笔钱：“一笔是<strong>今天的钱</strong>，也就是大家现在的收入；一笔是<strong>明天的钱</strong>，也就是通过自己的成长可以获得更多的收入；但对于很多20多岁的年轻人而言，最值钱的是<strong>后天的钱</strong>，也就是你在美团的所学所获。学习成长很像零存整取，对美团发展有信心的同事都倾向于在年轻的时候获得更多的成长。”    </p>
<p>“美团四大名著”：《高效能人士的七个习惯》《金字塔原理》《学会提问》《用图表说话》。</p>
<h2 id="千亿美元市值"><a href="#千亿美元市值" class="headerlink" title="千亿美元市值"></a>千亿美元市值</h2><p>2010 年 3 月 4 日（美团上线的第一天），王兴在自己的微博写下了：“Every time you spend money, you are casting a votefor what kind of world you want.”（<strong>每次你花钱的时候，你都在为你想要的世界投票</strong>）   </p>
<p>2019 年第二季度的财报数据显示，美团第二季度营收 227 亿元，同比增长 50.6%，经调整净利润 15 亿元，<strong>首次实现整体盈利</strong>。同时，上半年公司实现营收 418.8 亿元，同比增长 58.9%，经调整净利润 4.53 亿元。也就是说，美团不仅实现了季度盈利，而且还实现了上半年整体盈利。  </p>
<p>2020 年 3 月 30 日，美团发布了 2019 年全年财报。数据显示，2019年全年，美团收入达到 975 亿元，同比增长 49.5%，经调整净利润达 47 亿元。从全年收入来看，餐饮外卖业务、到店及酒店旅游业务、新业务（包括零售、供应链解决方案、共享单车、网约车等）营收贡献分别约为 548 亿元、223 亿元、204 亿元。  </p>
<p>2020 年 5 月 26 日，港股开盘后，美团一直大涨，收盘时，股价报 138.9 港元&#x2F;股。美团港股总市值达到 8093.34 亿港元，突破 1000 亿美元。至此，美团已经跻身国内互联网公司市值前三，并成为继阿里、腾讯之后，国内第三家市值超过千亿美元的互联网公司。   </p>
<p>2015 年 5 月，王兴在内部管理论坛上交流时，提出要将美团打造成一家超过千亿美元市值的公司。经过整整五年时间的长跑，2020 年 5 月，美团终于成为一家超过千亿美元市值的公司。  </p>
<p>预测未来，最好的办法就是去实现它。    </p>
<h2 id="两句美团老话"><a href="#两句美团老话" class="headerlink" title="两句美团老话"></a>两句美团老话</h2><p>第一句：人们往往会高估一两年时间发生的变化，但低估十年时间发生的变化。  </p>
<p>第二句：坚持做正确的事情，是在一次次的资源投入选择、产品迭代选择、方向选择中兑现的。当然，<strong>如果你坚持做正确的事情，在坚持所带来的正面结果上，其实兑现的周期常常比大家想象的短很多</strong>。</p>
<p>2020 年 3 月 4 日，美团迎来了十周岁生日。王兴给全体员工发了内部邮件。   </p>
<p>十年一瞬，以客户为中心、长期有耐心、坚持做正确的事而不是容易的事、拥抱变化、每天前进 30 公里、我不会但我可以学、苦练基本功……这些我们相信的，是十年来我们一路前行的航标，也将继续指引我们远航。   </p>
<p>新的十年，我不祝大家一帆风顺，我祝大家乘风破浪！<br>新的十年，既往不恋，纵情向前！   </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" itemprop="url">ASP.NET Core 搭载 Envoy 实现微服务的反向代理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-01T14:49:47+00:00">
                2021-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>回想起来，博主第一次接触到<code>Envoy</code>，其实是在微软的示例项目 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a>，在这个示例项目中，微软通过它来为<code>Ordering API</code>、<code>Catalog API</code>、<code>Basket API</code> 等多个服务提供网关的功能。当时，博主并没有对它做深入的探索。此刻再度回想起来，大概是因为那个时候更迷恋领域驱动设计(DDD)的理念。直到最近这段时间，博主需要在一个项目中用到<code>Envoy</code>，终于决定花点时间来学习一下相关内容。所以，接下来这几篇博客，大体上会以记录我学习<code>Envoy</code>的历程为主。考虑到<code>Envoy</code>的配置项特别多，在写作过程中难免会出现纰漏，希望大家谅解。如对具体的配置项存在疑问，请以官方最新的 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/">文档</a> 为准，本文所用的示例代码已经上传至 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway">Github</a>，大家作为参考即可。对于今天这篇博客，我们来聊聊 ASP.NET Core 搭载 Envoy 实现微服务的反向代理 这个话题，或许你曾经接触过 <a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/ThreeMammals/Ocelot">Ocelot</a>，这次我们不妨来尝试一点新的东西，譬如，通过<code>Docker-Compose</code>来实现服务编排，如果对我说的这些东西感兴趣的话，请跟随我的脚步，一起来探索这广阔无垠的技术世界吧！</p>
<h1 id="走近-Envoy"><a href="#走近-Envoy" class="headerlink" title="走近 Envoy"></a>走近 Envoy</h1><p><a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a> 官网对<code>Envoy</code>的定义是：</p>
<blockquote>
<p>Envoy 是一个开源边缘和服务代理，专为原生云应用设计。</p>
</blockquote>
<p>而更进一步的定义是：</p>
<blockquote>
<p>Envoy 是专为大型现代服务导向架构设计的 L7 代理和通讯总线。</p>
</blockquote>
<p>这两个定义依然让你感到云里雾里？没关系，请看下面这张图：</p>
<p><img src="https://i.loli.net/2021/07/02/k2DhXMudnibrzgt.png" alt="Envoy架构图"></p>
<p>注：<a target="_blank" rel="noopener" href="https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/architecture/">图片来源</a></p>
<p>相信从这张图中，大家多少能看到反向代理的身影，即下游客户端发起请求，<code>Envoy</code>对请求进行侦听(<strong>Listeners</strong>)，并按照路由转发请求到指定的集群(<strong>Clusters</strong>)。接下来，每一个集群可以配置多个终结点，<code>Envoy</code>按照指定的负载均衡算法来筛选终结点，而这些终结点则指向了具体的上游服务。例如，我们熟悉的 <a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a> ，使用<code>listen</code>关键字来指定侦听的端口，使用<code>location</code>关键字来指定路由，使用<code>proxy_pass</code>关键字来指定上游服务的地址。同样地，<a target="_blank" rel="noopener" href="https://github.com/ThreeMammals/Ocelot">Ocelot</a> 使用了类似的上下游(<strong>Upstream</strong>&#x2F;<strong>Downstream</strong>)的概念，唯一的不同是，它的上下游的概念与这里是完全相反的。</p>
<p>你可能会说，这个<code>Envoy</code>看起来“平平无奇”嘛，简直就像是“平平无奇”的古天乐一般。事实上，<code>Envoy</code>强大的地方在于：</p>
<ul>
<li>非侵入式的架构： 独立进程、对应用透明的<code>Sidecar</code>模式</li>
</ul>
<p><img src="https://i.loli.net/2021/07/02/lMnPhZzBd38tpVF.png" alt="Envoy 的 Sidecar 模式"></p>
<ul>
<li>L3&#x2F;L4&#x2F;L7 架构：<code>Envoy</code>同时支持 OSI 七层模型中的第三层(网络层, IP 协议)、第四层(传输层，TCP &#x2F; UDP 协议)、第七层(应用层，HTTP 协议)</li>
<li>顶级 HTTP&#x2F;2 支持： 视 <code>HTTP/2</code> 为一等公民，且可以在 <code>HTTP/2</code> 和 <code>HTTP/1.1</code>间相互转换</li>
<li>gRPC 支持：<code>Envoy</code> 支持 <code>HTTP/2</code>，自然支持使用 <code>HTTP/2</code> 作为底层多路复用协议的 <code>gRPC</code></li>
<li>服务发现和动态配置：与 <code>Nginx</code> 等代理的热加载不同，<code>Envoy</code> 可以通过 <code>API</code> 接口动态更新配置，无需重启代理。</li>
<li>特殊协议支持：Envoy 支持对特殊协议在 L7 进行嗅探和统计，包括：<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/mongo_proxy_filter#">MongoDB</a>、<a target="_blank" rel="noopener" href="https://www.servicemesher.com/envoy/intro/arch_overview/dynamo.html#arch-overview-dynamo">DynamoDB</a> 等。</li>
<li>可观测性：<code>Envoy</code> 内置 <code>stats</code> 模块，可以集成诸如 <code>prometheus/statsd</code> 等监控方案。还可以集成分布式追踪系统，对请求进行追踪。</li>
</ul>
<h1 id="Envoy配置文件"><a href="#Envoy配置文件" class="headerlink" title="Envoy配置文件"></a>Envoy配置文件</h1><p><code>Envoy</code>通过配置文件来实现各种各样的功能，其完整的配置结构如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;static_resources&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dynamic_resources&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_manager&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hds_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;flags_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stats_sinks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stats_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stats_flush_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;watchdog&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tracing&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;layered_runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;overload_manager&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;enable_dispatcher_stats&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;header_prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stats_server_version_override&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;...&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;use_tcp_for_dns_lookups&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里我们主要对侦听器(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>) 和 管理(<strong>Admin</strong>)这三个常用的部分来进行说明。其中，(<strong>Listeners</strong>)、集群(<strong>Clusters</strong>) 均位于 <code>static_resources</code> 节点下，而 管理(<strong>Admin</strong>) 则有一个单独的<code>admin</code>节点。</p>
<h2 id="侦听器-Listeners"><a href="#侦听器-Listeners" class="headerlink" title="侦听器(Listeners)"></a>侦听器(Listeners)</h2><p>侦听器，顾名思义就是侦听一个或者多个端口：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>
<p>在这里，它表示的是侦听<code>9090</code>这个端口，这里的<code>listeners</code>是一个数组，所以，你可以同时侦听多个端口。</p>
<h3 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h3><p>我们知道，单单侦听一个或者多个端口，是无法完成一个<code>HTTP</code>请求的，因为它还不具备处理<code>HTTP</code>请求的能力。</p>
<p><img src="https://i.loli.net/2021/07/02/CQftjTErndyNh7q.png" alt="Envoy Filters 架构图"></p>
<p>在 <code>Envoy</code> 中，这一工作由一个或者多个过滤器组成的过滤器链(<strong>Filter Chains</strong>) 来完成：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">listeners:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span></span><br><span class="line">      <span class="attr">socket_address:</span></span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">port_value:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">filter_chains:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">          <span class="attr">codec_type:</span> <span class="string">AUTO</span></span><br><span class="line">          <span class="attr">stat_prefix:</span> <span class="string">ingress_http</span></span><br><span class="line">          <span class="attr">route_config:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">local_route</span></span><br><span class="line">            <span class="attr">virtual_hosts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">              <span class="attr">domains:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">              <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/api/w&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/Weather</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">weatherservice</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">                  <span class="attr">prefix:</span> <span class="string">&quot;/api/c&quot;</span></span><br><span class="line">                <span class="attr">route:</span></span><br><span class="line">                  <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">                  <span class="attr">prefix_rewrite:</span> <span class="string">/City</span></span><br><span class="line">                  <span class="attr">cluster:</span> <span class="string">cityservice</span></span><br><span class="line">          <span class="attr">http_filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure>

<p>在这段配置中，<code>Http Connection Manager</code>表示的是位于 L3(<strong>网络层</strong>)&#x2F;L4(<strong>传输层</strong>) 的过滤器，这个过滤器连接的下一个过滤器是<code>envoy.filters.http.router</code>，表示的是 L7(<strong>应用层</strong>) 的关于路由的过滤器。个人感觉，这和我们通常所说的中间件相当接近。注意到，我们在 L3&#x2F;L4 这个层级上做了什么事情呢？其实应该是 TCP&#x2F;IP 层面上请求转发，这里定义的路由规则如下：</p>
<ul>
<li>当外部调用者访问<code>/api/w</code>时，请求会被转发到<code>WeatherService</code>。</li>
<li>当外部调用者访问<code>/api/c</code>时，请求会被转发到<code>CityService</code>。</li>
</ul>
<h2 id="集群-Clusters"><a href="#集群-Clusters" class="headerlink" title="集群(Clusters)"></a>集群(Clusters)</h2><p>在过滤器部分，我们定义了路由，那么，请求的最终去向是哪里呢？这里 <code>Envoy</code> 将其称之为 集群：:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># City Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cityservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br></pre></td></tr></table></figure>
<p>集群本身，其实只是一个名字，并没有实际的意义，真正工作的其实是指向上游服务的终结点，我们可以为每一个集群指定一个负载均衡策略，让它决定选择哪一个终结点来提供服务。</p>
<h3 id="负载均衡-Load-Assignment"><a href="#负载均衡-Load-Assignment" class="headerlink" title="负载均衡(Load Assignment)"></a>负载均衡(Load Assignment)</h3><p>目前，<code>Envoy</code>支持以下负载均衡算法：</p>
<ul>
<li>ROUND_ROBIN：轮询</li>
<li>LEAST_REQUEST：最少请求</li>
<li>RING_HASH：哈希环</li>
<li>RANDOM：随机</li>
<li>MAGLEV：磁悬浮</li>
<li>CLUSTER_PROVIDED</li>
</ul>
<p>下面的示例展示了如何为某个集群配置负载均衡：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">static_resources:</span></span><br><span class="line">  <span class="attr">clusters:</span></span><br><span class="line">  <span class="comment"># Weather Service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">LEAST_REQUEST</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice1</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="string">weatherservice2</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>weatherservice1</code>和<code>weatherservice2</code>是同一个服务的两个容器实例，当我们使用<code>Docker-Compose</code>进行构建的时候，不需要显式地去指定每一个服务的IP地址，只要对应<code>docker-compose.yaml</code>文件中的服务名称即可。</p>
<h2 id="管理-Admin"><a href="#管理-Admin" class="headerlink" title="管理(Admin)"></a>管理(Admin)</h2><p>管理(<strong>Admin</strong>)这块儿相对简单一点，主要用来指定<code>Envoy</code>的的管理接口的端口号、访问日志存储路径等等：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">access_log_path:</span> <span class="string">/tmp/admin_access.log</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">socket_address:</span> &#123; <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>, <span class="attr">port_value:</span> <span class="number">9091</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>好了，在正确配置<code>Envoy</code>以后，我们来考虑如何对这些服务进行编排，在本文的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway">例子</a> 中，我们有两个后端服务，<code>WeatherService</code> 和 <code>CityService</code>，它们本质上是两个<code>ASP.NET Core</code>应用，我们希望通过<code>Envoy</code>来实现反向代理功能。这样做的好处是，后端服务的架构不会直接暴露给外部使用者。所以，你会注意到，在微服务架构的设计中，网关经常扮演着重要的角色。那么，如何对服务进行编排呢？这里我们使用<code>Docker-Compose</code>来完成这个工作：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">cityservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line">  <span class="attr">weatherservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，这里需要部署3个服务，其中，<code>Envoy</code>负责监听<code>9090</code>端口，即对外的网关。而两个后端服务，<code>WeatherService</code> 和 <code>CityService</code>则被分别部署在<code>8082</code>和<code>8081</code>端口。这里最重要的是<code>envoy.yaml</code>这个配置文件，我们在上一节编写的配置文件会挂在到容器目录：<code>/etc/envoy/envoy.yaml</code>。<code>Envoy</code>将如何使用这个配置文件呢？事实上，这个<code>Dockerfile</code>是这样编写的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> envoyproxy/envoy-alpine:v1.<span class="number">16</span>-latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./envoy.yaml /etc/envoy.yaml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> go+r /etc/envoy.yaml</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/envoy&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/etc/envoy.yaml&quot;</span>, <span class="string">&quot;--service-cluster&quot;</span>, <span class="string">&quot;reverse-proxy&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>除此之外，Envoy通过<code>9091</code>端口提供管理功能，我们可以通过这个端口来获得集群、请求、统计等信息，这一特性我们将会在接下来的文章里用到：</p>
<p><img src="https://i.loli.net/2021/07/02/1OlNJ7um6BnLFeb.png" alt="Envoy 管理界面功能一览"></p>
<p>这里，想分享一个关于<code>Envoy</code>的小技巧，当我们在指定集群的地址时，可以使用<code>docker-compose.yaml</code>中定义的服务的名称，这会比填入一个固定的<code>IP</code>地址要更优雅一点，理由非常简单，我们不希望每次都来维护这个地址。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Weather Service</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">weatherservice</span></span><br><span class="line">   <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">   <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">   <span class="attr">load_assignment:</span></span><br><span class="line">     <span class="attr">cluster_name:</span> <span class="string">weatherservice</span></span><br><span class="line">     <span class="attr">endpoints:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">           <span class="attr">address:</span></span><br><span class="line">             <span class="attr">socket_address:</span></span><br><span class="line">               <span class="comment"># 建议使用 docker-compose.yaml 文件中对应的服务名称来代替IP地址</span></span><br><span class="line">               <span class="attr">address:</span> <span class="string">weatherservice</span></span><br><span class="line">               <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>接下来，如果每一个服务的<code>Dockerfile</code>都编写正确的话，我们就可以通过<code>docker compose up</code>命令启动这一组服务，通过命令行下打印出来的信息，我们可以确认，基于<code>Envoy</code>的网关服务、两个基于<code>ASP.NET Core</code>的后端服务都已经成功运行起来：</p>
<p><img src="https://i.loli.net/2021/07/02/KMo4dn17m9p8NSg.png" alt="在 Docker-Compose 中成功启动服务"></p>
<p>还记得我们的路由规则是是如何定义的吗？</p>
<ul>
<li>当外部调用者访问<code>/api/w</code>时，请求会被转发到<code>WeatherService</code>。</li>
<li>当外部调用者访问<code>/api/c</code>时，请求会被转发到<code>CityService</code>。</li>
</ul>
<p>实际的情况如何呢？我们不妨来验证一下：</p>
<p><img src="https://i.loli.net/2021/07/02/YX4VywtkOCJ2rSI.png" alt="通过 Envoy 调用 WeatcherService "></p>
<p>可以注意到，不管是浏览器返回的结果，还是容器内部输出的日志，都表明请求确实被转发到对应的服务上面去了，这说明我们设计的网关已经生效。至此，我们实现了基于<code>Envoy</code>的反向代理功能，有没有觉得比<code>Nginx</code>要简单一点？重要的是，基于<code>Docker-Compose</code>的服务编排使用起来真的舒适度爆棚，这意味着你会有更多的属于程序员的贤者时间。前段时间热映的电视剧《觉醒时代》，鲁迅先生写完《狂人日记》后那一滴眼泪令人动容。也许，这种如匠人一般反复雕琢、臻于完美的心境是互通的，即使人类的悲欢并不相通，对美和极致的追求竟然出奇的相似。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了 ASP.NET Core 搭载 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a> 实现反向代理这一过程。对于 <code>Envoy</code>，有两个重要的定义：<strong>第一、Envoy 是一个开源边缘和服务代理，专为原生云应用设计。第二、Envoy 是专为大型现代服务导向架构设计的 L7 代理和通讯总线</strong>。相比 <a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a>  和 <a target="_blank" rel="noopener" href="https://github.com/ThreeMammals/Ocelot">Ocelot</a> ，Envoy 提供了 <code>L7</code> 级别的代理服务，支持 <code>HTTP/2</code> 和 <code>gRPC</code>，无侵入式的<code>Sidecar</code>模式可以提供与应用进程完全隔离的代理服务。接下来，博主对 <code>Envoy</code> 配置文件的结构及主要的配置项进行了说明，对于常见的 API 网关，我们应该重点关注侦听器(<strong>Listeners</strong>) 和 集群(<strong>Clusters</strong>)。最终，我们结合<code>Docker-Compose</code>对服务进行了编排，并由此构建出了一个基本的反向代理的方案。本文的源代码已托管至 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyGateway">Github</a> ，大家可以在此基础上做进一步的探索。好了，以上就是这篇博客的的全部内容啦，欢迎大家就本文中提出的方案、代码等进行讨论，如果大家有任何意见或者建议，欢迎在评论区进行留言，谢谢大家！</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a target="_blank" rel="noopener" href="https://fuckcloudnative.io/envoy-handbook/">Envoy中文指南</a></li>
<li><a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/">Envoy官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sheng-jie/p/use-envoy-proxy-as-apigateways-in-eshoponcontainers.html">eShopOnContainers 知多少[12]：Envoy Gateways</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/heat-syncope-and-ambulance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/heat-syncope-and-ambulance/" itemprop="url">年轻人的第一次救护车：原来中暑真的会晕倒！</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-01T10:20:00+00:00">
                2021-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>今天一天解锁了好几个人生成就：</p>
<ul>
<li>✅ 中暑昏厥</li>
<li>✅ 被送上救护车</li>
<li>✅ 进急诊室</li>
</ul>
<p>不开玩笑，以我的经历在此提醒各位，一定不能小瞧中暑的危害啊！！</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/heat-syncope-and-ambulance/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-06-27-what-is-zuohui-said/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-06-27-what-is-zuohui-said/" itemprop="url">做难而正确的事 - 读《详谈左晖》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-27T01:31:12+00:00">
                2021-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/zuohui-book.jpeg" class="">

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A6%E6%99%96#cite_note-4">左晖</a> 是链家和贝壳找房的创始人兼董事长。不久前，左晖因肺癌恶化而逝世。选择读左晖的著作一来是因为贝壳上市后，市值超过了 500 亿美金（下图）。</p>
<p>二来是因为我发现用互联网手段改造传统行业是一个非常有挑战，但是成功后价值非常高的事情，想看看左晖是如何一步步把这件事情做成的。</p>
<img src="/images/beke-stock.jpeg" class="">

<p>左晖还有一点吸引我：他是学计算机的。他 1992 年毕业于北京化工大学计算机专业。这让我更容易把他当作一个模仿的榜样。</p>
<p>因为整本书都是李翔对左晖的访谈，所以我整理了一些对我有启发的观点，分享给大家。</p>
<h2 id="二、决策机制"><a href="#二、决策机制" class="headerlink" title="二、决策机制"></a>二、决策机制</h2><p>左晖因为离管理具体的业务远一些，所以在管理团队会用沟通式决策。他会把自己的观点抛出来和大家探讨交流，大家如果同意，就达成了一致，执行就没问题了。大家如果不同意，那他就先放一放。</p>
<p>这种决策机制需要两个条件：</p>
<ul>
<li>团队的氛围是足够倾听和平等的，否则左晖说什么大家就会当圣旨去执行。左晖也不太敢说了，因为他离业务远，他也不敢保证说什么都是对的。</li>
<li>他的下属要足够厉害。对于不够厉害的下属，这种方式也成不了。左晖选人用人还是足够好的。</li>
</ul>
<img src="/images/zuohui-book-1.jpeg" class="">

<h2 id="三、互联网化传统行业"><a href="#三、互联网化传统行业" class="headerlink" title="三、互联网化传统行业"></a>三、互联网化传统行业</h2><p>房产中介是一个传统行业，但是左晖的贝壳会尝试用互联网的方式来赋能在这个平台上的中小中介。我看下来，这个赋能主要是：</p>
<ul>
<li>标准化中介服务的环节。然后通过培训、数据、系统来帮助中小中介。</li>
<li>通过数据反馈来迭代。</li>
</ul>
<p>左晖把贝壳的目标定义成了三个指标：</p>
<ul>
<li>店面总交易额：GTV。5000 万一年是温饱线。贝壳会帮助大家达成这个目标，让大家活下来。</li>
<li>NPS 值。现在行业 NPS 是负的，贝壳希望做到 30% 。</li>
<li>经纪人平均从业时间。行业平均值是 6、7个月，贝壳希望做到 30 个月。</li>
</ul>
<p>以上指标如何达成呢？贝壳把服务环节标准化，比如有一个标准就是：IM 的即时响应率，贝壳要求是 24 秒。因为贝壳发现，在现在这个时代，房产中介必须要学会在线上和消费者交流。</p>
<p>如何在 24 秒内就能回应消费者的线上询问呢？我相信这里面一定是一个系统工程。包括相关的工具、人员培训、话术 SOP、自动辅助应答、知识库的建立、客服人员的满意度考核、工作量与薪资结算打通。</p>
<p>这些系统性的工作，除了建立相关的技术工具外，还需要有相关的培训和服务。在淘宝，如果你需要一个 24 小时的客服，你不需要真正招聘这个人，网上有一堆这样的客服公司与你对接。他们会帮你梳理好问题，然后可以按次计费。而你只需要关心开店的核心工作就行了。我想贝壳很可能也是在超着这样一个标准化道路上前行。</p>
<p>好就好在，链家已经把这些工作在公司内部做到了。贝壳要做的，就是把链家成熟的工具抽取出来，把成熟的培训抽取出来，以加盟的模式输出给整个中介行业。</p>
<p>左晖把这个输出的能力叫做：品质的规模化复制。</p>
<h2 id="四、品质的规模化复制的核心"><a href="#四、品质的规模化复制的核心" class="headerlink" title="四、品质的规模化复制的核心"></a>四、品质的规模化复制的核心</h2><p>左晖认为品质的规模化复制，包括抽象能力和复制能力。</p>
<p>抽象能力需要把每个人角色、每个组织、每个流程以及匹配关系抽象出来。我感觉有点像定义人、事情、流程。</p>
<p>复制能力是通过文化、组织、IT 系统、团队把能力落地。这个一方面是需要时间，因为团队文化和 IT 系统的建设是需要时间的。另一方面是需要人才，传统行业的人才通常没有这个基础素质。</p>
<p>所以左晖说，线上的人做线下相对容易，因为线上的人更开放。</p>
<h2 id="五、不看同行"><a href="#五、不看同行" class="headerlink" title="五、不看同行"></a>五、不看同行</h2><p>左晖有一个观点，和猿辅导的几个创始人的观点挺像的，就是不看同行做了什么。</p>
<p>大家的核心观点都一样：因为我们处在一个商业大变革的时代，别人做一个事情成功了或失败了，给自己的借鉴意义是相对小的。核心还是看自己怎么去思考和判断。</p>
<p>左晖在做贝壳的时候，市面上已经有一些平台公司了。但是他不太关心这些公司是怎么做的，坚持按照自己的想法做贝壳。按他的原话说：</p>
<blockquote>
<p>我觉得我们今天好象都偷懒了，要去问踩了哪些坑。但这个坑毕竟是他踩的，你自己没踩过，你听的跟你碰到的差别是非常大的，或者是完全不一样的。你有那个功夫到处去打听，还不如自己去干。</p>
</blockquote>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>左晖用他的抽象能力和复制能力把链家做好了，接着又把这种能力平台化，做好了贝壳。这给我很大的启发。互联网巨大的魅力就是数据和规模，而这些都是可以创造巨大价值的事情。贝壳用真实的案例让我看到了传统行业互联网化的巨大机会。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-6-23-apptips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-6-23-apptips/" itemprop="url">近期值得关注的 App 及使用技巧</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-23T14:00:00+00:00">
                2021-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>今天发一些比较零散的东西，包含我意外发现的一些 App 功能、软件下载可能会遇到的问题，主题不定，希望对你有帮助。</p>
<h2 id="奇点：将微博同步到-Twitter"><a href="#奇点：将微博同步到-Twitter" class="headerlink" title="奇点：将微博同步到 Twitter"></a>奇点：将微博同步到 Twitter</h2><p>奇点，是 iOS 上的一个第三方微博客户端，视觉设计看起来有点像是 Twitter，功能不多介绍，这里只想介绍它的一个小功能——<strong>将微博动态同步到 Twitter</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/IMG_E0C109A76AA0-1.jpeg" alt="IMG_E0C109A76AA0-1"></p>
<p>以前我也折腾过将微博动态同步到 Twitter，不过用的是自动化服务 IFTTT，现在 IFTTT 已经无法实现这一功能了。</p>
<p>在奇点中使用这一同步功能的时候，需要挂着木弟子，否则就会遇到同步失败的问题。</p>
<p>奇点是由国内的开发者 @图拉鼎 开发的，关于他的更多作品，可以参考之前发布过的文章：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lSVYwt08DmIR3gKSYcCyBw">值得关注的小众软件背后，还有一群可爱的开发者</a></p>
<h2 id="iPhone-自带的听歌识曲功能"><a href="#iPhone-自带的听歌识曲功能" class="headerlink" title="iPhone 自带的听歌识曲功能"></a>iPhone 自带的听歌识曲功能</h2><p>这是我最近才发现的一个点，原来 iPhone 也自带了听歌识曲的功能，只是我从未发现，也没有将它打开。</p>
<p>苹果之前收购了一款听歌识曲应用 Shazam，后来它将这个应用的功能<strong>集成到了 iOS 系统中</strong>，让我们可以在无需安装 Shazam 的情况下，就能用上听歌识曲。</p>
<p>我们有两种方式使用这个功能：一种是呼叫 Siri，「嘿 Siri，听听这是什么歌？」，另一种则是将它添加到<strong>控制中心</strong>中。</p>
<p>打开系统设置 &gt;&gt; 控制中心，将下方「更多控制」的「音乐识别」拖拽到上方的「包含的控制」中，添加之后，我们就可以在屏幕顶部的下拉菜单中，看到这个音乐识别的按钮啦。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/IMG_9246.PNG" alt="IMG_9246"></p>
<h2 id="QQ-音乐-for-Mac"><a href="#QQ-音乐-for-Mac" class="headerlink" title="QQ 音乐 for Mac"></a>QQ 音乐 for Mac</h2><p>之前曾简单介绍过，相比 Windows 系统，Mac 版的 QQ 音乐增加了「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/w_W_vhBZM3RwZry8uCs6dA"><strong>歌词动效</strong></a>」的功能，在音乐的歌词页面右下角，就能看到这个按钮。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623085202303.png" alt="image-20210623085202303"></p>
<p>前阵子发现它又增加了其他的样式，从最初只有折叠水波、时光隧道两种样式，增加到了现在的 10 种样式，使用动效之前需要先下载，下面👇我截取了其中两种样式，这里就不放录制的动效了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623085821611.png" alt="image-20210623085821611"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623085846710.png" alt="image-20210623085846710"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623085956877.png" alt="image-20210623085956877"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623085056124.png" alt="image-20210623085056124"></p>
<h2 id="VS-Code-下载速度慢"><a href="#VS-Code-下载速度慢" class="headerlink" title="VS Code 下载速度慢"></a>VS Code 下载速度慢</h2><p>这周写的 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5dTb1e3qRGf3Jhom6oO1yg">Python 抓取 B 站弹幕</a>的文章，我用到了微软推出的代码编辑器 <strong>VS Code</strong>，可能是因为装了太多插件，影响到 VS Code 的正常运行，软件提示我说「VS Code 已损坏」，让我重装软件。</p>
<p>于是我照做，打算从 VS Code 官网下载最新版的应用，但却遇到了另外一个问题：下载速度慢得龟速，下到一半还提示下载错误。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623211331657.png" alt="image-20210623211331657"></p>
<p>这与我很久之前从官网下载 VS Code 是完全不一样的体会，这回给我的直觉就是：又多了一个给高墙挡住的官网了。</p>
<p>后来从网上翻了一下，才找到一个经国内 CDN 加速的下载地址，才顺利下载到最新版本的应用：</p>
<p><em><a target="_blank" rel="noopener" href="https://vscode.cdn.azure.cn/stable/507ce72a4466fbb27b715c3722558bb15afa9f48/VSCodeUserSetup-x64-1.57.1.exe">https://vscode.cdn.azure.cn/stable/507ce72a4466fbb27b715c3722558bb15afa9f48/VSCodeUserSetup-x64-1.57.1.exe</a></em></p>
<p>如果你是 Mac 用户，可以从这个链接下载：</p>
<p><em><a target="_blank" rel="noopener" href="https://vscode.cdn.azure.cn/stable/507ce72a4466fbb27b715c3722558bb15afa9f48/VSCode-darwin.zip">https://vscode.cdn.azure.cn/stable/507ce72a4466fbb27b715c3722558bb15afa9f48/VSCode-darwin.zip</a></em></p>
<p>关于如何找到最新版 VS Code 在国内 CDN 加速下载的地址，有个网友给我提供了一个网址：</p>
<p><em><a target="_blank" rel="noopener" href="https://update.code.visualstudio.com/api/update/darwin/stable/VERSION">https://update.code.visualstudio.com/api/update/darwin/stable/VERSION</a></em></p>
<p>在浏览器中打开这个网址，会返回下方的内容：</p>
<ul>
<li>url：这个 url 就是 Mac 版 VS Code 的下载链接</li>
<li>productVersion：这是 VS Code 最新的版本号</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210623210605496.png" alt="image-20210623210605496"></p>
<p>要想得到 Windows 版 VS Code 的下载链接，我们需要手动更改一下上面的 url，将 url 末尾的 <code>-darwin.zip</code> 替换为 <code>UserSetup-x64-最新的软件版本号.exe</code>，就可以得到前面的 Windows 版下载链接啦。  </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a><strong>欢迎关注</strong></h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP-NET-Core-gRPC-%E6%89%93%E9%80%9A%E5%89%8D%E7%AB%AF%E4%B8%96%E7%95%8C%E7%9A%84%E5%B0%9D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP-NET-Core-gRPC-%E6%89%93%E9%80%9A%E5%89%8D%E7%AB%AF%E4%B8%96%E7%95%8C%E7%9A%84%E5%B0%9D%E8%AF%95/" itemprop="url">ASP.NET Core gRPC 打通前端世界的尝试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-20T13:37:36+00:00">
                2021-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在构建以 gRPC 为核心的微服务架构的过程中，我们逐渐接触到了 gRPC 的过滤器、健康检查、重试等方面的内容。虽然， Protocol Buffers 搭配 HTTP&#x2F;2 ，在整个传输层上带来了显著的性能提升，可当这套微服务方案面对前后端分离的浪潮时，我们能明显地有点“<strong>水土不服</strong>”。其实，如果单单是以 Protocol Buffers 来作为 HTTP 通信的载体，通过 <a target="_blank" rel="noopener" href="https://github.com/dcodeIO/protobuf.js">protobuf.js</a> 就可以实现前端的二进制化。考虑到 gRPC 实际的通信过程远比这个复杂，同时还要考虑<code>.proto</code>文件在前&#x2F;后端共享的问题，所以，我们面对的其实是一个相当复杂的问题。现代的前端世界，是一个<code>React</code>、<code>Angular</code>和<code>Vue</code>三足鼎立的世界，如果这个世界不能和微服务的世界打通，我们面对的或许并不是一个真实的世界。因为博主注意到，项目中有一部分 gRPC 服务被封装为<code>Web API</code>并提供给前端，这说明大家都意识到了这个问题。所以，这篇博客想和大家分享的是，如何打通 gRPC 和 前端 两个不同的世界，这里介绍四种方式：<strong>gRPC-Web</strong>、<strong>gRpc-Gateway</strong>、<strong>封装 Web API</strong>、<strong>编写中间件</strong>，希望能给大家带来一点启发。</p>
<h1 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h1><p><a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Web</a> 是官方提供的一个方案，它的原理是利用命令行工具<code>ptotoc</code>及其插件<code>protoc-gen-grpc-web</code>来生成<code>.proto</code>对应的客户端代码，这些代码经过<code>webpack</code>这类打包工具处理以后，就可以在前端使用。所以，对于 gRPC-Web ，你可以从两个方面来考虑它：第一，它支持生成强类型的客户端代码；第二，它支持在非 HTTP&#x2F;2 环境下使用 gRPC 。下面是一个基本的使用流程：</p>
<p>首先，我们需要下载命令行工具：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">protoc</a> 及其插件：<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-web/releases">protoc-gen-grpc-web</a>。</p>
<p>此时，我们可以使用下面的命令来生成<code>JavaScript</code>版本的 gRPC 代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc greetjs.proto \</span><br><span class="line">  --js_out=import_style=commonjs:. \</span><br><span class="line">  --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. \</span><br><span class="line">  --plugin=protoc-gen-grpc-web=C:\Users\Payne\go\bin\protoc-gen-grpc-web.exe</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>--js_out</code> 和 <code>--grpc-web_out</code> 分别指定了我们要生成的<code>JavaScript</code>代码的模块化标准，这里使用的是 <a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS</a> 规范。</li>
<li><code>mode=grpcwebtext</code> 指定 gRPC-Web 的数据传输方式。目前：支持两种方式，application&#x2F;grpc-web-text(Base64 编码，文本格式) 和 application&#x2F;grpc-web+proto(二进制格式)，前者支持 Unary Calls 和 Server Streaming Calls，后者只支持 Unary Calls。</li>
</ul>
<p>在这个例子中，会生成下面两个文件，它们分别定义了<code>客户端</code>和<code>消息</code>这两个部分：</p>
<p><img src="https://i.loli.net/2021/06/22/Yd9A5CEONkZgBjU.png" alt="利用 protoc 生成 JavaScript 代码"></p>
<p>此时，我们可以这样编写我们的逻辑代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> proto.<span class="property">greet</span>.<span class="title class_">GreeterClient</span>(<span class="string">&#x27;http://localhost:8000&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> proto.<span class="property">greet</span>.<span class="title class_">HelloRequest</span>();</span><br><span class="line"><span class="keyword">var</span> metadata = &#123; &#125;</span><br><span class="line">request.<span class="title function_">setName</span>(<span class="string">&#x27;长安书小妆&#x27;</span>);</span><br><span class="line">client.<span class="title function_">sayHello</span>(request, metadata, <span class="keyword">function</span>(<span class="params">error, response</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你更倾向于使用类型安全的 TypeScript，你还可以按下面的方式来生成代码：</p>
<ul>
<li><code>import_style=commonjs+dts</code>: CommonJS &amp; .d.ts typings</li>
<li><code>import_style=typescript</code>: 100% TypeScript</li>
</ul>
<p>更多的细节请参考官方文档：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/grpc/grpc-web#typescript-support">https://hub.fastgit.org/grpc/grpc-web#typescript-support</a></p>
<p>接下来，对于 .NET 开发者而言， gRPC-Web 意味着我们只需要简单地配置下 ASP.NET Core 的中间件管道，就可以享受到上面提供的这些便利。因为 Visual Studio 会在编译<code>.proto</code>文件时，自动帮你生成这个客户端代码，我们可以将这一技术应用到单页面应用(<strong>SPA</strong>) 和 WebAssembly 中，最典型的例子莫过于微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0">Blazor</a>，它使得 gRPC 可以充当客户端与服务端间的信使。同样地，这里准备了相关的示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseGrpcWeb();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;().EnableGrpcWeb();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家留意一下微软官方的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/grpc/grpc-dotnet/blob/master/examples/Browser/Server/wwwroot/Scripts/index.js">示例项目</a>，就会发现和这里类似的东西，因为原理上一脉相承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">HelloRequest</span>, <span class="title class_">HelloReply</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./greet_pb.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">GreeterClient</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./greet_grpc_web_pb.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="title class_">GreeterClient</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sendInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;send&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> streamInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> resultText = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unary call</span></span><br><span class="line">sendInput.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">HelloRequest</span>();</span><br><span class="line">    request.<span class="title function_">setName</span>(nameInput.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">sayHello</span>(request, &#123;&#125;, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">        resultText.<span class="property">innerHTML</span> = <span class="title function_">htmlEscape</span>(response.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gRPC-Web 在将 gRPC 带入前端世界的过程中，其实是牺牲了一部分重要特性的，譬如浏览器中无法实现 HTTP&#x2F;2，相对应地，gRPC-Web 不再支持客户端流和双向流，依然支持服务端流，博主猜测可能是利用了服务端发送事件(<strong>Server Sent Event</strong>)。不过，这并不影响我们对这个项目的敬意，感谢它将 gRPC 带入了前端的世界。</p>
<h1 id="gRPC-Gateway"><a href="#gRPC-Gateway" class="headerlink" title="gRPC-Gateway"></a>gRPC-Gateway</h1><p><a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a> 同样是命令行工具<code>protoc</code>的一个插件，其原理是，读取 gRPC 服务定义，并生成一个反向代理服务器，将 RESTful JSON API 转换为 gRPC 。而两者间的对应关系，则是通过<code>.proto</code>文件中的自定义选项来维护的。简单来说，就是在我们定义 gRPC 服务的同时，增加一组选项来表明这是一个 RESTful JSON API 。目前，这个插件只支持<code>Go</code>语言的代码生成。所以，如果想玩一玩这个插件，需要大家安装好<code>Go</code>的环境。</p>
<p>首先，我们从 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/protocolbuffers/protobuf/releases/tag/v3.6.1">Github</a> 下载 Protocol Buffers 的编译器，它负责从从<code>.proto</code>文件生成代码。</p>
<p>这里我们选择 Windows 版本，直接将其解压到一个非中文的路径下即可。</p>
<p><img src="https://i.loli.net/2021/06/21/eTfGF9hI6cPSlwR.png" alt="Protocol Buffers 的编译器"></p>
<p>这里，我们需要配置下面两个环境变量：</p>
<ul>
<li>PATH：C:\Program Files\Protobuf\bin</li>
<li>PROTOC_INCLUDE：C:\Program Files\Protobuf\include</li>
</ul>
<p>接下来，在<code>Go</code>环境中进行以下设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway </span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger </span><br><span class="line">go install github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过<code>Go</code>完成了<code>protoc</code>的插件的安装。此时，我们可以通过下面的命令来生成<code>Go</code>代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成Go的客户端代码</span></span><br><span class="line">protoc --proto_path=. \</span><br><span class="line">  --go_out=. \</span><br><span class="line">  --plugin=protoc-gen-go=C:\Users\Payne\go\bin\protoc-gen-go.exe \</span><br><span class="line">  ./greet.proto </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成Go的反向代理服务器端代码</span></span><br><span class="line">protoc \</span><br><span class="line">  -I C:\Users\Payne\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.9.0\third_party\googleapis\ \</span><br><span class="line">  --proto_path=. \</span><br><span class="line">  --grpc-gateway_out=. \</span><br><span class="line">  --plugin=protoc-gen-grpc-gateway=C:\Users\Payne\go\bin\protoc-gen-grpc-gateway.exe \</span><br><span class="line">  ./greet.proto </span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面两个<code>.go</code>格式的文件：</p>
<p><img src="https://i.loli.net/2021/06/22/wHvUzr5OybAtfkS.png" alt="通过 grpc-gateway 生成 Go 代码"></p>
<p>关于反向代理服务器的观点的验证，大家可以从生成的第二个文件中去发现。</p>
<p>而关于 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a> 这个插件的使用，最直观的用法，其实应该来自<code>.proto</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// Go里面的包名，必选</span><br><span class="line">option go_package = &quot;grpc-gateway/hello-word&quot;;</span><br><span class="line"></span><br><span class="line">package greet;</span><br><span class="line"></span><br><span class="line">// Google的API注解相关的.proto文件，必选</span><br><span class="line">import &quot;Protos/google/api/annotations.proto&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;</span><br><span class="line">      option (google.api.http) = &#123; </span><br><span class="line">          post: &quot;/v1/greet/sayHello&quot;</span><br><span class="line">          body: &quot;*&quot; </span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到博主并不擅长<code>Go</code>这门语言，这里我们就不再对它做进一步的探索啦！事实上，我觉得这个方案非常糟糕，因为只要修改了<code>.proto</code>文件，这个代理服务器就要重新生成，更不用说只支持<code>Go</code>这一显著的缺点啦！</p>
<h1 id="封装-Web-API"><a href="#封装-Web-API" class="headerlink" title="封装 Web API"></a>封装 Web API</h1><p>封装 Web API，这是一个非常朴实无华的方案，博主目前的公司就是采用这种方案，所以，你能想象得到，基本就是在控制器中调用客户端。唯一的弊病在于，这是一个非常低效的工作。当年，博主的前公司，就是风风火火地要这样替换掉 WCF，结果最终还是不了了之。所以说，世间没有银弹，历史不过是一次次地重复上演。下面是一个简单的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SayHello</span>(<span class="params">HelloRequestDTO requestDTO</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> request = requestDTO.Adapt&lt;HelloRequest&gt;();</span><br><span class="line">    <span class="keyword">var</span> client = _serviceProvider.GetService&lt;Greeter.GreeterClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> replay = <span class="keyword">await</span> client.SayHelloAsync(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(replay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而一旦做到这一层，其实我们是把一个未知的问题转化成一个已知的问题，这是数学家最常用的思路。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>();</span><br><span class="line">headers.<span class="title function_">append</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">   <span class="attr">headers</span>: headers,</span><br><span class="line">   <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;长安书小妆&#x27;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://localhost:44372/Greet/SayHello&quot;</span>, options)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error));</span><br></pre></td></tr></table></figure>

<p>那么，下一个问题，你打算用 Fetch API 还是 Axios 呢？这个问题就交给前端的朋友啦！因为，我是一个伪全栈工程师(逃。</p>
<h1 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h1><p>其实，读到这里，你就会明白，这才是我真正要分享的内容，而此前种种，不过是我为了丰富这个话题而抛出的它山之石。既然觉得手写 Web API 太麻烦，那么我们能不能用一种新的思路来解决这个问题呢？这里说一下博主的思路，用户传入 JSON，经过中间件反序列化为<code>.proto</code>对应的类型，我们将这个类型传递给 gRPC 的客户端作为请求参数，等拿到结果以后，我们再将它序列化为 JSON 即可。这样，我们就实现了将一个 gRPC 服务转化为 Web API 的想法。下面是具体的代码，其实这个代码并不复杂，我最初打算用反射来解决，可惜 gRPC 生成的这个客户端方法重载实在太多啦，所以，我最后决定用下面的这种方式。当然啦，缺点就和 gRPC-Gateway 一样，每一个接口都要单独写，好处大概是代码量减少了好多。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义扩展方法：AddGrpcGateway</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcGateway</span>&lt;<span class="title">TClient</span>,<span class="title">TRequest</span>,<span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">this</span> IApplicationBuilder app, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">string</span> route, </span></span></span><br><span class="line"><span class="params"><span class="function">  Func&lt;<span class="built_in">string</span>, TRequest&gt; requestBuilder, </span></span></span><br><span class="line"><span class="params"><span class="function">  Func&lt;TClient,TRequest,TResponse&gt; responseBuilder</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt; endpoints.MapPost(route, <span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> streamReader = <span class="keyword">new</span> StreamReader(context.Request.Body))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = (TClient)app.ApplicationServices.GetService(<span class="keyword">typeof</span>(TClient));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> payload = <span class="keyword">await</span> streamReader.ReadToEndAsync();</span><br><span class="line">            <span class="keyword">var</span> request = requestBuilder(payload);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> reply = responseBuilder(client, request);</span><br><span class="line">            <span class="keyword">var</span> response = JsonConvert.SerializeObject(reply);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(response));</span><br><span class="line">            context.Response.StatusCode = <span class="number">200</span>;</span><br><span class="line">            context.Response.ContentType = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，这个方案依赖 gRPC 的客户端代码，同时需要读取 HTTP 的请求体，所以，我们还需要下面的代码作为辅助：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们通过中间件配置一个路由即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议放在 UseEndpoints() 方法下面</span></span><br><span class="line">app.AddGrpcGateway&lt;Greeter.GreeterClient, HelloRequest, HelloReply&gt;(</span><br><span class="line">    route: <span class="string">&quot;greet/SayHello&quot;</span>,</span><br><span class="line">    requestBuilder: json =&gt; <span class="keyword">new</span> MessageParser&lt;HelloRequest&gt;(() =&gt; <span class="keyword">new</span> HelloRequest()).ParseJson(json),</span><br><span class="line">    responseBuilder: (client, request) =&gt; client.SayHelloAsync(request).ResponseAsync.Result</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>为了证明这个中间件真的有用，我们用 <a target="_blank" rel="noopener" href="https://www.apifox.cn/">Apifox</a>  或者 <a target="_blank" rel="noopener" href="https://www.postman.com/downloads/">Postman</a> 测试一下看看。</p>
<p><img src="https://i.loli.net/2021/06/21/hEmSVqOCy9tBbdv.png" alt="自定义中间件实现 gRPC 转 API 效果"></p>
<p>此时，可以看到，这就真的和调用一个 Web API 一样，我们完全意识不到，这是一个 gRPC 服务。你觉得，这样子算是达到目的了吗？</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，本文完全是临时想起来决定要写的一篇文章，起因就是看到了项目中有人在手动地封装 gRPC 服务为 RESTful 服务，当时就在想有没有一种方案，可以让这个过程稍微好一点点。所以，你可以认为，我写这篇博客的初衷，原来就是为了炫耀我写的那几行代码。不过，人到了一定的阶段以后，不管是写作还是思考，都似乎越来越喜欢某种框架结构，这种体验就有点像是上学时候写论文一样，虽然你明确地知道自己在做什么，可当你真正要把你的思路或者过程复述出来的时候，你还是需要有一个“文献综述”的环节。我个人以为，这是一种由外及内的认知方法，通过内外世界的对比来寻找自我提升的突破口。对于本文而言，不管是 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Web</a> 还是 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a>，从本质上来讲，它们都是 Protocol Buffers 工具链中的插件，在这个过程中发现了平时使用 gRPC 过程中被隐藏了的一部分细节，这些细节如果能和开发工具完美结合的话，就可以极大地提升我们在 gRPC 方面的开发效率，譬如 gRPC-Web 在 .NET 中的实现就利用了 MSBuild 的自定义编译任务，这就让底层的 Protocol Buffers 工具链、前端构建工具等对使用者来说是无感知的，从开发体验上就给人心旷神怡的感觉。我个人还是倾向于结合 ASP.NET Core 或者容器级别的 Envoy 来解决这个问题，我觉得应该还有更好的方案，希望大家可以在评论区写下你的想法。好啦，这篇博客就先写到这里，谢谢大家！</p>
<h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>截至 2021 年 6 月 25 日，基于中间件的方案已支持以下特性：自动注入客户端、自动配置路由。详情请参考：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway">https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway</a>。在此方案下，只需要 4 行代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClients(opt =&gt; opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...     </span></span><br><span class="line">    app.AddGrpcGateway();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-6-19-python_bili/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-6-19-python_bili/" itemprop="url">用 Python 爬取 B 站视频弹幕，生成词云图</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-19T10:00:00+00:00">
                2021-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>最近 B 站上有一个超火且非常洗脑的视频《蜜雪冰城主题曲MV 中英双语版》，视频中原来的歌词是「<strong>你爱我，我爱你，蜜雪冰城甜蜜蜜</strong>」。</p>
<p>看到有些网友在弹幕中把它篡改成「<strong>你碍我，我碍你，你学编程天灭你</strong>」，哈哈哈哈哈。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640.png" alt="图片"></p>
<p>为了弄清这些有趣的网友都在弹幕中说了啥，结合我之前学会的一点 <strong>Python 爬虫</strong>的知识，我用 Python 抓取了这个视频的所有弹幕，并将弹幕做成了如下的<strong>词云图</strong>：</p>
<p>词云图会自动将比较长的弹幕拆分成单个的词汇，之后根据单个词汇出现的频率来决定字号的大小，<strong>字号越大，说明在弹幕中出现的频率越高</strong>。</p>
<p>显而易见，出现次数最多的弹幕当属「<strong>哈哈哈哈哈哈</strong>」，即便长大了，听到这可爱的儿歌，看到这萌萌哒雪人，还是会觉得欢乐无穷。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210847892.png" alt="图片"></p>
<p>看完上面的词云图，如果你想知道词云图是怎么生成的，可以继续看下面的文章。</p>
<p>我也将用到的源码放到了 GitHub 上，有需要的朋友可以前往 GitHub 下载或复制代码，跟着我一起「<strong>改代码</strong>」，之后就能<strong>随意抓取任意 B 站视频的弹幕了</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210858176.png" alt="图片">  </p>
<p><strong>抓取 B 站视频弹幕 Python 代码</strong>：<br><a target="_blank" rel="noopener" href="https://github.com/phh95/pythonProject/tree/main/%E6%8A%93%E5%8F%96B%E7%AB%99%E5%BC%B9%E5%B9%95">https://github.com/phh95/pythonProject/tree/main/%E6%8A%93%E5%8F%96B%E7%AB%99%E5%BC%B9%E5%B9%95</a>       </p>
<p><strong>制作词云图的流程</strong>是这样的：先使用 <strong>dammu_spider.py</strong> 抓取视频的弹幕，得到一个<strong>包含所有弹幕的 txt 文件</strong>，再用 <strong>词云.py</strong> 将得到的 txt 文件导出为<strong>词云图</strong>。</p>
<h2 id="01-安装-Python"><a href="#01-安装-Python" class="headerlink" title="01. 安装 Python"></a><strong>01. 安装 Python</strong></h2><p>打开 Python 官网，下载最新版的 Python3.9.5，它支持 Windows、macOS 和 Linux 系统。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210822844.png" alt="图片"></p>
<p><strong>Python 官网地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></em></p>
<p>下载之后，打开 Python 安装程序，先勾选安装面板下方的「<strong>Add Python 3.x to PATH</strong>」，再点击「<strong>Install Now</strong>」，一直点下一步等待 Python 完成安装。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210815165.png" alt="图片来自网络"></p>
<p>安装好 Python 之后，为了确认我们配置好了 Python 环境，可以按下 <strong>Win + S</strong> 打开 Windows 自带的搜索，输入 <strong>cmd</strong>，打开「<strong>命令提示符</strong>」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210914887.png" alt="图片"></p>
<p>在打开的窗口中，输入 <strong>python</strong> 后按下回车，如果下方<strong>返回 Python 的版本号</strong>，例如我这里返回的版本号是 <strong>Python 3.9.2</strong> ，则说明 Python 已经配置妥当了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210922315.png" alt="图片"></p>
<h2 id="02-安装-Python-开发工具"><a href="#02-安装-Python-开发工具" class="headerlink" title="02. 安装 Python 开发工具"></a><strong>02. 安装 Python 开发工具</strong></h2><p>写 Python 代码有很多工具，如下图所示，这些工具被统称为 <strong>IDE</strong>，这是英文 Integrated Development Environment 的缩写，中文翻译为「<strong>集成开发环境</strong>」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210929929.png" alt="图片"></p>
<p>目前我用过的开发工具有两个，一个是社区版的 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649912923&idx=1&sn=26e8b3b8a7a12983c03781551b67b96f&chksm=83a87276b4dffb60265b4cc75eab2fe6e7992e924ad2577e2ae45af9a0f2ba1202c27f2f4670&scene=21#wechat_redirect"><strong>PyCharm</strong></a>，一个是微软推出的 VS Code。</p>
<p>如果你贪图方便的话，可以使用 PyCharm，而如果你用的是 VS Code，还需要给 VS Code 安装一个名为「<strong>Python</strong>」的插件。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210938217.png" alt="图片"></p>
<p>关于如何让 VS Code 的语言变成<strong>中文</strong>以及<strong>安装插件</strong>的问题，可以看之前我写过的一篇文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649881449&idx=1&sn=56c9016004fb2cb9960d8300c230a079&chksm=83abff44b4dc7652e2957e8dfd63c5bcca8f667731bc3fd1272aa908664695313b5e8ac0c6f7&scene=21#wechat_redirect"><strong>那些排版好看的公众号，都在偷偷用这些神器！</strong></a></p>
<p><strong>PyCharm 下载地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></em></p>
<p><strong>VS Code 下载地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></em></p>
<h2 id="03-安装第三方-Python-库"><a href="#03-安装第三方-Python-库" class="headerlink" title="03. 安装第三方 Python 库"></a><strong>03. 安装第三方 Python 库</strong></h2><p>爬取 B 站弹幕的代码中，用到了 Python 没有内置的第三方库，为了不影响后续程序的运行，我们先安装一下这些第三方库：</p>
<ul>
<li>requests</li>
<li>jieba</li>
<li>wordcloud</li>
</ul>
<p>安装这些库也非常简单，先打开 <strong>Windows</strong> 自带的「<strong>命令提示符</strong>」窗口，如果你用的是 Mac 电脑，则打开 <strong>macOS</strong> 系统自带的「<strong>终端</strong>」。</p>
<p>在命令提示符窗口中分别输入 <strong>pip3 install + 第三方库的名称</strong>，例如安装 wordcloud 库，就输入 <strong>pip3 install wordcloud</strong> 。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210950937.png" alt="图片"></p>
<p>如果程序可以顺利安装的话，在末尾会提示「<strong>Successfully installed</strong>」，至于最末尾出现的黄色警告文字「WARNING」，它是警告信息而不是报错，可以忽略它们。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210956347.png" alt="图片"></p>
<p>重复上面的操作，分别逐一安装三个第三方库 requests、jieba 和 wordcloud。</p>
<p>安装好第三方库之后，就可以开始修改代码啦。由于我在 Windows 电脑上用的 IDE 是 <strong>VS Code</strong>，下面就以 VS Code 来演示如何修改 Python 代码：</p>
<h2 id="04-修改抓取视频弹幕的代码"><a href="#04-修改抓取视频弹幕的代码" class="headerlink" title="04. 修改抓取视频弹幕的代码"></a><strong>04. 修改抓取视频弹幕的代码</strong></h2><p>在 VS Code 中使用快捷键 <strong>Ctrl + N</strong> 新建一份文档，刚开始我们需要确定我们想使用的编程语言。</p>
<p>点击文档第一行的蓝色文字「<strong>选择语言</strong>」，在弹出的输入框中输入 Python，点击下方返回的 Python。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211003487.png" alt="图片"></p>
<p>打开 GitHub 上的 danmu_spider.py 文件，用鼠标选中所有代码，右击选择「复制」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211009372.png" alt="图片"></p>
<p>将复制的代码粘贴到 VS Code 中，我们最先要更改的代码是 <strong>url 的值</strong>，这个 url 指向的是<strong>视频的弹幕地址</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211014766.png" alt="图片"></p>
<p>打开你想抓取弹幕的 B 站视频，按下 <strong>F12</strong> 键，打开<strong>浏览器开发者工具</strong>，切换到 <strong>Network</strong> 选项卡，再点击视频右侧弹幕列表的「<strong>展开</strong>」按钮。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211019811.png" alt="图片"></p>
<p>拖动开发者工具右下角的滑钮，将其拖拽到底部，接着点击弹幕列表底部的「查看历史弹幕」，随意选择一个日期。</p>
<p>例如我选择查看 <strong>6 月 10 日</strong>的弹幕，下方的开发者工具，会新增一个后缀为 <strong>data&#x3D;2020-06-10</strong> 的记录。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210656010-20210619211025852.png" alt="图片"></p>
<p>点击这条记录，在右侧展开的 General &gt;&gt; <strong>Request URL</strong>，就可以看到获取这一天的所有弹幕的链接地址，<strong>复制 Request URL 后面的 https 链接</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211031366.png" alt="图片"></p>
<p>将其粘贴到 VS Code 中的 url 处，并**将链接末尾的日期，替换为 {date}**，这是为了后面更灵活地指定抓取的弹幕所在的日期。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211035945.png" alt="图片"></p>
<p>url 上方的 range(5,18) 就可以用来指定我们想<strong>抓取哪几天的弹幕</strong>，这里的 (<strong>5,18</strong>) 意思就是我想抓取蜜雪冰城视频，从 6 月 5 号到 6 月 18 号这段时间的所有视频弹幕。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211041265.png" alt="图片"></p>
<p>至于你需要如何修改这两个参数，可以查看对应视频的<strong>历史弹幕小日历</strong>，来决定你要如何设置这两个参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211047607.png" alt="图片"></p>
<p>接着代码中要修改的参数是 <strong>cookie</strong>，这个参数记录了你的登录信息，因此只有在浏览器中<strong>登录自己的 B 站账号</strong>，才能找到这个我们需要的参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211055382.png" alt="图片"></p>
<p>cookie 同样可以在开发者工具面板中找到，在刚点开的 06-10 记录中，向下滑动右侧的滑动，就可以在 <strong>Request Headers</strong> 中看到 <strong>cookie</strong> 了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211101597.png" alt="图片"></p>
<p>将 cookie 的值复制到 VS Code 中进行替换，原本有好几行的 cookie 值会变成一行：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211107753.png" alt="图片"></p>
<p>这里复制的 cookie 值还有一个<strong>小问题</strong>，cookie 值里面包含了一个<strong>英文的单引号</strong>，这在 Python 中会让程序<strong>误以为 cookie 值到这里就结束了</strong>，实际上并没有。</p>
<p>为了解决这个问题，我们需要在这个单引号的前面加一个反斜杠 \ ，通过<strong>转义</strong>的方式，让它变成一个<strong>普通的单引号</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211205866.png" alt="图片"></p>
<p>接着还需要<strong>修改一下保存抓取的弹幕的 txt 文件的名称</strong>，名称可以随你起，可以是中文，也可以是英文，记得名称末尾需要<strong>带上格式后缀 .txt</strong> 。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211215478" alt="图片"></p>
<p>修改好以上代码之后，右击鼠标，选择「<strong>在终端中运行 Python 文件</strong>」，Python 就会开始运行当前的代码。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211221472.png" alt="图片"></p>
<p>运行程序没有报错、顺利的话，你就可以得到一个包含有多个弹幕的 <strong>txt 文件</strong>，这个文件位于 <strong>C 盘 &gt;&gt; 用户 &gt;&gt; 用户名</strong> 路径下。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211227217.png" alt="图片"></p>
<p>如果你在这个路径下找不到 txt 文件，可以使用 Windows 自带的搜索，以 txt 文件名进行搜索，应该就可以找到这个文件。</p>
<h2 id="05-修改导出词云图的代码"><a href="#05-修改导出词云图的代码" class="headerlink" title="05. 修改导出词云图的代码"></a><strong>05. 修改导出词云图的代码</strong></h2><p>得到所有弹幕文本之后，我们还需要将得到的文本再作进一步的处理，才能得到最终想要的词云图。</p>
<p>同样在 VS Code 中新建一个文档，将 GitHub 上的 <strong>词云.py</strong> 的代码复制到文档中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211239037.png" alt="图片"></p>
<p>首先修改第 6 行的代码，这里需要替换成你在上一步抓取得到的<strong>弹幕 txt 文件的名称</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211244415" alt="图片"></p>
<p>接着来到第 25、26 行代码，这里需要设置导出的词云图所使用的字体，如果你用的是 Windows 系统，那么就使用第 25 行代码，将 26 行代码删除。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211248486.png" alt="图片"></p>
<p>如果你的电脑系统是 <strong>macOS</strong>，那么就使用第 26 行代码，将字体设置为苹果系统自带的<strong>苹方字体</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210703139-20210619211253542.png" alt="图片"></p>
<p>接着来到文档的最后一行代码，这里用来<strong>设置导出的词云图的名称</strong>，同样图片的名称可以随意设置，最后别忘了加上<strong>格式后缀 .png</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210703761.png" alt="图片"></p>
<p>修改好之后，同样右击鼠标，选择「<strong>在终端中运行 Python 文件</strong>」，运行修改好的 Python 程序。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211303730.png" alt="图片"></p>
<p>程序运行完毕，和之前导出的弹幕文件相同路径下，即 <strong>C 盘 &gt;&gt; 用户 &gt;&gt; 用户名</strong> 路径，就可以看到导出的词云图了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211309259.png" alt="图片"></p>
<p>以上，就是使用 Python 抓取 B 站视频弹幕、并导出词云图的过程了，仅说明了如何修改现成的代码，如果要说清代码是如何写出的，那就要花费更多的功夫了。</p>
<p>本文的代码参考了一个视频和一篇文章，在此也一并列出，感兴趣的朋友可以去看一下：</p>
<p>[1] 【Python】爬取B站弹幕，看哪个弹幕更有梗？，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UK4y137Ye">https://www.bilibili.com/video/BV1UK4y137Ye</a>    </p>
<p>[2] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwNDY5OTI2OA==&mid=2247484638&idx=1&sn=262ff53eaafb742387ab6e936cafef9c&scene=21#wechat_redirect"><strong>Python爬取B站弹幕并制作词云图</strong></a></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a><strong>欢迎关注</strong></h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/" itemprop="url">完成新冠疫苗接种</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-18T12:00:00+00:00">
                2021-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%A7%82%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">观点</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>今天终于完成了在两针新冠疫苗的接种程序，打完没有什么不良反应。不过按照现在这个变异病毒蔓延的情况看，可能还需要第三针加强针疫苗，也不知道什么时候能安排上。</p>
<p>按照不同年龄层，香港对新冠疫苗的接种安排了不同的时间，而且需要现在网上预约两针接种的日期和地点。接种的疫苗有 BNT &#x2F;复兴的“复必泰” mRNA 疫苗和科兴的“克尔来福”灭活疫苗两种选择，我选择了国产的科兴“克尔来福”灭活疫苗。提供科兴疫苗接种的社区疫苗接种中心离我还挺近的，走路就能到。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/EFCore%20%E5%AE%9E%E4%BD%93%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E5%BA%93%EF%BC%9AEFCore.NamingConventions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/EFCore%20%E5%AE%9E%E4%BD%93%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E5%BA%93%EF%BC%9AEFCore.NamingConventions/" itemprop="url">EFCore 实体命名约定库：EFCore.NamingConventions</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-17T08:37:11+00:00">
                2021-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在软件开发过程中，数据库永远都是绕不开的一个话题。有时候，我们甚至会因此而获得一个名字——“<strong>CURD Boy</strong>”。虽然不过是朴实无华的“<strong>增删查改</strong>”，可隐隐然早已分出了无数的流派。在这些不同的流派中，有的人坚持“<strong>我手写我心</strong>”，认为手写<code>SQL</code>才是真正的王道，没有读过&#x2F;写过成百上千行的存储过程，便不足以谈论程序员的人生。而有的人喜欢<code>ORM</code>的清晰、整洁，认为数据库和面向对象存在着天然抗阻，<code>ORM</code>更有利于推进<code>DDD</code>和微服务的落地。相信大家都听说过<code>Java</code>里的<code>SSH</code>框架，从<code>Hibernate</code>到<code>Mybatis</code>再到<code>Spring Data JPA</code>，可以说这种争论一直没有停止过。这里我们不打算讨论这个问题，我们平时使用<code>EF</code>或者<code>EFCore</code>的过程中，作为连接数据库和面向对象两个异世界的桥梁，<code>ORM</code>需要我们来告诉它，实体数据与数据库表字段的映射关系，所以，经常需要通过<code>数据注解</code>或者<code>Fulent API</code>来写各种配置。那么，有没有什么方案可以让我们偷这个懒呢？下面隆重请出本文的主角：<a target="_blank" rel="noopener" href="https://github.com/efcore/EFCore.NamingConventions">EFCore.NamingConventions</a>。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><a target="_blank" rel="noopener" href="https://github.com/efcore/EFCore.NamingConventions">EFCore. NamingConventions</a>，目前由一个非官方的组织进行维护，代码托管在 Github 上，100％的开源项目。</p>
<p>如果你希望直接使用它的话，可以直接通过<code>NuGet</code>进行安装：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package EFCore.NamingConventions  </span><br></pre></td></tr></table></figure>

<p>接下来，我们只需要在<code>DbContext</code>的  <code>OnConfiguring()</code>方法中，调用它提供的扩展方法即可： </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span>  </span><br><span class="line">=&gt; optionsBuilder  </span><br><span class="line">.UseSqlite(<span class="string">&quot;Data Source=Chinook.db&quot;</span>)</span><br><span class="line">.UseSnakeCaseNamingConvention();  </span><br></pre></td></tr></table></figure>

<p>或者，你可以使用依赖注入的方式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;ChinookContext&gt;(options =&gt; </span><br><span class="line">    options.UseSqlite(<span class="string">&quot;Data Source=Chinook.db&quot;</span>)</span><br><span class="line">          .UseSnakeCaseNamingConvention()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里我以<code>SQLite</code>数据库为例，来展示它的具体使用细节。事实上，它提供了 4 种命名约定的策略：</p>
<ul>
<li>UseSnakeCaseNamingConvention: <code>FullName</code> -&gt; <code>full_name</code></li>
<li>UseLowerCaseNamingConvention: <code>FullName</code> -&gt; <code>fullname</code></li>
<li>UseCamelCaseNamingConvention: <code>FullName</code> -&gt; <code>fullName</code></li>
<li>UseUpperCaseNamingConvention: <code>FullName</code> -&gt; <code>FULLNAME</code></li>
</ul>
<p>简单来说，就是当我们的实体中存在一个属性<code>FullName</code>时，它会告诉<code>EF</code>或者<code>EFCore</code>，这个属性<code>FullName</code>对应的表字段是什么。  </p>
<p>虽然，在大多数的场景中，我们都希望属性名称和表字段一致，可你要知道，像<code>Oracle</code>这种对大小写敏感的数据库，特别喜欢自作聪明地帮你全部改成大写。</p>
<p>所以，在上家公司工作的时候，为了兼容<code>Oracle</code>这病态的癖好，公司里有个不成文的规定，那就是：所有实体的属性名称最好都大写。</p>
<p>本来大家用驼峰命名就是为了好认单词，好家伙！这下全部大写了，一眼望过去简直就是灾难，因为没有办法做到“<strong>望文生义</strong>”，如果那个时候知道这个库的存在，是不是就能解决这个问题了呢？</p>
<h1 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h1><p>下面我们以<code>UseSnakeCaseNamingConvention</code>为例，结合<code>SQLite</code>来做一个简单的例子。</p>
<p>首先，我们定义必要的实体，并为<code>DbContext</code>配置实体命名约束规则：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artist</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Artist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，通过迁移命令来生成数据库架构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration &quot;Init-Database&quot; -Context ChinookContext</span><br><span class="line">Update-Database</span><br></pre></td></tr></table></figure>

<p>可以注意到，生成的数据库表字段会以小写+下划线的方式命名。这就是所谓的实体命名约束。</p>
<p><img src="https://i.loli.net/2021/06/18/cSVRWrDTbnv29Ze.png" alt="通过实体命名约束生成的 Album 表"></p>
<p>只要大家都看着这个约定来写实体的属性，这套机制就可以完美工作。它和<code>MVC</code>里的默认路由一样，都是属于一种“<strong>约定大于配置</strong>”的方案。</p>
<p>在我看来，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。</p>
<p>以上就是<code>EFCore.NamingConventions</code>的基本用法，更多的细节大家可以去阅读它的<code>README</code>，因为这个库需要结合迁移功能来使用，所以，如果要在已存在的表上应用这套约束规则时，建议大家还是小心谨慎一点。</p>
<p>我个人觉得，它可以方便团队去制定一套数据库规范，进而去约束开发人员写出更规范的命名。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了可用于<code>EFCore</code>的实体命名约束库：<code>EFCore.NamingConventions</code>。这是一个由社区维护的、开源的项目，它可以在创建<code>DbContext</code>的时候，指定一个实体命名约束规则，即实体属性如何与数据库表字段进行对应，这是一种约定大于配置的方案，一旦团队形成了属于自己的数据库命名风格，那么，研发人员只需要按照规范为实体属性命名，例如开发人员可以使用驼峰风格的命名，而数据库管理员则可以使用下划线风格的命名。这样，就可以省略一部分字段映射的配置代码，从而提高团队研发的效率。值得说明的一点是，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-06-13-the-mindset-book-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-06-13-the-mindset-book-summary/" itemprop="url">谈谈心智控制 - 读《终身成长》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-13T15:44:56+00:00">
                2021-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/mindset-book-1.jpg" class="">

<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近看了一本畅销书《终身成长》，里面主要对比两种思维：固定型思维和成长型思维。</p>
<p>固定型思维把任何挫折当做对自己的否定，而成长型思维把这个看做通往成功的必经之路。</p>
<p>有趣的是，这类思想的书我看了很多。从《和时间做朋友》到《为什么佛教是真的》；从《真实的幸福》到《终身成长》；从《假性亲密关系》到《情感吸血鬼》，我发现大家讲的都是一件事情：心智控制。</p>
<p>于是我打算再把这几本书里面讲到的心智控制整理一下分享给大家。</p>
<h2 id="二、认识自己的大脑和情绪"><a href="#二、认识自己的大脑和情绪" class="headerlink" title="二、认识自己的大脑和情绪"></a>二、认识自己的大脑和情绪</h2><img src="/images/mindset-book-2.jpg" class="">

<p>我们还是得提到《头脑特工队》这个电影，这个电影把人的不同情绪分解成了几个不同的自我，当这几个自我打架的时候，谁占上风谁就主导了行为。</p>
<p>最后，人类的“叙事自我”会为自己的所有行为提供一个看似合理的解释，但这个解释只是为了让自我接受自己的行为。</p>
<p>所以说，人的大脑是一个菜市场，谁的声音大最后就听谁的。当你害怕的时候，“害怕”自我声音最大；当你高兴的时候，“愉悦”自我声音最大。</p>
<p>但是，《为什么佛教是真的》这本书里面就说了，这些“自我”其实都不是真正的自己。因为这些“自我”会绑架你的行为，让你难受。</p>
<p>人类千百万年的进化，使得人们对于一个快乐的事情的愉悦感，会随着刺激的次数变多而降低。比如你第一次吃某种美食特别好吃，但是你每天都吃的话，你就会觉得味道也就那样了；你刚住进大房子觉得特别舒服，但是住久了你也又习惯了。即便是吸毒，一个瘾君子也是需要不断加大剂量，才能够保持自己的快感。所以你看，如果你一味追求快乐，你会越来越难以获得快乐，快乐总是短暂的。</p>
<p>如果快乐难以获得，那是不是说，人类就是应该受苦一辈子呢？不是的。</p>
<h2 id="三、糟糕的情绪控制"><a href="#三、糟糕的情绪控制" class="headerlink" title="三、糟糕的情绪控制"></a>三、糟糕的情绪控制</h2><img src="/images/mindset-book-3.jpg" class="">

<p>当你明白情绪容易控制你，快乐总是短暂这些事实之后，你要学会的是通过“跳出坏情绪”的方式来控制情绪。但是很多人不能掌握这种技巧，大家惯用的手段有两个：发泄情绪和压抑情绪。</p>
<p>发泄情绪很好理解，人们通过呼喊、争吵、哭泣，甚至动手打架来将情绪释放出来。这种方式是很好的疏解情绪的方式，但终归自己内心还是受到了压力。</p>
<p>压抑情绪比起发泄情绪看起来没有什么特别的行为变化，但是通常这种情绪的负能量会向内传达，最终引起心理压力。心理压力进一步也会影响生理，造成自己容易失眠、焦虑、抵抗力下降等等。我有一年得胃病，很大程度就是因为压力太大造成胃酸过多。</p>
<p>如果你有了坏情绪，还是应该释放出来。每个小孩都会这个事情，成年人反倒会压抑情绪，其实是不好的。</p>
<p>但是最好的办法，还是下面提到的不产生负面情绪的办法。</p>
<h2 id="四、好的情绪控制"><a href="#四、好的情绪控制" class="headerlink" title="四、好的情绪控制"></a>四、好的情绪控制</h2><p>《真实的幸福》、《终身成长》和《假性亲密关系》都介绍了这种情绪控制方法：简单来说就是用乐观的一面来看待原本糟糕的结果。</p>
<p>任何事情都是有两面的。如果你看乐观的一面，那么你就有可能不会产生负面情绪。</p>
<p>聚个例子：我当年做胃镜感觉特别难受。但是当我给别人提起这件事情的时候，我会这么说：“你没做过胃镜吧？只有做过胃镜人生才算完整，那个感觉一辈子都忘不了，推荐你下次试试。”</p>
<p>《终身成长》里面有大量的案例，比如你很喜欢的科目考砸了，如果你乐观一点看，这说明你又可以在自己喜欢的科目上继续提高了。你想，如果一个你喜欢的事情已经做到极致了，那会是一件多么无聊的事情。</p>
<p>平时很多时候大家都可以训练自己乐观处理情绪的能力。比如我最近老加班，但是我就想：明天肯定比今天会好一点，再加把劲。</p>
<img src="/images/mindset-book-4.jpg" class="">

<p>《为什么佛教是真的》主要介绍了“冥想”这个技巧，通过冥想让自己能够站在上帝视角审视自己的情绪。这样当负面情绪产生的时候，你就会以一种同情和理解的方式接纳这个情绪，而不是被这个情绪控制。</p>
<p>关于冥想我练习很少，但是我特别理解它的那种控制情绪的目标。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>1、人的行为由多个“自我”共同决定。</p>
<p>2、糟糕的情绪需要宣泄和化解，压抑情绪是不好的。</p>
<p>3、用乐观的角度看问题，就可以很大程度上避免负面情绪。</p>
<p>4、冥想有助于控制负面情绪。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP-NET-Core-gRPC-%E9%9B%86%E6%88%90-Polly-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP-NET-Core-gRPC-%E9%9B%86%E6%88%90-Polly-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" itemprop="url">ASP.NET Core gRPC 集成 Polly 实现优雅重试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-07T07:19:11+00:00">
                2021-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在上一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1657075397/">博客</a> 中，我们一起探索和实现了<code>gRPC</code>的健康检查。从服务治理的角度来看，健康检查保证的是被调用的服务“健康”或者“可用”。可即使如此，我们依然会遇到，因为网络不稳定等原因而造成的服务调用失败的情形，就如同我们赖以生存的这个真实世界，本身就充满了各种不确定的因素一样，“<strong>世间唯一不变的只有变化本身</strong>”。不管是面对不稳定的服务，还是面对不确定的人生，任何时候我们都需要有一个 B 计划，甚至我们人生中的一切努力，本质上都是为了多一份自由，一份选择的自由。在微服务的世界里，我们将这种选择称之为“<strong>降级(Fallback)<strong>”，如果大家有接触过 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/App-vNext/Polly">Polly</a> 这类框架，就会明白我这里的所说的“</strong>降级</strong>”具体是什么。在众多的“<strong>降级</strong>”策略中，<strong>重试</strong>是一种非常朴素的策略，尤其是当你调用一个不稳定的服务的时候。</p>
<p><img src="https://i.loli.net/2021/06/09/GIBVj3sKb5zMeE1.jpg" alt="重试"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在此之前，博主曾经介绍过 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2070070822/">HttpClient</a> 的重试。所以，今天这篇博客我们来聊聊<code>gRPC</code>的客户端重试，因为要构建一个高可用的微服务架构，除了需要高可用的服务提供者，同样还需要高可用的服务消费者。下面，博主将由浅入深地为大家分享 4 种重试方案的实现，除了 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1">官方</a> 内置的方案，基本上都需要搭配 Polly 来使用，所以，到这里你可以理解这篇博客的标题，为什么博主会 <a target="_blank" rel="noopener" href="https://music.163.com/#/song?id=167720">毁人不倦</a> 地尝试不同的重试方案，因为每一种方案都有它自身的局限性，博主想要的是一种更优雅的方案。具体来讲，主要有：<strong>基于 gRPC RetryPolicy</strong>、<strong>基于 HttpClientFactory</strong>、<strong>基于 gRPC 拦截器</strong> 以及 <strong>基于 CallInvoker</strong>  4 种方案。如果大家还有更好的思路，欢迎大家在博客评论区积极留言、参与讨论。</p>
<h1 id="基于-gRPC-RetryPolicy"><a href="#基于-gRPC-RetryPolicy" class="headerlink" title="基于 gRPC RetryPolicy"></a>基于 gRPC RetryPolicy</h1><p>所谓的 gRPC RetryPolicy，其实是指 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1">官方</a> 提供的暂时性故障处理方案，它允许我们在创建<code>GrpcChannel</code>的时候，去指定一个重试策略：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    RetryPolicy = <span class="keyword">new</span> RetryPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        InitialBackoff = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        MaxBackoff = TimeSpan.FromSeconds(<span class="number">5</span>),</span><br><span class="line">        BackoffMultiplier = <span class="number">1.5</span>,</span><br><span class="line">        RetryableStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>MethodConfig</code>可以为指定的方法配置一个重试策略，当传入的方法名为<code>MethodName.Default</code>时，它将应用于该通道下的所有 gRPC 方法。如你所见，在重试策略中我们可以指定重试次数、重试间隔等参数。<strong>这个方案本身没有太多心智上的负担，唯一的缺点是，它没有预留出可扩展的接口</strong>，以至于我们想要验证它到底有没有重试的时候，居然要通过<code>Fiddler</code>抓包这种方式，换句话讲，我们没有办法自定义整个重试行为，譬如你想在重试过程中记录日志，这种方案就会鸡肋起来，<strong>对使用者来说，这完全就是一个黑盒子</strong>。</p>
<p><img src="https://i.loli.net/2021/06/09/QzjaH4VqWMnEFcb.png" alt="官方自带的 “黑盒子” 重试机制"></p>
<p>除此之外，官方还提供了一种成为 <code>Hedging</code> 重试策略作为备选方案。类似地，它通过 <code>HedgingPolicy</code> 属性来指定重试策略。对比 <code>RetryPolicy</code>，它可以同时发送单个 gRPC 请求的多个副本，并使用第一个成功的结果作为返回值，所以，<strong>一个显而易见的约束是，它要求这个 gRPC 方法是无副作用的、幂等的函数</strong>。其实，这是所有重试方案都应该考虑的一个问题，而不单单是 <code>HedgingPolicy</code>。由于这两种策略有着本质上的不同，请记住：<strong>RetryPolicy 不能与 HedgingPolicy 一起使用。</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    HedgingPolicy = <span class="keyword">new</span> HedgingPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        NonFatalStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>世间的一切都是双刃剑， <code>HedgingPolicy</code> 同样打不破这铁笼一般的人间真实，虽然它可以一次发送多个<code>gRPC</code>请求，可毫无疑问的是，<strong>这是一种相当浪费的策略，因为不管有多少个请求，它始终都取第一个结果作为返回值，而剩余的结果都将会被直接抛弃</strong>。想想每一年的高考状元，大家是不是都只记住了第一名。也许，人生正是如此呢，程序世界固然是由 0 和 1 构成的虚幻世界，可何尝就不是真实世界的某种投影呢？这里请允许博主安利一部动漫<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/30401194/">《你好世界》</a>，它用视觉化的方式表达了真实世界与程序世界的某种特殊联系。</p>
<h1 id="基于-HttpClientFactory"><a href="#基于-HttpClientFactory" class="headerlink" title="基于 HttpClientFactory"></a>基于 HttpClientFactory</h1><p>接下来，我们要介绍的是基于 <code>HttpClentFactory</code> 的重试方案。也许，大家会感到困惑，明明这篇博客说的是 <code>gRPC</code> ，为什么 <code>HttpClientFactory</code> 会出现在这里呢？其实，很多时候，我们看到的只有表面，而出奇制胜的招式往往出自你对于本质的理解。如果大家阅读过 <code>gRPC</code> 客户端部分的源代码，就会意识到这样一件事情，即，<code>gRPC</code> 底层依然用到了 <code>HttpClient</code> 这套所谓“管道式”的体系，你可以理解为，最终传输层还是要交给 <code>HttpClient</code> 来处理，而 <code>HttpClientFactory</code> 本来就支持结合 <code>Polly</code> 进行重试，所以，我们其实是针对同一个问题的不同阶段进行了切入处理。一旦想清楚这一点，下面的代码理解起来就没有难度啦：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt; &#123;</span><br><span class="line">    opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ConfigurePrimaryHttpMessageHandler(() =&gt; <span class="keyword">new</span> HttpClientHandler &#123;</span><br><span class="line">    ClientCertificateOptions = ClientCertificateOption.Manual,</span><br><span class="line">    ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) =&gt; <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddPolicyHandler(</span><br><span class="line">    HttpPolicyExtensions.HandleTransientHttpError()</span><br><span class="line">    .OrResult(res =&gt; res.StatusCode != System.Net.HttpStatusCode.OK)</span><br><span class="line">    .WaitAndRetryAsync(</span><br><span class="line">      <span class="number">6</span>, </span><br><span class="line">      retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)) + TimeSpan.FromMilliseconds(<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">100</span>)), </span><br><span class="line">      (result, timeSpan, current, context)=&gt; &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;StatusCode=<span class="subst">&#123;result.Result?.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;Exception=<span class="subst">&#123;result.Exception?.Message&#125;</span>&quot;</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalMilliseconds&#125;</span>秒&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">await</span> serviceProvider.GetService&lt;Greeter.GreeterClient&gt;().SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，为了模拟网络不畅的这种场景，我们故意指定了一个错误的终结点信息。此时，我们会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/06/09/5yamSqIzbH3heXF.png" alt="基于 HttpClientFactory 的重试方案"></p>
<p>不过话又说回来，因为我们选择切入的阶段是“<strong>传输层</strong>”，所以，相对于整个 <code>RpcException</code> 而言，我们其实是找到了一个问题的子集，这意味着这个方案并不能覆盖到所有的场景，如果是在非“<strong>传输层</strong>”引发了某种异常，我们就没有办法通过这种方式去做重试处理。所以，我在一开始就说过，没有 100% 完美的解决方案，每一种方案都有它自身的局限性，这句话在这里得到了第一次印证。如果大家再回过头去看第一种方案，是不是就会发现，它里面还是使用了<code>HTTP</code>状态码作为是否重试的判断依据。所以，大家觉得呢？欢迎大家在评论区留下你的想法。</p>
<h1 id="基于-gRPC-拦截器"><a href="#基于-gRPC-拦截器" class="headerlink" title="基于 gRPC 拦截器"></a>基于 gRPC 拦截器</h1><p>关于 <code>gRPC</code> 的拦截器，博主专门写过一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1679688265/">博客</a> 来介绍它，所以，在一开始考虑重试方案的时候，拦截器其实是最容易想到的一种方案，主要思路是利用 <code>Polly</code> 中<code>Policy</code>的<code>Execute()</code>方法，对拦截器中获取<code>gRPC</code>调用结果的过程进行包装，我们一起来看下面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    TRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">    ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryPolicy =</span><br><span class="line">        Policy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;</span><br><span class="line">        .Handle&lt;RpcException&gt;(s =&gt; s.StatusCode == StatusCode.Internal)</span><br><span class="line">        .Or&lt;WebException&gt;()</span><br><span class="line">        .OrResult(r =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> awaiter = r.GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (awaiter.IsCompleted)</span><br><span class="line">                <span class="keyword">return</span> r.GetStatus().StatusCode == StatusCode.OK;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.ResponseAsync.Wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AggregateException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .WaitAndRetryAsync(<span class="number">3</span>, x =&gt; TimeSpan.FromSeconds(<span class="number">5</span>), (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retryPolicy.ExecuteAsync(() =&gt; Task.FromResult(continuation(request, context))).Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 <code>gRPC</code> 拦截器的这种方案，它最大的问题在于异常的颗粒度太大，这句话是什么意思呢？简单来讲就是在拦截器这个层面上，你能捕捉到的只有<code>RpcException</code>，这样就使得我们难以捕获更小粒度的异常，譬如网络异常、超时异常等等。其次，<code>gPRC</code> 拦截器中大量使用了，类似<code>AsyncUnaryCall&lt;TResponse&gt;</code>这样的异步的返回值类型，这让我们在编写 Policy 的时候，多多少少会有一点不自在。综上所述，这个最容易想到的方案，本身是没有太大的问题的，最关键的问题是我们能接受什么样的异常颗粒度。而像异步返回值这种问题，只要写过一次以后，博主以为，它并不会成为我们继续探索的阻碍，这一点大家可以自己去体会。</p>
<p>在尝试基于拦截器的重试方案的过程中，博主发现，指定一个错误的终结点信息，<code>gRPC</code>会在进入拦截器前就引发异常。这意味着这种基于拦截器的重试方案，在面对“<strong>传输层</strong>”的异常时略显乏力，所以，从某种程度上来讲，这个方案同样是一个不完美的方案。可这世上人来人往、本无完人，我们实在没有必要耽于技术方案的绝对完美而不可自拔，当求真、莫求执，所谓“<strong>大成若缺</strong>”，可以欣赏得来缺憾之美，同样是一种幸福。</p>
<h1 id="基于-CallInvoker"><a href="#基于-CallInvoker" class="headerlink" title="基于 CallInvoker"></a>基于 CallInvoker</h1><p>如果说，前面的 3 种方案都属于“<strong>见招拆招</strong>”的外家功夫。那么，接下来我要分享的思路，绝对可以称得上是“<strong>打通任督二脉</strong>”的玄门内功。</p>
<p><img src="https://i.loli.net/2021/06/09/IOwrYtdLXGxMeHf.png" alt="gRPC客户端底层原理说明"></p>
<p>首先，博主想用一张图来讲解 <code>gRPC</code> 客户端的工作原理。从这张图中，我们可以看出，初始化一个<code>gRPC</code>的客户端，主要有<code>GrpcChannel</code>和<code>CallInvoker</code>两种构造形式，而<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法会返回<code>HttpClientCallInvoker</code>的一个实例。此时，我们就会发现，<code>HttpClientCallInvoker</code>是<code>CallInvoker</code>的一个子类。所以，我们基本可以判定<code>CallInvoker</code>是一个扮演着重要角色的类。继续探索，我们就会发现，<code>GrpcCallInvokerFactory</code>内部通过构造<code>GrpcChannel</code>，进而实现了<code>CreateCallInvoker()</code>方法，换句话说，本质上依然是调用了<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法。最终，这个<code>CallInvoker</code>实例会作为参数，传递给<code>DefaultClientActivator</code>的<code>CreateClient()</code>方法，至此我们就完成了整个<code>gRPC</code>客户端的创建工作。</p>
<p>好了，相信现在大家都有一个疑问，这个<code>CallInvoke</code>到底是个什么东西呢？为什么它在整个<code>gRPC</code>的底层中是如此的重要呢？其实，它就是一个平平无奇的抽象类啦，可是一旦配合着<code>gRPC</code>中的<code>Calls</code>类来使用，这个<code>CallInvoker</code>简直就是扩展<code>gRPC</code>的一个重要的桥梁，因为我们不用关心底层是如何处理<code>gRPC</code>请求&#x2F;响应的，而这丝毫不影响我们对这个过程进行自定义重写。因此，按照这样的思路，我们有了下面的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GrpcCallInvoker</span> : <span class="title">CallInvoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Channel _channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcPollyPolicyOptions _pollyOptions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcCallInvoker</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        GrpcPollyPolicyOptions pollyOptions</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _channel = channel;</span><br><span class="line">        _pollyOptions = pollyOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncClientStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncClientStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncDuplexStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncServerStreamingCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncServerStreamingCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TResponse <span class="title">BlockingUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;TResponse&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.BlockingUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想，经过连续三篇文章的洗礼，大家对这些方法应该都不陌生了吧！下面我们来着重讲解下<code>CreateCall()</code>和<code>CreatePollyPolicy()</code>这两个方法。其中，<code>CreateCall()</code>这个方法会相对简单一点，因为它完全就是返回<code>gRPC</code>的内置类型<code>CallInvocationDetails</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CallInvocationDetails</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">CreateCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    Method&lt;TRequest, TResponse&gt; method,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> host,</span></span></span><br><span class="line"><span class="params"><span class="function">    CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TRequest : <span class="keyword">class</span></span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TResponse : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallInvocationDetails&lt;TRequest, TResponse&gt;(_channel, method, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，<code>CreatePollyPolicy()</code>这个方法就非常的明确啦，通过注入的<code>GrpcPollyPolicyOptions</code>来构造一个Policy。考虑到我们要做的是一个通用的方案，这里预留了<strong>断路器</strong>、<strong>重试</strong>、<strong>超时</strong>三种不同策略的参数。如果希望对构建 Policy 的过程进行自定义，则可以通过重写该方法来实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Policy</span>&lt;<span class="title">TResult</span>&gt; <span class="title">CreatePollyPolicy</span>&lt;<span class="title">TResult</span>&gt;()</span></span><br><span class="line">&#123;</span><br><span class="line">    Policy&lt;TResult&gt; policy = <span class="literal">null</span>; ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造断路器策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.CircuitBreakerCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyBreaker = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Exception&gt;()</span><br><span class="line">            .CircuitBreaker(_pollyOptions.CircuitBreakerCount, _pollyOptions.CircuitBreakerTime);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? policyBreaker :</span><br><span class="line">                    policy.Wrap(policyBreaker) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.CircuitBreaker.BrokenCircuitException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超时策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.Timeout &gt; TimeSpan.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyTimeout = Policy.Timeout(() =&gt; _pollyOptions.Timeout, Polly.Timeout.TimeoutStrategy.Pessimistic);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? (Policy&lt;TResult&gt;)policyTimeout.AsPolicy&lt;TResult&gt;() :</span><br><span class="line">        policy.Wrap(policyTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.Timeout.TimeoutRejectedException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造重试策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.RetryCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy&lt;TResult&gt;.Handle&lt;Exception&gt;().WaitAndRetry(</span><br><span class="line">          _pollyOptions.RetryCount, </span><br><span class="line">          x =&gt; _pollyOptions.RetryInterval, </span><br><span class="line">          (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalSeconds&#125;</span>秒&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? retryPolicy :</span><br><span class="line">            policy.Wrap(retryPolicy) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们无法修改<code>DefaultGrpcClientFactory</code>中关于<code>CallInvoker</code>这部分的逻辑，所以，我们采取了下面的“<strong>迂回战术</strong>”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc();</span><br><span class="line">services.AddTransient&lt;GrpcCallInvoker&gt;();</span><br><span class="line">services.AddTransient&lt;Channel&gt;(sp =&gt; <span class="keyword">new</span> Channel(<span class="string">&quot;localhost&quot;</span>, <span class="number">5001</span>, ChannelCredentials.Insecure));</span><br><span class="line">services.AddTransient&lt;GrpcPollyPolicyOptions&gt;(sp =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GrpcPollyPolicyOptions()</span><br><span class="line">    &#123;</span><br><span class="line">        RetryCount = <span class="number">10</span>,</span><br><span class="line">        RetryInterval = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        CircuitBreakerCount = <span class="number">5</span>,</span><br><span class="line">        CircuitBreakerTime = TimeSpan.FromSeconds(<span class="number">6</span>),</span><br><span class="line">        Timeout = TimeSpan.FromSeconds(<span class="number">10</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callInvoker = services.BuildServiceProvider().GetService&lt;GrpcCallInvoker&gt;();</span><br><span class="line"><span class="keyword">var</span> client = (Greeter.GreeterClient)Activator.CreateInstance(<span class="keyword">typeof</span>(Greeter.GreeterClient), callInvoker);</span><br><span class="line">client.SayHello(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，如果我们故意写一个错误的终结点地址，我们将会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/06/09/m67kG1hDfgyPJKs.png" alt="基于 CallInvoker 的重试方案"></p>
<p>因为重试 5 次后就会启动断路器，所以，这个接口在重试 5 次后就立即停止了调用，这证明我们设想的这个方案是可以完美工作的！</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完以后，突然发现这一篇的信息量有点爆炸，尤其是<code>CallInvoker</code>这一部分，需要花点时间去阅读 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-dotnet">gRPC</a> 的源代码。可对于博主而言，其实更加享受的是，探索 <code>gRPC</code> 重试方案的这个过程。起初，因为对拦截器更熟悉一点，所以，我最先想到的是基于拦截器的重试方案。经过博主一番验证以后，发现这是一个有缺陷的方案。这时候，我意外发现，官方提供了重试策略，可这个重试策略对于使用者来说是一个黑盒子。再后来，发现可以在 HttpClient 上做一点文章，虽然它针对的是“<strong>传输层</strong>”这个阶段。直到从网上查资料，意识到可以重写<code>CallInvoker</code>这个抽象类，这个时候终于找到了最完美的方案。所以，通过这个过程，大家可以发现，我这篇博客的写作过程，其实与我思考过程有着明显的不同。思考的过程中带入“<strong>先入为主</strong>”的意识，这让我的思考过程走了不少的弯路，而写作过程则是一个由浅入深、由表及里的顺序。也许，下一次遇到类似的问题，我会先了解一下官方有没有提供标准方案，这是我在写完这篇博客以后最大的一个感悟。好了，这篇博客就先写到这里啦，如果大家对文中的内容由意见或者建议，欢迎大家在评论区给我留言，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-6-4-100flag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-6-4-100flag/" itemprop="url">✅连续日更公众号100天完成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-04T14:00:00+00:00">
                2021-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>音乐：<a target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/albumDetail/003IAzUi25muDF">李健 - Marine玛琳娜</a></p>
<p>Hello 大家好，我是安哥。</p>
<p>如约而至，今天刚好是我的公众号「效率工具指南」连续日更的第 100 天。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227889661171.jpg" alt="-w636"></p>
<p>最开始想日更的时候，我写了这么一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904522&idx=1&sn=fed827fe64310e6cfcc5afb9d06697a0&chksm=83a851a7b4dfd8b1b51e8abeeeeb946a044333135e37343ad063cfb91fb440ea19e0771133b9&token=2050480873&lang=zh_CN#rd">日更公众号的好处</a></p>
<p>后来觉得，上面这篇文章写得还是有点虚，不够接地气，后来还补写了另外一篇：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904906&idx=1&sn=bb9769c4f9aaf80648510b56355f4dc8&chksm=83a85327b4dfda31d3c6a4a95ca7da3be5c01e009a055f4acc6e9af512f38c3d33364c07ccbc&token=2050480873&lang=zh_CN#rd">写公众号能赚多少钱？</a></p>
<p>不整虚的，想让你看看我从写东西中赚到的钱，数额不多，就像一位朋友在评论区说的：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227910201100.jpg" alt="-w862"></p>
<p>这些物质激励虽然不多，但对我来说还是挺重要的，因为这是对我能够把写东西这件事坚持下来的一个重要驱动力。</p>
<p>人性中都有一个弱点，或者说是我们与生俱来受到的一个约束——生命有限、没有耐心，多数人都没有办法长时间做一件反馈周期长、付出了很多时间却看不到回报的事情。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227902471773.jpg" alt="-w747">图片来自书籍《薛兆丰的经济学讲义》</p>
<p>正因为这样，我们需要及时给自己制造反馈，或者说<strong>打造最小闭环</strong>，常见的例如小时候经常会有的事情：</p>
<blockquote>
<p>妈妈答应你，假设你这次考试能拿 85 分，就给你买一个游戏机。</p>
</blockquote>
<p>而写东西，其实也可以给自己制造一些比较短的、获取收益的闭环，例如我现在能想到的，就是去知乎上推荐好物，当有人买了你推荐的好物或者通过你的好物链接购买了电台平台的商品，你就可以获得平台返回给你的佣金。</p>
<p>虽然钱并不太多，但这也算是一种人为打造的写作的最小闭环的方法：</p>
<blockquote>
<p>从写东西中赚到钱 ➡️ 会让你坚定「写作能赚到钱」的想法，或者到把赚到的钱再投入于写作中，例如购买一台 Mac，有更舒适地码字体验 ➡️ 有了更多动力，继续写东西，继续赚到钱</p>
</blockquote>
<p>以此循环下去。</p>
<h2 id="到底为什么要日更？"><a href="#到底为什么要日更？" class="headerlink" title="到底为什么要日更？"></a>到底为什么要日更？</h2><p>从心底里说，我们那么辛苦地打拼，为的都是拥有更多的自由、拥有更多的闲暇，不去做那些我们不想做的事。</p>
<p>当我发现，老老实实打一份工并不会让人有足够的自由时，我就觉得还是得在工作之余干点自己的事情，得到 App 的万维钢老师也把个人在工作之余干的有意义的事情称为「秘密项目」。</p>
<p>至于想日更，我只是想着在今年做点不一样的事情，做一点之前没有做过的事情，原本只想着日更超过 30 天后就停下来，但后来收到了<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649911131&idx=1&sn=052ccfec34336842339b179f3b7014b5&chksm=83a86b76b4dfe260dbe386ce7136b0845d3db2cd63cc534326b93dd99a5eddefa1ba26a7a0f7&token=2050480873&lang=zh_CN#rd">女票的鼓励、看到一些日更同行者的坚持✊</a>，因此在日更到 45 天的时候，立下了一个新的 flag：要坚持日更到第 100 天。</p>
<p>很开心，我今天做到了，是时候可以停下来缓一缓了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16228099740580.jpg" alt="-w745"></p>
<p>此外，日更这件事，在一定程度上也和自己的工作相辅相成，在过去的 100 天里，我写的绝大多数文章都是工具文，这和我在工作中要写的东西是一致的，因此之前写的文章，不少都可以发在公司的号上。</p>
<h2 id="日更可以链接到更多的人吗？"><a href="#日更可以链接到更多的人吗？" class="headerlink" title="日更可以链接到更多的人吗？"></a>日更可以链接到更多的人吗？</h2><p>我看到一些同在日更的朋友，在谈及日更的好处的时候，会说到可以链接更多的人。</p>
<p>但 100 天下来，我感觉我并没有借由写东西这件事情，认识到了更多的人，目前就只认识了一个产品经理和一个同是做类似内容的网友。</p>
<p>一个比较明显的体会是，100 天下来文章的留言数还是那么少，来留言的大部分还是之前认识的朋友，这是我值得反思的一点。</p>
<p>可能还是因为我写的工具文太多，缺少内心想法的流露、缺少人间烟火味，找不到太多共鸣、可以交流的点，因而就没啥人留言，或者是自己的人设还不够具体、不够突出？</p>
<p>看到一些同是做工具内容的同行，它们的留言区好像就不会像我这么冷清，这应该还是我的问题。</p>
<h2 id="日更的意外之喜"><a href="#日更的意外之喜" class="headerlink" title="日更的意外之喜"></a>日更的意外之喜</h2><p>出乎我意料的是，日更期间，我终于接到这个公众号的第一条推广了，这是我之前没有想到的。</p>
<p>原本我以为只有公众号达到 1 万以上关注、阅读量稳定在 1000 附近，才达到接广告的门槛，没想到这个想法提前实现了。</p>
<p>感谢还没取关的朋友的理解。</p>
<h2 id="日更的顾虑"><a href="#日更的顾虑" class="headerlink" title="日更的顾虑"></a>日更的顾虑</h2><p>在做着一份正式工作的同时，还在高频地更新自己的公众号，被人知道了，会不会担心别人在心里嘀咕：你上班是不是在摸鱼了？顾着写自己的公众号了？</p>
<p>其实这不止是我遇到的问题，还有一些在公司里担任要职、一边同时维护着自己公众号的人也会遇到：</p>
<p>例如公众号「MacTalk」的池建强老师，但他又不太一样：</p>
<p>他现在在做一款名为「极客时间」的 App，就职于现在这家公司之前，他的公众号已经做得非常不错了，文章基本都有上万的阅读量，在职的时候，他凭借自己的公众号和以前积攒的影响力，给公司的产品带来了第一批用户，完成了产品的冷启动。</p>
<p>之前看他写的一篇文章，是这么说的：</p>
<blockquote>
<p>写公众号和做视频号并不会占用太多时间，只要管理好自己的精力就可以了。人们不做这些有价值的事情，时间也是白白浪费。而我之所以做这些东西，是因为这些东西和我本身的特质有关，和我做的事情也息息相关，比如<strong>我通过自己的影响力给产品带来冷启动付费用户几万个，是不是很有价值呢？</strong><br>——文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lZ6rd25MAN2vRCxqx9hkIQ">你到底在忙啥呢？</a>》</p>
</blockquote>
<p>当然，我自己还没到池老师这种大腕的级别，能做的只有一些小事——把公众号文章转发到朋友圈、向身边的人推荐自家的公众号。</p>
<p>还有另外一位博主 @张辉，他会在自己的朋友圈高频地分享自己的所思所想，曾经我也对「工作日上班期间要不要发朋友圈」这件事存在着疑惑，对于这个问题，这位博主讲了他和他妈妈的一段对话：</p>
<blockquote>
<p>他妈妈问他，你每天在朋友圈发那些信息，你老板看了会不会不高兴，他说我老板要是在意，我早被开除几百回了。他之前换工作，也面临好几个选择，之所以选择现在的公司，是因为能够做自己。<br>做自己很难，但是很重要。其实每个人内心深处都喜欢活生生的，而不是脸谱化的人。</p>
</blockquote>
<h2 id="与日更有关的数据"><a href="#与日更有关的数据" class="headerlink" title="与日更有关的数据"></a>与日更有关的数据</h2><p>100 天下来，我的关注数从 2 月 24 日当天的 7814 增长到了现在的 9758，净增 1944</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227888849753.jpg" alt="-w1416"></p>
<p>为了验证之前一位网友说的一个观点，大意是「相比断断续续地更新，日更可以给公众号带来更多的关注」，我去翻了一下我的公众号 2020 年一年下来的关注净增数据：</p>
<p>2020 年初的关注数只有 1849，看到这个数字我瞬间被吓到了，原来去年最初的关注数少得可怜。。。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227894553969.jpg" alt="-w1412"></p>
<p>2020 年末的关注数是 7033</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227894023802.jpg" alt="-w1420"></p>
<p>2020 年一年下来，我的公众号净增 5184 个关注，花费了 12 个月，中间有比较迅猛的增长，应该还是有些文章受到了微信算法的推荐，感谢微信团队。</p>
<p>如果按照前面的算法，3 个月可以净增 1944 个关注，如果坚持连续更新一整年，理想的话，应该可以净增 7776 个关注，看起来似乎也还行？？？ </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227896562260.jpg" alt="-w716"></p>
<p>暂时不想了，还是先停下来休息一下，喘喘气吧，太累了，真不是人干的活。</p>
<p>看到这里，如果你有什么想要问我的，欢迎在下方的评论区留言，知无不言。</p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南"></p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP-NET-Core-gRPC-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP-NET-Core-gRPC-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url">ASP.NET Core gRPC 健康检查的探索与实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-01T03:37:36+00:00">
                2021-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>各位朋友，大家好，欢迎大家关注我的博客。在上一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1679688265/">博客</a> 中，博主和大家分享了<code>gRPC</code>的拦截器在日志记录方面的简单应用，今天我们继续来探索<code>gRPC</code>在构建微服务架构方面的可能性。其实，从博主个人的理解而言，不管我们的微服务架构是采用<code>RPC</code>方式还是采用<code>RESTful</code>方式，我们最终要面对的问题本质上都是一样的，博主这里将其归纳为：服务划分、服务编写 和 服务治理。首先，服务划分决定了每一个服务的上下文边界以及服务颗粒度大小，如果按照领域驱动设计(<strong>DDD</strong>)的思想来描述微服务，我认为它更接近于限界上下文(<strong>BoundedContext</strong>)的概念。其次，服务编写决定了每一个服务的具体实现方式，譬如是采用无状态的<code>RESTful</code>风格的<code>API</code>，还是采用强类型的、基于代理的<code>RPC</code>风格的<code>API</code>。最后，服务治理是微服务架构中永远避不开的话题，服务注册、服务发现、健康检查、日志监控等等一切的话题，其实都是在围绕着<strong>服务治理</strong>而展开，尤其是当我们编写了一个又一个的服务以后，此时该如何管理这些浩如“<strong>星</strong>”海的服务呢？所以，在今天这篇博客中，博主想和大家一起探索下<code>gRPC</code>的健康检查，希望能给大家带来一点启发。</p>
<p><img src="https://i.loli.net/2021/06/02/oVS3YkPIncr2xM9.jpg" alt="健康检查-服务注册-服务发现示意图"></p>
<p>关于“健康检查”，大家都知道的一点是，它起到一种“防微杜渐”的作用。不知道大家还记不记得，语文课本里的经典故事《扁鹊见蔡桓公》，扁鹊一直在告知蔡桓公其病情如何，而蔡桓公讳疾忌医，直至病入骨髓、不治而亡。其实，对应到我们的领域知识，后端依赖的各种服务譬如数据库、消息队列、Redis、API 等等，都需要这样一个“<strong>扁鹊</strong>”来实时地“<strong>望闻问切</strong>”，当发现问题的时候及时地采取相应措施，不要像“<strong>蔡桓公</strong>”一样病入骨髓，等到整个系统都瘫痪了，这时候火急火燎地去“救火”，难免会和蔡桓公一样，发出“悔之晚矣”的喟叹。当我们决定使用<code>gRPC</code>来构建微服务架构的时候，我们如何确保这些服务一直是可用的呢？所以，提供一种针对<code>gRPC</code>服务的健康检查方案就会显得非常迫切。这里，博主主要为大家介绍两种实现方式，它们分别是：基于<code>IHostedService</code>的实现方式 以及 基于<code>Consul</code>的实现方式。</p>
<h1 id="基于-IHostedService-的实现方式"><a href="#基于-IHostedService-的实现方式" class="headerlink" title="基于 IHostedService 的实现方式"></a>基于 IHostedService 的实现方式</h1><p>第一种方式，主要是利用<code>IHostedService</code>可以在程序后台执行的特点，搭配<code>Timer</code>就可以实现定时轮询。在 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc">gRPC</a> 的 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">官方规范</a> 中，提供了一份<code>Protocol Buffers</code>的声明文件，它规定了一个健康检查服务必须实现<code>Check()</code>和<code>Watch()</code>两个方法。既然是官方定义好的规范，建议大家不要修改这份声明文件，我们直接沿用即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要实现对应的<code>HealthCheckService</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">Health.HealthBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse() &#123; </span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()&#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要实现<code>HostedHealthCheckService</code>，它实现了<code>IHostedService</code>接口，并在其中调用<code>HealthCheckService</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HostedHealthCheckService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HostedHealthCheckService&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostedHealthCheckService</span>(<span class="params">ILogger&lt;HostedHealthCheckService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> start running....&quot;</span>);</span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoCheck, <span class="literal">null</span>, TimeSpan.Zero, TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> stop running....&quot;</span>);</span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoCheck</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>); ;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> Health.HealthClient(channel);</span><br><span class="line">        client.Check(<span class="keyword">new</span> HealthCheckRequest() &#123; Service = <span class="string">&quot;https://localhost:5001&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是大家非常熟悉的<strong>依赖注入</strong>环节：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddHostedService&lt;HostedHealthCheckService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;HealthCheckService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家对上一篇博客中的拦截器还有印象，对于下面的结果应该会感到非常亲切：</p>
<p><img src="https://i.loli.net/2021/06/02/vx2QLUoMzXaWpZY.png" alt="基于 IHostedService 的 gRPC 健康检查"></p>
<p>除此以外，我们还可以直接安装第三方库：<code>Grpc.HealthCheck</code>。此时，我们需要继承<code>HealthServiceImpl</code>类并重写其中的<code>Check()</code>和<code>Watch()</code>方法:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">HealthServiceImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们只需要在<code>HostedHealthCheckService</code>调用它即可，这个非常简单。</p>
<p>故，无需博主多言，相信屏幕前的你都能写得出来，如果写不出来，参考博主给出得实现即可(逃！</p>
<h1 id="基于-Consul-的实现方式"><a href="#基于-Consul-的实现方式" class="headerlink" title="基于 Consul 的实现方式"></a>基于 Consul 的实现方式</h1><p><a target="_blank" rel="noopener" href="https://www.consul.io/">Consul</a> 是一个由 <a target="_blank" rel="noopener" href="https://www.hashicorp.com/about">HashiCorp</a> 提供的产品，它提供了服务注册、服务发现、健康检查、键值存储等等的特性。这里，我们通过集成它的<code>SDK</code>来实现<code>gRPC</code>服务的服务注册、服务发现、健康检查，从某种程度上来讲，它无形中帮助我们实现了客户端的负载均衡，因为我们可以将每一个服务的终结点都注册到<code>Consul</code>中，而<code>Consul</code>的健康检查则可以定时移除那些不可用的服务。所以，客户端获得的终结点实际上都是可用的终结点。</p>
<p>首先，我们需要安装第三方库：<code>Consul</code>。接下来，我们可需要通过<code>Docker</code>安装一下<code>Consul</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul</span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>Consul</code>的端口号为：8500，我们可以直接访问：<code>http://localhost:8500</code>：</p>
<p><img src="https://i.loli.net/2021/06/02/Gjb9XhpRCI7g2w5.png" alt="Consul 界面效果展示"></p>
<p>接下来，为了让<code>Startup</code>类看起来清爽一点，首先，我们先来写一点扩展方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定的gRPC服务添加健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcHealthCheck</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册ConsulClient</span></span><br><span class="line">    services.AddSingleton&lt;IConsulClient, ConsulClient&gt;(_ =&gt; <span class="keyword">new</span> ConsulClient(consulConfig =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseUrl = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Consul:BaseUrl&quot;</span>);</span><br><span class="line">        consulConfig.Address = <span class="keyword">new</span> Uri(baseUrl);</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册gRPC服务</span></span><br><span class="line">    RegisterConsul&lt;TService&gt;(services).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>RegisterConsul()</code>方法负责告诉<code>Consul</code>，某个服务对应的 IP 和端口号分别是多少，采用什么样的方式进行健康检查。</p>
<p>不过，由于<code>Consul</code>默认不支持<code>gRPC</code>的健康检查，所以，我们使用了更为常见的基于<code>TCP</code>方式的健康检查。你可以认为，只要服务器连接畅通，<code>gRPC</code>服务就是健康的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">RegisterConsul</span>&lt;<span class="title">TService</span>&gt;(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serverHost = GetLocalIP();</span><br><span class="line">    <span class="keyword">var</span> serverPort = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;().GetValue&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;gRPC:Port&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> RegisterConsul&lt;TService&gt;(services, serverHost, serverPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">RegisterConsul</span>&lt;<span class="title">TService</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  IServiceCollection services, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">string</span> serverHost, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">int</span> serverPort</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> client = services.BuildServiceProvider().GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> registerID = <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">typeof</span>(TService).Name&#125;</span>-<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>&quot;</span>;</span><br><span class="line">    <span class="keyword">await</span> client.Agent.ServiceDeregister(registerID);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Agent.ServiceRegister(<span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">    &#123;</span><br><span class="line">        ID = registerID,</span><br><span class="line">        Name = <span class="keyword">typeof</span>(TService).Name,</span><br><span class="line">        Address = serverHost,</span><br><span class="line">        Port = serverPort,</span><br><span class="line">        Check = <span class="keyword">new</span> AgentServiceCheck</span><br><span class="line">        &#123;</span><br><span class="line">            TCP = <span class="string">$&quot;<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>&quot;</span>,</span><br><span class="line">            Status = HealthStatus.Passing,</span><br><span class="line">            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Interval = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        Tags = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;gRpc&quot;</span> &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Consul</code>中的健康检查，更常用的是基于<code>HTTP</code>的健康检查，简单来说，就是我们提供一个接口，供<code>Consul</code>来调用，我们可以去设置请求的头(Header)、消息体(Body)、方法(Method)等等。所以，对于这里的实现，你还可以替换为更一般的实现，即提供一个 API 接口，然后在这个接口中调用<code>gRPC</code>的客户端。除此以外，如果你擅长写脚本，<code>Consul</code>同样支持脚本级别的健康检查。</p>
<p>在这里，博主水平扩展(复制)了两套服务，它们分别被部署在<code>5001</code>和<code>6001</code>两个端口上，通过<code>Consul</code>能达到什么效果呢？我们一起来看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddGrpcHealthCheck&lt;GreeterService&gt;();</span><br><span class="line">    services.AddGrpcHealthCheck&lt;CalculatorService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">        endpoints.MapGrpcService&lt;CalculatorService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，此时，我们注意到<code>Consul</code>中有两个服务注册进去，它们分别是：<code>GreeterService</code> 和 <code>CalculatorService</code>：</p>
<p><img src="https://i.loli.net/2021/06/02/eTBj7Iqn256GXKw.png" alt="gRPC 服务成功注册到 Consul 中"></p>
<p>以其中一个<code>CalculatorService</code>为例，我们可以注意到，它的确注册了<code>5001</code>和<code>6001</code>两个实例：</p>
<p><img src="https://i.loli.net/2021/06/03/xlhMjJ1ZcN3nwBe.png" alt="CalculatorService 的两个实例"></p>
<p>至此，我们就完成了基于<code>Consul</code>的健康检查，在这里，图中的绿色标记表示服务可用。</p>
<h1 id="关于-gRPC-的引申话题"><a href="#关于-gRPC-的引申话题" class="headerlink" title="关于 gRPC 的引申话题"></a>关于 gRPC 的引申话题</h1><p>其实，写到这里的时候，这篇博客就该接近尾声啦，因为对于 gRPC 健康检查的探索基本都已找到答案，可我还是想聊一聊关于 gRPC 的引申话题。理由特别简单，就是在我看来，接下来要讲的这点内容，完全撑不起一篇博客的篇幅，索性就在这篇博客里顺带一提。我打算分享两个话题，<strong>其一，是 gRPC 客户端的负载均衡；其二，是 gRPC 接口的测试工具。</strong></p>
<h2 id="gRPC-客户端的负载均衡"><a href="#gRPC-客户端的负载均衡" class="headerlink" title="gRPC 客户端的负载均衡"></a>gRPC 客户端的负载均衡</h2><p>截止到目前为止，结合<code>Consul</code>我们已经实现了服务注册和服务发现两个功能。通过调研我们可以发现，针对服务器端的<code>gRPC</code>的负载均衡，目前主要有<code>Nginx</code>和<code>Envoy</code>两种方案，这两种相方案对要更复杂一点，博主目前所在的公司，在<code>gRPC</code>的负载均衡上感觉是个空白，这算是博主想要研究<code>gRPC</code>的一个主要原因。而在这里，由于<code>Consul</code>里注册了所有<code>gRPC</code>服务的终结点信息，所以，我们更容易想到的，其实是客户端的负载均衡，具体怎么实现呢？我们一起看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从Consul中获取服务终结点信息</span></span><br><span class="line"><span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="built_in">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$&quot;<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>&quot;</span>).ToList();</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Channel和Client</span></span><br><span class="line"><span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$&quot;https://<span class="subst">&#123;serviceUrl&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="keyword">var</span> client = <span class="keyword">new</span> Calculator.CalculatorClient(channel);</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">10</span>, Op = <span class="string">&quot;+&quot;</span>, Num2 = <span class="number">12</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>可以看出，基本思路就是从<code>Consul</code>里拿到对应服务的终结点信息，然后构造出<code>GrpcChannel</code>，再通过<code>GrpcChannel</code>构造出 Client 即可。</p>
<p>不过，博主觉得这个过程有一点繁琐，我们有没有办法让这些细节隐藏起来呢？于是，我们有了下面的改进方案：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">TGrpcClient</span>&gt; <span class="title">GetGrpcClientAsync</span>&lt;<span class="title">TGrpcClient</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">this</span> IServiceProvider serviceProvider</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="built_in">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$&quot;<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>&quot;</span>).ToList();</span><br><span class="line">    <span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$&quot;https://<span class="subst">&#123;serviceUrl&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> constructorInfo = <span class="keyword">typeof</span>(TGrpcClient).GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(GrpcChannel) &#125;);</span><br><span class="line">    <span class="keyword">if</span> (constructorInfo == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure <span class="subst">&#123;<span class="keyword">typeof</span>(TGrpcClient).Name&#125;</span> is a gRpc client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clientInstance = (TGrpcClient)constructorInfo.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; channel &#125;);</span><br><span class="line">    <span class="keyword">return</span> clientInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，有没有觉得简单一点？完美！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">await</span> serviceProvider.GetGrpcClientAsync&lt;CalculatorClient&gt;();</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">1</span>, Num2 = <span class="number">2</span>, Op = <span class="string">&quot;+&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="gRPC-接口的测试工具"><a href="#gRPC-接口的测试工具" class="headerlink" title="gRPC 接口的测试工具"></a>gRPC 接口的测试工具</h2><p>我猜，大多数看到这个标题会一脸鄙夷，心里大概会想，就测试工具这种东西值得特地写出来吗？诚然，以前写 API 接口的时候，大家都是用 <a target="_blank" rel="noopener" href="https://www.postman.com/downloads/">Postman</a> 或者 <a target="_blank" rel="noopener" href="https://www.apifox.cn/">Apifox</a> 这样的工具来进行测试的，可是突然有一天你要调试一个<code>gRPC</code>的接口，你总不能每次都调用客户端啊，所以，这里要给大家推荐两个<code>gRPC</code>接口的测试工具，它们分别是: <a target="_blank" rel="noopener" href="https://github.com/fullstorydev/grpcurl">grpcurl</a> 和 <a target="_blank" rel="noopener" href="https://github.com/fullstorydev/grpcui">grpcui</a>，它们都出自同一个人 <a target="_blank" rel="noopener" href="https://github.com/fullstorydev">FullStory</a> 之手，基于 Go 语言开发，简单介绍下使用方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 建议使用国内源</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line">// grpcurl</span><br><span class="line">brew install grpcurl</span><br><span class="line"></span><br><span class="line">// grpcui</span><br><span class="line">go get github.com/fullstorydev/grpcui/...</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br><span class="line"></span><br><span class="line">// 安装后的路径为：C:\Users\&lt;User&gt;\go\bin\grpcui.exe</span><br><span class="line">grpcui -bind &lt;Your-IP&gt; -plaintext &lt;Your-gRPC-Service&gt;</span><br></pre></td></tr></table></figure>

<p>虽然这个说明简单而直白，可我还是没能装好，我不得不祭出 Docker 这个神器，果然它不会令我失望：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wongnai/grpcui</span><br><span class="line">docker run -e GRPCUI_SERVER=localhost:5001 -p 8080:8080 wongnai/grpcui</span><br></pre></td></tr></table></figure>

<p>这里有两个重要的参数，其中，<code>8080</code>是<code>grpcui</code>的服务地址，可以按个人喜好进行修改，<code>GRPCUI_SERVER</code>是<code>gRPC</code>服务地址，该工具运行效果如下：</p>
<p><img src="https://i.loli.net/2021/06/03/gGMaVKquDbtdWUN.png" alt="gRPCUI 接口测试工具"></p>
<p>对于使用者来说，我们只需要选择服务(service)、方法(rpc)、然后填入参数即可，个人感觉非常方便。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文探索并实现了<code>gRPC</code>服务健康检查，主要提供了两种思路：基于<code>IHostedService</code> + <code>Timer</code>的轮询的方案 以及 基于<code>Consul</code>的集服务注册、服务发现、健康检查于一身的方案。特别地，对于后者而言，我们可以顺理成章地联想到客户端的负载均衡，其原理是：<code>Consul</code>中注册了所有<code>gRPC</code>服务的终结点信息，通过<code>IConsulClient</code>可以拿到所有可用的终结点信息，只要以此为基础来构建<code>GrpcChannel</code>即可。根据这个原理，我们引申出了<code>gRPC</code>客户端负载均衡的相关话题，这里我们采用的是随机选择一个终结点信息的做法，事实上，按照一般负载均衡的理论，我们还可以采取轮询、加权、Hash 等等的算法，大家可以按照自己的业务场景来选择合适的方法。最后，我们简单介绍了下<code>gRPC</code>接口测试方面的内容，它可以帮助我们更高效地编写、验证<code>gRPC</code>接口。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、参与讨论，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-5-28-githubbeautify2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-5-28-githubbeautify2/" itemprop="url">GitHub 个人主页美化（下）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-28T14:00:00+00:00">
                2021-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>虽然我不是程序员，但还是会时不时到世界上最大的代码托管网站 <strong>GitHub</strong> 上去逛一逛，看看自己关注的人是不是 Star（收藏）了一些有意思的项目。</p>
<p>之前写过一篇为自己的 GitHub 主页添加<strong>个性小标签</strong>的方法，效果见下图：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128050423.jpg"></p>
<p>添加个性小标签的方法见👉👉：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649909962&idx=1&sn=cc1b4341f2940a75214ead8c3c2ccf3d&chksm=83a86ee7b4dfe7f10daef1ceef82005ccc4f5d6c6fb97d57ca297039b54d0ddb4e8d389cc18a&scene=21#wechat_redirect">如何美化 GitHub 个人主页？</a>  </p>
<p>除了添加小标签，前段时间还在 GitHub 上看到另外一些有意思的 GitHub 个人主页。</p>
<p>一个是显示自己注册 GitHub 的时间、提交代码的次数、仓库的数量、以及自己最常使用的语言。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128507232.jpg"></p>
<p>另一个则是显示自己的项目获得的 Stars 数量、今年提交代码的次数、创建的 issue 的数量、以及一个计算出来的总评分 A+。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128802152.jpg"></p>
<p>这些实现起来其实都非常简单，只需要你稍微懂一点 Markdown 的语法。</p>
<p>和之前介绍过的在 GitHub 主页添加小标签一样，你需要先<strong>创建一个与你 GitHub ID 同名的 GitHub 仓库</strong>。</p>
<p>点击 GitHub 个人页右上角的加号 + ，在弹出的面板中，选择「<strong>New repository</strong>」，创建一个新的 GitHub 仓库。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129097996.jpg"></p>
<p>Repository name 是仓库的名称，这里的仓库名必须与前面的 Owner 下方的 GitHub ID 一样，例如我的 ID 为 phh95，因此这里的仓库名也为 phh95。</p>
<p>创建时记得勾选从下方的「<strong>Add a README file</strong>」，在仓库中添加一个名为 README 的 Markdown 文件，等会我们就是要在这个文件中添加我们想放在 GitHub 个人主页的内容。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129328640.jpg"></p>
<h2 id="01-Metrics"><a href="#01-Metrics" class="headerlink" title="01. Metrics"></a>01. Metrics</h2><p>获得类似下图的 GitHub 数据统计，需要用到一个在线工具「Metrics」，打开网站之后，在左侧输入你的 GitHub ID，稍等一会，就会返回右侧所有和你相关的数据。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129571049.jpg"></p>
<p>这里输入阮一峰老师的 ID 进行举例，右侧就是这个网站返回给我们的统计数据。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129720474.jpg"></p>
<p>点击右侧的 Markdown code 选项卡，切换到统计视图对应的 Markdown 链接。</p>
<p>如果这是你的 GitHub 账号统计数据，可以点击下方的<strong>蓝色链接</strong>，它会将这个链接添加到和你 GitHub ID 同名仓库中，这样你就可以在个人首页看到这些统计数据啦。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130089032.jpg"></p>
<p>Metrics 网址：<br><em><a target="_blank" rel="noopener" href="https://metrics.lecoq.io/">https://metrics.lecoq.io/</a></em></p>
<h2 id="02-显示常用的编程语言"><a href="#02-显示常用的编程语言" class="headerlink" title="02. 显示常用的编程语言"></a>02. 显示常用的编程语言</h2><p>在 GitHub 个人页显示最常用的编程语言，只需要在与 GitHub ID 同名的仓库的 README.md 文档中添加下面的文本：</p>
<p><code>![这里写你的昵称&#39;s Most used languages](https://github-readme-stats.vercel.app/api/top-langs?username=这里替换成你的 GitHub ID&amp;show_icons=true&amp;count_private=true&amp;theme=gotham)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130457996.jpg"></p>
<p>复制后稍作修改，向下滑动页面，点击绿色的「<strong>Commit changes</strong>」按钮，提交确认刚刚作出的修改。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130630284.jpg"></p>
<p>再回到自己的 GitHub 主页，它就会显示<strong>你最常使用的编程语言</strong>，这个统计数据来自于你 Push 到 GitHub 的内容。</p>
<p>譬如我之前将一些在本地写的 Python 文件 Push 到 GitHub 仓库，它就会显示我最常使用的语言为 Python。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130817920.jpg"></p>
<p>如果你觉得这个显示常用语言的样式不好看，还可以更改文本链接末尾的<strong>参数设置</strong>，例如隐藏底部的深色边框。</p>
<p>下图的效果对应的文本内容为：</p>
<p><code>![这里写你的昵称&#39;s Most used languages](https://github-readme-stats.vercel.app/api/top-langs/?username=这里替换成你的 GitHub ID&amp;layout=compact&amp;hide_border=true&amp;langs_count=10)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131079398.jpg"></p>
<h2 id="03-GitHub-统计卡片"><a href="#03-GitHub-统计卡片" class="headerlink" title="03. GitHub 统计卡片"></a>03. GitHub 统计卡片</h2><p>在 GitHub 上，不少人都会在自己的 GitHub 主页添加下图的 GitHub 统计卡片：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131263530.jpg"></p>
<p>这个 GitHub 统计卡片，来源于 GitHub 上的一个名为「<strong>GitHub Readme Stats</strong>」的项目。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131422494.jpg"></p>
<p>GitHub Readme Stats 项目地址：<br><em><a target="_blank" rel="noopener" href="https://sourl.cn/Sxq854">https://sourl.cn/Sxq854</a></em></p>
<p>这个项目提供了中文版的说明文档，将其添加到自己的 GitHub 主页也非常简单，将下方的链接复制到 GitHub ID 同名的仓库的 README.md 文档中，稍微修改一下信息就可以了。</p>
<p><code>[![这里写你的昵称&#39;s GitHub stats](https://github-readme-stats.vercel.app/api?username=这里替换成你的 GitHub ID)](https://github.com/anuraghazra/github-readme-stats)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131676869.jpg"></p>
<p>这个统计卡片还提供了<strong>其他的主题样式</strong>，即不同的配色方案，如果你想使用其他的主题，需要在上方的链接后面增加一些额外的参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131892558.jpg"></p>
<p>举个例子，我想使用其中的一个名为 <strong>radical</strong> 的主题，我就得原先的链接后面加多两个参数的配置，一个是<strong>显示图标</strong>，一个是<strong>设置所使用的主题名称</strong>。</p>
<p><code>[![这里写你的昵称&#39;s GitHub stats](https://github-readme-stats.vercel.app/api?username=这里替换成你的 GitHub ID&amp;show_icons=true&amp;theme=radical)](https://github.com/anuraghazra/github-readme-stats)</code></p>
<p>增加了参数配置之后，原先配色方案为<strong>蓝白黑</strong>的卡片就变成了下图的<strong>粉黑青</strong>配色：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222132210757.jpg"></p>
<h2 id="04-添加其他平台的统计数据"><a href="#04-添加其他平台的统计数据" class="headerlink" title="04. 添加其他平台的统计数据"></a>04. 添加其他平台的统计数据</h2><p>除了前面介绍的内容，GitHub 上还有一位开发者采用了类似于「GitHub Readme Stats」的思路，写了一个在 GitHub 个人页<strong>显示其他平台统计数据</strong>的工具。</p>
<p>目前支持统计的网站有：<strong>知乎、B 站、LeetCode、LeetCode 中文站</strong>和<strong>掘金</strong>，下图提供了<strong>知乎统计卡片</strong>的预览效果。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222132545884.jpg"></p>
<p>对这个项目感兴趣的朋友，可以移步开发者的 GitHub 项目页面，查看具体的使用或实现方法：</p>
<p><em><a target="_blank" rel="noopener" href="https://github.com/songquanpeng/stats-cards">https://github.com/songquanpeng/stats-cards</a></em></p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南"></p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/2021-05-27-we-dont-need-deno/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/2021-05-27-we-dont-need-deno/" itemprop="url">我们并不需要 Deno</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-26T16:00:00+00:00">
                2021-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><a target="_blank" rel="noopener" href="https://deno.land/">Deno</a> 一出生便带着光环 —— 它发布于 Node.js 创始人 Ryan Dahl 的演讲「<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=M3BM9TB-8yA">Design Mistakes in Node</a>（<a target="_blank" rel="noopener" href="https://tinyclouds.org/jsconf2018.pdf">幻灯片</a>）」，当时有些人说 Node.js 要凉了，但我不这么认为。</p>
<h2 id="原生-TypeScript"><a href="#原生-TypeScript" class="headerlink" title="原生 TypeScript"></a>原生 TypeScript</h2><p>其实目前我们在引擎的「用户态」去使用 TypeScript 并没有引入任何问题，而且给用户带来了很大的灵活性。考虑到 TypeScript 不可能离开 JavaScript 的生态 —— 毕竟引擎总是要支持 JavaScript 的；再加上 TypeScript 有不同的版本、不同的编译开关，在用户态使用 TypeScript 可以说是最好的方案了。TypeScirpt 迟早会成为 Deno 的历史包袱。</p>
<p>从性能的角度，在 TypeScript 没出现之前，V8 已经在 JavaScript 上进行大量 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29638866">魔法优化</a> 了，可以说 JIT 出来的代码并不比其他静态类型的语言差太多，是没法简单地通过 TypeScript 来提升性能的。再加上前面说了引擎总还是要支持 JavaScript、TypeScript 的运行时语义依然是 JavaScript（TypeScript 并不能保证对象的实际类型在运行时不被修改），所以引擎也不可能从对 JavaScript 的魔法优化切换到基于 TypeScript 的类型来做优化。</p>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>我一直认为 NPM 是最好用的包管理器之一，这包括将依赖保存在项目目录中 —— 在调整一个项目的依赖时不必担心对其他项目产生影响；每个包都可以指定自己的依赖版本，允许多版本并存 —— 在升级一个包的依赖时不会影响到其他包，每个包都可以使用新的版本或继续使用旧的版本；NPM 负责查找和安装包，而 Node.js 则用相对简单的协议去使用这些包，它们可以彼此独立地升级演进。</p>
<p>可以看到 NPM 最终极大地减轻了开发者的心智负担，只要你按照正确的方式去使用它，极少会遇到其他语言中有关依赖管理的问题。而 Deno 则反其道行之。虽然 Deno 也提供了一些相关的功能（<a target="_blank" rel="noopener" href="https://deno.land/manual@master/linking_to_external_code/reloading_modules">deno cache</a>），但你会发现 Deno 的本意仍然是不希望进行「依赖管理」。</p>
<p>在代码中包含 URL 是一个非常糟糕的做法（Golang 也是如此），Deno 称之为去中心化，但其实它只是重新将使用包的代码与包的来源耦合在了一起（现在 Deno 提供了一个 <a target="_blank" rel="noopener" href="https://deno.land/x">官方的代理</a>，但这样和 NPM 的中心仓库又有什么区别呢）。缓存机制也带来了相当大的不确定性：<code>package-lock.json</code> 可以保证每次安装的依赖是完全一致的，而 Deno 的 <a target="_blank" rel="noopener" href="https://deno.land/manual@v1.10.2/linking_to_external_code/integrity_checking">lock.json</a> 只能检查依赖是否有变化（如果有的话就拒绝运行）。这使得开发者很难控制依赖更新的时机，<a target="_blank" rel="noopener" href="https://deno.land/manual/linking_to_external_code#but-what-if-the-host-of-the-url-goes-down-the-source-won#39t-be-available">Deno 则建议将依赖缓存放入 Git</a>。</p>
<h2 id="内建权限系统"><a href="#内建权限系统" class="headerlink" title="内建权限系统"></a>内建权限系统</h2><p>一直以来通用编程语言都不曾在语言层面引入权限控制，但确实开源社区也曾报出过多次恶意代码的事件，但 Deno 的权限机制相当粗糙 —— 只能在进程级别进行权限控制，我可以大胆地预言，在几乎所有的场景里我们都需要 <code>--allow-all</code>，并不能对安全起到太多作用。</p>
<p>我们需要考虑 Deno 的用户到底是开发者还是使用者：对于 Deno 脚本的使用者来说关注的当然是进程级别的权限；而对于开发者我认为更关注的是第三方包的权限，权限系统应该以包为单位（然而 Deno 里并没有包的概念了），Node 里本来也有 vm 模块可以一定程度上实现沙盒（但确实非常难以控制）。</p>
<p>而且说起来我们现在已经有了 Docker（或者更广泛的容器的概念）这种彻底的隔离和权限控制机制，业界对编程语言引入一套权限控制已经没有太大的需求了。</p>
<h2 id="孤立的生态"><a href="#孤立的生态" class="headerlink" title="孤立的生态"></a>孤立的生态</h2><p>可以说 JavaScript 的生态来自于用户态类库的充分竞争，Deno 则在 Runtime API 之外提供了 Standard Library（类似 <code>golang.org/x</code>）、提供了全套的开发工具链（fmt、test、doc、lint、bundle），在试图提供开箱即用的使用体验的同时，也削弱了第三方生态。</p>
<p>在 Node.js 和 NPM 已然成为 JavaScript 事实标准的一部分的情况下，Deno 本来可以通过兼容 Node.js 或 NPM 有一个非常好的开场。但 Deno 却选择了和 Node.js 划清界限，而是兼容了一些浏览器环境的 API（如 prompt 或 onload）。</p>
<p>Deno 自己的说法是为了遵循已有的 Web 标准避免发明新东西，但实际上这些 Web 标准在设计时并未充分考虑浏览器之外的 Runtime，况且 Deno 其实也没能避免发明新东西（这些新东西被放在了 Deno 这个命名空间中）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Deno 就是这样一个有着非常鲜明个人偏好的 JavaScript Runtime，它试图去纠正 Node.js 的一些「设计失误」、希望给出一种「JavaScript 最佳实践」，希望提供高质量且开箱即用的标准库和工具链。这些偏好的选择总会有人喜欢或不喜欢，但除此之外 Deno 实在是缺少一个 killer feature（杀手级特性）让一个「理性」的 Node.js 开发者（如一个公司）切换到 Deno。</p>
<p>通过单一文件发行、进程级别的权限控制使 Deno 会更适合命令行工具的开发，但能否与已经广泛用于命令行工具的 Golang 竞争尚且存疑。</p>
<p>作为一个 Node.js 开发者，我并不觉得 Deno 可以在未来替代 Node 成为我的主力开发工具，Deno 更像是 Golang 的设计哲学对 JavaScript 的一次入侵。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP-NET-Core-gRPC-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP-NET-Core-gRPC-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/" itemprop="url">ASP.NET Core gRPC 拦截器的使用技巧分享</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-26T01:03:35+00:00">
                2021-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><code>gRPC</code>是微软在<code>.NET Core</code> 及其后续版本中主推的 RPC 框架，它使用 <code>Google</code> 的 <code>Protocol Buffers</code> 作为序列化协议，使用 <strong>HTTP&#x2F;2</strong> 作为通信协议，具有<strong>跨语言</strong>、<strong>高性能</strong>、<strong>双向流式调用</strong>等优点。考虑到，接下来要参与的是，一个以<code>gRPC</code>为核心而构建的微服务项目。因此，博主准备调研一下<code>gRPC</code>的相关内容，而首当其冲的，则是从 .NET Core 3.1 开始就有的拦截器，它类似于<code>ASP.NET Core</code>中的过滤器和中间件，体现了一种面向切面编程(<strong>AOP</strong>)的思想，非常适合在 RPC 服务调用的时候做某种统一处理，譬如参数校验、身份验证、日志记录等等。在今天这篇博客中，博主主要和大家分享的是，利用 .NET Core gRPC 中的拦截器实现日志记录的简单技巧，希望能给大家带来一点启发。</p>
<p><img src="https://i.loli.net/2021/05/28/1MgBG2uRHwEqXvt.jpg" alt="开源、多语言、高性能的 gRPC"></p>
<h1 id="关于-Interceptor-类"><a href="#关于-Interceptor-类" class="headerlink" title="关于 Interceptor 类"></a>关于 Interceptor 类</h1><p><code>Interceptor</code>类是 gRPC 服务拦截器的基类，它本身是一个抽象类，其中定义了下面的虚方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> TResponse <span class="title">BlockingUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">ClientStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Task <span class="title">DuplexStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Task <span class="title">ServerStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">UnaryServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br></pre></td></tr></table></figure>
<p>整体而言，如果从通信方式上来划分，可以分为：<strong>流式调用</strong> 和 <strong>普通调用</strong>；而如果从使用方来划分，则可以分为：<strong>客户端</strong> 和 <strong>服务端</strong>。进一步讲的话，针对<strong>流式调用</strong>，它还分为：”<strong>单向流</strong>“ 和 “<strong>双向流</strong>“。关于这些细节上的差异，大家可以通过 <code>gRPC</code> 的 <a target="_blank" rel="noopener" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/">官方文档</a> 来了解，这里我们给出的是每一种方法对应的用途：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AsyncClientStreamingCall</td>
<td>拦截异步客户端流式调用</td>
</tr>
<tr>
<td>AsyncDuplexStreamingCall</td>
<td>拦截双向流式调用</td>
</tr>
<tr>
<td>AsyncUnaryCall</td>
<td>拦截异步普通调用</td>
</tr>
<tr>
<td>BlockingUnaryCall</td>
<td>拦截阻塞普通调用</td>
</tr>
<tr>
<td>AsyncServerStreamingCall</td>
<td>拦截异步服务端流式调用</td>
</tr>
<tr>
<td>ClientStreamingServerHandler</td>
<td>拦截客户端流式调用的服务端处理程序</td>
</tr>
<tr>
<td>DuplexStreamingServerHandler</td>
<td>拦截双向流式调用的服务端处理程序</td>
</tr>
<tr>
<td>ServerStreamingServerHandler</td>
<td>拦截服务端流式调用的服务端处理程序</td>
</tr>
<tr>
<td>UnaryServerHandler</td>
<td>拦截普通调用的服务端处理程序</td>
</tr>
</tbody></table>
<h1 id="实现一个拦截器"><a href="#实现一个拦截器" class="headerlink" title="实现一个拦截器"></a>实现一个拦截器</h1><p>好了，下面我们一起实现一个拦截器。这里，我们使用的是微软官方的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreeterService</span> : <span class="title">Greeter.GreeterBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">        &#123;</span><br><span class="line">            Message = <span class="string">&quot;Hello &quot;</span> + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>实现服务器端的普通调用拦截，我们需要重写的方法是<code>UnaryServerHandler</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCServerLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GRPCServerLoggingInterceptor&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GRPCServerLoggingInterceptor</span>(<span class="params">ILogger&lt;GRPCServerLoggingInterceptor&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 UnaryServerHandler() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">UnaryServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request, ServerCallContext context, </span></span></span><br><span class="line"><span class="params"><span class="function">      UnaryServerMethod&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish.&quot;</span>);</span><br><span class="line">        _logger.LogInformation(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">LogRequest</span>&lt;<span class="title">TRequest</span>&gt;(<span class="params">TRequest request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">is</span> IMessage)</span><br><span class="line">            payload = JsonConvert.SerializeObject(</span><br><span class="line">                (request <span class="keyword">as</span> IMessage)</span><br><span class="line">                .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(request <span class="keyword">as</span> IMessage))</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Send request of <span class="subst">&#123;<span class="keyword">typeof</span>(TRequest)&#125;</span>:<span class="subst">&#123;payload&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC响应</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">LogResponse</span>&lt;<span class="title">TResponse</span>&gt;(<span class="params">TResponse response, AggregateException exception</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">is</span> IMessage)</span><br><span class="line">                payload = JsonConvert.SerializeObject(</span><br><span class="line">                  (response <span class="keyword">as</span> IMessage)</span><br><span class="line">                  .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                  .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(response <span class="keyword">as</span> IMessage))</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span>:<span class="subst">&#123;payload&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsgs = <span class="built_in">string</span>.Join(<span class="string">&quot;;&quot;</span>, exception.InnerExceptions.Select(x =&gt; x.Message));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span> throws exceptions: <span class="subst">&#123;errorMsgs&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>gRPC</code>而言，每一个由<code>.proto</code>声明文件生成的类，都带有一个叫做<code>Descriptor</code>的属性，我们可以利用这个属性获得<code>gRPC</code>请求和响应的详细信息。所以，在<code>LogRequest()</code>和<code>LogResponse()</code>两个方法中，我们均使用了这一思路来记录<code>gRPC</code>的报文信息，因为传输层的<code>gRPC</code>使用了二进制作为数据载体，这可以说是一种用可读性换取高效率的做法，不过幸运的是，我们在这里实现了这个小目标。</p>
<p>接下来，为了让这个拦截器真正生效，我们还需要修改一下<code>Startup</code>类中注册<code>gRPC</code>这部分的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GRPCServerLoggingInterceptor&gt;());</span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/05/27/3nZXelLPVwJ7AjS.png" alt="gRPC服务器端拦截器效果展示"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>实现客户端的普通调用拦截，我们需要重写的方法是<code>AsyncUnaryCall()</code>，依样画葫芦即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCClientLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重写 AsyncUnaryCall() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        TRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">        ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">        AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.ResponseAsync.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.ResponseAsync.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish.&quot;</span>);</span><br><span class="line">        Console.WriteLine(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，为了让拦截器在客户端生效，我们需要这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Grpc.Core.Interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>);</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">channel.Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">var</span> invoker = channel.CreateCallInvoker().Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(invoker);</span><br><span class="line"><span class="keyword">await</span> client.SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/05/28/XcwmOQbzKTJPtUj.png" alt="gRPC客户端拦截器效果展示"></p>
<p>客户端感觉不太好的一点就是，这个<code>Interceptor</code>传入的必须是一个实例，考虑到拦截器内部可能会依赖类似<code>ILogger</code>等等的组件，建议还是通过<code>IoC</code>容器来取得一个拦截器的实例，然后再传入<code>Intercept()</code>方法中。博主所在的项目中，则是非常“<strong>土豪</strong>”地使用了<code>PostSharp</code>，直接走动态编织的方案，果然，“<strong>这次第，怎一个羡字了得</strong>”。当然，<code>gRPC</code>的客户端，其实提供了日志相关的支持，不过，我个人感觉这个有一点无力：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(logging =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConsole();</span><br><span class="line">    logging.SetMinimumLevel(LogLevel.Debug);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(</span><br><span class="line">    <span class="string">&quot;https://localhost:5001&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> GrpcChannelOptions &#123; LoggerFactory = loggerFactory &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了<code>gRPC</code>拦截器的使用技巧，<code>gRPC</code>支持一元调用(<strong>UnaryCall</strong>)、流式调用(<strong>StreamingCall</strong>)、阻塞调用(<strong>BlockingCall</strong>)，因为区分客户端和服务器端，所以，实际上会有各种各样的组合方式。<code>gRPC</code>的拦截器实际上就是选择对应的场景去重写相应的方法，其中，拦截器的基类为<code>Interceptor</code>类，这里我们都是以普通的一元调用为例的，大家可以结合各自的业务场景，去做进一步的调整和优化。这里，我们使用<code>IMessage</code>类的<code>Descriptor</code>属性来“反射”报文中定义的字段，这样就实现了针对<code>gRPC</code>服务请求&#x2F;响应的日志记录功能。关于<code>gRPC</code>中日志和诊断的更进一步的话题，大家可以参考微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0">官方文档</a> 。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/SnowNLP%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%96%99%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/SnowNLP%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%96%99%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/" itemprop="url">SnowNLP 使用自定义语料进行模型训练</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-19T13:22:41+00:00">
                2021-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 是一个功能强大的中文文本处理库，它囊括了中文分词、词性标注、情感分析、文本分类、关键字&#x2F;摘要提取、<code>TF/IDF</code>、文本相似度等诸多功能，像<strong>隐马尔科夫模型</strong>、<strong>朴素贝叶斯</strong>、<code>TextRank</code>等算法均在这个库中有对应的应用。如果大家仔细观察过博主的博客，就会发现博主使用了摘要提取这一功能来增强博客的<code>SEO</code>，即通过自然语言处理(<strong>NLP</strong>)技术，提取每一篇文章中的摘要信息。因为 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 本身使用的语料是电商网站评论，所以，当我们面对不同的使用场景时，它自带的这个模型难免会出现“水土不服”。因此，如果我们希望得到更接近实际的结果，最好的方案是使用自定义语料进行模型训练。值得庆幸的是，这一切在 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 中实施起来非常简单，并不需要我们去钻研那些高深莫测的算法。至此，就引出了今天这篇博客的主题，即 SnowNLP 使用自定义语料进行模型训练。</p>
<p>不知道大家是否还有印象，博主曾经在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2758545080/">《通过 Python 分析 2020 年全年微博热搜数据》</a> 这篇文章中提到过 SnowNLP 的模型训练。当时，博主采集了整个 2020 年的微博热搜话题，因为要体现整个一年里的情感变化，博主特意找了两份微博语料，并以此为基础训练出了一个模型文件。</p>
<p><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势"></p>
<p>那么，具体是怎么样做的呢？我们一起来看一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> sentiment</span><br><span class="line">sentiment.train(<span class="string">&#x27;./train/neg60000.txt&#x27;</span>, <span class="string">&#x27;./train/pos60000.txt&#x27;</span>)</span><br><span class="line">sentiment.save(<span class="string">&#x27;weibo.marshal&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>千万不要怀疑你的眼睛，因为它真的只有短短的三行代码。简单来说，我们只需要准备一个“<strong>积极</strong>”的语料文件，一个“<strong>消极</strong>”的语料文件，它就可以训练出一个模型文件。特别注意的是，如果是在<code>Python 3.X</code>的版本下，最终生成的模型文件的扩展名将会是<code>.3</code>，下图是博主这里训练出的模型文件：</p>
<p><img src="https://i.loli.net/2021/05/20/EQnaXv3x6Vyfm7j.png" alt="SnowNLP 使用自定义语料进行模型训练"></p>
<p>好了，一旦训练出这个模型文件，我们就可以考虑替换掉 SnowNLP 的默认模型文件，我们可以在以下位置：<code>\Lib\site-packages\snownlp\sentiment</code> 找到下列文件。为了安全起见，我们首先将原来的模型文件重命名，然后再放入我们自己的模型文件。</p>
<p><img src="https://i.loli.net/2021/05/20/C5QS3uhvt1liqXc.png" alt="SnowNLP 使用自定义模型替换默认模型"></p>
<p>此时，我们就可以利用训练好的模型，分析某一条微博的情感倾向。这里我选取了几条我的微博，看看这个情感倾向预测的结果如何：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;我爱你，并不期待回声&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.8760737296091975</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;想找一个人，一起做老爷爷、老奶奶才做的事情，比如，替我拔一拔头上的白头发……[二哈] ​​&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.001629297651780881</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;如果两个人都不爱了，一别两宽，各生欢喜，其实是挺好的结局；可如果还有一个人爱着，对那个人来说，爱又是什么呢？&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.809651945221708</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;为了发张自拍，特意出来跑步，还有谁？[doge] ​​​&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.4041057894917053</span></span><br></pre></td></tr></table></figure>

<p>有人说，双子座是一个白天自愈、晚上孤独的星座，我确信这是真的，因为从我出生的那一刻起，那种宏大宇宙中的孤独感就一直笼罩着我，用一句话来形容，大概就是“<strong>热闹是人家的，我什么都没有</strong>”，因为内心世界里的两个灵魂，从来没有一刻闲歇地在纠缠和撕裂。我一直都想了解一件事情，如果这些基于概率或者是公式的算法，都可以琢磨出人类某个时刻的心境，我们期望别人能懂自己是不是太过矫情，我们是真的了解自己吗？</p>
<p>OK，说完微博话题这个场景，我们再来说说电影评论这个场景。回想今年过年的时候，一部<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/34841067/">《你好，李焕英》</a>，成为贺岁档电影中的一匹黑马，而相比之下，<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a>则有点“<strong>滑铁卢</strong>”的感觉。为了搞清楚某一部电影真实的评价情况，此时，我们可以考虑使用 SnowNLP ，对影评的情感趋向进行打分。同样地，这里我们找了一部分影评语料，为 SnowNLP 训练一个单独的模型。接下来，我们不妨从豆瓣上抓取一定数量的影评，来验证下我们这里训练好的模型，这里以<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a>为例：</p>
<p><img src="https://i.loli.net/2021/05/22/5Mo1ncNyEO2K69j.png" alt="从豆瓣上抓取到的电影评论"></p>
<p>可以发现，这些影评的情感趋向介于 0 到 0.1 这个区间的数量最多，占到 160 以上，这意味着约有 30%的观众认为这部电影是个不折不扣的烂片。</p>
<p><img src="https://i.loli.net/2021/05/22/1hvXtjciPlWBzD9.jpg" alt="唐人街探案3豆瓣影评情感分布"></p>
<p>目前，<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a> 在豆瓣上的评分只有 5.5 分，其中，2 星和 3 星的评价占到 70%以上。由于豆瓣接口的限制，我们大概只能抓到 500 条左右的影评信息，可即使如此，可以看出大家对这部电影的情绪多少有一点不满。博主当时看这个电影，最大的感受是里面充斥着太多强行搞笑的东西，例如开篇机场那一场打砸抢的戏份，我完全不明白它存在的意义是什么，虽然日本演员们的表演可圈可点，可在这样一个推理和叙事都非常脆弱的故事里，大概就剩下翻来覆去重复使用的搞笑伎俩啦，你敢说医院这场戏和第一部阿香家那场戏没有相似的地方吗？更不用说，医院这场戏大家都在评论里无限吐槽啦！</p>
<p><img src="https://i.loli.net/2021/05/22/MRsAc76vgmTEK4z.png" alt="豆瓣电影-唐人街探案3"></p>
<p>其实，对于情感，我一直不知道该怎么来讲，可能是程序员的这份理性，让我在维系亲密关系或者说的情感的时候，有时候会生出一种近乎漠然的、置身事外的错觉，换句话说，也许是那种被人称为“<strong>天性凉薄</strong>”的东西。前任同我讲，我最爱的人其实是我自己，并不是她。因为站在她的角度上来讲，她并没有感受到我给予她的爱。我该怎么回答这个问题呢？在一切看似理性的数学计算背后，人类这些极为在乎的情感到底又是什么形式？也许有一天，两个人的感情说变淡就突然变淡，不管我们曾经说过什么样的话，在那一刻都会变得苍白无力，逐年攀升的离婚率触目惊心，可我们每个人都像扑向火焰的飞蛾，在这爱与欲望无法随心所欲的世界里，被欲望裹挟着不断向前。人会变的绝情、冷漠，我们自以为那是成长，可那不过是心变硬了，可这是我们当初期待的长大吗？</p>
<p><img src="https://i.loli.net/2021/06/08/HrQbtvcjeI1h9M3.png" alt="欢迎来到无法随心所欲的爱与欲望的世界"></p>
<p>今天，听到袁隆平爷爷去世的消息，除了不断地提醒我们这代人已然老去这个事实以外，也许最大的体会应该是，我们在这个世界上追求的名利、身份和爱，最终都会无可避免地走向消亡，就如同我们身上这具躯壳一样，而真正能流传下去、泽被后世地，永远都是思想、是文化、是技术、是精神。佛家云：人死身灭，大概我们都不得不去接受这个残酷的事实，所以，请放下那些爱而不得、求而不得的执念吧，你一辈子不管遇见多少人，在某一个时候也许就会荡然无存，爱会消失、身会毁灭，这一切都是宇宙间的自然法则，与其去纠结那些“<strong>薛定谔态</strong>”的事物，不如多为这个世界做一点有意义的事情，正如尼采的那句名言，“<strong>对待生命你不妨大胆冒险一点, 因为无论如何你都要失去它</strong>”，我也许并不真正懂得人类的情感，因为它在理性面前毫无意义，世间万物毫无例外地走向那个坍塌的奇点，这难道不是一种荒凉的美感吗？</p>
<p><img src="https://i.loli.net/2021/05/22/kjR2nVSHlDNrCLi.jpg" alt="人的心情难道不是一个黑洞"></p>
<p>嘘，如果你读到这里，意外发现这是一篇水字数的博客，而这或许说明了一件事情，我的确是一个会懈怠、会疲倦的活生生的人。关于 SnowNLP 使用自定义语料进行模型训练的话题，这次我们就先写到这里，做数据挖掘的时候，有的人在乎的是最终的结果，而有的人享受的是整个过程，人类的情感或许是相似的，所以，学着去接受这个多样性有点多到奇葩的世界，学着去和平凡而普通的自己和解吧，欢迎大家在评论区交换想法或者观点，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-5-18-blogupdate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-5-18-blogupdate/" itemprop="url">你可以用 RSS 订阅我的博客了</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-17T16:00:00+00:00">
                2021-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>去年写过一篇介绍自己<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649893670&idx=1&sn=1f3f91248ade0d5f1bbe3c2046990d63&chksm=83a82f0bb4dfa61d463dfe7af7ecafa21ac0cf1bee21b1b147990b83f657f687d3857db40bf8&scene=21&token=1051004415&lang=zh_CN#wechat_redirect">创建了一个博客</a>的文章，创建博客之后，陆陆续续上传了一些文章，还不至于把博客完全荒废了。</p>
<p>博客，可以算是一个个人网站，相比于公众号，博客可以玩或者说可以自定义的地方更多，比如它可以像手机那样，换上各式各样的主题，给人不一样的视觉效果。</p>
<p>我的博客是用 Hexo 框架搭建的，下面是我收集的一些比较好看的 Hexo 主题（其实也没有收集很多主题，暂时只有三个）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a> 主题</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514211522989.png" alt="hexo-theme-next"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>：最近刚看到博客主题，页面左下角带有播放音乐的控件</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514215136167.png" alt="image-20210514215136167"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a>：我的博客目前正在使用的 Hexo 主题</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514215958123.png" alt="image-20210514215958123"></p>
<h2 id="如何为-Hexo-博客换上不同的主题？"><a href="#如何为-Hexo-博客换上不同的主题？" class="headerlink" title="如何为 Hexo 博客换上不同的主题？"></a>如何为 Hexo 博客换上不同的主题？</h2><p>如果你对前面介绍的 Hexo 主题感兴趣，可以去 GitHub 上搜索主题的名字，就能找到对应主题的代码文件。</p>
<p>点击绿色的「Code」按钮，选择「Download ZIP」，下载整个项目的源文件。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212610267455.jpg" alt="-w1520"></p>
<p>将下载的 ZIP 文件解压，将解压后的整个文件放进 Hexo 博客的 themes 文件夹中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212615371840.jpg" alt="-w1112"></p>
<p>下载下来的主题一般都会带有主题作者的信息，在应用到自己的博客之前，需要先进行修改。</p>
<p>如果你不知道如何修改主题中的信息，可以查看主题的作者是否提供了主题的「说明文档」或「使用文档」。</p>
<p>以我在用的 Hexo 主题「hexo-theme-fluid」为例，主题的作者写了一份详细的「配置指南」，给初次使用第三方主题的人提供了非常详细的指导。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212648922137.jpg" alt="-w1520"></p>
<p>Hexo 主题「hexo-theme-fluid」配置文档：<br><em><a target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></em></p>
<p>如果你使用的 Hexo 主题没有提供配置文档，也可以来参考上面的配置文档，因为多数 Hexo 主题的配置，都是大同小异的。</p>
<h2 id="添加-RSS-订阅链接"><a href="#添加-RSS-订阅链接" class="headerlink" title="添加 RSS 订阅链接"></a>添加 RSS 订阅链接</h2><p>虽然之前写过一篇介绍<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904885&idx=1&sn=4cf0407adfa94e0e855ca3a5bc3bda20&chksm=83a852d8b4dfdbce023212961dfb446fc4fd8a8e595ea762ad8711602dd9c551811cdff19ca6&token=1051004415&lang=zh_CN#rd">通过 RSS 来订阅多个内容平台</a>的文章，但我自己却没有为自己的博客生成 RSS 订阅链接的意识🤦‍♂️</p>
<p>想起来要给博客添加 RSS 订阅链接，还是推特上一位网友给我提的。</p>
<p>为博客添加 RSS 订阅链接，需要安装一个插件「hexo-generator-feed」，具体可以参照 GitHub 上的一个项目「hexo-generator-feed」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212660487438.jpg" alt="-w1520"></p>
<p>hexo-generator-feed 项目地址：<br><em><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a></em></p>
<p>这个插件需要在终端中使用 <strong>npm</strong> 命令行工具安装<br>安装之前，需要打开<strong>终端</strong>（终端在 Windows 上叫做「命令行」），使用 <code>cd</code> 命令进入 Hexo 博客项目文件存放的位置。</p>
<p>例如我将 Hexo 博客项目文件存放在本地磁盘的 &#x2F;workspace&#x2F;hexo_blog 路径下，因此 <code>cd</code> 命令输入的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd workspace/hexo_blog</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212663991058.jpg" alt="-w1152"></p>
<p>进入 Hexo 博客项目文件所在的位置后，输入下方的命令安装「hexo-generator-feed」插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>安装了插件后，我们还需要对插件进行配置，插件项目的说明文档也对配置进行了说明：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212667655383.jpg" alt="-w1520"></p>
<p>说明文档中配置的参数比较多，但其实我们可以偷懒，不需要配置那么多参数。</p>
<p>打开博客项目文件夹中的配置文件 <code>_config.yml</code>，可以用记事本打开，也可以用代码编辑器，例如微软推出的 VS Code 打开。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212673979375.jpg" alt="-w1112"></p>
<p>打开配置文件，滑动到文件的最底部，在最底部加上下方的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 订阅 RSS</span><br><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: false</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212674929381.jpg" alt="-w1066"></p>
<p>修改好 <code>_config.yml</code> 文件后，按下快捷键 Ctrl + S 保存我们的修改。</p>
<p>接着打开博客项目中存放主题的文件夹 themes，接着再进入博客当前使用的主题中。</p>
<p>以下图为例，我进入了我使用的 Hexo 主题「fluid」的文件夹中，其中也有一个名为 <code>_config.yml</code> 的配置文件，同样使用记事本或者代码编辑器打开它。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212677314446.jpg" alt="-w1112"></p>
<p>同样滑动到配置文件的末尾，在空白处加上下面的一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212680030990.jpg" alt="-w1066"></p>
<p>加入上面的一行代码之后，同样 Ctrl + S 保存文件。</p>
<p>此时，将所有的修改 Push 到远端的服务器，稍等一会，就可以使用 RSS 来订阅自己的博客了，RSS 链接为：<code>博客域名/atom.xml</code></p>
<p>举个例子，我的个人博客域名为 <code>penghh.fun</code>，我的博客 RSS 订阅链接相应地就是：<code>penghh.fun/atom.xml</code></p>
<p>如果你有使用 RSS 阅读器来获取信息的习惯，可以将我博客的 RSS 链接添加到你的 RSS 阅读器中：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212686091065.jpg" alt="-w1400"></p>
<p>这部分给 Hexo 博客生成 RSS 订阅链接的内容，参考了网友 @千古壹号 写的内容，原文如下，可扫码阅读：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/qrcodea--a1.png" alt="QRcode_A — a1"></p>
<h2 id="添加单篇博客阅读量统计"><a href="#添加单篇博客阅读量统计" class="headerlink" title="添加单篇博客阅读量统计"></a>添加单篇博客阅读量统计</h2><p>博客不像公众号——会在文章页面的左下角显示阅读数，如果我们想要为博客添加单篇文章阅读量的统计功能，还需要手动进行配置。</p>
<p>配置之前，最好先查看一下你使用的 Hexo 主题的配置文件 <code>_config.yml</code> 是否已经写好了相关的代码，只是默认暂未开启统计功能。</p>
<p>打开 Hexo 主题的 <code>_config.yml</code> 文件，按下快捷键 Ctrl + F 打开搜索功能，你可以<strong>试着使用下方这些关键字</strong>进行搜索，查看 Hexo 主题是否写好了统计博客阅读量的代码：</p>
<ul>
<li>web analytics</li>
<li>views</li>
<li>leancloud</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212694034937.jpg" alt="-w1066"></p>
<p>譬如，我使用的 Hexo 主题「fluid」就写好了统计阅读量的代码，只是缺少相应的配置，默认就无法统计单篇文章的阅读量。</p>
<p>这里我使用一个第三方服务 <strong>Leancloud</strong> 来统计文章的阅读量。</p>
<p>首先需要打开 Leancloud 的官网，注册一个账号，注册好账号之后，点击左上角的按钮，创建一个应用。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212698785178.jpg" alt="-w1520"></p>
<p>创建时「应用名称」可以随你自由命名，下方的「应用计价方案」选择「<strong>开发版</strong>」就好，不需要花钱，接着点击右下角的蓝色按钮「创建」。<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212699186782.jpg" alt="-w1520"></p>
<p>创建好应用之后，打开应用的「设置 &gt;&gt; 应用 Keys」，页面中有两个参数，一个是 <strong>AppID</strong>，一个是 <strong>AppKey</strong>。</p>
<p>这两个参数下方的值等会要用到，暂时不要把网页关掉。<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212701931820.jpg" alt="-w1520"></p>
<p>回到博客主题的配置文件中，搜索 Leancloud，如下图所示，可以看到 leancloud 下方有两个需要配置的参数，一个是 <strong>app_id</strong>，一个是 <strong>app_key</strong>，这两个参数的值就分别对应上面说到的 <strong>AppID</strong> 和 <strong>AppKey</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212704379312.jpg" alt="-w1066"></p>
<p>接着我们还要开启每篇博客的数据统计的功能，在博客主题配置文件中搜索关键字 view。</p>
<p>每篇博客的数据统计 views 下方有两个参数，一个是 enable，将其设置为 enable 或 true 都可以；一个是统计的来源 source，设置为 leancloud。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212718906462.jpg" alt="-w1066"></p>
<p>完成以上配置之后，将所有变更 Push 到服务器，稍等一小会，刷新自己的博客，一般情况下，就可以在每篇博客的顶部看到阅读量的统计数据了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212721365539.jpg" alt="-w1742"></p>
<h2 id="交换博客「友情链接」"><a href="#交换博客「友情链接」" class="headerlink" title="交换博客「友情链接」"></a>交换博客「友情链接」</h2><p>不像以前，现在刚起步做博客更难了，因为许多人都不怎么在电脑端阅读内容了，都更倾向于使用手机获取信息，而且人们更喜欢观看视频而非枯燥的文字内容了。</p>
<p>基于种种原因，从零开始做一个博客，真的难上加难。</p>
<p>因此，如果你刚好也有自己的博客，且有交换友情链接🔗的想法，不嫌弃的话，可以在评论区留言，我们互相在各自的博客添加彼此的链接。</p>
<p>你的博客链接的位置，我已经留好了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212724879342.jpg" alt="-w1742"></p>
<p>以上，希望有帮助。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-5-13-picgoandtypora/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-5-13-picgoandtypora/" itemprop="url">Windows 写作三件套：PicGo + Typora + 腾讯云</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-12T16:00:00+00:00">
                2021-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。   </p>
<p>之前发过的一些排版不太一样的文章，我都是在 Mac 上的 Markdown 写作软件 MWeb 中写的，因为我在 MWeb 中配置了腾讯云图床，每次写好文章后，使用 MWeb 内置的上传服务，将图片上传到腾讯云图床之后返回 Markdown 链接，就可以很方便地将文章分发到多个平台，<strong>不会出现图片丢失</strong>的情况。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512115719307.png" alt="image-20210512115719307"></p>
<p>但由于 MWeb 是苹果生态独有的软件，没有 Windows 版本，这就导致我得在 Windows 上寻找其他的替代工具，来达到同样的目的。</p>
<p>先列一下我在 Windows 上写文章用到的工具：</p>
<ul>
<li>写作工具：Typora</li>
<li>图片上传工具：PicGo</li>
</ul>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>在 Windows 上使用 Markdown 格式来写文章，首先还是要解决<strong>图床</strong>的问题，这里我同样选择将图片上传到腾讯云。不过不像 MWeb 集成了图片上传功能，在 Windows 上传图片需要用到一个工具：<strong>PicGo</strong>。</p>
<p>PicGo，是一个开源免费的图片上传 + 管理工具，支持 macOS、Windows 和 Linux 系统。PicGo 配合我们等下要用到的写作工具 Typora，可以很方便地将图片上传到腾讯云图床上。</p>
<p>PicGo 下载链接：<br><em><a target="_blank" rel="noopener" href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></em></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512135204123.png" alt="image-20210512135204123"></p>
<p>看到这里，如果你还是有点稀里糊涂，可以将 PicGo 上传图片的过程，类比成你将本地的图片上传到 QQ 空间相册的操作，只不过我们上传的图片是存放在腾讯云、而非 QQ 空间上。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512135929312.png" alt="image-20210512135929312"></p>
<p>使用 PicGo 上传本地图片之前，需要先对 PicGo 进行设置：</p>
<p>点击 PicGo 左侧栏的图床设置，由于我想将图片存放到腾讯云，图床这里就选择「腾讯云 COS」，将 COS 版本的版本切换到 v5。</p>
<p>下面还有几个必须要配置的参数：</p>
<ul>
<li>SecretId</li>
<li>SecretKey</li>
<li>APPID</li>
<li>存储空间名</li>
<li>存储区域</li>
</ul>
<p>获取这些参数，需要在浏览器中打开腾讯云的官网：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/">https://cloud.tencent.com/</a>   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512140635868.png" alt="image-20210512140635868"></p>
<p>打开腾讯云登录账号之后，点击右上角的邮箱账号，选择「<strong>账号信息</strong>」，在打开的页面中，就可以看到 <strong>APPID</strong> 信息。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512141722265.png" alt="image-20210512141722265"></p>
<p>再次点击右上角的邮箱账号，选择「<strong>访问管理</strong>」，在打开的页面中，点击左侧栏的「访问密钥 &gt;&gt; API 密钥管理」，将页面中「<strong>SecretId</strong>」和「<strong>SecretKey</strong>」的值分别填入 PicGo 中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512145215009.png" alt="image-20210512145215009"></p>
<p>接着点击左上角的「云产品」，在弹出的面板中，选择「<strong>对象存储</strong>」，进入腾讯云图床的管理页面。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512142141761.png" alt="image-20210512142141761"></p>
<p>点击左侧的「存储桶列表」，可以看到自己创建的图床，对于首次使用腾讯云图床的朋友，需要点击「创建存储桶」，创建存放图片的图床。</p>
<p>创建存储桶时，需要注意的是，我们要将「访问权限」设置为「公有读私有写」，这里的「公有读」是为了之后你将图片链接用于文章中，别人可以看到图片的内容，而不是图片显示为已丢失，「私有写」则是说只有你才有上传图片或管理图床的权限。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512143147439.png" alt="image-20210512143147439"></p>
<p>创建好存储桶之后，回到存储桶列表的首页，「<strong>存储桶名称</strong>」的值就是 PicGo 中的<strong>存储名</strong>，「所属区域」下的「<strong>ap-地名拼音</strong>」对应 PicGo 就是 PicGo 中的<strong>存储区域</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512142732590.png" alt="image-20210512142732590"></p>
<p>到这里，我们就完成了 PicGo 的配置，点击下方的「确定」按钮，桌面右下角会弹出「设置成功」的提示。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512145731492.png" alt="image-20210512145731492"></p>
<p>此时，你可以切换到 PicGo 左侧栏的「上传区」，将桌面的任意一张图片拖拽到中间的「上传区域」，如果桌面右下角弹出「上传成功」的通知，则说明我们已经将 PicGo 配置好了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512150257700.png" alt="image-20210512150257700"></p>
<p>PicGo 有两种上传图片的方式：</p>
<ul>
<li>拖拽图片到上传区域上传，或者使用「点击上传」打开本地文件夹、上传图片</li>
<li>读取系统剪贴板图片后上传图片</li>
</ul>
<p>第二种上传图片的方式，就是将图片复制到系统剪贴板之后，点击「剪贴板图片」或者使用快捷键 <strong>Ctrl + Shift + P</strong>，就可以将剪贴板的图片上传到腾讯云图床。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%B8%A4%E7%A7%8D%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F.png" alt="剪贴板两种上传方式"></p>
<p>但说实话，使用 PicGo 这两种上传图片的方式，对于想一气呵成写文章的人来说，还不够高效和优雅。</p>
<p>基于此，我们可以配合写作工具 Typora，借助其内置的「<strong>上传服务</strong>」功能，将添加到 Typora 中的图片<strong>自动上传到腾讯云图床</strong>，替代使用 PicGo 手动上传图片的流程。</p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>Typora，是一款开源免费的 Markdown 编辑器，支持 Windows、macOS 和 Linux 系统。Typora 的编辑界面非常简洁，就像是一张白纸（我将软件背景设置为了深色）一样。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512161747802.png" alt="image-20210512161747802"> </p>
<p>Typora 官网：<br><em><a target="_blank" rel="noopener" href="https://www.typora.io/">https://www.typora.io/</a></em></p>
<p>为了将我们在 Typora 编辑器中添加的图片自动上传到图床，我们需要对软件进行设置，点击左上角的「文件」，选择「偏好设置」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512162922041.png" alt="image-20210512162922041"></p>
<p>切换到「图像」选项卡，首先将顶部的「插入图片时」的「无特殊操作」更改为「上传图片」，即我们往 Typora 添加图片的同时，自动执行上传图片的操作。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512163837665.png" alt="image-20210512163837665"></p>
<p>接着勾选下方的两个选项——「对网络位置的图片应用」和「插入时自动转义图片 URL」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512163753994.png" alt="image-20210512163753994"></p>
<p>下面的<strong>上传服务</strong>选择「<strong>PicGo（app）</strong>」，PICGo 路径选择 PicGo 应用安装的位置。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512164010827.png" alt="image-20210512164010827"></p>
<p>完成这些设置之后，回到 Typora 的编辑界面，当你将电脑本地的图片拖拽到 Typora、或者往 Typora 粘贴剪贴板中的图片时，插入图片的同时，它就会自动上传到腾讯云图床，并返回图片对应的 Markdown 链接。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E7%9A%84%E5%90%8C%E6%97%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.gif" alt="添加图片的同时自动上传图片"></p>
<p>至此，借助 PicGo 和 Typora 的上传服务，我们在文章中添加的图片，就存放在我们自家的图床上。这样当你把在 Typora 中写好的内容粘贴到其他的内容平台时，就再也不会遇到粘贴过去图片丢失的问题了。</p>
<p>值得一提的是，写稿子的人最怕遇到的一件事情，可能是写到一半还没保存的文档一不小就丢失了，如果你想把 Typora 作为你的主力编辑器，记得<strong>先打开它的「自动保存」</strong>，预防扑街。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512165707339.png" alt="image-20210512165707339"></p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「点赞&#x2F;在看」鼓励一下我，谢谢。</p>
<p>我的年度目标：公众号达到 1 万关注<br>目前进度 9086&#x2F;10000<br>需要得到你的支持<br>公众号千千万，在比特世界相遇也是一种缘分<br>还没关注的朋友，请点下面👇👇的卡片关注   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/04/27/gong-zhong-hao-xiao-lu-gong-ju-zhi-nan.png" alt="公众号：效率工具指南">   </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><a class="extend next" rel="next" href="/page/16/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
