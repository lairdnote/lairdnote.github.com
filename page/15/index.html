<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/15/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/15/"/>





  <title>逐流小站</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-MW47YH6RH0', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/20/ASP-NET-Core-gRPC-%E6%89%93%E9%80%9A%E5%89%8D%E7%AB%AF%E4%B8%96%E7%95%8C%E7%9A%84%E5%B0%9D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/20/ASP-NET-Core-gRPC-%E6%89%93%E9%80%9A%E5%89%8D%E7%AB%AF%E4%B8%96%E7%95%8C%E7%9A%84%E5%B0%9D%E8%AF%95/" itemprop="url">ASP.NET Core gRPC 打通前端世界的尝试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-20T21:37:36+08:00">
                2021-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在构建以 gRPC 为核心的微服务架构的过程中，我们逐渐接触到了 gRPC 的过滤器、健康检查、重试等方面的内容。虽然， Protocol Buffers 搭配 HTTP&#x2F;2 ，在整个传输层上带来了显著的性能提升，可当这套微服务方案面对前后端分离的浪潮时，我们能明显地有点“<strong>水土不服</strong>”。其实，如果单单是以 Protocol Buffers 来作为 HTTP 通信的载体，通过 <a target="_blank" rel="noopener" href="https://github.com/dcodeIO/protobuf.js">protobuf.js</a> 就可以实现前端的二进制化。考虑到 gRPC 实际的通信过程远比这个复杂，同时还要考虑<code>.proto</code>文件在前&#x2F;后端共享的问题，所以，我们面对的其实是一个相当复杂的问题。现代的前端世界，是一个<code>React</code>、<code>Angular</code>和<code>Vue</code>三足鼎立的世界，如果这个世界不能和微服务的世界打通，我们面对的或许并不是一个真实的世界。因为博主注意到，项目中有一部分 gRPC 服务被封装为<code>Web API</code>并提供给前端，这说明大家都意识到了这个问题。所以，这篇博客想和大家分享的是，如何打通 gRPC 和 前端 两个不同的世界，这里介绍四种方式：<strong>gRPC-Web</strong>、<strong>gRpc-Gateway</strong>、<strong>封装 Web API</strong>、<strong>编写中间件</strong>，希望能给大家带来一点启发。</p>
<h1 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h1><p><a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Web</a> 是官方提供的一个方案，它的原理是利用命令行工具<code>ptotoc</code>及其插件<code>protoc-gen-grpc-web</code>来生成<code>.proto</code>对应的客户端代码，这些代码经过<code>webpack</code>这类打包工具处理以后，就可以在前端使用。所以，对于 gRPC-Web ，你可以从两个方面来考虑它：第一，它支持生成强类型的客户端代码；第二，它支持在非 HTTP&#x2F;2 环境下使用 gRPC 。下面是一个基本的使用流程：</p>
<p>首先，我们需要下载命令行工具：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">protoc</a> 及其插件：<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-web/releases">protoc-gen-grpc-web</a>。</p>
<p>此时，我们可以使用下面的命令来生成<code>JavaScript</code>版本的 gRPC 代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc greetjs.proto \</span><br><span class="line">  --js_out=import_style=commonjs:. \</span><br><span class="line">  --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. \</span><br><span class="line">  --plugin=protoc-gen-grpc-web=C:\Users\Payne\go\bin\protoc-gen-grpc-web.exe</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>--js_out</code> 和 <code>--grpc-web_out</code> 分别指定了我们要生成的<code>JavaScript</code>代码的模块化标准，这里使用的是 <a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS</a> 规范。</li>
<li><code>mode=grpcwebtext</code> 指定 gRPC-Web 的数据传输方式。目前：支持两种方式，application&#x2F;grpc-web-text(Base64 编码，文本格式) 和 application&#x2F;grpc-web+proto(二进制格式)，前者支持 Unary Calls 和 Server Streaming Calls，后者只支持 Unary Calls。</li>
</ul>
<p>在这个例子中，会生成下面两个文件，它们分别定义了<code>客户端</code>和<code>消息</code>这两个部分：</p>
<p><img src="https://i.loli.net/2021/06/22/Yd9A5CEONkZgBjU.png" alt="利用 protoc 生成 JavaScript 代码"></p>
<p>此时，我们可以这样编写我们的逻辑代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> proto.<span class="property">greet</span>.<span class="title class_">GreeterClient</span>(<span class="string">&#x27;http://localhost:8000&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> proto.<span class="property">greet</span>.<span class="title class_">HelloRequest</span>();</span><br><span class="line"><span class="keyword">var</span> metadata = &#123; &#125;</span><br><span class="line">request.<span class="title function_">setName</span>(<span class="string">&#x27;长安书小妆&#x27;</span>);</span><br><span class="line">client.<span class="title function_">sayHello</span>(request, metadata, <span class="keyword">function</span>(<span class="params">error, response</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你更倾向于使用类型安全的 TypeScript，你还可以按下面的方式来生成代码：</p>
<ul>
<li><code>import_style=commonjs+dts</code>: CommonJS &amp; .d.ts typings</li>
<li><code>import_style=typescript</code>: 100% TypeScript</li>
</ul>
<p>更多的细节请参考官方文档：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/grpc/grpc-web#typescript-support">https://hub.fastgit.org/grpc/grpc-web#typescript-support</a></p>
<p>接下来，对于 .NET 开发者而言， gRPC-Web 意味着我们只需要简单地配置下 ASP.NET Core 的中间件管道，就可以享受到上面提供的这些便利。因为 Visual Studio 会在编译<code>.proto</code>文件时，自动帮你生成这个客户端代码，我们可以将这一技术应用到单页面应用(<strong>SPA</strong>) 和 WebAssembly 中，最典型的例子莫过于微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-5.0">Blazor</a>，它使得 gRPC 可以充当客户端与服务端间的信使。同样地，这里准备了相关的示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseGrpcWeb();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;().EnableGrpcWeb();</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家留意一下微软官方的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/grpc/grpc-dotnet/blob/master/examples/Browser/Server/wwwroot/Scripts/index.js">示例项目</a>，就会发现和这里类似的东西，因为原理上一脉相承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">HelloRequest</span>, <span class="title class_">HelloReply</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./greet_pb.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">GreeterClient</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./greet_grpc_web_pb.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="title class_">GreeterClient</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sendInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;send&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> streamInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> resultText = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unary call</span></span><br><span class="line">sendInput.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">HelloRequest</span>();</span><br><span class="line">    request.<span class="title function_">setName</span>(nameInput.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">sayHello</span>(request, &#123;&#125;, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">        resultText.<span class="property">innerHTML</span> = <span class="title function_">htmlEscape</span>(response.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gRPC-Web 在将 gRPC 带入前端世界的过程中，其实是牺牲了一部分重要特性的，譬如浏览器中无法实现 HTTP&#x2F;2，相对应地，gRPC-Web 不再支持客户端流和双向流，依然支持服务端流，博主猜测可能是利用了服务端发送事件(<strong>Server Sent Event</strong>)。不过，这并不影响我们对这个项目的敬意，感谢它将 gRPC 带入了前端的世界。</p>
<h1 id="gRPC-Gateway"><a href="#gRPC-Gateway" class="headerlink" title="gRPC-Gateway"></a>gRPC-Gateway</h1><p><a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a> 同样是命令行工具<code>protoc</code>的一个插件，其原理是，读取 gRPC 服务定义，并生成一个反向代理服务器，将 RESTful JSON API 转换为 gRPC 。而两者间的对应关系，则是通过<code>.proto</code>文件中的自定义选项来维护的。简单来说，就是在我们定义 gRPC 服务的同时，增加一组选项来表明这是一个 RESTful JSON API 。目前，这个插件只支持<code>Go</code>语言的代码生成。所以，如果想玩一玩这个插件，需要大家安装好<code>Go</code>的环境。</p>
<p>首先，我们从 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/protocolbuffers/protobuf/releases/tag/v3.6.1">Github</a> 下载 Protocol Buffers 的编译器，它负责从从<code>.proto</code>文件生成代码。</p>
<p>这里我们选择 Windows 版本，直接将其解压到一个非中文的路径下即可。</p>
<p><img src="https://i.loli.net/2021/06/21/eTfGF9hI6cPSlwR.png" alt="Protocol Buffers 的编译器"></p>
<p>这里，我们需要配置下面两个环境变量：</p>
<ul>
<li>PATH：C:\Program Files\Protobuf\bin</li>
<li>PROTOC_INCLUDE：C:\Program Files\Protobuf\include</li>
</ul>
<p>接下来，在<code>Go</code>环境中进行以下设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway </span><br><span class="line">go install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger </span><br><span class="line">go install github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过<code>Go</code>完成了<code>protoc</code>的插件的安装。此时，我们可以通过下面的命令来生成<code>Go</code>代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成Go的客户端代码</span></span><br><span class="line">protoc --proto_path=. \</span><br><span class="line">  --go_out=. \</span><br><span class="line">  --plugin=protoc-gen-go=C:\Users\Payne\go\bin\protoc-gen-go.exe \</span><br><span class="line">  ./greet.proto </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成Go的反向代理服务器端代码</span></span><br><span class="line">protoc \</span><br><span class="line">  -I C:\Users\Payne\go\pkg\mod\github.com\grpc-ecosystem\grpc-gateway@v1.9.0\third_party\googleapis\ \</span><br><span class="line">  --proto_path=. \</span><br><span class="line">  --grpc-gateway_out=. \</span><br><span class="line">  --plugin=protoc-gen-grpc-gateway=C:\Users\Payne\go\bin\protoc-gen-grpc-gateway.exe \</span><br><span class="line">  ./greet.proto </span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面两个<code>.go</code>格式的文件：</p>
<p><img src="https://i.loli.net/2021/06/22/wHvUzr5OybAtfkS.png" alt="通过 grpc-gateway 生成 Go 代码"></p>
<p>关于反向代理服务器的观点的验证，大家可以从生成的第二个文件中去发现。</p>
<p>而关于 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a> 这个插件的使用，最直观的用法，其实应该来自<code>.proto</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// Go里面的包名，必选</span><br><span class="line">option go_package = &quot;grpc-gateway/hello-word&quot;;</span><br><span class="line"></span><br><span class="line">package greet;</span><br><span class="line"></span><br><span class="line">// Google的API注解相关的.proto文件，必选</span><br><span class="line">import &quot;Protos/google/api/annotations.proto&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;</span><br><span class="line">      option (google.api.http) = &#123; </span><br><span class="line">          post: &quot;/v1/greet/sayHello&quot;</span><br><span class="line">          body: &quot;*&quot; </span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到博主并不擅长<code>Go</code>这门语言，这里我们就不再对它做进一步的探索啦！事实上，我觉得这个方案非常糟糕，因为只要修改了<code>.proto</code>文件，这个代理服务器就要重新生成，更不用说只支持<code>Go</code>这一显著的缺点啦！</p>
<h1 id="封装-Web-API"><a href="#封装-Web-API" class="headerlink" title="封装 Web API"></a>封装 Web API</h1><p>封装 Web API，这是一个非常朴实无华的方案，博主目前的公司就是采用这种方案，所以，你能想象得到，基本就是在控制器中调用客户端。唯一的弊病在于，这是一个非常低效的工作。当年，博主的前公司，就是风风火火地要这样替换掉 WCF，结果最终还是不了了之。所以说，世间没有银弹，历史不过是一次次地重复上演。下面是一个简单的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SayHello</span>(<span class="params">HelloRequestDTO requestDTO</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> request = requestDTO.Adapt&lt;HelloRequest&gt;();</span><br><span class="line">    <span class="keyword">var</span> client = _serviceProvider.GetService&lt;Greeter.GreeterClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> replay = <span class="keyword">await</span> client.SayHelloAsync(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(replay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而一旦做到这一层，其实我们是把一个未知的问题转化成一个已知的问题，这是数学家最常用的思路。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>();</span><br><span class="line">headers.<span class="title function_">append</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">   <span class="attr">headers</span>: headers,</span><br><span class="line">   <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;长安书小妆&#x27;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://localhost:44372/Greet/SayHello&quot;</span>, options)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error));</span><br></pre></td></tr></table></figure>

<p>那么，下一个问题，你打算用 Fetch API 还是 Axios 呢？这个问题就交给前端的朋友啦！因为，我是一个伪全栈工程师(逃。</p>
<h1 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h1><p>其实，读到这里，你就会明白，这才是我真正要分享的内容，而此前种种，不过是我为了丰富这个话题而抛出的它山之石。既然觉得手写 Web API 太麻烦，那么我们能不能用一种新的思路来解决这个问题呢？这里说一下博主的思路，用户传入 JSON，经过中间件反序列化为<code>.proto</code>对应的类型，我们将这个类型传递给 gRPC 的客户端作为请求参数，等拿到结果以后，我们再将它序列化为 JSON 即可。这样，我们就实现了将一个 gRPC 服务转化为 Web API 的想法。下面是具体的代码，其实这个代码并不复杂，我最初打算用反射来解决，可惜 gRPC 生成的这个客户端方法重载实在太多啦，所以，我最后决定用下面的这种方式。当然啦，缺点就和 gRPC-Gateway 一样，每一个接口都要单独写，好处大概是代码量减少了好多。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义扩展方法：AddGrpcGateway</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcGateway</span>&lt;<span class="title">TClient</span>,<span class="title">TRequest</span>,<span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">this</span> IApplicationBuilder app, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">string</span> route, </span></span></span><br><span class="line"><span class="params"><span class="function">  Func&lt;<span class="built_in">string</span>, TRequest&gt; requestBuilder, </span></span></span><br><span class="line"><span class="params"><span class="function">  Func&lt;TClient,TRequest,TResponse&gt; responseBuilder</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt; endpoints.MapPost(route, <span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> streamReader = <span class="keyword">new</span> StreamReader(context.Request.Body))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = (TClient)app.ApplicationServices.GetService(<span class="keyword">typeof</span>(TClient));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> payload = <span class="keyword">await</span> streamReader.ReadToEndAsync();</span><br><span class="line">            <span class="keyword">var</span> request = requestBuilder(payload);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> reply = responseBuilder(client, request);</span><br><span class="line">            <span class="keyword">var</span> response = JsonConvert.SerializeObject(reply);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(response));</span><br><span class="line">            context.Response.StatusCode = <span class="number">200</span>;</span><br><span class="line">            context.Response.ContentType = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，这个方案依赖 gRPC 的客户端代码，同时需要读取 HTTP 的请求体，所以，我们还需要下面的代码作为辅助：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们通过中间件配置一个路由即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议放在 UseEndpoints() 方法下面</span></span><br><span class="line">app.AddGrpcGateway&lt;Greeter.GreeterClient, HelloRequest, HelloReply&gt;(</span><br><span class="line">    route: <span class="string">&quot;greet/SayHello&quot;</span>,</span><br><span class="line">    requestBuilder: json =&gt; <span class="keyword">new</span> MessageParser&lt;HelloRequest&gt;(() =&gt; <span class="keyword">new</span> HelloRequest()).ParseJson(json),</span><br><span class="line">    responseBuilder: (client, request) =&gt; client.SayHelloAsync(request).ResponseAsync.Result</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>为了证明这个中间件真的有用，我们用 <a target="_blank" rel="noopener" href="https://www.apifox.cn/">Apifox</a>  或者 <a target="_blank" rel="noopener" href="https://www.postman.com/downloads/">Postman</a> 测试一下看看。</p>
<p><img src="https://i.loli.net/2021/06/21/hEmSVqOCy9tBbdv.png" alt="自定义中间件实现 gRPC 转 API 效果"></p>
<p>此时，可以看到，这就真的和调用一个 Web API 一样，我们完全意识不到，这是一个 gRPC 服务。你觉得，这样子算是达到目的了吗？</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，本文完全是临时想起来决定要写的一篇文章，起因就是看到了项目中有人在手动地封装 gRPC 服务为 RESTful 服务，当时就在想有没有一种方案，可以让这个过程稍微好一点点。所以，你可以认为，我写这篇博客的初衷，原来就是为了炫耀我写的那几行代码。不过，人到了一定的阶段以后，不管是写作还是思考，都似乎越来越喜欢某种框架结构，这种体验就有点像是上学时候写论文一样，虽然你明确地知道自己在做什么，可当你真正要把你的思路或者过程复述出来的时候，你还是需要有一个“文献综述”的环节。我个人以为，这是一种由外及内的认知方法，通过内外世界的对比来寻找自我提升的突破口。对于本文而言，不管是 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Web</a> 还是 <a target="_blank" rel="noopener" href="https://github.com/grpc-ecosystem/grpc-gateway">gRPC-Gateway</a>，从本质上来讲，它们都是 Protocol Buffers 工具链中的插件，在这个过程中发现了平时使用 gRPC 过程中被隐藏了的一部分细节，这些细节如果能和开发工具完美结合的话，就可以极大地提升我们在 gRPC 方面的开发效率，譬如 gRPC-Web 在 .NET 中的实现就利用了 MSBuild 的自定义编译任务，这就让底层的 Protocol Buffers 工具链、前端构建工具等对使用者来说是无感知的，从开发体验上就给人心旷神怡的感觉。我个人还是倾向于结合 ASP.NET Core 或者容器级别的 Envoy 来解决这个问题，我觉得应该还有更好的方案，希望大家可以在评论区写下你的想法。好啦，这篇博客就先写到这里，谢谢大家！</p>
<h1 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h1><p>截至 2021 年 6 月 25 日，基于中间件的方案已支持以下特性：自动注入客户端、自动配置路由。详情请参考：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway">https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/GRPC.Logging/Grpc.Gateway</a>。在此方案下，只需要 4 行代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.Configure&lt;KestrelServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.Configure&lt;IISServerOptions&gt;(x =&gt; x.AllowSynchronousIO = <span class="literal">true</span>);</span><br><span class="line">    services.AddGrpcClients(opt =&gt; opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...     </span></span><br><span class="line">    app.AddGrpcGateway();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/19/2021-6-19-python_bili/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/19/2021-6-19-python_bili/" itemprop="url">用 Python 爬取 B 站视频弹幕，生成词云图</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-19T18:00:00+08:00">
                2021-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>最近 B 站上有一个超火且非常洗脑的视频《蜜雪冰城主题曲MV 中英双语版》，视频中原来的歌词是「<strong>你爱我，我爱你，蜜雪冰城甜蜜蜜</strong>」。</p>
<p>看到有些网友在弹幕中把它篡改成「<strong>你碍我，我碍你，你学编程天灭你</strong>」，哈哈哈哈哈。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640.png" alt="图片"></p>
<p>为了弄清这些有趣的网友都在弹幕中说了啥，结合我之前学会的一点 <strong>Python 爬虫</strong>的知识，我用 Python 抓取了这个视频的所有弹幕，并将弹幕做成了如下的<strong>词云图</strong>：</p>
<p>词云图会自动将比较长的弹幕拆分成单个的词汇，之后根据单个词汇出现的频率来决定字号的大小，<strong>字号越大，说明在弹幕中出现的频率越高</strong>。</p>
<p>显而易见，出现次数最多的弹幕当属「<strong>哈哈哈哈哈哈</strong>」，即便长大了，听到这可爱的儿歌，看到这萌萌哒雪人，还是会觉得欢乐无穷。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210847892.png" alt="图片"></p>
<p>看完上面的词云图，如果你想知道词云图是怎么生成的，可以继续看下面的文章。</p>
<p>我也将用到的源码放到了 GitHub 上，有需要的朋友可以前往 GitHub 下载或复制代码，跟着我一起「<strong>改代码</strong>」，之后就能<strong>随意抓取任意 B 站视频的弹幕了</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210858176.png" alt="图片">  </p>
<p><strong>抓取 B 站视频弹幕 Python 代码</strong>：<br><a target="_blank" rel="noopener" href="https://github.com/phh95/pythonProject/tree/main/%E6%8A%93%E5%8F%96B%E7%AB%99%E5%BC%B9%E5%B9%95">https://github.com/phh95/pythonProject/tree/main/%E6%8A%93%E5%8F%96B%E7%AB%99%E5%BC%B9%E5%B9%95</a>       </p>
<p><strong>制作词云图的流程</strong>是这样的：先使用 <strong>dammu_spider.py</strong> 抓取视频的弹幕，得到一个<strong>包含所有弹幕的 txt 文件</strong>，再用 <strong>词云.py</strong> 将得到的 txt 文件导出为<strong>词云图</strong>。</p>
<h2 id="01-安装-Python"><a href="#01-安装-Python" class="headerlink" title="01. 安装 Python"></a><strong>01. 安装 Python</strong></h2><p>打开 Python 官网，下载最新版的 Python3.9.5，它支持 Windows、macOS 和 Linux 系统。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210822844.png" alt="图片"></p>
<p><strong>Python 官网地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></em></p>
<p>下载之后，打开 Python 安装程序，先勾选安装面板下方的「<strong>Add Python 3.x to PATH</strong>」，再点击「<strong>Install Now</strong>」，一直点下一步等待 Python 完成安装。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210815165.png" alt="图片来自网络"></p>
<p>安装好 Python 之后，为了确认我们配置好了 Python 环境，可以按下 <strong>Win + S</strong> 打开 Windows 自带的搜索，输入 <strong>cmd</strong>，打开「<strong>命令提示符</strong>」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210914887.png" alt="图片"></p>
<p>在打开的窗口中，输入 <strong>python</strong> 后按下回车，如果下方<strong>返回 Python 的版本号</strong>，例如我这里返回的版本号是 <strong>Python 3.9.2</strong> ，则说明 Python 已经配置妥当了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210922315.png" alt="图片"></p>
<h2 id="02-安装-Python-开发工具"><a href="#02-安装-Python-开发工具" class="headerlink" title="02. 安装 Python 开发工具"></a><strong>02. 安装 Python 开发工具</strong></h2><p>写 Python 代码有很多工具，如下图所示，这些工具被统称为 <strong>IDE</strong>，这是英文 Integrated Development Environment 的缩写，中文翻译为「<strong>集成开发环境</strong>」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210929929.png" alt="图片"></p>
<p>目前我用过的开发工具有两个，一个是社区版的 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649912923&idx=1&sn=26e8b3b8a7a12983c03781551b67b96f&chksm=83a87276b4dffb60265b4cc75eab2fe6e7992e924ad2577e2ae45af9a0f2ba1202c27f2f4670&scene=21#wechat_redirect"><strong>PyCharm</strong></a>，一个是微软推出的 VS Code。</p>
<p>如果你贪图方便的话，可以使用 PyCharm，而如果你用的是 VS Code，还需要给 VS Code 安装一个名为「<strong>Python</strong>」的插件。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210938217.png" alt="图片"></p>
<p>关于如何让 VS Code 的语言变成<strong>中文</strong>以及<strong>安装插件</strong>的问题，可以看之前我写过的一篇文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649881449&idx=1&sn=56c9016004fb2cb9960d8300c230a079&chksm=83abff44b4dc7652e2957e8dfd63c5bcca8f667731bc3fd1272aa908664695313b5e8ac0c6f7&scene=21#wechat_redirect"><strong>那些排版好看的公众号，都在偷偷用这些神器！</strong></a></p>
<p><strong>PyCharm 下载地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></em></p>
<p><strong>VS Code 下载地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></em></p>
<h2 id="03-安装第三方-Python-库"><a href="#03-安装第三方-Python-库" class="headerlink" title="03. 安装第三方 Python 库"></a><strong>03. 安装第三方 Python 库</strong></h2><p>爬取 B 站弹幕的代码中，用到了 Python 没有内置的第三方库，为了不影响后续程序的运行，我们先安装一下这些第三方库：</p>
<ul>
<li>requests</li>
<li>jieba</li>
<li>wordcloud</li>
</ul>
<p>安装这些库也非常简单，先打开 <strong>Windows</strong> 自带的「<strong>命令提示符</strong>」窗口，如果你用的是 Mac 电脑，则打开 <strong>macOS</strong> 系统自带的「<strong>终端</strong>」。</p>
<p>在命令提示符窗口中分别输入 <strong>pip3 install + 第三方库的名称</strong>，例如安装 wordcloud 库，就输入 <strong>pip3 install wordcloud</strong> 。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210950937.png" alt="图片"></p>
<p>如果程序可以顺利安装的话，在末尾会提示「<strong>Successfully installed</strong>」，至于最末尾出现的黄色警告文字「WARNING」，它是警告信息而不是报错，可以忽略它们。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210956347.png" alt="图片"></p>
<p>重复上面的操作，分别逐一安装三个第三方库 requests、jieba 和 wordcloud。</p>
<p>安装好第三方库之后，就可以开始修改代码啦。由于我在 Windows 电脑上用的 IDE 是 <strong>VS Code</strong>，下面就以 VS Code 来演示如何修改 Python 代码：</p>
<h2 id="04-修改抓取视频弹幕的代码"><a href="#04-修改抓取视频弹幕的代码" class="headerlink" title="04. 修改抓取视频弹幕的代码"></a><strong>04. 修改抓取视频弹幕的代码</strong></h2><p>在 VS Code 中使用快捷键 <strong>Ctrl + N</strong> 新建一份文档，刚开始我们需要确定我们想使用的编程语言。</p>
<p>点击文档第一行的蓝色文字「<strong>选择语言</strong>」，在弹出的输入框中输入 Python，点击下方返回的 Python。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211003487.png" alt="图片"></p>
<p>打开 GitHub 上的 danmu_spider.py 文件，用鼠标选中所有代码，右击选择「复制」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211009372.png" alt="图片"></p>
<p>将复制的代码粘贴到 VS Code 中，我们最先要更改的代码是 <strong>url 的值</strong>，这个 url 指向的是<strong>视频的弹幕地址</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211014766.png" alt="图片"></p>
<p>打开你想抓取弹幕的 B 站视频，按下 <strong>F12</strong> 键，打开<strong>浏览器开发者工具</strong>，切换到 <strong>Network</strong> 选项卡，再点击视频右侧弹幕列表的「<strong>展开</strong>」按钮。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211019811.png" alt="图片"></p>
<p>拖动开发者工具右下角的滑钮，将其拖拽到底部，接着点击弹幕列表底部的「查看历史弹幕」，随意选择一个日期。</p>
<p>例如我选择查看 <strong>6 月 10 日</strong>的弹幕，下方的开发者工具，会新增一个后缀为 <strong>data&#x3D;2020-06-10</strong> 的记录。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210656010-20210619211025852.png" alt="图片"></p>
<p>点击这条记录，在右侧展开的 General &gt;&gt; <strong>Request URL</strong>，就可以看到获取这一天的所有弹幕的链接地址，<strong>复制 Request URL 后面的 https 链接</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211031366.png" alt="图片"></p>
<p>将其粘贴到 VS Code 中的 url 处，并**将链接末尾的日期，替换为 {date}**，这是为了后面更灵活地指定抓取的弹幕所在的日期。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211035945.png" alt="图片"></p>
<p>url 上方的 range(5,18) 就可以用来指定我们想<strong>抓取哪几天的弹幕</strong>，这里的 (<strong>5,18</strong>) 意思就是我想抓取蜜雪冰城视频，从 6 月 5 号到 6 月 18 号这段时间的所有视频弹幕。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211041265.png" alt="图片"></p>
<p>至于你需要如何修改这两个参数，可以查看对应视频的<strong>历史弹幕小日历</strong>，来决定你要如何设置这两个参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211047607.png" alt="图片"></p>
<p>接着代码中要修改的参数是 <strong>cookie</strong>，这个参数记录了你的登录信息，因此只有在浏览器中<strong>登录自己的 B 站账号</strong>，才能找到这个我们需要的参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211055382.png" alt="图片"></p>
<p>cookie 同样可以在开发者工具面板中找到，在刚点开的 06-10 记录中，向下滑动右侧的滑动，就可以在 <strong>Request Headers</strong> 中看到 <strong>cookie</strong> 了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211101597.png" alt="图片"></p>
<p>将 cookie 的值复制到 VS Code 中进行替换，原本有好几行的 cookie 值会变成一行：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211107753.png" alt="图片"></p>
<p>这里复制的 cookie 值还有一个<strong>小问题</strong>，cookie 值里面包含了一个<strong>英文的单引号</strong>，这在 Python 中会让程序<strong>误以为 cookie 值到这里就结束了</strong>，实际上并没有。</p>
<p>为了解决这个问题，我们需要在这个单引号的前面加一个反斜杠 \ ，通过<strong>转义</strong>的方式，让它变成一个<strong>普通的单引号</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211205866.png" alt="图片"></p>
<p>接着还需要<strong>修改一下保存抓取的弹幕的 txt 文件的名称</strong>，名称可以随你起，可以是中文，也可以是英文，记得名称末尾需要<strong>带上格式后缀 .txt</strong> 。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211215478" alt="图片"></p>
<p>修改好以上代码之后，右击鼠标，选择「<strong>在终端中运行 Python 文件</strong>」，Python 就会开始运行当前的代码。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211221472.png" alt="图片"></p>
<p>运行程序没有报错、顺利的话，你就可以得到一个包含有多个弹幕的 <strong>txt 文件</strong>，这个文件位于 <strong>C 盘 &gt;&gt; 用户 &gt;&gt; 用户名</strong> 路径下。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211227217.png" alt="图片"></p>
<p>如果你在这个路径下找不到 txt 文件，可以使用 Windows 自带的搜索，以 txt 文件名进行搜索，应该就可以找到这个文件。</p>
<h2 id="05-修改导出词云图的代码"><a href="#05-修改导出词云图的代码" class="headerlink" title="05. 修改导出词云图的代码"></a><strong>05. 修改导出词云图的代码</strong></h2><p>得到所有弹幕文本之后，我们还需要将得到的文本再作进一步的处理，才能得到最终想要的词云图。</p>
<p>同样在 VS Code 中新建一个文档，将 GitHub 上的 <strong>词云.py</strong> 的代码复制到文档中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211239037.png" alt="图片"></p>
<p>首先修改第 6 行的代码，这里需要替换成你在上一步抓取得到的<strong>弹幕 txt 文件的名称</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211244415" alt="图片"></p>
<p>接着来到第 25、26 行代码，这里需要设置导出的词云图所使用的字体，如果你用的是 Windows 系统，那么就使用第 25 行代码，将 26 行代码删除。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211248486.png" alt="图片"></p>
<p>如果你的电脑系统是 <strong>macOS</strong>，那么就使用第 26 行代码，将字体设置为苹果系统自带的<strong>苹方字体</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210703139-20210619211253542.png" alt="图片"></p>
<p>接着来到文档的最后一行代码，这里用来<strong>设置导出的词云图的名称</strong>，同样图片的名称可以随意设置，最后别忘了加上<strong>格式后缀 .png</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619210703761.png" alt="图片"></p>
<p>修改好之后，同样右击鼠标，选择「<strong>在终端中运行 Python 文件</strong>」，运行修改好的 Python 程序。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211303730.png" alt="图片"></p>
<p>程序运行完毕，和之前导出的弹幕文件相同路径下，即 <strong>C 盘 &gt;&gt; 用户 &gt;&gt; 用户名</strong> 路径，就可以看到导出的词云图了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/640-20210619211309259.png" alt="图片"></p>
<p>以上，就是使用 Python 抓取 B 站视频弹幕、并导出词云图的过程了，仅说明了如何修改现成的代码，如果要说清代码是如何写出的，那就要花费更多的功夫了。</p>
<p>本文的代码参考了一个视频和一篇文章，在此也一并列出，感兴趣的朋友可以去看一下：</p>
<p>[1] 【Python】爬取B站弹幕，看哪个弹幕更有梗？，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UK4y137Ye">https://www.bilibili.com/video/BV1UK4y137Ye</a>    </p>
<p>[2] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwNDY5OTI2OA==&mid=2247484638&idx=1&sn=262ff53eaafb742387ab6e936cafef9c&scene=21#wechat_redirect"><strong>Python爬取B站弹幕并制作词云图</strong></a></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a><strong>欢迎关注</strong></h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/18/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/18/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/" itemprop="url">完成新冠疫苗接种</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-18T20:00:00+08:00">
                2021-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%A7%82%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">观点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>今天终于完成了在两针新冠疫苗的接种程序，打完没有什么不良反应。不过按照现在这个变异病毒蔓延的情况看，可能还需要第三针加强针疫苗，也不知道什么时候能安排上。</p>
<p>按照不同年龄层，香港对新冠疫苗的接种安排了不同的时间，而且需要现在网上预约两针接种的日期和地点。接种的疫苗有 BNT &#x2F;复兴的“复必泰” mRNA 疫苗和科兴的“克尔来福”灭活疫苗两种选择，我选择了国产的科兴“克尔来福”灭活疫苗。提供科兴疫苗接种的社区疫苗接种中心离我还挺近的，走路就能到。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/06/18/2021/57-%E5%AE%8C%E6%88%90%E6%96%B0%E5%86%A0%E7%96%AB%E8%8B%97%E6%8E%A5%E7%A7%8D/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/17/EFCore%20%E5%AE%9E%E4%BD%93%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E5%BA%93%EF%BC%9AEFCore.NamingConventions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/17/EFCore%20%E5%AE%9E%E4%BD%93%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E5%BA%93%EF%BC%9AEFCore.NamingConventions/" itemprop="url">EFCore 实体命名约定库：EFCore.NamingConventions</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-17T16:37:11+08:00">
                2021-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在软件开发过程中，数据库永远都是绕不开的一个话题。有时候，我们甚至会因此而获得一个名字——“<strong>CURD Boy</strong>”。虽然不过是朴实无华的“<strong>增删查改</strong>”，可隐隐然早已分出了无数的流派。在这些不同的流派中，有的人坚持“<strong>我手写我心</strong>”，认为手写<code>SQL</code>才是真正的王道，没有读过&#x2F;写过成百上千行的存储过程，便不足以谈论程序员的人生。而有的人喜欢<code>ORM</code>的清晰、整洁，认为数据库和面向对象存在着天然抗阻，<code>ORM</code>更有利于推进<code>DDD</code>和微服务的落地。相信大家都听说过<code>Java</code>里的<code>SSH</code>框架，从<code>Hibernate</code>到<code>Mybatis</code>再到<code>Spring Data JPA</code>，可以说这种争论一直没有停止过。这里我们不打算讨论这个问题，我们平时使用<code>EF</code>或者<code>EFCore</code>的过程中，作为连接数据库和面向对象两个异世界的桥梁，<code>ORM</code>需要我们来告诉它，实体数据与数据库表字段的映射关系，所以，经常需要通过<code>数据注解</code>或者<code>Fulent API</code>来写各种配置。那么，有没有什么方案可以让我们偷这个懒呢？下面隆重请出本文的主角：<a target="_blank" rel="noopener" href="https://github.com/efcore/EFCore.NamingConventions">EFCore.NamingConventions</a>。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><a target="_blank" rel="noopener" href="https://github.com/efcore/EFCore.NamingConventions">EFCore. NamingConventions</a>，目前由一个非官方的组织进行维护，代码托管在 Github 上，100％的开源项目。</p>
<p>如果你希望直接使用它的话，可以直接通过<code>NuGet</code>进行安装：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package EFCore.NamingConventions  </span><br></pre></td></tr></table></figure>

<p>接下来，我们只需要在<code>DbContext</code>的  <code>OnConfiguring()</code>方法中，调用它提供的扩展方法即可： </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span>  </span><br><span class="line">=&gt; optionsBuilder  </span><br><span class="line">.UseSqlite(<span class="string">&quot;Data Source=Chinook.db&quot;</span>)</span><br><span class="line">.UseSnakeCaseNamingConvention();  </span><br></pre></td></tr></table></figure>

<p>或者，你可以使用依赖注入的方式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;ChinookContext&gt;(options =&gt; </span><br><span class="line">    options.UseSqlite(<span class="string">&quot;Data Source=Chinook.db&quot;</span>)</span><br><span class="line">          .UseSnakeCaseNamingConvention()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里我以<code>SQLite</code>数据库为例，来展示它的具体使用细节。事实上，它提供了 4 种命名约定的策略：</p>
<ul>
<li>UseSnakeCaseNamingConvention: <code>FullName</code> -&gt; <code>full_name</code></li>
<li>UseLowerCaseNamingConvention: <code>FullName</code> -&gt; <code>fullname</code></li>
<li>UseCamelCaseNamingConvention: <code>FullName</code> -&gt; <code>fullName</code></li>
<li>UseUpperCaseNamingConvention: <code>FullName</code> -&gt; <code>FULLNAME</code></li>
</ul>
<p>简单来说，就是当我们的实体中存在一个属性<code>FullName</code>时，它会告诉<code>EF</code>或者<code>EFCore</code>，这个属性<code>FullName</code>对应的表字段是什么。  </p>
<p>虽然，在大多数的场景中，我们都希望属性名称和表字段一致，可你要知道，像<code>Oracle</code>这种对大小写敏感的数据库，特别喜欢自作聪明地帮你全部改成大写。</p>
<p>所以，在上家公司工作的时候，为了兼容<code>Oracle</code>这病态的癖好，公司里有个不成文的规定，那就是：所有实体的属性名称最好都大写。</p>
<p>本来大家用驼峰命名就是为了好认单词，好家伙！这下全部大写了，一眼望过去简直就是灾难，因为没有办法做到“<strong>望文生义</strong>”，如果那个时候知道这个库的存在，是不是就能解决这个问题了呢？</p>
<h1 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h1><p>下面我们以<code>UseSnakeCaseNamingConvention</code>为例，结合<code>SQLite</code>来做一个简单的例子。</p>
<p>首先，我们定义必要的实体，并为<code>DbContext</code>配置实体命名约束规则：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artist</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Artist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，通过迁移命令来生成数据库架构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration &quot;Init-Database&quot; -Context ChinookContext</span><br><span class="line">Update-Database</span><br></pre></td></tr></table></figure>

<p>可以注意到，生成的数据库表字段会以小写+下划线的方式命名。这就是所谓的实体命名约束。</p>
<p><img src="https://i.loli.net/2021/06/18/cSVRWrDTbnv29Ze.png" alt="通过实体命名约束生成的 Album 表"></p>
<p>只要大家都看着这个约定来写实体的属性，这套机制就可以完美工作。它和<code>MVC</code>里的默认路由一样，都是属于一种“<strong>约定大于配置</strong>”的方案。</p>
<p>在我看来，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。</p>
<p>以上就是<code>EFCore.NamingConventions</code>的基本用法，更多的细节大家可以去阅读它的<code>README</code>，因为这个库需要结合迁移功能来使用，所以，如果要在已存在的表上应用这套约束规则时，建议大家还是小心谨慎一点。</p>
<p>我个人觉得，它可以方便团队去制定一套数据库规范，进而去约束开发人员写出更规范的命名。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要介绍了可用于<code>EFCore</code>的实体命名约束库：<code>EFCore.NamingConventions</code>。这是一个由社区维护的、开源的项目，它可以在创建<code>DbContext</code>的时候，指定一个实体命名约束规则，即实体属性如何与数据库表字段进行对应，这是一种约定大于配置的方案，一旦团队形成了属于自己的数据库命名风格，那么，研发人员只需要按照规范为实体属性命名，例如开发人员可以使用驼峰风格的命名，而数据库管理员则可以使用下划线风格的命名。这样，就可以省略一部分字段映射的配置代码，从而提高团队研发的效率。值得说明的一点是，不管是配置还是约定。当以团队为单位进行协作时，最好还是以文档的形式记录下来，否则会出现两种结局，<strong>其一是没人知道怎么配置，其二是新人不知道有这个约定</strong>。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/13/2021-06-13-the-mindset-book-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/13/2021-06-13-the-mindset-book-summary/" itemprop="url">谈谈心智控制 - 读《终身成长》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-13T23:44:56+08:00">
                2021-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/images/mindset-book-1.jpg" class="">

<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近看了一本畅销书《终身成长》，里面主要对比两种思维：固定型思维和成长型思维。</p>
<p>固定型思维把任何挫折当做对自己的否定，而成长型思维把这个看做通往成功的必经之路。</p>
<p>有趣的是，这类思想的书我看了很多。从《和时间做朋友》到《为什么佛教是真的》；从《真实的幸福》到《终身成长》；从《假性亲密关系》到《情感吸血鬼》，我发现大家讲的都是一件事情：心智控制。</p>
<p>于是我打算再把这几本书里面讲到的心智控制整理一下分享给大家。</p>
<h2 id="二、认识自己的大脑和情绪"><a href="#二、认识自己的大脑和情绪" class="headerlink" title="二、认识自己的大脑和情绪"></a>二、认识自己的大脑和情绪</h2><img src="/images/mindset-book-2.jpg" class="">

<p>我们还是得提到《头脑特工队》这个电影，这个电影把人的不同情绪分解成了几个不同的自我，当这几个自我打架的时候，谁占上风谁就主导了行为。</p>
<p>最后，人类的“叙事自我”会为自己的所有行为提供一个看似合理的解释，但这个解释只是为了让自我接受自己的行为。</p>
<p>所以说，人的大脑是一个菜市场，谁的声音大最后就听谁的。当你害怕的时候，“害怕”自我声音最大；当你高兴的时候，“愉悦”自我声音最大。</p>
<p>但是，《为什么佛教是真的》这本书里面就说了，这些“自我”其实都不是真正的自己。因为这些“自我”会绑架你的行为，让你难受。</p>
<p>人类千百万年的进化，使得人们对于一个快乐的事情的愉悦感，会随着刺激的次数变多而降低。比如你第一次吃某种美食特别好吃，但是你每天都吃的话，你就会觉得味道也就那样了；你刚住进大房子觉得特别舒服，但是住久了你也又习惯了。即便是吸毒，一个瘾君子也是需要不断加大剂量，才能够保持自己的快感。所以你看，如果你一味追求快乐，你会越来越难以获得快乐，快乐总是短暂的。</p>
<p>如果快乐难以获得，那是不是说，人类就是应该受苦一辈子呢？不是的。</p>
<h2 id="三、糟糕的情绪控制"><a href="#三、糟糕的情绪控制" class="headerlink" title="三、糟糕的情绪控制"></a>三、糟糕的情绪控制</h2><img src="/images/mindset-book-3.jpg" class="">

<p>当你明白情绪容易控制你，快乐总是短暂这些事实之后，你要学会的是通过“跳出坏情绪”的方式来控制情绪。但是很多人不能掌握这种技巧，大家惯用的手段有两个：发泄情绪和压抑情绪。</p>
<p>发泄情绪很好理解，人们通过呼喊、争吵、哭泣，甚至动手打架来将情绪释放出来。这种方式是很好的疏解情绪的方式，但终归自己内心还是受到了压力。</p>
<p>压抑情绪比起发泄情绪看起来没有什么特别的行为变化，但是通常这种情绪的负能量会向内传达，最终引起心理压力。心理压力进一步也会影响生理，造成自己容易失眠、焦虑、抵抗力下降等等。我有一年得胃病，很大程度就是因为压力太大造成胃酸过多。</p>
<p>如果你有了坏情绪，还是应该释放出来。每个小孩都会这个事情，成年人反倒会压抑情绪，其实是不好的。</p>
<p>但是最好的办法，还是下面提到的不产生负面情绪的办法。</p>
<h2 id="四、好的情绪控制"><a href="#四、好的情绪控制" class="headerlink" title="四、好的情绪控制"></a>四、好的情绪控制</h2><p>《真实的幸福》、《终身成长》和《假性亲密关系》都介绍了这种情绪控制方法：简单来说就是用乐观的一面来看待原本糟糕的结果。</p>
<p>任何事情都是有两面的。如果你看乐观的一面，那么你就有可能不会产生负面情绪。</p>
<p>聚个例子：我当年做胃镜感觉特别难受。但是当我给别人提起这件事情的时候，我会这么说：“你没做过胃镜吧？只有做过胃镜人生才算完整，那个感觉一辈子都忘不了，推荐你下次试试。”</p>
<p>《终身成长》里面有大量的案例，比如你很喜欢的科目考砸了，如果你乐观一点看，这说明你又可以在自己喜欢的科目上继续提高了。你想，如果一个你喜欢的事情已经做到极致了，那会是一件多么无聊的事情。</p>
<p>平时很多时候大家都可以训练自己乐观处理情绪的能力。比如我最近老加班，但是我就想：明天肯定比今天会好一点，再加把劲。</p>
<img src="/images/mindset-book-4.jpg" class="">

<p>《为什么佛教是真的》主要介绍了“冥想”这个技巧，通过冥想让自己能够站在上帝视角审视自己的情绪。这样当负面情绪产生的时候，你就会以一种同情和理解的方式接纳这个情绪，而不是被这个情绪控制。</p>
<p>关于冥想我练习很少，但是我特别理解它的那种控制情绪的目标。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>1、人的行为由多个“自我”共同决定。</p>
<p>2、糟糕的情绪需要宣泄和化解，压抑情绪是不好的。</p>
<p>3、用乐观的角度看问题，就可以很大程度上避免负面情绪。</p>
<p>4、冥想有助于控制负面情绪。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/07/ASP-NET-Core-gRPC-%E9%9B%86%E6%88%90-Polly-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/07/ASP-NET-Core-gRPC-%E9%9B%86%E6%88%90-Polly-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" itemprop="url">ASP.NET Core gRPC 集成 Polly 实现优雅重试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-07T15:19:11+08:00">
                2021-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1657075397/">博客</a> 中，我们一起探索和实现了<code>gRPC</code>的健康检查。从服务治理的角度来看，健康检查保证的是被调用的服务“健康”或者“可用”。可即使如此，我们依然会遇到，因为网络不稳定等原因而造成的服务调用失败的情形，就如同我们赖以生存的这个真实世界，本身就充满了各种不确定的因素一样，“<strong>世间唯一不变的只有变化本身</strong>”。不管是面对不稳定的服务，还是面对不确定的人生，任何时候我们都需要有一个 B 计划，甚至我们人生中的一切努力，本质上都是为了多一份自由，一份选择的自由。在微服务的世界里，我们将这种选择称之为“<strong>降级(Fallback)<strong>”，如果大家有接触过 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/App-vNext/Polly">Polly</a> 这类框架，就会明白我这里的所说的“</strong>降级</strong>”具体是什么。在众多的“<strong>降级</strong>”策略中，<strong>重试</strong>是一种非常朴素的策略，尤其是当你调用一个不稳定的服务的时候。</p>
<p><img src="https://i.loli.net/2021/06/09/GIBVj3sKb5zMeE1.jpg" alt="重试"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在此之前，博主曾经介绍过 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2070070822/">HttpClient</a> 的重试。所以，今天这篇博客我们来聊聊<code>gRPC</code>的客户端重试，因为要构建一个高可用的微服务架构，除了需要高可用的服务提供者，同样还需要高可用的服务消费者。下面，博主将由浅入深地为大家分享 4 种重试方案的实现，除了 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1">官方</a> 内置的方案，基本上都需要搭配 Polly 来使用，所以，到这里你可以理解这篇博客的标题，为什么博主会 <a target="_blank" rel="noopener" href="https://music.163.com/#/song?id=167720">毁人不倦</a> 地尝试不同的重试方案，因为每一种方案都有它自身的局限性，博主想要的是一种更优雅的方案。具体来讲，主要有：<strong>基于 gRPC RetryPolicy</strong>、<strong>基于 HttpClientFactory</strong>、<strong>基于 gRPC 拦截器</strong> 以及 <strong>基于 CallInvoker</strong>  4 种方案。如果大家还有更好的思路，欢迎大家在博客评论区积极留言、参与讨论。</p>
<h1 id="基于-gRPC-RetryPolicy"><a href="#基于-gRPC-RetryPolicy" class="headerlink" title="基于 gRPC RetryPolicy"></a>基于 gRPC RetryPolicy</h1><p>所谓的 gRPC RetryPolicy，其实是指 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/retries?view=aspnetcore-3.1">官方</a> 提供的暂时性故障处理方案，它允许我们在创建<code>GrpcChannel</code>的时候，去指定一个重试策略：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    RetryPolicy = <span class="keyword">new</span> RetryPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        InitialBackoff = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        MaxBackoff = TimeSpan.FromSeconds(<span class="number">5</span>),</span><br><span class="line">        BackoffMultiplier = <span class="number">1.5</span>,</span><br><span class="line">        RetryableStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>MethodConfig</code>可以为指定的方法配置一个重试策略，当传入的方法名为<code>MethodName.Default</code>时，它将应用于该通道下的所有 gRPC 方法。如你所见，在重试策略中我们可以指定重试次数、重试间隔等参数。<strong>这个方案本身没有太多心智上的负担，唯一的缺点是，它没有预留出可扩展的接口</strong>，以至于我们想要验证它到底有没有重试的时候，居然要通过<code>Fiddler</code>抓包这种方式，换句话讲，我们没有办法自定义整个重试行为，譬如你想在重试过程中记录日志，这种方案就会鸡肋起来，<strong>对使用者来说，这完全就是一个黑盒子</strong>。</p>
<p><img src="https://i.loli.net/2021/06/09/QzjaH4VqWMnEFcb.png" alt="官方自带的 “黑盒子” 重试机制"></p>
<p>除此之外，官方还提供了一种成为 <code>Hedging</code> 重试策略作为备选方案。类似地，它通过 <code>HedgingPolicy</code> 属性来指定重试策略。对比 <code>RetryPolicy</code>，它可以同时发送单个 gRPC 请求的多个副本，并使用第一个成功的结果作为返回值，所以，<strong>一个显而易见的约束是，它要求这个 gRPC 方法是无副作用的、幂等的函数</strong>。其实，这是所有重试方案都应该考虑的一个问题，而不单单是 <code>HedgingPolicy</code>。由于这两种策略有着本质上的不同，请记住：<strong>RetryPolicy 不能与 HedgingPolicy 一起使用。</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultMethodConfig = <span class="keyword">new</span> MethodConfig &#123;</span><br><span class="line">    Names = &#123; MethodName.Default &#125;,</span><br><span class="line">    HedgingPolicy = <span class="keyword">new</span> HedgingPolicy &#123;</span><br><span class="line">        MaxAttempts = <span class="number">5</span>,</span><br><span class="line">        NonFatalStatusCodes = &#123; StatusCode.Unavailable &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>, <span class="keyword">new</span> GrpcChannelOptions &#123;</span><br><span class="line">    ServiceConfig = <span class="keyword">new</span> ServiceConfig &#123; MethodConfigs = &#123; defaultMethodConfig &#125; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>世间的一切都是双刃剑， <code>HedgingPolicy</code> 同样打不破这铁笼一般的人间真实，虽然它可以一次发送多个<code>gRPC</code>请求，可毫无疑问的是，<strong>这是一种相当浪费的策略，因为不管有多少个请求，它始终都取第一个结果作为返回值，而剩余的结果都将会被直接抛弃</strong>。想想每一年的高考状元，大家是不是都只记住了第一名。也许，人生正是如此呢，程序世界固然是由 0 和 1 构成的虚幻世界，可何尝就不是真实世界的某种投影呢？这里请允许博主安利一部动漫<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/30401194/">《你好世界》</a>，它用视觉化的方式表达了真实世界与程序世界的某种特殊联系。</p>
<h1 id="基于-HttpClientFactory"><a href="#基于-HttpClientFactory" class="headerlink" title="基于 HttpClientFactory"></a>基于 HttpClientFactory</h1><p>接下来，我们要介绍的是基于 <code>HttpClentFactory</code> 的重试方案。也许，大家会感到困惑，明明这篇博客说的是 <code>gRPC</code> ，为什么 <code>HttpClientFactory</code> 会出现在这里呢？其实，很多时候，我们看到的只有表面，而出奇制胜的招式往往出自你对于本质的理解。如果大家阅读过 <code>gRPC</code> 客户端部分的源代码，就会意识到这样一件事情，即，<code>gRPC</code> 底层依然用到了 <code>HttpClient</code> 这套所谓“管道式”的体系，你可以理解为，最终传输层还是要交给 <code>HttpClient</code> 来处理，而 <code>HttpClientFactory</code> 本来就支持结合 <code>Polly</code> 进行重试，所以，我们其实是针对同一个问题的不同阶段进行了切入处理。一旦想清楚这一点，下面的代码理解起来就没有难度啦：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(opt =&gt; &#123;</span><br><span class="line">    opt.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:8001&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ConfigurePrimaryHttpMessageHandler(() =&gt; <span class="keyword">new</span> HttpClientHandler &#123;</span><br><span class="line">    ClientCertificateOptions = ClientCertificateOption.Manual,</span><br><span class="line">    ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) =&gt; <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddPolicyHandler(</span><br><span class="line">    HttpPolicyExtensions.HandleTransientHttpError()</span><br><span class="line">    .OrResult(res =&gt; res.StatusCode != System.Net.HttpStatusCode.OK)</span><br><span class="line">    .WaitAndRetryAsync(</span><br><span class="line">      <span class="number">6</span>, </span><br><span class="line">      retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="number">2</span>, retryAttempt)) + TimeSpan.FromMilliseconds(<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">100</span>)), </span><br><span class="line">      (result, timeSpan, current, context)=&gt; &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;StatusCode=<span class="subst">&#123;result.Result?.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;Exception=<span class="subst">&#123;result.Exception?.Message&#125;</span>&quot;</span>);</span><br><span class="line">          Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalMilliseconds&#125;</span>秒&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">await</span> serviceProvider.GetService&lt;Greeter.GreeterClient&gt;().SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，为了模拟网络不畅的这种场景，我们故意指定了一个错误的终结点信息。此时，我们会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/06/09/5yamSqIzbH3heXF.png" alt="基于 HttpClientFactory 的重试方案"></p>
<p>不过话又说回来，因为我们选择切入的阶段是“<strong>传输层</strong>”，所以，相对于整个 <code>RpcException</code> 而言，我们其实是找到了一个问题的子集，这意味着这个方案并不能覆盖到所有的场景，如果是在非“<strong>传输层</strong>”引发了某种异常，我们就没有办法通过这种方式去做重试处理。所以，我在一开始就说过，没有 100% 完美的解决方案，每一种方案都有它自身的局限性，这句话在这里得到了第一次印证。如果大家再回过头去看第一种方案，是不是就会发现，它里面还是使用了<code>HTTP</code>状态码作为是否重试的判断依据。所以，大家觉得呢？欢迎大家在评论区留下你的想法。</p>
<h1 id="基于-gRPC-拦截器"><a href="#基于-gRPC-拦截器" class="headerlink" title="基于 gRPC 拦截器"></a>基于 gRPC 拦截器</h1><p>关于 <code>gRPC</code> 的拦截器，博主专门写过一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1679688265/">博客</a> 来介绍它，所以，在一开始考虑重试方案的时候，拦截器其实是最容易想到的一种方案，主要思路是利用 <code>Polly</code> 中<code>Policy</code>的<code>Execute()</code>方法，对拦截器中获取<code>gRPC</code>调用结果的过程进行包装，我们一起来看下面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    TRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">    ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> retryPolicy =</span><br><span class="line">        Policy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;</span><br><span class="line">        .Handle&lt;RpcException&gt;(s =&gt; s.StatusCode == StatusCode.Internal)</span><br><span class="line">        .Or&lt;WebException&gt;()</span><br><span class="line">        .OrResult(r =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> awaiter = r.GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (awaiter.IsCompleted)</span><br><span class="line">                <span class="keyword">return</span> r.GetStatus().StatusCode == StatusCode.OK;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.ResponseAsync.Wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AggregateException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .WaitAndRetryAsync(<span class="number">3</span>, x =&gt; TimeSpan.FromSeconds(<span class="number">5</span>), (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retryPolicy.ExecuteAsync(() =&gt; Task.FromResult(continuation(request, context))).Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 <code>gRPC</code> 拦截器的这种方案，它最大的问题在于异常的颗粒度太大，这句话是什么意思呢？简单来讲就是在拦截器这个层面上，你能捕捉到的只有<code>RpcException</code>，这样就使得我们难以捕获更小粒度的异常，譬如网络异常、超时异常等等。其次，<code>gPRC</code> 拦截器中大量使用了，类似<code>AsyncUnaryCall&lt;TResponse&gt;</code>这样的异步的返回值类型，这让我们在编写 Policy 的时候，多多少少会有一点不自在。综上所述，这个最容易想到的方案，本身是没有太大的问题的，最关键的问题是我们能接受什么样的异常颗粒度。而像异步返回值这种问题，只要写过一次以后，博主以为，它并不会成为我们继续探索的阻碍，这一点大家可以自己去体会。</p>
<p>在尝试基于拦截器的重试方案的过程中，博主发现，指定一个错误的终结点信息，<code>gRPC</code>会在进入拦截器前就引发异常。这意味着这种基于拦截器的重试方案，在面对“<strong>传输层</strong>”的异常时略显乏力，所以，从某种程度上来讲，这个方案同样是一个不完美的方案。可这世上人来人往、本无完人，我们实在没有必要耽于技术方案的绝对完美而不可自拔，当求真、莫求执，所谓“<strong>大成若缺</strong>”，可以欣赏得来缺憾之美，同样是一种幸福。</p>
<h1 id="基于-CallInvoker"><a href="#基于-CallInvoker" class="headerlink" title="基于 CallInvoker"></a>基于 CallInvoker</h1><p>如果说，前面的 3 种方案都属于“<strong>见招拆招</strong>”的外家功夫。那么，接下来我要分享的思路，绝对可以称得上是“<strong>打通任督二脉</strong>”的玄门内功。</p>
<p><img src="https://i.loli.net/2021/06/09/IOwrYtdLXGxMeHf.png" alt="gRPC客户端底层原理说明"></p>
<p>首先，博主想用一张图来讲解 <code>gRPC</code> 客户端的工作原理。从这张图中，我们可以看出，初始化一个<code>gRPC</code>的客户端，主要有<code>GrpcChannel</code>和<code>CallInvoker</code>两种构造形式，而<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法会返回<code>HttpClientCallInvoker</code>的一个实例。此时，我们就会发现，<code>HttpClientCallInvoker</code>是<code>CallInvoker</code>的一个子类。所以，我们基本可以判定<code>CallInvoker</code>是一个扮演着重要角色的类。继续探索，我们就会发现，<code>GrpcCallInvokerFactory</code>内部通过构造<code>GrpcChannel</code>，进而实现了<code>CreateCallInvoker()</code>方法，换句话说，本质上依然是调用了<code>GrpcChannel</code>中的<code>CreateCallInvoker()</code>方法。最终，这个<code>CallInvoker</code>实例会作为参数，传递给<code>DefaultClientActivator</code>的<code>CreateClient()</code>方法，至此我们就完成了整个<code>gRPC</code>客户端的创建工作。</p>
<p>好了，相信现在大家都有一个疑问，这个<code>CallInvoke</code>到底是个什么东西呢？为什么它在整个<code>gRPC</code>的底层中是如此的重要呢？其实，它就是一个平平无奇的抽象类啦，可是一旦配合着<code>gRPC</code>中的<code>Calls</code>类来使用，这个<code>CallInvoker</code>简直就是扩展<code>gRPC</code>的一个重要的桥梁，因为我们不用关心底层是如何处理<code>gRPC</code>请求&#x2F;响应的，而这丝毫不影响我们对这个过程进行自定义重写。因此，按照这样的思路，我们有了下面的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GrpcCallInvoker</span> : <span class="title">CallInvoker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Channel _channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GrpcPollyPolicyOptions _pollyOptions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcCallInvoker</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        GrpcPollyPolicyOptions pollyOptions</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _channel = channel;</span><br><span class="line">        _pollyOptions = pollyOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncClientStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncClientStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncDuplexStreamingCall&lt;TRequest, TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncDuplexStreamingCall(CreateCall(method, host, options)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncServerStreamingCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncServerStreamingCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;AsyncUnaryCall&lt;TResponse&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.AsyncUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> TResponse <span class="title">BlockingUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      Method&lt;TRequest, TResponse&gt; method, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">string</span> host, </span></span></span><br><span class="line"><span class="params"><span class="function">      CallOptions options, </span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policy = CreatePollyPolicy&lt;TResponse&gt;();</span><br><span class="line">        <span class="keyword">return</span> policy.Execute(() =&gt; Calls.BlockingUnaryCall(CreateCall(method, host, options), request));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想，经过连续三篇文章的洗礼，大家对这些方法应该都不陌生了吧！下面我们来着重讲解下<code>CreateCall()</code>和<code>CreatePollyPolicy()</code>这两个方法。其中，<code>CreateCall()</code>这个方法会相对简单一点，因为它完全就是返回<code>gRPC</code>的内置类型<code>CallInvocationDetails</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">CallInvocationDetails</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">CreateCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    Method&lt;TRequest, TResponse&gt; method,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> host,</span></span></span><br><span class="line"><span class="params"><span class="function">    CallOptions options</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TRequest : <span class="keyword">class</span></span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TResponse : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallInvocationDetails&lt;TRequest, TResponse&gt;(_channel, method, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，<code>CreatePollyPolicy()</code>这个方法就非常的明确啦，通过注入的<code>GrpcPollyPolicyOptions</code>来构造一个Policy。考虑到我们要做的是一个通用的方案，这里预留了<strong>断路器</strong>、<strong>重试</strong>、<strong>超时</strong>三种不同策略的参数。如果希望对构建 Policy 的过程进行自定义，则可以通过重写该方法来实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Policy</span>&lt;<span class="title">TResult</span>&gt; <span class="title">CreatePollyPolicy</span>&lt;<span class="title">TResult</span>&gt;()</span></span><br><span class="line">&#123;</span><br><span class="line">    Policy&lt;TResult&gt; policy = <span class="literal">null</span>; ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造断路器策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.CircuitBreakerCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyBreaker = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Exception&gt;()</span><br><span class="line">            .CircuitBreaker(_pollyOptions.CircuitBreakerCount, _pollyOptions.CircuitBreakerTime);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? policyBreaker :</span><br><span class="line">                    policy.Wrap(policyBreaker) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断路器降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.CircuitBreaker.BrokenCircuitException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超时策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.Timeout &gt; TimeSpan.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> policyTimeout = Policy.Timeout(() =&gt; _pollyOptions.Timeout, Polly.Timeout.TimeoutStrategy.Pessimistic);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? (Policy&lt;TResult&gt;)policyTimeout.AsPolicy&lt;TResult&gt;() :</span><br><span class="line">        policy.Wrap(policyTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时降级</span></span><br><span class="line">        <span class="keyword">var</span> policyFallBack = Policy&lt;TResult&gt;</span><br><span class="line">            .Handle&lt;Polly.Timeout.TimeoutRejectedException&gt;()</span><br><span class="line">            .Fallback(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(TResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        policy = policyFallBack.Wrap(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造重试策略</span></span><br><span class="line">    <span class="keyword">if</span> (_pollyOptions.RetryCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> retryPolicy = Policy&lt;TResult&gt;.Handle&lt;Exception&gt;().WaitAndRetry(</span><br><span class="line">          _pollyOptions.RetryCount, </span><br><span class="line">          x =&gt; _pollyOptions.RetryInterval, </span><br><span class="line">          (result, timeSpan, current, context) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;正在进行第<span class="subst">&#123;current&#125;</span>次重试，间隔<span class="subst">&#123;timeSpan.TotalSeconds&#125;</span>秒&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        policy = policy == <span class="literal">null</span> ? retryPolicy :</span><br><span class="line">            policy.Wrap(retryPolicy) <span class="keyword">as</span> Policy&lt;TResult&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们无法修改<code>DefaultGrpcClientFactory</code>中关于<code>CallInvoker</code>这部分的逻辑，所以，我们采取了下面的“<strong>迂回战术</strong>”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc();</span><br><span class="line">services.AddTransient&lt;GrpcCallInvoker&gt;();</span><br><span class="line">services.AddTransient&lt;Channel&gt;(sp =&gt; <span class="keyword">new</span> Channel(<span class="string">&quot;localhost&quot;</span>, <span class="number">5001</span>, ChannelCredentials.Insecure));</span><br><span class="line">services.AddTransient&lt;GrpcPollyPolicyOptions&gt;(sp =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GrpcPollyPolicyOptions()</span><br><span class="line">    &#123;</span><br><span class="line">        RetryCount = <span class="number">10</span>,</span><br><span class="line">        RetryInterval = TimeSpan.FromSeconds(<span class="number">1</span>),</span><br><span class="line">        CircuitBreakerCount = <span class="number">5</span>,</span><br><span class="line">        CircuitBreakerTime = TimeSpan.FromSeconds(<span class="number">6</span>),</span><br><span class="line">        Timeout = TimeSpan.FromSeconds(<span class="number">10</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callInvoker = services.BuildServiceProvider().GetService&lt;GrpcCallInvoker&gt;();</span><br><span class="line"><span class="keyword">var</span> client = (Greeter.GreeterClient)Activator.CreateInstance(<span class="keyword">typeof</span>(Greeter.GreeterClient), callInvoker);</span><br><span class="line">client.SayHello(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，如果我们故意写一个错误的终结点地址，我们将会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/06/09/m67kG1hDfgyPJKs.png" alt="基于 CallInvoker 的重试方案"></p>
<p>因为重试 5 次后就会启动断路器，所以，这个接口在重试 5 次后就立即停止了调用，这证明我们设想的这个方案是可以完美工作的！</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完以后，突然发现这一篇的信息量有点爆炸，尤其是<code>CallInvoker</code>这一部分，需要花点时间去阅读 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-dotnet">gRPC</a> 的源代码。可对于博主而言，其实更加享受的是，探索 <code>gRPC</code> 重试方案的这个过程。起初，因为对拦截器更熟悉一点，所以，我最先想到的是基于拦截器的重试方案。经过博主一番验证以后，发现这是一个有缺陷的方案。这时候，我意外发现，官方提供了重试策略，可这个重试策略对于使用者来说是一个黑盒子。再后来，发现可以在 HttpClient 上做一点文章，虽然它针对的是“<strong>传输层</strong>”这个阶段。直到从网上查资料，意识到可以重写<code>CallInvoker</code>这个抽象类，这个时候终于找到了最完美的方案。所以，通过这个过程，大家可以发现，我这篇博客的写作过程，其实与我思考过程有着明显的不同。思考的过程中带入“<strong>先入为主</strong>”的意识，这让我的思考过程走了不少的弯路，而写作过程则是一个由浅入深、由表及里的顺序。也许，下一次遇到类似的问题，我会先了解一下官方有没有提供标准方案，这是我在写完这篇博客以后最大的一个感悟。好了，这篇博客就先写到这里啦，如果大家对文中的内容由意见或者建议，欢迎大家在评论区给我留言，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/04/2021-6-4-100flag/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/04/2021-6-4-100flag/" itemprop="url">✅连续日更公众号100天完成</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-04T22:00:00+08:00">
                2021-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>音乐：<a target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/albumDetail/003IAzUi25muDF">李健 - Marine玛琳娜</a></p>
<p>Hello 大家好，我是安哥。</p>
<p>如约而至，今天刚好是我的公众号「效率工具指南」连续日更的第 100 天。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227889661171.jpg" alt="-w636"></p>
<p>最开始想日更的时候，我写了这么一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904522&idx=1&sn=fed827fe64310e6cfcc5afb9d06697a0&chksm=83a851a7b4dfd8b1b51e8abeeeeb946a044333135e37343ad063cfb91fb440ea19e0771133b9&token=2050480873&lang=zh_CN#rd">日更公众号的好处</a></p>
<p>后来觉得，上面这篇文章写得还是有点虚，不够接地气，后来还补写了另外一篇：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904906&idx=1&sn=bb9769c4f9aaf80648510b56355f4dc8&chksm=83a85327b4dfda31d3c6a4a95ca7da3be5c01e009a055f4acc6e9af512f38c3d33364c07ccbc&token=2050480873&lang=zh_CN#rd">写公众号能赚多少钱？</a></p>
<p>不整虚的，想让你看看我从写东西中赚到的钱，数额不多，就像一位朋友在评论区说的：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227910201100.jpg" alt="-w862"></p>
<p>这些物质激励虽然不多，但对我来说还是挺重要的，因为这是对我能够把写东西这件事坚持下来的一个重要驱动力。</p>
<p>人性中都有一个弱点，或者说是我们与生俱来受到的一个约束——生命有限、没有耐心，多数人都没有办法长时间做一件反馈周期长、付出了很多时间却看不到回报的事情。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227902471773.jpg" alt="-w747">图片来自书籍《薛兆丰的经济学讲义》</p>
<p>正因为这样，我们需要及时给自己制造反馈，或者说<strong>打造最小闭环</strong>，常见的例如小时候经常会有的事情：</p>
<blockquote>
<p>妈妈答应你，假设你这次考试能拿 85 分，就给你买一个游戏机。</p>
</blockquote>
<p>而写东西，其实也可以给自己制造一些比较短的、获取收益的闭环，例如我现在能想到的，就是去知乎上推荐好物，当有人买了你推荐的好物或者通过你的好物链接购买了电台平台的商品，你就可以获得平台返回给你的佣金。</p>
<p>虽然钱并不太多，但这也算是一种人为打造的写作的最小闭环的方法：</p>
<blockquote>
<p>从写东西中赚到钱 ➡️ 会让你坚定「写作能赚到钱」的想法，或者到把赚到的钱再投入于写作中，例如购买一台 Mac，有更舒适地码字体验 ➡️ 有了更多动力，继续写东西，继续赚到钱</p>
</blockquote>
<p>以此循环下去。</p>
<h2 id="到底为什么要日更？"><a href="#到底为什么要日更？" class="headerlink" title="到底为什么要日更？"></a>到底为什么要日更？</h2><p>从心底里说，我们那么辛苦地打拼，为的都是拥有更多的自由、拥有更多的闲暇，不去做那些我们不想做的事。</p>
<p>当我发现，老老实实打一份工并不会让人有足够的自由时，我就觉得还是得在工作之余干点自己的事情，得到 App 的万维钢老师也把个人在工作之余干的有意义的事情称为「秘密项目」。</p>
<p>至于想日更，我只是想着在今年做点不一样的事情，做一点之前没有做过的事情，原本只想着日更超过 30 天后就停下来，但后来收到了<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649911131&idx=1&sn=052ccfec34336842339b179f3b7014b5&chksm=83a86b76b4dfe260dbe386ce7136b0845d3db2cd63cc534326b93dd99a5eddefa1ba26a7a0f7&token=2050480873&lang=zh_CN#rd">女票的鼓励、看到一些日更同行者的坚持✊</a>，因此在日更到 45 天的时候，立下了一个新的 flag：要坚持日更到第 100 天。</p>
<p>很开心，我今天做到了，是时候可以停下来缓一缓了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16228099740580.jpg" alt="-w745"></p>
<p>此外，日更这件事，在一定程度上也和自己的工作相辅相成，在过去的 100 天里，我写的绝大多数文章都是工具文，这和我在工作中要写的东西是一致的，因此之前写的文章，不少都可以发在公司的号上。</p>
<h2 id="日更可以链接到更多的人吗？"><a href="#日更可以链接到更多的人吗？" class="headerlink" title="日更可以链接到更多的人吗？"></a>日更可以链接到更多的人吗？</h2><p>我看到一些同在日更的朋友，在谈及日更的好处的时候，会说到可以链接更多的人。</p>
<p>但 100 天下来，我感觉我并没有借由写东西这件事情，认识到了更多的人，目前就只认识了一个产品经理和一个同是做类似内容的网友。</p>
<p>一个比较明显的体会是，100 天下来文章的留言数还是那么少，来留言的大部分还是之前认识的朋友，这是我值得反思的一点。</p>
<p>可能还是因为我写的工具文太多，缺少内心想法的流露、缺少人间烟火味，找不到太多共鸣、可以交流的点，因而就没啥人留言，或者是自己的人设还不够具体、不够突出？</p>
<p>看到一些同是做工具内容的同行，它们的留言区好像就不会像我这么冷清，这应该还是我的问题。</p>
<h2 id="日更的意外之喜"><a href="#日更的意外之喜" class="headerlink" title="日更的意外之喜"></a>日更的意外之喜</h2><p>出乎我意料的是，日更期间，我终于接到这个公众号的第一条推广了，这是我之前没有想到的。</p>
<p>原本我以为只有公众号达到 1 万以上关注、阅读量稳定在 1000 附近，才达到接广告的门槛，没想到这个想法提前实现了。</p>
<p>感谢还没取关的朋友的理解。</p>
<h2 id="日更的顾虑"><a href="#日更的顾虑" class="headerlink" title="日更的顾虑"></a>日更的顾虑</h2><p>在做着一份正式工作的同时，还在高频地更新自己的公众号，被人知道了，会不会担心别人在心里嘀咕：你上班是不是在摸鱼了？顾着写自己的公众号了？</p>
<p>其实这不止是我遇到的问题，还有一些在公司里担任要职、一边同时维护着自己公众号的人也会遇到：</p>
<p>例如公众号「MacTalk」的池建强老师，但他又不太一样：</p>
<p>他现在在做一款名为「极客时间」的 App，就职于现在这家公司之前，他的公众号已经做得非常不错了，文章基本都有上万的阅读量，在职的时候，他凭借自己的公众号和以前积攒的影响力，给公司的产品带来了第一批用户，完成了产品的冷启动。</p>
<p>之前看他写的一篇文章，是这么说的：</p>
<blockquote>
<p>写公众号和做视频号并不会占用太多时间，只要管理好自己的精力就可以了。人们不做这些有价值的事情，时间也是白白浪费。而我之所以做这些东西，是因为这些东西和我本身的特质有关，和我做的事情也息息相关，比如<strong>我通过自己的影响力给产品带来冷启动付费用户几万个，是不是很有价值呢？</strong><br>——文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lZ6rd25MAN2vRCxqx9hkIQ">你到底在忙啥呢？</a>》</p>
</blockquote>
<p>当然，我自己还没到池老师这种大腕的级别，能做的只有一些小事——把公众号文章转发到朋友圈、向身边的人推荐自家的公众号。</p>
<p>还有另外一位博主 @张辉，他会在自己的朋友圈高频地分享自己的所思所想，曾经我也对「工作日上班期间要不要发朋友圈」这件事存在着疑惑，对于这个问题，这位博主讲了他和他妈妈的一段对话：</p>
<blockquote>
<p>他妈妈问他，你每天在朋友圈发那些信息，你老板看了会不会不高兴，他说我老板要是在意，我早被开除几百回了。他之前换工作，也面临好几个选择，之所以选择现在的公司，是因为能够做自己。<br>做自己很难，但是很重要。其实每个人内心深处都喜欢活生生的，而不是脸谱化的人。</p>
</blockquote>
<h2 id="与日更有关的数据"><a href="#与日更有关的数据" class="headerlink" title="与日更有关的数据"></a>与日更有关的数据</h2><p>100 天下来，我的关注数从 2 月 24 日当天的 7814 增长到了现在的 9758，净增 1944</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227888849753.jpg" alt="-w1416"></p>
<p>为了验证之前一位网友说的一个观点，大意是「相比断断续续地更新，日更可以给公众号带来更多的关注」，我去翻了一下我的公众号 2020 年一年下来的关注净增数据：</p>
<p>2020 年初的关注数只有 1849，看到这个数字我瞬间被吓到了，原来去年最初的关注数少得可怜。。。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227894553969.jpg" alt="-w1412"></p>
<p>2020 年末的关注数是 7033</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227894023802.jpg" alt="-w1420"></p>
<p>2020 年一年下来，我的公众号净增 5184 个关注，花费了 12 个月，中间有比较迅猛的增长，应该还是有些文章受到了微信算法的推荐，感谢微信团队。</p>
<p>如果按照前面的算法，3 个月可以净增 1944 个关注，如果坚持连续更新一整年，理想的话，应该可以净增 7776 个关注，看起来似乎也还行？？？ </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/06/04/16227896562260.jpg" alt="-w716"></p>
<p>暂时不想了，还是先停下来休息一下，喘喘气吧，太累了，真不是人干的活。</p>
<p>看到这里，如果你有什么想要问我的，欢迎在下方的评论区留言，知无不言。</p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/06/01/ASP-NET-Core-gRPC-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/01/ASP-NET-Core-gRPC-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url">ASP.NET Core gRPC 健康检查的探索与实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-01T11:37:36+08:00">
                2021-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>各位朋友，大家好，欢迎大家关注我的博客。在上一篇 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1679688265/">博客</a> 中，博主和大家分享了<code>gRPC</code>的拦截器在日志记录方面的简单应用，今天我们继续来探索<code>gRPC</code>在构建微服务架构方面的可能性。其实，从博主个人的理解而言，不管我们的微服务架构是采用<code>RPC</code>方式还是采用<code>RESTful</code>方式，我们最终要面对的问题本质上都是一样的，博主这里将其归纳为：服务划分、服务编写 和 服务治理。首先，服务划分决定了每一个服务的上下文边界以及服务颗粒度大小，如果按照领域驱动设计(<strong>DDD</strong>)的思想来描述微服务，我认为它更接近于限界上下文(<strong>BoundedContext</strong>)的概念。其次，服务编写决定了每一个服务的具体实现方式，譬如是采用无状态的<code>RESTful</code>风格的<code>API</code>，还是采用强类型的、基于代理的<code>RPC</code>风格的<code>API</code>。最后，服务治理是微服务架构中永远避不开的话题，服务注册、服务发现、健康检查、日志监控等等一切的话题，其实都是在围绕着<strong>服务治理</strong>而展开，尤其是当我们编写了一个又一个的服务以后，此时该如何管理这些浩如“<strong>星</strong>”海的服务呢？所以，在今天这篇博客中，博主想和大家一起探索下<code>gRPC</code>的健康检查，希望能给大家带来一点启发。</p>
<p><img src="https://i.loli.net/2021/06/02/oVS3YkPIncr2xM9.jpg" alt="健康检查-服务注册-服务发现示意图"></p>
<p>关于“健康检查”，大家都知道的一点是，它起到一种“防微杜渐”的作用。不知道大家还记不记得，语文课本里的经典故事《扁鹊见蔡桓公》，扁鹊一直在告知蔡桓公其病情如何，而蔡桓公讳疾忌医，直至病入骨髓、不治而亡。其实，对应到我们的领域知识，后端依赖的各种服务譬如数据库、消息队列、Redis、API 等等，都需要这样一个“<strong>扁鹊</strong>”来实时地“<strong>望闻问切</strong>”，当发现问题的时候及时地采取相应措施，不要像“<strong>蔡桓公</strong>”一样病入骨髓，等到整个系统都瘫痪了，这时候火急火燎地去“救火”，难免会和蔡桓公一样，发出“悔之晚矣”的喟叹。当我们决定使用<code>gRPC</code>来构建微服务架构的时候，我们如何确保这些服务一直是可用的呢？所以，提供一种针对<code>gRPC</code>服务的健康检查方案就会显得非常迫切。这里，博主主要为大家介绍两种实现方式，它们分别是：基于<code>IHostedService</code>的实现方式 以及 基于<code>Consul</code>的实现方式。</p>
<h1 id="基于-IHostedService-的实现方式"><a href="#基于-IHostedService-的实现方式" class="headerlink" title="基于 IHostedService 的实现方式"></a>基于 IHostedService 的实现方式</h1><p>第一种方式，主要是利用<code>IHostedService</code>可以在程序后台执行的特点，搭配<code>Timer</code>就可以实现定时轮询。在 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc">gRPC</a> 的 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">官方规范</a> 中，提供了一份<code>Protocol Buffers</code>的声明文件，它规定了一个健康检查服务必须实现<code>Check()</code>和<code>Watch()</code>两个方法。既然是官方定义好的规范，建议大家不要修改这份声明文件，我们直接沿用即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要实现对应的<code>HealthCheckService</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">Health.HealthBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse() &#123; </span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()&#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要实现<code>HostedHealthCheckService</code>，它实现了<code>IHostedService</code>接口，并在其中调用<code>HealthCheckService</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HostedHealthCheckService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HostedHealthCheckService&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostedHealthCheckService</span>(<span class="params">ILogger&lt;HostedHealthCheckService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> start running....&quot;</span>);</span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoCheck, <span class="literal">null</span>, TimeSpan.Zero, TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(HostedHealthCheckService)&#125;</span> stop running....&quot;</span>);</span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoCheck</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>); ;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> Health.HealthClient(channel);</span><br><span class="line">        client.Check(<span class="keyword">new</span> HealthCheckRequest() &#123; Service = <span class="string">&quot;https://localhost:5001&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是大家非常熟悉的<strong>依赖注入</strong>环节：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddHostedService&lt;HostedHealthCheckService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;HealthCheckService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家对上一篇博客中的拦截器还有印象，对于下面的结果应该会感到非常亲切：</p>
<p><img src="https://i.loli.net/2021/06/02/vx2QLUoMzXaWpZY.png" alt="基于 IHostedService 的 gRPC 健康检查"></p>
<p>除此以外，我们还可以直接安装第三方库：<code>Grpc.HealthCheck</code>。此时，我们需要继承<code>HealthServiceImpl</code>类并重写其中的<code>Check()</code>和<code>Watch()</code>方法:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckService</span> : <span class="title">HealthServiceImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HealthCheckResponse&gt; <span class="title">Check</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">Watch</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      HealthCheckRequest request, </span></span></span><br><span class="line"><span class="params"><span class="function">      IServerStreamWriter&lt;HealthCheckResponse&gt; responseStream, </span></span></span><br><span class="line"><span class="params"><span class="function">      ServerCallContext context</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加更多的细节</span></span><br><span class="line">        <span class="keyword">await</span> responseStream.WriteAsync(<span class="keyword">new</span> HealthCheckResponse()</span><br><span class="line">        &#123;</span><br><span class="line">            Status = HealthCheckResponse.Types.ServingStatus.Serving</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们只需要在<code>HostedHealthCheckService</code>调用它即可，这个非常简单。</p>
<p>故，无需博主多言，相信屏幕前的你都能写得出来，如果写不出来，参考博主给出得实现即可(逃！</p>
<h1 id="基于-Consul-的实现方式"><a href="#基于-Consul-的实现方式" class="headerlink" title="基于 Consul 的实现方式"></a>基于 Consul 的实现方式</h1><p><a target="_blank" rel="noopener" href="https://www.consul.io/">Consul</a> 是一个由 <a target="_blank" rel="noopener" href="https://www.hashicorp.com/about">HashiCorp</a> 提供的产品，它提供了服务注册、服务发现、健康检查、键值存储等等的特性。这里，我们通过集成它的<code>SDK</code>来实现<code>gRPC</code>服务的服务注册、服务发现、健康检查，从某种程度上来讲，它无形中帮助我们实现了客户端的负载均衡，因为我们可以将每一个服务的终结点都注册到<code>Consul</code>中，而<code>Consul</code>的健康检查则可以定时移除那些不可用的服务。所以，客户端获得的终结点实际上都是可用的终结点。</p>
<p>首先，我们需要安装第三方库：<code>Consul</code>。接下来，我们可需要通过<code>Docker</code>安装一下<code>Consul</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul</span><br><span class="line">docker run --name consul -d -p 8500:8500 consul</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>Consul</code>的端口号为：8500，我们可以直接访问：<code>http://localhost:8500</code>：</p>
<p><img src="https://i.loli.net/2021/06/02/Gjb9XhpRCI7g2w5.png" alt="Consul 界面效果展示"></p>
<p>接下来，为了让<code>Startup</code>类看起来清爽一点，首先，我们先来写一点扩展方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定的gRPC服务添加健康检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGrpcHealthCheck</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册ConsulClient</span></span><br><span class="line">    services.AddSingleton&lt;IConsulClient, ConsulClient&gt;(_ =&gt; <span class="keyword">new</span> ConsulClient(consulConfig =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseUrl = configuration.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Consul:BaseUrl&quot;</span>);</span><br><span class="line">        consulConfig.Address = <span class="keyword">new</span> Uri(baseUrl);</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册gRPC服务</span></span><br><span class="line">    RegisterConsul&lt;TService&gt;(services).Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>RegisterConsul()</code>方法负责告诉<code>Consul</code>，某个服务对应的 IP 和端口号分别是多少，采用什么样的方式进行健康检查。</p>
<p>不过，由于<code>Consul</code>默认不支持<code>gRPC</code>的健康检查，所以，我们使用了更为常见的基于<code>TCP</code>方式的健康检查。你可以认为，只要服务器连接畅通，<code>gRPC</code>服务就是健康的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">RegisterConsul</span>&lt;<span class="title">TService</span>&gt;(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> serverHost = GetLocalIP();</span><br><span class="line">    <span class="keyword">var</span> serverPort = services.BuildServiceProvider().GetService&lt;IConfiguration&gt;().GetValue&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;gRPC:Port&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> RegisterConsul&lt;TService&gt;(services, serverHost, serverPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册指定服务到Consul</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">RegisterConsul</span>&lt;<span class="title">TService</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  IServiceCollection services, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">string</span> serverHost, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">int</span> serverPort</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> client = services.BuildServiceProvider().GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> registerID = <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">typeof</span>(TService).Name&#125;</span>-<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>&quot;</span>;</span><br><span class="line">    <span class="keyword">await</span> client.Agent.ServiceDeregister(registerID);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> client.Agent.ServiceRegister(<span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">    &#123;</span><br><span class="line">        ID = registerID,</span><br><span class="line">        Name = <span class="keyword">typeof</span>(TService).Name,</span><br><span class="line">        Address = serverHost,</span><br><span class="line">        Port = serverPort,</span><br><span class="line">        Check = <span class="keyword">new</span> AgentServiceCheck</span><br><span class="line">        &#123;</span><br><span class="line">            TCP = <span class="string">$&quot;<span class="subst">&#123;serverHost&#125;</span>:<span class="subst">&#123;serverPort&#125;</span>&quot;</span>,</span><br><span class="line">            Status = HealthStatus.Passing,</span><br><span class="line">            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Interval = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">            Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        Tags = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;gRpc&quot;</span> &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Consul</code>中的健康检查，更常用的是基于<code>HTTP</code>的健康检查，简单来说，就是我们提供一个接口，供<code>Consul</code>来调用，我们可以去设置请求的头(Header)、消息体(Body)、方法(Method)等等。所以，对于这里的实现，你还可以替换为更一般的实现，即提供一个 API 接口，然后在这个接口中调用<code>gRPC</code>的客户端。除此以外，如果你擅长写脚本，<code>Consul</code>同样支持脚本级别的健康检查。</p>
<p>在这里，博主水平扩展(复制)了两套服务，它们分别被部署在<code>5001</code>和<code>6001</code>两个端口上，通过<code>Consul</code>能达到什么效果呢？我们一起来看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigureServices</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GrpcServerLoggingInterceptor&gt;());</span><br><span class="line">    services.AddGrpcHealthCheck&lt;GreeterService&gt;();</span><br><span class="line">    services.AddGrpcHealthCheck&lt;CalculatorService&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">        endpoints.MapGrpcService&lt;CalculatorService&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，此时，我们注意到<code>Consul</code>中有两个服务注册进去，它们分别是：<code>GreeterService</code> 和 <code>CalculatorService</code>：</p>
<p><img src="https://i.loli.net/2021/06/02/eTBj7Iqn256GXKw.png" alt="gRPC 服务成功注册到 Consul 中"></p>
<p>以其中一个<code>CalculatorService</code>为例，我们可以注意到，它的确注册了<code>5001</code>和<code>6001</code>两个实例：</p>
<p><img src="https://i.loli.net/2021/06/03/xlhMjJ1ZcN3nwBe.png" alt="CalculatorService 的两个实例"></p>
<p>至此，我们就完成了基于<code>Consul</code>的健康检查，在这里，图中的绿色标记表示服务可用。</p>
<h1 id="关于-gRPC-的引申话题"><a href="#关于-gRPC-的引申话题" class="headerlink" title="关于 gRPC 的引申话题"></a>关于 gRPC 的引申话题</h1><p>其实，写到这里的时候，这篇博客就该接近尾声啦，因为对于 gRPC 健康检查的探索基本都已找到答案，可我还是想聊一聊关于 gRPC 的引申话题。理由特别简单，就是在我看来，接下来要讲的这点内容，完全撑不起一篇博客的篇幅，索性就在这篇博客里顺带一提。我打算分享两个话题，<strong>其一，是 gRPC 客户端的负载均衡；其二，是 gRPC 接口的测试工具。</strong></p>
<h2 id="gRPC-客户端的负载均衡"><a href="#gRPC-客户端的负载均衡" class="headerlink" title="gRPC 客户端的负载均衡"></a>gRPC 客户端的负载均衡</h2><p>截止到目前为止，结合<code>Consul</code>我们已经实现了服务注册和服务发现两个功能。通过调研我们可以发现，针对服务器端的<code>gRPC</code>的负载均衡，目前主要有<code>Nginx</code>和<code>Envoy</code>两种方案，这两种相方案对要更复杂一点，博主目前所在的公司，在<code>gRPC</code>的负载均衡上感觉是个空白，这算是博主想要研究<code>gRPC</code>的一个主要原因。而在这里，由于<code>Consul</code>里注册了所有<code>gRPC</code>服务的终结点信息，所以，我们更容易想到的，其实是客户端的负载均衡，具体怎么实现呢？我们一起看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从Consul中获取服务终结点信息</span></span><br><span class="line"><span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="built_in">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$&quot;<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>&quot;</span>).ToList();</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Channel和Client</span></span><br><span class="line"><span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$&quot;https://<span class="subst">&#123;serviceUrl&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> <span class="keyword">var</span> client = <span class="keyword">new</span> Calculator.CalculatorClient(channel);</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">10</span>, Op = <span class="string">&quot;+&quot;</span>, Num2 = <span class="number">12</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>可以看出，基本思路就是从<code>Consul</code>里拿到对应服务的终结点信息，然后构造出<code>GrpcChannel</code>，再通过<code>GrpcChannel</code>构造出 Client 即可。</p>
<p>不过，博主觉得这个过程有一点繁琐，我们有没有办法让这些细节隐藏起来呢？于是，我们有了下面的改进方案：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">TGrpcClient</span>&gt; <span class="title">GetGrpcClientAsync</span>&lt;<span class="title">TGrpcClient</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">this</span> IServiceProvider serviceProvider</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> consulClient = serviceProvider.GetService&lt;IConsulClient&gt;();</span><br><span class="line">    <span class="keyword">var</span> serviceName = <span class="keyword">typeof</span>(TGrpcClient).Name.Replace(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> services = <span class="keyword">await</span> consulClient.Health.Service(serviceName, <span class="built_in">string</span>.Empty, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> serviceUrls = services.Response.Select(s =&gt; <span class="string">$&quot;<span class="subst">&#123;s.Service.Address&#125;</span>:<span class="subst">&#123;s.Service.Port&#125;</span>&quot;</span>).ToList();</span><br><span class="line">    <span class="keyword">if</span> (serviceUrls == <span class="literal">null</span> || !serviceUrls.Any())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure service <span class="subst">&#123;serviceName&#125;</span> is registered in consul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceUrl = serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Count - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">$&quot;https://<span class="subst">&#123;serviceUrl&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> constructorInfo = <span class="keyword">typeof</span>(TGrpcClient).GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(GrpcChannel) &#125;);</span><br><span class="line">    <span class="keyword">if</span> (constructorInfo == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Please make sure <span class="subst">&#123;<span class="keyword">typeof</span>(TGrpcClient).Name&#125;</span> is a gRpc client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clientInstance = (TGrpcClient)constructorInfo.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; channel &#125;);</span><br><span class="line">    <span class="keyword">return</span> clientInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，有没有觉得简单一点？完美！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">await</span> serviceProvider.GetGrpcClientAsync&lt;CalculatorClient&gt;();</span><br><span class="line"><span class="keyword">await</span> client.CalcAsync(<span class="keyword">new</span> CalculatorRequest() &#123; Num1 = <span class="number">1</span>, Num2 = <span class="number">2</span>, Op = <span class="string">&quot;+&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="gRPC-接口的测试工具"><a href="#gRPC-接口的测试工具" class="headerlink" title="gRPC 接口的测试工具"></a>gRPC 接口的测试工具</h2><p>我猜，大多数看到这个标题会一脸鄙夷，心里大概会想，就测试工具这种东西值得特地写出来吗？诚然，以前写 API 接口的时候，大家都是用 <a target="_blank" rel="noopener" href="https://www.postman.com/downloads/">Postman</a> 或者 <a target="_blank" rel="noopener" href="https://www.apifox.cn/">Apifox</a> 这样的工具来进行测试的，可是突然有一天你要调试一个<code>gRPC</code>的接口，你总不能每次都调用客户端啊，所以，这里要给大家推荐两个<code>gRPC</code>接口的测试工具，它们分别是: <a target="_blank" rel="noopener" href="https://github.com/fullstorydev/grpcurl">grpcurl</a> 和 <a target="_blank" rel="noopener" href="https://github.com/fullstorydev/grpcui">grpcui</a>，它们都出自同一个人 <a target="_blank" rel="noopener" href="https://github.com/fullstorydev">FullStory</a> 之手，基于 Go 语言开发，简单介绍下使用方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 建议使用国内源</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"></span><br><span class="line">// grpcurl</span><br><span class="line">brew install grpcurl</span><br><span class="line"></span><br><span class="line">// grpcui</span><br><span class="line">go get github.com/fullstorydev/grpcui/...</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br><span class="line"></span><br><span class="line">// 安装后的路径为：C:\Users\&lt;User&gt;\go\bin\grpcui.exe</span><br><span class="line">grpcui -bind &lt;Your-IP&gt; -plaintext &lt;Your-gRPC-Service&gt;</span><br></pre></td></tr></table></figure>

<p>虽然这个说明简单而直白，可我还是没能装好，我不得不祭出 Docker 这个神器，果然它不会令我失望：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wongnai/grpcui</span><br><span class="line">docker run -e GRPCUI_SERVER=localhost:5001 -p 8080:8080 wongnai/grpcui</span><br></pre></td></tr></table></figure>

<p>这里有两个重要的参数，其中，<code>8080</code>是<code>grpcui</code>的服务地址，可以按个人喜好进行修改，<code>GRPCUI_SERVER</code>是<code>gRPC</code>服务地址，该工具运行效果如下：</p>
<p><img src="https://i.loli.net/2021/06/03/gGMaVKquDbtdWUN.png" alt="gRPCUI 接口测试工具"></p>
<p>对于使用者来说，我们只需要选择服务(service)、方法(rpc)、然后填入参数即可，个人感觉非常方便。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文探索并实现了<code>gRPC</code>服务健康检查，主要提供了两种思路：基于<code>IHostedService</code> + <code>Timer</code>的轮询的方案 以及 基于<code>Consul</code>的集服务注册、服务发现、健康检查于一身的方案。特别地，对于后者而言，我们可以顺理成章地联想到客户端的负载均衡，其原理是：<code>Consul</code>中注册了所有<code>gRPC</code>服务的终结点信息，通过<code>IConsulClient</code>可以拿到所有可用的终结点信息，只要以此为基础来构建<code>GrpcChannel</code>即可。根据这个原理，我们引申出了<code>gRPC</code>客户端负载均衡的相关话题，这里我们采用的是随机选择一个终结点信息的做法，事实上，按照一般负载均衡的理论，我们还可以采取轮询、加权、Hash 等等的算法，大家可以按照自己的业务场景来选择合适的方法。最后，我们简单介绍了下<code>gRPC</code>接口测试方面的内容，它可以帮助我们更高效地编写、验证<code>gRPC</code>接口。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、参与讨论，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/28/2021-5-28-githubbeautify2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/28/2021-5-28-githubbeautify2/" itemprop="url">GitHub 个人主页美化（下）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-28T22:00:00+08:00">
                2021-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>虽然我不是程序员，但还是会时不时到世界上最大的代码托管网站 <strong>GitHub</strong> 上去逛一逛，看看自己关注的人是不是 Star（收藏）了一些有意思的项目。</p>
<p>之前写过一篇为自己的 GitHub 主页添加<strong>个性小标签</strong>的方法，效果见下图：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128050423.jpg"></p>
<p>添加个性小标签的方法见👉👉：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649909962&idx=1&sn=cc1b4341f2940a75214ead8c3c2ccf3d&chksm=83a86ee7b4dfe7f10daef1ceef82005ccc4f5d6c6fb97d57ca297039b54d0ddb4e8d389cc18a&scene=21#wechat_redirect">如何美化 GitHub 个人主页？</a>  </p>
<p>除了添加小标签，前段时间还在 GitHub 上看到另外一些有意思的 GitHub 个人主页。</p>
<p>一个是显示自己注册 GitHub 的时间、提交代码的次数、仓库的数量、以及自己最常使用的语言。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128507232.jpg"></p>
<p>另一个则是显示自己的项目获得的 Stars 数量、今年提交代码的次数、创建的 issue 的数量、以及一个计算出来的总评分 A+。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222128802152.jpg"></p>
<p>这些实现起来其实都非常简单，只需要你稍微懂一点 Markdown 的语法。</p>
<p>和之前介绍过的在 GitHub 主页添加小标签一样，你需要先<strong>创建一个与你 GitHub ID 同名的 GitHub 仓库</strong>。</p>
<p>点击 GitHub 个人页右上角的加号 + ，在弹出的面板中，选择「<strong>New repository</strong>」，创建一个新的 GitHub 仓库。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129097996.jpg"></p>
<p>Repository name 是仓库的名称，这里的仓库名必须与前面的 Owner 下方的 GitHub ID 一样，例如我的 ID 为 phh95，因此这里的仓库名也为 phh95。</p>
<p>创建时记得勾选从下方的「<strong>Add a README file</strong>」，在仓库中添加一个名为 README 的 Markdown 文件，等会我们就是要在这个文件中添加我们想放在 GitHub 个人主页的内容。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129328640.jpg"></p>
<h2 id="01-Metrics"><a href="#01-Metrics" class="headerlink" title="01. Metrics"></a>01. Metrics</h2><p>获得类似下图的 GitHub 数据统计，需要用到一个在线工具「Metrics」，打开网站之后，在左侧输入你的 GitHub ID，稍等一会，就会返回右侧所有和你相关的数据。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129571049.jpg"></p>
<p>这里输入阮一峰老师的 ID 进行举例，右侧就是这个网站返回给我们的统计数据。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222129720474.jpg"></p>
<p>点击右侧的 Markdown code 选项卡，切换到统计视图对应的 Markdown 链接。</p>
<p>如果这是你的 GitHub 账号统计数据，可以点击下方的<strong>蓝色链接</strong>，它会将这个链接添加到和你 GitHub ID 同名仓库中，这样你就可以在个人首页看到这些统计数据啦。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130089032.jpg"></p>
<p>Metrics 网址：<br><em><a target="_blank" rel="noopener" href="https://metrics.lecoq.io/">https://metrics.lecoq.io/</a></em></p>
<h2 id="02-显示常用的编程语言"><a href="#02-显示常用的编程语言" class="headerlink" title="02. 显示常用的编程语言"></a>02. 显示常用的编程语言</h2><p>在 GitHub 个人页显示最常用的编程语言，只需要在与 GitHub ID 同名的仓库的 README.md 文档中添加下面的文本：</p>
<p><code>![这里写你的昵称&#39;s Most used languages](https://github-readme-stats.vercel.app/api/top-langs?username=这里替换成你的 GitHub ID&amp;show_icons=true&amp;count_private=true&amp;theme=gotham)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130457996.jpg"></p>
<p>复制后稍作修改，向下滑动页面，点击绿色的「<strong>Commit changes</strong>」按钮，提交确认刚刚作出的修改。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130630284.jpg"></p>
<p>再回到自己的 GitHub 主页，它就会显示<strong>你最常使用的编程语言</strong>，这个统计数据来自于你 Push 到 GitHub 的内容。</p>
<p>譬如我之前将一些在本地写的 Python 文件 Push 到 GitHub 仓库，它就会显示我最常使用的语言为 Python。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222130817920.jpg"></p>
<p>如果你觉得这个显示常用语言的样式不好看，还可以更改文本链接末尾的<strong>参数设置</strong>，例如隐藏底部的深色边框。</p>
<p>下图的效果对应的文本内容为：</p>
<p><code>![这里写你的昵称&#39;s Most used languages](https://github-readme-stats.vercel.app/api/top-langs/?username=这里替换成你的 GitHub ID&amp;layout=compact&amp;hide_border=true&amp;langs_count=10)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131079398.jpg"></p>
<h2 id="03-GitHub-统计卡片"><a href="#03-GitHub-统计卡片" class="headerlink" title="03. GitHub 统计卡片"></a>03. GitHub 统计卡片</h2><p>在 GitHub 上，不少人都会在自己的 GitHub 主页添加下图的 GitHub 统计卡片：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131263530.jpg"></p>
<p>这个 GitHub 统计卡片，来源于 GitHub 上的一个名为「<strong>GitHub Readme Stats</strong>」的项目。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131422494.jpg"></p>
<p>GitHub Readme Stats 项目地址：<br><em><a target="_blank" rel="noopener" href="https://sourl.cn/Sxq854">https://sourl.cn/Sxq854</a></em></p>
<p>这个项目提供了中文版的说明文档，将其添加到自己的 GitHub 主页也非常简单，将下方的链接复制到 GitHub ID 同名的仓库的 README.md 文档中，稍微修改一下信息就可以了。</p>
<p><code>[![这里写你的昵称&#39;s GitHub stats](https://github-readme-stats.vercel.app/api?username=这里替换成你的 GitHub ID)](https://github.com/anuraghazra/github-readme-stats)</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131676869.jpg"></p>
<p>这个统计卡片还提供了<strong>其他的主题样式</strong>，即不同的配色方案，如果你想使用其他的主题，需要在上方的链接后面增加一些额外的参数。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222131892558.jpg"></p>
<p>举个例子，我想使用其中的一个名为 <strong>radical</strong> 的主题，我就得原先的链接后面加多两个参数的配置，一个是<strong>显示图标</strong>，一个是<strong>设置所使用的主题名称</strong>。</p>
<p><code>[![这里写你的昵称&#39;s GitHub stats](https://github-readme-stats.vercel.app/api?username=这里替换成你的 GitHub ID&amp;show_icons=true&amp;theme=radical)](https://github.com/anuraghazra/github-readme-stats)</code></p>
<p>增加了参数配置之后，原先配色方案为<strong>蓝白黑</strong>的卡片就变成了下图的<strong>粉黑青</strong>配色：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222132210757.jpg"></p>
<h2 id="04-添加其他平台的统计数据"><a href="#04-添加其他平台的统计数据" class="headerlink" title="04. 添加其他平台的统计数据"></a>04. 添加其他平台的统计数据</h2><p>除了前面介绍的内容，GitHub 上还有一位开发者采用了类似于「GitHub Readme Stats」的思路，写了一个在 GitHub 个人页<strong>显示其他平台统计数据</strong>的工具。</p>
<p>目前支持统计的网站有：<strong>知乎、B 站、LeetCode、LeetCode 中文站</strong>和<strong>掘金</strong>，下图提供了<strong>知乎统计卡片</strong>的预览效果。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/16222132545884.jpg"></p>
<p>对这个项目感兴趣的朋友，可以移步开发者的 GitHub 项目页面，查看具体的使用或实现方法：</p>
<p><em><a target="_blank" rel="noopener" href="https://github.com/songquanpeng/stats-cards">https://github.com/songquanpeng/stats-cards</a></em></p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/27/2021/2021-05-27-we-dont-need-deno/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/27/2021/2021-05-27-we-dont-need-deno/" itemprop="url">我们并不需要 Deno</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-27T00:00:00+08:00">
                2021-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a target="_blank" rel="noopener" href="https://deno.land/">Deno</a> 一出生便带着光环 —— 它发布于 Node.js 创始人 Ryan Dahl 的演讲「<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=M3BM9TB-8yA">Design Mistakes in Node</a>（<a target="_blank" rel="noopener" href="https://tinyclouds.org/jsconf2018.pdf">幻灯片</a>）」，当时有些人说 Node.js 要凉了，但我不这么认为。</p>
<h2 id="原生-TypeScript"><a href="#原生-TypeScript" class="headerlink" title="原生 TypeScript"></a>原生 TypeScript</h2><p>其实目前我们在引擎的「用户态」去使用 TypeScript 并没有引入任何问题，而且给用户带来了很大的灵活性。考虑到 TypeScript 不可能离开 JavaScript 的生态 —— 毕竟引擎总是要支持 JavaScript 的；再加上 TypeScript 有不同的版本、不同的编译开关，在用户态使用 TypeScript 可以说是最好的方案了。TypeScirpt 迟早会成为 Deno 的历史包袱。</p>
<p>从性能的角度，在 TypeScript 没出现之前，V8 已经在 JavaScript 上进行大量 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29638866">魔法优化</a> 了，可以说 JIT 出来的代码并不比其他静态类型的语言差太多，是没法简单地通过 TypeScript 来提升性能的。再加上前面说了引擎总还是要支持 JavaScript、TypeScript 的运行时语义依然是 JavaScript（TypeScript 并不能保证对象的实际类型在运行时不被修改），所以引擎也不可能从对 JavaScript 的魔法优化切换到基于 TypeScript 的类型来做优化。</p>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>我一直认为 NPM 是最好用的包管理器之一，这包括将依赖保存在项目目录中 —— 在调整一个项目的依赖时不必担心对其他项目产生影响；每个包都可以指定自己的依赖版本，允许多版本并存 —— 在升级一个包的依赖时不会影响到其他包，每个包都可以使用新的版本或继续使用旧的版本；NPM 负责查找和安装包，而 Node.js 则用相对简单的协议去使用这些包，它们可以彼此独立地升级演进。</p>
<p>可以看到 NPM 最终极大地减轻了开发者的心智负担，只要你按照正确的方式去使用它，极少会遇到其他语言中有关依赖管理的问题。而 Deno 则反其道行之。虽然 Deno 也提供了一些相关的功能（<a target="_blank" rel="noopener" href="https://deno.land/manual@master/linking_to_external_code/reloading_modules">deno cache</a>），但你会发现 Deno 的本意仍然是不希望进行「依赖管理」。</p>
<p>在代码中包含 URL 是一个非常糟糕的做法（Golang 也是如此），Deno 称之为去中心化，但其实它只是重新将使用包的代码与包的来源耦合在了一起（现在 Deno 提供了一个 <a target="_blank" rel="noopener" href="https://deno.land/x">官方的代理</a>，但这样和 NPM 的中心仓库又有什么区别呢）。缓存机制也带来了相当大的不确定性：<code>package-lock.json</code> 可以保证每次安装的依赖是完全一致的，而 Deno 的 <a target="_blank" rel="noopener" href="https://deno.land/manual@v1.10.2/linking_to_external_code/integrity_checking">lock.json</a> 只能检查依赖是否有变化（如果有的话就拒绝运行）。这使得开发者很难控制依赖更新的时机，<a target="_blank" rel="noopener" href="https://deno.land/manual/linking_to_external_code#but-what-if-the-host-of-the-url-goes-down-the-source-won#39t-be-available">Deno 则建议将依赖缓存放入 Git</a>。</p>
<h2 id="内建权限系统"><a href="#内建权限系统" class="headerlink" title="内建权限系统"></a>内建权限系统</h2><p>一直以来通用编程语言都不曾在语言层面引入权限控制，但确实开源社区也曾报出过多次恶意代码的事件，但 Deno 的权限机制相当粗糙 —— 只能在进程级别进行权限控制，我可以大胆地预言，在几乎所有的场景里我们都需要 <code>--allow-all</code>，并不能对安全起到太多作用。</p>
<p>我们需要考虑 Deno 的用户到底是开发者还是使用者：对于 Deno 脚本的使用者来说关注的当然是进程级别的权限；而对于开发者我认为更关注的是第三方包的权限，权限系统应该以包为单位（然而 Deno 里并没有包的概念了），Node 里本来也有 vm 模块可以一定程度上实现沙盒（但确实非常难以控制）。</p>
<p>而且说起来我们现在已经有了 Docker（或者更广泛的容器的概念）这种彻底的隔离和权限控制机制，业界对编程语言引入一套权限控制已经没有太大的需求了。</p>
<h2 id="孤立的生态"><a href="#孤立的生态" class="headerlink" title="孤立的生态"></a>孤立的生态</h2><p>可以说 JavaScript 的生态来自于用户态类库的充分竞争，Deno 则在 Runtime API 之外提供了 Standard Library（类似 <code>golang.org/x</code>）、提供了全套的开发工具链（fmt、test、doc、lint、bundle），在试图提供开箱即用的使用体验的同时，也削弱了第三方生态。</p>
<p>在 Node.js 和 NPM 已然成为 JavaScript 事实标准的一部分的情况下，Deno 本来可以通过兼容 Node.js 或 NPM 有一个非常好的开场。但 Deno 却选择了和 Node.js 划清界限，而是兼容了一些浏览器环境的 API（如 prompt 或 onload）。</p>
<p>Deno 自己的说法是为了遵循已有的 Web 标准避免发明新东西，但实际上这些 Web 标准在设计时并未充分考虑浏览器之外的 Runtime，况且 Deno 其实也没能避免发明新东西（这些新东西被放在了 Deno 这个命名空间中）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Deno 就是这样一个有着非常鲜明个人偏好的 JavaScript Runtime，它试图去纠正 Node.js 的一些「设计失误」、希望给出一种「JavaScript 最佳实践」，希望提供高质量且开箱即用的标准库和工具链。这些偏好的选择总会有人喜欢或不喜欢，但除此之外 Deno 实在是缺少一个 killer feature（杀手级特性）让一个「理性」的 Node.js 开发者（如一个公司）切换到 Deno。</p>
<p>通过单一文件发行、进程级别的权限控制使 Deno 会更适合命令行工具的开发，但能否与已经广泛用于命令行工具的 Golang 竞争尚且存疑。</p>
<p>作为一个 Node.js 开发者，我并不觉得 Deno 可以在未来替代 Node 成为我的主力开发工具，Deno 更像是 Golang 的设计哲学对 JavaScript 的一次入侵。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/26/ASP-NET-Core-gRPC-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/26/ASP-NET-Core-gRPC-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB/" itemprop="url">ASP.NET Core gRPC 拦截器的使用技巧分享</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-26T09:03:35+08:00">
                2021-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>gRPC</code>是微软在<code>.NET Core</code> 及其后续版本中主推的 RPC 框架，它使用 <code>Google</code> 的 <code>Protocol Buffers</code> 作为序列化协议，使用 <strong>HTTP&#x2F;2</strong> 作为通信协议，具有<strong>跨语言</strong>、<strong>高性能</strong>、<strong>双向流式调用</strong>等优点。考虑到，接下来要参与的是，一个以<code>gRPC</code>为核心而构建的微服务项目。因此，博主准备调研一下<code>gRPC</code>的相关内容，而首当其冲的，则是从 .NET Core 3.1 开始就有的拦截器，它类似于<code>ASP.NET Core</code>中的过滤器和中间件，体现了一种面向切面编程(<strong>AOP</strong>)的思想，非常适合在 RPC 服务调用的时候做某种统一处理，譬如参数校验、身份验证、日志记录等等。在今天这篇博客中，博主主要和大家分享的是，利用 .NET Core gRPC 中的拦截器实现日志记录的简单技巧，希望能给大家带来一点启发。</p>
<p><img src="https://i.loli.net/2021/05/28/1MgBG2uRHwEqXvt.jpg" alt="开源、多语言、高性能的 gRPC"></p>
<h1 id="关于-Interceptor-类"><a href="#关于-Interceptor-类" class="headerlink" title="关于 Interceptor 类"></a>关于 Interceptor 类</h1><p><code>Interceptor</code>类是 gRPC 服务拦截器的基类，它本身是一个抽象类，其中定义了下面的虚方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncClientStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt; <span class="title">AsyncDuplexStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> TResponse <span class="title">BlockingUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">ClientStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncServerStreamingCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Task <span class="title">DuplexStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Task <span class="title">ServerStreamingServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">UnaryServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;()</span>;</span><br></pre></td></tr></table></figure>
<p>整体而言，如果从通信方式上来划分，可以分为：<strong>流式调用</strong> 和 <strong>普通调用</strong>；而如果从使用方来划分，则可以分为：<strong>客户端</strong> 和 <strong>服务端</strong>。进一步讲的话，针对<strong>流式调用</strong>，它还分为：”<strong>单向流</strong>“ 和 “<strong>双向流</strong>“。关于这些细节上的差异，大家可以通过 <code>gRPC</code> 的 <a target="_blank" rel="noopener" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/">官方文档</a> 来了解，这里我们给出的是每一种方法对应的用途：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AsyncClientStreamingCall</td>
<td>拦截异步客户端流式调用</td>
</tr>
<tr>
<td>AsyncDuplexStreamingCall</td>
<td>拦截双向流式调用</td>
</tr>
<tr>
<td>AsyncUnaryCall</td>
<td>拦截异步普通调用</td>
</tr>
<tr>
<td>BlockingUnaryCall</td>
<td>拦截阻塞普通调用</td>
</tr>
<tr>
<td>AsyncServerStreamingCall</td>
<td>拦截异步服务端流式调用</td>
</tr>
<tr>
<td>ClientStreamingServerHandler</td>
<td>拦截客户端流式调用的服务端处理程序</td>
</tr>
<tr>
<td>DuplexStreamingServerHandler</td>
<td>拦截双向流式调用的服务端处理程序</td>
</tr>
<tr>
<td>ServerStreamingServerHandler</td>
<td>拦截服务端流式调用的服务端处理程序</td>
</tr>
<tr>
<td>UnaryServerHandler</td>
<td>拦截普通调用的服务端处理程序</td>
</tr>
</tbody></table>
<h1 id="实现一个拦截器"><a href="#实现一个拦截器" class="headerlink" title="实现一个拦截器"></a>实现一个拦截器</h1><p>好了，下面我们一起实现一个拦截器。这里，我们使用的是微软官方的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreeterService</span> : <span class="title">Greeter.GreeterBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">        &#123;</span><br><span class="line">            Message = <span class="string">&quot;Hello &quot;</span> + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>实现服务器端的普通调用拦截，我们需要重写的方法是<code>UnaryServerHandler</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCServerLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GRPCServerLoggingInterceptor&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GRPCServerLoggingInterceptor</span>(<span class="params">ILogger&lt;GRPCServerLoggingInterceptor&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 UnaryServerHandler() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">Task</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">UnaryServerHandler</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      TRequest request, ServerCallContext context, </span></span></span><br><span class="line"><span class="params"><span class="function">      UnaryServerMethod&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish.&quot;</span>);</span><br><span class="line">        _logger.LogInformation(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">LogRequest</span>&lt;<span class="title">TRequest</span>&gt;(<span class="params">TRequest request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">is</span> IMessage)</span><br><span class="line">            payload = JsonConvert.SerializeObject(</span><br><span class="line">                (request <span class="keyword">as</span> IMessage)</span><br><span class="line">                .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(request <span class="keyword">as</span> IMessage))</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;Send request of <span class="subst">&#123;<span class="keyword">typeof</span>(TRequest)&#125;</span>:<span class="subst">&#123;payload&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录gRPC响应</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">LogResponse</span>&lt;<span class="title">TResponse</span>&gt;(<span class="params">TResponse response, AggregateException exception</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> payload = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">is</span> IMessage)</span><br><span class="line">                payload = JsonConvert.SerializeObject(</span><br><span class="line">                  (response <span class="keyword">as</span> IMessage)</span><br><span class="line">                  .Descriptor.Fields.InDeclarationOrder()</span><br><span class="line">                  .ToDictionary(x =&gt; x.Name, x =&gt; x.Accessor.GetValue(response <span class="keyword">as</span> IMessage))</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span>:<span class="subst">&#123;payload&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsgs = <span class="built_in">string</span>.Join(<span class="string">&quot;;&quot;</span>, exception.InnerExceptions.Select(x =&gt; x.Message));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Receive response of <span class="subst">&#123;<span class="keyword">typeof</span>(TResponse)&#125;</span> throws exceptions: <span class="subst">&#123;errorMsgs&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>gRPC</code>而言，每一个由<code>.proto</code>声明文件生成的类，都带有一个叫做<code>Descriptor</code>的属性，我们可以利用这个属性获得<code>gRPC</code>请求和响应的详细信息。所以，在<code>LogRequest()</code>和<code>LogResponse()</code>两个方法中，我们均使用了这一思路来记录<code>gRPC</code>的报文信息，因为传输层的<code>gRPC</code>使用了二进制作为数据载体，这可以说是一种用可读性换取高效率的做法，不过幸运的是，我们在这里实现了这个小目标。</p>
<p>接下来，为了让这个拦截器真正生效，我们还需要修改一下<code>Startup</code>类中注册<code>gRPC</code>这部分的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpc(options =&gt; options.Interceptors.Add&lt;GRPCServerLoggingInterceptor&gt;());</span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/05/27/3nZXelLPVwJ7AjS.png" alt="gRPC服务器端拦截器效果展示"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>实现客户端的普通调用拦截，我们需要重写的方法是<code>AsyncUnaryCall()</code>，依样画葫芦即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GRPCClientLoggingInterceptor</span> : <span class="title">Interceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重写 AsyncUnaryCall() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TResponse</span>&gt; <span class="title">AsyncUnaryCall</span>&lt;<span class="title">TRequest</span>, <span class="title">TResponse</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        TRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">        ClientInterceptorContext&lt;TRequest, TResponse&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">        AsyncUnaryCallContinuation&lt;TRequest, TResponse&gt; continuation</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC begin</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> begin.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Request</span></span><br><span class="line">        builder.AppendLine(LogRequest(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging Response</span></span><br><span class="line">        <span class="keyword">var</span> reply = continuation(request, context);</span><br><span class="line">        <span class="keyword">var</span> response = reply.ResponseAsync.Result;</span><br><span class="line">        <span class="keyword">var</span> exception = reply.ResponseAsync.Exception;</span><br><span class="line">        builder.AppendLine(LogResponse(response, exception));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call gRPC finish</span></span><br><span class="line">        builder.AppendLine(<span class="string">$&quot;Call gRPC <span class="subst">&#123;context.Host&#125;</span>/<span class="subst">&#123;context.Method&#125;</span> finish.&quot;</span>);</span><br><span class="line">        Console.WriteLine(builder.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reply;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，为了让拦截器在客户端生效，我们需要这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Grpc.Core.Interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>);</span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line">channel.Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">var</span> invoker = channel.CreateCallInvoker().Intercept(<span class="keyword">new</span> GRPCClientLoggingInterceptor());</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(invoker);</span><br><span class="line"><span class="keyword">await</span> client.SayHelloAsync(<span class="keyword">new</span> HelloRequest() &#123; Name = <span class="string">&quot;长安书小妆&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，我们可以得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/05/28/XcwmOQbzKTJPtUj.png" alt="gRPC客户端拦截器效果展示"></p>
<p>客户端感觉不太好的一点就是，这个<code>Interceptor</code>传入的必须是一个实例，考虑到拦截器内部可能会依赖类似<code>ILogger</code>等等的组件，建议还是通过<code>IoC</code>容器来取得一个拦截器的实例，然后再传入<code>Intercept()</code>方法中。博主所在的项目中，则是非常“<strong>土豪</strong>”地使用了<code>PostSharp</code>，直接走动态编织的方案，果然，“<strong>这次第，怎一个羡字了得</strong>”。当然，<code>gRPC</code>的客户端，其实提供了日志相关的支持，不过，我个人感觉这个有一点无力：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(logging =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    logging.AddConsole();</span><br><span class="line">    logging.SetMinimumLevel(LogLevel.Debug);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(</span><br><span class="line">    <span class="string">&quot;https://localhost:5001&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> GrpcChannelOptions &#123; LoggerFactory = loggerFactory &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了<code>gRPC</code>拦截器的使用技巧，<code>gRPC</code>支持一元调用(<strong>UnaryCall</strong>)、流式调用(<strong>StreamingCall</strong>)、阻塞调用(<strong>BlockingCall</strong>)，因为区分客户端和服务器端，所以，实际上会有各种各样的组合方式。<code>gRPC</code>的拦截器实际上就是选择对应的场景去重写相应的方法，其中，拦截器的基类为<code>Interceptor</code>类，这里我们都是以普通的一元调用为例的，大家可以结合各自的业务场景，去做进一步的调整和优化。这里，我们使用<code>IMessage</code>类的<code>Descriptor</code>属性来“反射”报文中定义的字段，这样就实现了针对<code>gRPC</code>服务请求&#x2F;响应的日志记录功能。关于<code>gRPC</code>中日志和诊断的更进一步的话题，大家可以参考微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/diagnostics?view=aspnetcore-5.0">官方文档</a> 。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/19/SnowNLP%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%96%99%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/19/SnowNLP%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%96%99%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/" itemprop="url">SnowNLP 使用自定义语料进行模型训练</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-19T21:22:41+08:00">
                2021-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 是一个功能强大的中文文本处理库，它囊括了中文分词、词性标注、情感分析、文本分类、关键字&#x2F;摘要提取、<code>TF/IDF</code>、文本相似度等诸多功能，像<strong>隐马尔科夫模型</strong>、<strong>朴素贝叶斯</strong>、<code>TextRank</code>等算法均在这个库中有对应的应用。如果大家仔细观察过博主的博客，就会发现博主使用了摘要提取这一功能来增强博客的<code>SEO</code>，即通过自然语言处理(<strong>NLP</strong>)技术，提取每一篇文章中的摘要信息。因为 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 本身使用的语料是电商网站评论，所以，当我们面对不同的使用场景时，它自带的这个模型难免会出现“水土不服”。因此，如果我们希望得到更接近实际的结果，最好的方案是使用自定义语料进行模型训练。值得庆幸的是，这一切在 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 中实施起来非常简单，并不需要我们去钻研那些高深莫测的算法。至此，就引出了今天这篇博客的主题，即 SnowNLP 使用自定义语料进行模型训练。</p>
<p>不知道大家是否还有印象，博主曾经在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2758545080/">《通过 Python 分析 2020 年全年微博热搜数据》</a> 这篇文章中提到过 SnowNLP 的模型训练。当时，博主采集了整个 2020 年的微博热搜话题，因为要体现整个一年里的情感变化，博主特意找了两份微博语料，并以此为基础训练出了一个模型文件。</p>
<p><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势"></p>
<p>那么，具体是怎么样做的呢？我们一起来看一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> sentiment</span><br><span class="line">sentiment.train(<span class="string">&#x27;./train/neg60000.txt&#x27;</span>, <span class="string">&#x27;./train/pos60000.txt&#x27;</span>)</span><br><span class="line">sentiment.save(<span class="string">&#x27;weibo.marshal&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>千万不要怀疑你的眼睛，因为它真的只有短短的三行代码。简单来说，我们只需要准备一个“<strong>积极</strong>”的语料文件，一个“<strong>消极</strong>”的语料文件，它就可以训练出一个模型文件。特别注意的是，如果是在<code>Python 3.X</code>的版本下，最终生成的模型文件的扩展名将会是<code>.3</code>，下图是博主这里训练出的模型文件：</p>
<p><img src="https://i.loli.net/2021/05/20/EQnaXv3x6Vyfm7j.png" alt="SnowNLP 使用自定义语料进行模型训练"></p>
<p>好了，一旦训练出这个模型文件，我们就可以考虑替换掉 SnowNLP 的默认模型文件，我们可以在以下位置：<code>\Lib\site-packages\snownlp\sentiment</code> 找到下列文件。为了安全起见，我们首先将原来的模型文件重命名，然后再放入我们自己的模型文件。</p>
<p><img src="https://i.loli.net/2021/05/20/C5QS3uhvt1liqXc.png" alt="SnowNLP 使用自定义模型替换默认模型"></p>
<p>此时，我们就可以利用训练好的模型，分析某一条微博的情感倾向。这里我选取了几条我的微博，看看这个情感倾向预测的结果如何：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;我爱你，并不期待回声&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.8760737296091975</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;想找一个人，一起做老爷爷、老奶奶才做的事情，比如，替我拔一拔头上的白头发……[二哈] ​​&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.001629297651780881</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;如果两个人都不爱了，一别两宽，各生欢喜，其实是挺好的结局；可如果还有一个人爱着，对那个人来说，爱又是什么呢？&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.809651945221708</span></span><br><span class="line"></span><br><span class="line">s = SnowNLP(<span class="string">u&#x27;为了发张自拍，特意出来跑步，还有谁？[doge] ​​​&#x27;</span>)</span><br><span class="line">s.sentiments <span class="comment"># 0.4041057894917053</span></span><br></pre></td></tr></table></figure>

<p>有人说，双子座是一个白天自愈、晚上孤独的星座，我确信这是真的，因为从我出生的那一刻起，那种宏大宇宙中的孤独感就一直笼罩着我，用一句话来形容，大概就是“<strong>热闹是人家的，我什么都没有</strong>”，因为内心世界里的两个灵魂，从来没有一刻闲歇地在纠缠和撕裂。我一直都想了解一件事情，如果这些基于概率或者是公式的算法，都可以琢磨出人类某个时刻的心境，我们期望别人能懂自己是不是太过矫情，我们是真的了解自己吗？</p>
<p>OK，说完微博话题这个场景，我们再来说说电影评论这个场景。回想今年过年的时候，一部<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/34841067/">《你好，李焕英》</a>，成为贺岁档电影中的一匹黑马，而相比之下，<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a>则有点“<strong>滑铁卢</strong>”的感觉。为了搞清楚某一部电影真实的评价情况，此时，我们可以考虑使用 SnowNLP ，对影评的情感趋向进行打分。同样地，这里我们找了一部分影评语料，为 SnowNLP 训练一个单独的模型。接下来，我们不妨从豆瓣上抓取一定数量的影评，来验证下我们这里训练好的模型，这里以<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a>为例：</p>
<p><img src="https://i.loli.net/2021/05/22/5Mo1ncNyEO2K69j.png" alt="从豆瓣上抓取到的电影评论"></p>
<p>可以发现，这些影评的情感趋向介于 0 到 0.1 这个区间的数量最多，占到 160 以上，这意味着约有 30%的观众认为这部电影是个不折不扣的烂片。</p>
<p><img src="https://i.loli.net/2021/05/22/1hvXtjciPlWBzD9.jpg" alt="唐人街探案3豆瓣影评情感分布"></p>
<p>目前，<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/27619748/">《唐人街探案 3》</a> 在豆瓣上的评分只有 5.5 分，其中，2 星和 3 星的评价占到 70%以上。由于豆瓣接口的限制，我们大概只能抓到 500 条左右的影评信息，可即使如此，可以看出大家对这部电影的情绪多少有一点不满。博主当时看这个电影，最大的感受是里面充斥着太多强行搞笑的东西，例如开篇机场那一场打砸抢的戏份，我完全不明白它存在的意义是什么，虽然日本演员们的表演可圈可点，可在这样一个推理和叙事都非常脆弱的故事里，大概就剩下翻来覆去重复使用的搞笑伎俩啦，你敢说医院这场戏和第一部阿香家那场戏没有相似的地方吗？更不用说，医院这场戏大家都在评论里无限吐槽啦！</p>
<p><img src="https://i.loli.net/2021/05/22/MRsAc76vgmTEK4z.png" alt="豆瓣电影-唐人街探案3"></p>
<p>其实，对于情感，我一直不知道该怎么来讲，可能是程序员的这份理性，让我在维系亲密关系或者说的情感的时候，有时候会生出一种近乎漠然的、置身事外的错觉，换句话说，也许是那种被人称为“<strong>天性凉薄</strong>”的东西。前任同我讲，我最爱的人其实是我自己，并不是她。因为站在她的角度上来讲，她并没有感受到我给予她的爱。我该怎么回答这个问题呢？在一切看似理性的数学计算背后，人类这些极为在乎的情感到底又是什么形式？也许有一天，两个人的感情说变淡就突然变淡，不管我们曾经说过什么样的话，在那一刻都会变得苍白无力，逐年攀升的离婚率触目惊心，可我们每个人都像扑向火焰的飞蛾，在这爱与欲望无法随心所欲的世界里，被欲望裹挟着不断向前。人会变的绝情、冷漠，我们自以为那是成长，可那不过是心变硬了，可这是我们当初期待的长大吗？</p>
<p><img src="https://i.loli.net/2021/06/08/HrQbtvcjeI1h9M3.png" alt="欢迎来到无法随心所欲的爱与欲望的世界"></p>
<p>今天，听到袁隆平爷爷去世的消息，除了不断地提醒我们这代人已然老去这个事实以外，也许最大的体会应该是，我们在这个世界上追求的名利、身份和爱，最终都会无可避免地走向消亡，就如同我们身上这具躯壳一样，而真正能流传下去、泽被后世地，永远都是思想、是文化、是技术、是精神。佛家云：人死身灭，大概我们都不得不去接受这个残酷的事实，所以，请放下那些爱而不得、求而不得的执念吧，你一辈子不管遇见多少人，在某一个时候也许就会荡然无存，爱会消失、身会毁灭，这一切都是宇宙间的自然法则，与其去纠结那些“<strong>薛定谔态</strong>”的事物，不如多为这个世界做一点有意义的事情，正如尼采的那句名言，“<strong>对待生命你不妨大胆冒险一点, 因为无论如何你都要失去它</strong>”，我也许并不真正懂得人类的情感，因为它在理性面前毫无意义，世间万物毫无例外地走向那个坍塌的奇点，这难道不是一种荒凉的美感吗？</p>
<p><img src="https://i.loli.net/2021/05/22/kjR2nVSHlDNrCLi.jpg" alt="人的心情难道不是一个黑洞"></p>
<p>嘘，如果你读到这里，意外发现这是一篇水字数的博客，而这或许说明了一件事情，我的确是一个会懈怠、会疲倦的活生生的人。关于 SnowNLP 使用自定义语料进行模型训练的话题，这次我们就先写到这里，做数据挖掘的时候，有的人在乎的是最终的结果，而有的人享受的是整个过程，人类的情感或许是相似的，所以，学着去接受这个多样性有点多到奇葩的世界，学着去和平凡而普通的自己和解吧，欢迎大家在评论区交换想法或者观点，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/18/2021-5-18-blogupdate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/18/2021-5-18-blogupdate/" itemprop="url">你可以用 RSS 订阅我的博客了</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-18T00:00:00+08:00">
                2021-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>去年写过一篇介绍自己<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649893670&idx=1&sn=1f3f91248ade0d5f1bbe3c2046990d63&chksm=83a82f0bb4dfa61d463dfe7af7ecafa21ac0cf1bee21b1b147990b83f657f687d3857db40bf8&scene=21&token=1051004415&lang=zh_CN#wechat_redirect">创建了一个博客</a>的文章，创建博客之后，陆陆续续上传了一些文章，还不至于把博客完全荒废了。</p>
<p>博客，可以算是一个个人网站，相比于公众号，博客可以玩或者说可以自定义的地方更多，比如它可以像手机那样，换上各式各样的主题，给人不一样的视觉效果。</p>
<p>我的博客是用 Hexo 框架搭建的，下面是我收集的一些比较好看的 Hexo 主题（其实也没有收集很多主题，暂时只有三个）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a> 主题</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514211522989.png" alt="hexo-theme-next"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>：最近刚看到博客主题，页面左下角带有播放音乐的控件</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514215136167.png" alt="image-20210514215136167"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a>：我的博客目前正在使用的 Hexo 主题</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210514215958123.png" alt="image-20210514215958123"></p>
<h2 id="如何为-Hexo-博客换上不同的主题？"><a href="#如何为-Hexo-博客换上不同的主题？" class="headerlink" title="如何为 Hexo 博客换上不同的主题？"></a>如何为 Hexo 博客换上不同的主题？</h2><p>如果你对前面介绍的 Hexo 主题感兴趣，可以去 GitHub 上搜索主题的名字，就能找到对应主题的代码文件。</p>
<p>点击绿色的「Code」按钮，选择「Download ZIP」，下载整个项目的源文件。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212610267455.jpg" alt="-w1520"></p>
<p>将下载的 ZIP 文件解压，将解压后的整个文件放进 Hexo 博客的 themes 文件夹中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212615371840.jpg" alt="-w1112"></p>
<p>下载下来的主题一般都会带有主题作者的信息，在应用到自己的博客之前，需要先进行修改。</p>
<p>如果你不知道如何修改主题中的信息，可以查看主题的作者是否提供了主题的「说明文档」或「使用文档」。</p>
<p>以我在用的 Hexo 主题「hexo-theme-fluid」为例，主题的作者写了一份详细的「配置指南」，给初次使用第三方主题的人提供了非常详细的指导。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212648922137.jpg" alt="-w1520"></p>
<p>Hexo 主题「hexo-theme-fluid」配置文档：<br><em><a target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></em></p>
<p>如果你使用的 Hexo 主题没有提供配置文档，也可以来参考上面的配置文档，因为多数 Hexo 主题的配置，都是大同小异的。</p>
<h2 id="添加-RSS-订阅链接"><a href="#添加-RSS-订阅链接" class="headerlink" title="添加 RSS 订阅链接"></a>添加 RSS 订阅链接</h2><p>虽然之前写过一篇介绍<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649904885&idx=1&sn=4cf0407adfa94e0e855ca3a5bc3bda20&chksm=83a852d8b4dfdbce023212961dfb446fc4fd8a8e595ea762ad8711602dd9c551811cdff19ca6&token=1051004415&lang=zh_CN#rd">通过 RSS 来订阅多个内容平台</a>的文章，但我自己却没有为自己的博客生成 RSS 订阅链接的意识🤦‍♂️</p>
<p>想起来要给博客添加 RSS 订阅链接，还是推特上一位网友给我提的。</p>
<p>为博客添加 RSS 订阅链接，需要安装一个插件「hexo-generator-feed」，具体可以参照 GitHub 上的一个项目「hexo-generator-feed」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212660487438.jpg" alt="-w1520"></p>
<p>hexo-generator-feed 项目地址：<br><em><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-generator-feed">https://github.com/hexojs/hexo-generator-feed</a></em></p>
<p>这个插件需要在终端中使用 <strong>npm</strong> 命令行工具安装<br>安装之前，需要打开<strong>终端</strong>（终端在 Windows 上叫做「命令行」），使用 <code>cd</code> 命令进入 Hexo 博客项目文件存放的位置。</p>
<p>例如我将 Hexo 博客项目文件存放在本地磁盘的 &#x2F;workspace&#x2F;hexo_blog 路径下，因此 <code>cd</code> 命令输入的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd workspace/hexo_blog</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212663991058.jpg" alt="-w1152"></p>
<p>进入 Hexo 博客项目文件所在的位置后，输入下方的命令安装「hexo-generator-feed」插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>安装了插件后，我们还需要对插件进行配置，插件项目的说明文档也对配置进行了说明：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212667655383.jpg" alt="-w1520"></p>
<p>说明文档中配置的参数比较多，但其实我们可以偷懒，不需要配置那么多参数。</p>
<p>打开博客项目文件夹中的配置文件 <code>_config.yml</code>，可以用记事本打开，也可以用代码编辑器，例如微软推出的 VS Code 打开。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212673979375.jpg" alt="-w1112"></p>
<p>打开配置文件，滑动到文件的最底部，在最底部加上下方的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 订阅 RSS</span><br><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: false</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212674929381.jpg" alt="-w1066"></p>
<p>修改好 <code>_config.yml</code> 文件后，按下快捷键 Ctrl + S 保存我们的修改。</p>
<p>接着打开博客项目中存放主题的文件夹 themes，接着再进入博客当前使用的主题中。</p>
<p>以下图为例，我进入了我使用的 Hexo 主题「fluid」的文件夹中，其中也有一个名为 <code>_config.yml</code> 的配置文件，同样使用记事本或者代码编辑器打开它。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212677314446.jpg" alt="-w1112"></p>
<p>同样滑动到配置文件的末尾，在空白处加上下面的一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212680030990.jpg" alt="-w1066"></p>
<p>加入上面的一行代码之后，同样 Ctrl + S 保存文件。</p>
<p>此时，将所有的修改 Push 到远端的服务器，稍等一会，就可以使用 RSS 来订阅自己的博客了，RSS 链接为：<code>博客域名/atom.xml</code></p>
<p>举个例子，我的个人博客域名为 <code>penghh.fun</code>，我的博客 RSS 订阅链接相应地就是：<code>penghh.fun/atom.xml</code></p>
<p>如果你有使用 RSS 阅读器来获取信息的习惯，可以将我博客的 RSS 链接添加到你的 RSS 阅读器中：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212686091065.jpg" alt="-w1400"></p>
<p>这部分给 Hexo 博客生成 RSS 订阅链接的内容，参考了网友 @千古壹号 写的内容，原文如下，可扫码阅读：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/qrcodea--a1.png" alt="QRcode_A — a1"></p>
<h2 id="添加单篇博客阅读量统计"><a href="#添加单篇博客阅读量统计" class="headerlink" title="添加单篇博客阅读量统计"></a>添加单篇博客阅读量统计</h2><p>博客不像公众号——会在文章页面的左下角显示阅读数，如果我们想要为博客添加单篇文章阅读量的统计功能，还需要手动进行配置。</p>
<p>配置之前，最好先查看一下你使用的 Hexo 主题的配置文件 <code>_config.yml</code> 是否已经写好了相关的代码，只是默认暂未开启统计功能。</p>
<p>打开 Hexo 主题的 <code>_config.yml</code> 文件，按下快捷键 Ctrl + F 打开搜索功能，你可以<strong>试着使用下方这些关键字</strong>进行搜索，查看 Hexo 主题是否写好了统计博客阅读量的代码：</p>
<ul>
<li>web analytics</li>
<li>views</li>
<li>leancloud</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212694034937.jpg" alt="-w1066"></p>
<p>譬如，我使用的 Hexo 主题「fluid」就写好了统计阅读量的代码，只是缺少相应的配置，默认就无法统计单篇文章的阅读量。</p>
<p>这里我使用一个第三方服务 <strong>Leancloud</strong> 来统计文章的阅读量。</p>
<p>首先需要打开 Leancloud 的官网，注册一个账号，注册好账号之后，点击左上角的按钮，创建一个应用。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212698785178.jpg" alt="-w1520"></p>
<p>创建时「应用名称」可以随你自由命名，下方的「应用计价方案」选择「<strong>开发版</strong>」就好，不需要花钱，接着点击右下角的蓝色按钮「创建」。<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212699186782.jpg" alt="-w1520"></p>
<p>创建好应用之后，打开应用的「设置 &gt;&gt; 应用 Keys」，页面中有两个参数，一个是 <strong>AppID</strong>，一个是 <strong>AppKey</strong>。</p>
<p>这两个参数下方的值等会要用到，暂时不要把网页关掉。<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212701931820.jpg" alt="-w1520"></p>
<p>回到博客主题的配置文件中，搜索 Leancloud，如下图所示，可以看到 leancloud 下方有两个需要配置的参数，一个是 <strong>app_id</strong>，一个是 <strong>app_key</strong>，这两个参数的值就分别对应上面说到的 <strong>AppID</strong> 和 <strong>AppKey</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212704379312.jpg" alt="-w1066"></p>
<p>接着我们还要开启每篇博客的数据统计的功能，在博客主题配置文件中搜索关键字 view。</p>
<p>每篇博客的数据统计 views 下方有两个参数，一个是 enable，将其设置为 enable 或 true 都可以；一个是统计的来源 source，设置为 leancloud。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212718906462.jpg" alt="-w1066"></p>
<p>完成以上配置之后，将所有变更 Push 到服务器，稍等一小会，刷新自己的博客，一般情况下，就可以在每篇博客的顶部看到阅读量的统计数据了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212721365539.jpg" alt="-w1742"></p>
<h2 id="交换博客「友情链接」"><a href="#交换博客「友情链接」" class="headerlink" title="交换博客「友情链接」"></a>交换博客「友情链接」</h2><p>不像以前，现在刚起步做博客更难了，因为许多人都不怎么在电脑端阅读内容了，都更倾向于使用手机获取信息，而且人们更喜欢观看视频而非枯燥的文字内容了。</p>
<p>基于种种原因，从零开始做一个博客，真的难上加难。</p>
<p>因此，如果你刚好也有自己的博客，且有交换友情链接🔗的想法，不嫌弃的话，可以在评论区留言，我们互相在各自的博客添加彼此的链接。</p>
<p>你的博客链接的位置，我已经留好了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/18/16212724879342.jpg" alt="-w1742"></p>
<p>以上，希望有帮助。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/13/2021-5-13-picgoandtypora/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/13/2021-5-13-picgoandtypora/" itemprop="url">Windows 写作三件套：PicGo + Typora + 腾讯云</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-13T00:00:00+08:00">
                2021-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello 大家好，我是安哥。   </p>
<p>之前发过的一些排版不太一样的文章，我都是在 Mac 上的 Markdown 写作软件 MWeb 中写的，因为我在 MWeb 中配置了腾讯云图床，每次写好文章后，使用 MWeb 内置的上传服务，将图片上传到腾讯云图床之后返回 Markdown 链接，就可以很方便地将文章分发到多个平台，<strong>不会出现图片丢失</strong>的情况。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512115719307.png" alt="image-20210512115719307"></p>
<p>但由于 MWeb 是苹果生态独有的软件，没有 Windows 版本，这就导致我得在 Windows 上寻找其他的替代工具，来达到同样的目的。</p>
<p>先列一下我在 Windows 上写文章用到的工具：</p>
<ul>
<li>写作工具：Typora</li>
<li>图片上传工具：PicGo</li>
</ul>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>在 Windows 上使用 Markdown 格式来写文章，首先还是要解决<strong>图床</strong>的问题，这里我同样选择将图片上传到腾讯云。不过不像 MWeb 集成了图片上传功能，在 Windows 上传图片需要用到一个工具：<strong>PicGo</strong>。</p>
<p>PicGo，是一个开源免费的图片上传 + 管理工具，支持 macOS、Windows 和 Linux 系统。PicGo 配合我们等下要用到的写作工具 Typora，可以很方便地将图片上传到腾讯云图床上。</p>
<p>PicGo 下载链接：<br><em><a target="_blank" rel="noopener" href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></em></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512135204123.png" alt="image-20210512135204123"></p>
<p>看到这里，如果你还是有点稀里糊涂，可以将 PicGo 上传图片的过程，类比成你将本地的图片上传到 QQ 空间相册的操作，只不过我们上传的图片是存放在腾讯云、而非 QQ 空间上。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512135929312.png" alt="image-20210512135929312"></p>
<p>使用 PicGo 上传本地图片之前，需要先对 PicGo 进行设置：</p>
<p>点击 PicGo 左侧栏的图床设置，由于我想将图片存放到腾讯云，图床这里就选择「腾讯云 COS」，将 COS 版本的版本切换到 v5。</p>
<p>下面还有几个必须要配置的参数：</p>
<ul>
<li>SecretId</li>
<li>SecretKey</li>
<li>APPID</li>
<li>存储空间名</li>
<li>存储区域</li>
</ul>
<p>获取这些参数，需要在浏览器中打开腾讯云的官网：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/">https://cloud.tencent.com/</a>   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512140635868.png" alt="image-20210512140635868"></p>
<p>打开腾讯云登录账号之后，点击右上角的邮箱账号，选择「<strong>账号信息</strong>」，在打开的页面中，就可以看到 <strong>APPID</strong> 信息。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512141722265.png" alt="image-20210512141722265"></p>
<p>再次点击右上角的邮箱账号，选择「<strong>访问管理</strong>」，在打开的页面中，点击左侧栏的「访问密钥 &gt;&gt; API 密钥管理」，将页面中「<strong>SecretId</strong>」和「<strong>SecretKey</strong>」的值分别填入 PicGo 中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512145215009.png" alt="image-20210512145215009"></p>
<p>接着点击左上角的「云产品」，在弹出的面板中，选择「<strong>对象存储</strong>」，进入腾讯云图床的管理页面。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512142141761.png" alt="image-20210512142141761"></p>
<p>点击左侧的「存储桶列表」，可以看到自己创建的图床，对于首次使用腾讯云图床的朋友，需要点击「创建存储桶」，创建存放图片的图床。</p>
<p>创建存储桶时，需要注意的是，我们要将「访问权限」设置为「公有读私有写」，这里的「公有读」是为了之后你将图片链接用于文章中，别人可以看到图片的内容，而不是图片显示为已丢失，「私有写」则是说只有你才有上传图片或管理图床的权限。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512143147439.png" alt="image-20210512143147439"></p>
<p>创建好存储桶之后，回到存储桶列表的首页，「<strong>存储桶名称</strong>」的值就是 PicGo 中的<strong>存储名</strong>，「所属区域」下的「<strong>ap-地名拼音</strong>」对应 PicGo 就是 PicGo 中的<strong>存储区域</strong>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512142732590.png" alt="image-20210512142732590"></p>
<p>到这里，我们就完成了 PicGo 的配置，点击下方的「确定」按钮，桌面右下角会弹出「设置成功」的提示。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512145731492.png" alt="image-20210512145731492"></p>
<p>此时，你可以切换到 PicGo 左侧栏的「上传区」，将桌面的任意一张图片拖拽到中间的「上传区域」，如果桌面右下角弹出「上传成功」的通知，则说明我们已经将 PicGo 配置好了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512150257700.png" alt="image-20210512150257700"></p>
<p>PicGo 有两种上传图片的方式：</p>
<ul>
<li>拖拽图片到上传区域上传，或者使用「点击上传」打开本地文件夹、上传图片</li>
<li>读取系统剪贴板图片后上传图片</li>
</ul>
<p>第二种上传图片的方式，就是将图片复制到系统剪贴板之后，点击「剪贴板图片」或者使用快捷键 <strong>Ctrl + Shift + P</strong>，就可以将剪贴板的图片上传到腾讯云图床。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%B8%A4%E7%A7%8D%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F.png" alt="剪贴板两种上传方式"></p>
<p>但说实话，使用 PicGo 这两种上传图片的方式，对于想一气呵成写文章的人来说，还不够高效和优雅。</p>
<p>基于此，我们可以配合写作工具 Typora，借助其内置的「<strong>上传服务</strong>」功能，将添加到 Typora 中的图片<strong>自动上传到腾讯云图床</strong>，替代使用 PicGo 手动上传图片的流程。</p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>Typora，是一款开源免费的 Markdown 编辑器，支持 Windows、macOS 和 Linux 系统。Typora 的编辑界面非常简洁，就像是一张白纸（我将软件背景设置为了深色）一样。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512161747802.png" alt="image-20210512161747802"> </p>
<p>Typora 官网：<br><em><a target="_blank" rel="noopener" href="https://www.typora.io/">https://www.typora.io/</a></em></p>
<p>为了将我们在 Typora 编辑器中添加的图片自动上传到图床，我们需要对软件进行设置，点击左上角的「文件」，选择「偏好设置」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512162922041.png" alt="image-20210512162922041"></p>
<p>切换到「图像」选项卡，首先将顶部的「插入图片时」的「无特殊操作」更改为「上传图片」，即我们往 Typora 添加图片的同时，自动执行上传图片的操作。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512163837665.png" alt="image-20210512163837665"></p>
<p>接着勾选下方的两个选项——「对网络位置的图片应用」和「插入时自动转义图片 URL」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512163753994.png" alt="image-20210512163753994"></p>
<p>下面的<strong>上传服务</strong>选择「<strong>PicGo（app）</strong>」，PICGo 路径选择 PicGo 应用安装的位置。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512164010827.png" alt="image-20210512164010827"></p>
<p>完成这些设置之后，回到 Typora 的编辑界面，当你将电脑本地的图片拖拽到 Typora、或者往 Typora 粘贴剪贴板中的图片时，插入图片的同时，它就会自动上传到腾讯云图床，并返回图片对应的 Markdown 链接。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E7%9A%84%E5%90%8C%E6%97%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.gif" alt="添加图片的同时自动上传图片"></p>
<p>至此，借助 PicGo 和 Typora 的上传服务，我们在文章中添加的图片，就存放在我们自家的图床上。这样当你把在 Typora 中写好的内容粘贴到其他的内容平台时，就再也不会遇到粘贴过去图片丢失的问题了。</p>
<p>值得一提的是，写稿子的人最怕遇到的一件事情，可能是写到一半还没保存的文档一不小就丢失了，如果你想把 Typora 作为你的主力编辑器，记得<strong>先打开它的「自动保存」</strong>，预防扑街。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210512165707339.png" alt="image-20210512165707339"></p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「点赞&#x2F;在看」鼓励一下我，谢谢。</p>
<p>我的年度目标：公众号达到 1 万关注<br>目前进度 9086&#x2F;10000<br>需要得到你的支持<br>公众号千千万，在比特世界相遇也是一种缘分<br>还没关注的朋友，请点下面👇👇的卡片关注   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/04/27/gong-zhong-hao-xiao-lu-gong-ju-zhi-nan.png" alt="公众号：效率工具指南">   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/12/2021-5-12-workmate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/12/2021-5-12-workmate/" itemprop="url">相聚总是很短，离别总在眼前。</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-12T00:00:00+08:00">
                2021-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前有一回和水韬聊到，好像家庭背景不是很好的孩子，长大之后在做选择的时候，总会显得优柔寡断、不够爽快、包袱太多。</p>
<p>不像出身阔绰家庭的孩子，他们选择做一件事的时候，会更多地考虑自己当下的状态，这一刻爽或舒服就够了，他们不会太去忧愁说，如果现在这么任性，「明天」该怎么办？</p>
<p>比较巧的是，这位朋友和我，我们俩都属于前一种人。</p>
<p>而且，即便我不去忧愁，不去考虑那么多东西，身边的人可能也会催促你去忧愁，催促你紧张甚至是焦虑起来。</p>
<p>前面铺垫这么多，其实想说的还是职业上的选择。</p>
<p>今晚想了想，一份工作，要想让自己觉得很满意，除了看得见摸得着的钱💰，可能还受到这些因素的影响：</p>
<ul>
<li>是否认同你自己正在做的事情，或者说如果你变成一个消费者，你是否会购买自己公司的产品</li>
<li>是否能与同事建立良好的关系</li>
<li>是否认同或尊重与你一起共事的人</li>
<li>是否能从中获得满足感或者成就感</li>
<li>是否能让自己获得成长而不是单调地重复</li>
<li>是否拥有良好的企业文化</li>
</ul>
<p>工作三年，身边的人来了一茬，又走了一茬，其中有少数几个自己喜欢、觉得日后能成为朋友的同事，当得知 TA 们要离开的消息，心情总是会变得很低落。</p>
<p>对于 TA 们的离去，我似乎也没有什么好的办法，将他们挽留下来，因为我确实没办法，只能眼睁睁地看着 TA 们离去。</p>
<p>现实就是这么残忍：相聚总是很短，离别总在眼前。</p>
<p>和 TA 们一起共事的时光，没有发生过像职场剧或者宫斗剧那些恶心的事情，相处也很愉快。</p>
<p>在公司里，最开始我倾向于独立行动，下班后为了能有单车骑车回家，我选择了先回家再吃饭。</p>
<p>后来一位同事好几次问我下班后要不要一起吃饭，为了不显得不合群，我答应了。</p>
<p>连着和同事一起吃了几次饭之后，下饭后一起吃饭，好像就变成了约定俗成的事情。吃饭的间隙，我们会聊一些对方的八卦（感情经历）、游戏、最近在看的剧等等。</p>
<p>吃饭唠嗑的时候，才是我比较放松的时候，不想在办公室里那么拘谨，那种感觉，有点像是回到了学生时代、和朋友吃饭唠嗑的场景。</p>
<p>正因为这样，之前共事的时光，现在回想起来，不仅是周日晚上绞尽脑汁思考要写什么的苦恼，也有我们一起吃饭唠嗑、一起去白云山、一起去音乐节、一起做饭的快乐回忆，那些种种，才是更尤为珍贵的东西。</p>
<p>写这篇文章的过程中，我想到了一件事：希望未来有一天（可能是我们都退休的时候），能有机会重新聚到一起，讲述自己一路走来的各种事情，相遇的人会再重逢。</p>
<p>祝福你们。</p>
<p>音乐：<br>摩登兄弟刘宇宁 - 如约<br>杨宗纬 - 初爱<br>李健 - 温暖   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/10/2021/55-%E7%BA%AA%E5%BD%95%E7%89%87%E4%B8%AD%E5%9B%BD%E7%AC%AC%E5%85%AB%E9%9B%86%E5%BD%B1%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/2021/55-%E7%BA%AA%E5%BD%95%E7%89%87%E4%B8%AD%E5%9B%BD%E7%AC%AC%E5%85%AB%E9%9B%86%E5%BD%B1%E8%AF%84/" itemprop="url">纪录片《中国》第八集影评</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-10T18:00:00+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%A7%82%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">观点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>看了芒果 TV 纪录片《中国》第八集《融合》，写写点评吧。播出版其实是有另外的配音的，芒果台又另外请了很多明星单独给每一集配音，然后收费观看。所以说，要论营销还是芒果会玩。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/05/10/2021/55-%E7%BA%AA%E5%BD%95%E7%89%87%E4%B8%AD%E5%9B%BD%E7%AC%AC%E5%85%AB%E9%9B%86%E5%BD%B1%E8%AF%84/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/09/2021-5-9-pythoninstall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/2021-5-9-pythoninstall/" itemprop="url">学 Python 前的准备工作</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-09T10:00:00+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文不是广告，请不要因为你在朋友圈或许多公众号看到的 Python 课程文案&#x2F;广告，而也把本文误认为是一篇广告。</p>
<p>这只是我作为一名 Python 初学者写的一篇 Python 入坑前的准备工作的文章。</p>
<h2 id="为什么要学-Python？"><a href="#为什么要学-Python？" class="headerlink" title="为什么要学 Python？"></a>为什么要学 Python？</h2><p>做任何一件事之前，可能都会有无数个理由，但我目前还没想得特别清楚，可能包含下面一个或多个原因：</p>
<ul>
<li>想了解一下，这个语言真的有传说中的那么神奇吗？可以解放双手？可以让我们从繁琐枯燥的重复劳动中解放出来？</li>
<li>听说 Python 的学习曲线比较缓，比较适合无编程基础的人学？想来试试。</li>
<li>想知道，我学 Python 多久之后就会放弃？因为学 Python 之前，我还买过两门开发微信小程序的课程，学到一半没做出个啥就放弃了。</li>
<li>想着 100 天公众号日更即将结束（目前进度 74&#x2F;100），我想试试能不能坚持做别的事情 100 天看看？于是我选择了 Python。</li>
<li>觉得会用 Python 抓取自己想要的数据，这个行为本身就很「极客」。</li>
<li>最后一个理由：人生苦短，我选 Python。</li>
</ul>
<h2 id="选择哪个版本的-Python"><a href="#选择哪个版本的-Python" class="headerlink" title="选择哪个版本的 Python"></a>选择哪个版本的 Python</h2><p>这可能是初学者都会面临的问题，现如今 Python 分为 Python 2 和 Python 3 两个版本。</p>
<p>为方便之后使用各种第三方 Python 库，这里推荐安装 Python 3。</p>
<h2 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h2><p>一种比较简单的安装方式就是从官网下载安装包。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204828409010.jpg" alt="-w1517">Python 官网地址：<br><em><a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org/</a></em></p>
<p>对于 Mac 用户，还可以通过包管理工具 <strong>Homebrew</strong> 来安装 Python。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204829008263.jpg" alt="-w1517">Homebrew 官网地址：<br><em><a target="_blank" rel="noopener" href="https://brew.sh/index_zh-cn">https://brew.sh/index_zh-cn</a></em></p>
<p>不过用 Homebrew 之前，需要先安装 Homebrew。</p>
<p>关于 Homebrew 的安装，清华大学开源软件镜像站提供了安装的说明，但这份说明文档，对我这个编程门外汉来说，写得还是不够直白，所以就没参考下图介绍的安装方法。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204833576670.jpg" alt="-w1517">清华大学开源软件镜像站：<br><em><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></em></p>
<p>我参考了一位视频 Up 主提供的方法：</p>
<p>打开 Mac 的终端，输入 <code>xcode-select --install</code> 安装 Xcode 的命令行工具。</p>
<p>输入之后，它会询问你是否安装 Xcode 命令行工具，选择安装之后等待完成下载。</p>
<p>注：这里其实我也不知道安装了这个 Xcode 命令行工具能干啥，我只知道 Xcode 是苹果官方推出的 IDE 工具，如果你想开发 iOS App 的话，应该离不开它。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203911851823.jpg" alt="-w1117">安装好 Xcode 命令行工具之后，我们接着就可以来安装 Homebrew 了。</p>
<p>Homebrew 官方提供的文件存放在 GitHub 仓库上，由于某些特殊的原因，从 GitHub 仓库下载 Homebrew 非常费劲，需要使用木弟子才能提高下载速度。</p>
<p>这里推荐使用<strong>国内的 Homebrew 镜像源</strong>来安装 Homebrew，下图是这位 Up 主基于清华大学的镜像仓库制作的安装 Homebrew 的命令行：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204826102268.jpg" alt="-w1552">Homebrew install 项目地址：<br><em><a target="_blank" rel="noopener" href="https://gitee.com/iamhefang/homebrew-install">https://gitee.com/iamhefang/homebrew-install</a></em></p>
<p>在终端中输入如下的命令，接着输入电脑开机密码，就能开始 Homebrew 的安装啦：</p>
<p><code>/bin/bash -c &quot;$(curl -fsSL https://gitee.com/iamhefang/homebrew-install/raw/master/install.sh)&quot;</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203917754742.jpg" alt="-w1117">Homebrew 的文件比较大，安装的过程需要等待比较长的时间，需要耐心，当它完成安装的时候，你可以在终端看到「Installation successful」的提示。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203921686037.jpg" alt="-w1117">初次使用 Homebrew，你可以遵照软件的提示，在终端中输入 <code>brew help</code> 来查看 Homebrew 的帮助文件。  </p>
<p>帮助文件中提供了一些例子供我们参考，如下图的命令 <code>brew install FORMULA|CASK…</code> 就是我们等会安装 Python 需要用到的。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203924282234.jpg" alt="-w1117">安装好 Homebrew 之后，我们就可以通过 Homebrew 来安装 Python 了。</p>
<p>在终端中输入 <code>brew install python3</code>，按下回车键，等待 Python3 完成安装。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203930295687.jpg" alt="-w1270">安装好 Python3 之后，为了确认 Python3 已经安装到电脑上了，我们可以在终端中输入命令 <code>python3</code>，按下回车。</p>
<p>下方如果返回 Python3 的版本，例如我安装的 Python 版本是 3.9.4 ，则说明 Python 真的安装好啦。</p>
<p>顺带一提，在终端中运行 <code>python3</code> 会进入 Python 的解释环境，最下方的三个连续的大于号 <code>&gt;&gt;&gt;</code>，就代表我们当前已经进入了 Python 的解释器。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16203932177900.jpg" alt="-w1270">此时，如果我们可以输入许多程序员刚学一门新语言时会用到的一句代码 <code>print(&#39;Hello world&#39;)</code>，下方就会返回 <code>Hello world</code>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204840244154.jpg" alt="-w1086"></p>
<h2 id="写-Python-代码的工具"><a href="#写-Python-代码的工具" class="headerlink" title="写 Python 代码的工具"></a>写 Python 代码的工具</h2><p>上面介绍的系统自带的终端，虽然可以作为写 Python 代码的工具，但存在不少缺点，例如不够高效，不会自动补全代码，不会有代码提示……</p>
<p>本着「懒就是第一生产力」的原则，我们可以选择其他更合适的工具，例如 <strong>PyCharm</strong>，来作为写 Python 代码的工具。</p>
<p>PyCharm 分为两个版本，一个是社区版，一个是专业版，社区版可免费使用，这对初学者来说也已经够用啦。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204844040829.jpg" alt="-w1552">PyCharm 官网下载地址：<br><a target="_blank" rel="noopener" href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></p>
<p>顺便一提，如果你是在校学生，可以在 PyCharm 官网以学生身份免费申请使用 PyCharm 专业版。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/16204841660100.jpg" alt="-w1552">学生授权申请方式链接：<br><em><a target="_blank" rel="noopener" href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369">https://sales.jetbrains.com/hc/zh-cn/articles/207154369</a></em></p>
<p>以上，就是本次想和你分享的内容。<br>希望对想学 Python 的朋友有帮助。</p>
<p>下回看看能不能给各位一些 Python 学习的教程哈哈哈哈，不🐦的话。</p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>更多精彩内容，欢迎关注我的个人公众号「效率工具指南」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/08/gong-zhong-hao-xiao-lu-gong-ju-zhi-nan.png" alt="公众号：效率工具指南"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/08/2021-5-8-birthday/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/08/2021-5-8-birthday/" itemprop="url">生日快乐，何老师</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-08T00:00:00+08:00">
                2021-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天是何老师 23 岁的生日，先祝何老师生日快乐。</p>
<p>刚认识她的时候，看到她的自我介绍，里面写了「金牛座」，后来逐渐熟悉之后，才确切地知道她的生日🎂。</p>
<p>她的生日很好记，508，记起来就像宿舍的房间号一样好记🤦‍♂️。</p>
<p>之前有两个朋友问过我类似的问题，说：为啥没有见到我在朋友圈发何老师的照片。</p>
<p>以前上大学的时候，我很羡慕那些有对象的朋友，有些会在不定时在朋友圈「秀恩爱」、「撒狗粮」。</p>
<p>看到他们那种行为，我也会禁不住幻想：啥时候我也可以在朋友圈里秀一会恩爱呢？</p>
<p>刚和何老师确定关系的时候，我也有想过要不要在朋友圈发一下照片，发的话还要想一句不落俗套的文案。</p>
<p>其实，在还没确定关系的时候，那时我在看一档综艺，临时想到了一句文案，不过最终还是没发出来，只留在了我的滴答清单里。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/07/16203950068775.jpg" alt="-w503">可能是过了以前那个年纪，心态不一样，觉得两个人相处得如何，不需要暴露在别人面前，或者是自己还活得太拧巴、太在意别人的看法，于是就没有在朋友圈发你的照片，希望你不要太介意。</p>
<p>说说我们相处下来让我比较开心或者印象深刻的事情吧：</p>
<h2 id="何老师给我的惊喜"><a href="#何老师给我的惊喜" class="headerlink" title="何老师给我的惊喜"></a>何老师给我的惊喜</h2><p>有一回我周六要上班，何老师在微信上跟我说「晚上要和朋友约饭」，但没具体说和谁，也没和朋友提前说好要吃什么。</p>
<p>后来下班准备去吃饭的时候，接到她的电话，还听到她专门录的广州地铁的提示音「本次列车开往天河客运站」，才意识到她偷偷从深圳跑过来广州、来接我下班了😭</p>
<p>没想到我之前随口开玩笑和她说的，「什么时候能来接我下班呢？」，真的变成了现实，她也放到了心上。</p>
<h2 id="何老师喜欢画画"><a href="#何老师喜欢画画" class="headerlink" title="何老师喜欢画画"></a>何老师喜欢画画</h2><p>何老师喜欢画画，最近疯狂画画，有一周画了 4 张画，真棒👍。比起打字，画画需要耐心以及更多的时间，我真是在偷懒🤦‍♂️。</p>
<p>何老师在老家养了一只雪纳瑞，名字叫瑞瑞，她给她花了一幅画（瑞瑞是女孩子👧）：</p>
<p>我见过瑞瑞的照片，这幅画和写真照一模一样，尤其那两个炯炯有神的大眼睛👀哈哈哈哈</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/07/img7251.jpg" alt="IMG_7251"></p>
<h2 id="何老师做的让我觉得很好笑的事情"><a href="#何老师做的让我觉得很好笑的事情" class="headerlink" title="何老师做的让我觉得很好笑的事情"></a>何老师做的让我觉得很好笑的事情</h2><p>有两回在何老师家，我们商量好在家做饭，不去外面吃。</p>
<p>每次想看看买什么菜之前，何老师的第一反应不是打开美团或者京东生鲜，她的第一反应是打开 B 站，先看看美食区 Up 主都在做什么好吃的😋，再决定买什么菜。</p>
<p>我：？？？</p>
<p>第一次见到这种操作——现学现做——哈哈哈哈，我觉得很好笑。</p>
<p>我的想法是，做饭从简单的开始就好、按自己以往知道的菜的做法做就好了。</p>
<p>她偏不，她说每次做饭都要挑战一下做新菜，她做过的菜有：芝士虾仁、咖喱鸡……</p>
<p>虽然这是何老师第一次做的菜，但我尝起来觉得味道不错，于是也只能认输了😂。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/07/getimgdata.gif" alt="getimgdata"></p>
<p>而且，我们之前在外面吃了不少次，工作日也都是各自在外面吃，周末有时间在家自己做饭换一下口味，对工作党来说，已经是一种莫大的幸福了。</p>
<h2 id="何老师给我普及了不少知识"><a href="#何老师给我普及了不少知识" class="headerlink" title="何老师给我普及了不少知识"></a>何老师给我普及了不少知识</h2><p>何老师喜欢看各种科普，比如看丁香医生、看果壳网、看一些 B 站 Up 主的视频，例如那个尺度稍微有些大、又很搞笑的 Up 主 @Vivi可爱多。</p>
<p>看到有意思的东西，她都会转发给我，异地恋少了一些陪伴或者面对面的接触或互动，彼此之间转发的内容，有时也可以打开我们的话匣子，作为聊天的话题。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/07/16203970948837.jpg" alt="-w1517"></p>
<h2 id="何老师送给我的生日礼物"><a href="#何老师送给我的生日礼物" class="headerlink" title="何老师送给我的生日礼物"></a>何老师送给我的生日礼物</h2><p>去年我生日的时候，我们还没在一起，不过何老师也送了一个让我意外的礼物：</p>
<p>她唱了一首歌送给我哈哈哈哈，这里就不放她唱的了，放一下原唱吧：</p>
<p><a target="_blank" rel="noopener" href="https://music.163.com/#/song?id=1365898499">音乐 - 失眠飞行</a>   </p>
<p>祝何老师生日快乐，因为有了你，我的生活也变得可爱起来了：</p>
<p>每天和你以「宝宝」互相称呼对方，语言真的有魔力，每天和一个可爱的人聊天，瞬间也觉得自己变得可爱起来了。</p>
<p>感谢你，我爱你。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/07/16204014798699.jpg" alt="-w768"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/05/2021-5-5-weblog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/05/2021-5-5-weblog/" itemprop="url">运营微信公众号的工具集</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-05T00:00:00+08:00">
                2021-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>今天写一篇我在做这个公众号的过程中，经常会用到的一些工具，希望对正在做公众号、或者准备开始做公众号的朋友有帮助。</p>
<h2 id="微信公众号-X-小程序助手"><a href="#微信公众号-X-小程序助手" class="headerlink" title="微信公众号 X 小程序助手"></a>微信公众号 X 小程序助手</h2><p>这个是我很早之前就收藏的一个工具，但直到昨天，才第一次在公众号中使用。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202205504662.jpg" alt="-w1452"></p>
<p>它可以简化在公众号文章中插入各类小程序的流程，以插入来自 B 站小程序的视频为例，默认的插入方式需要按照下图的两个步骤，获取小程序路径，才能在文章中插入 B 站视频。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202207913715.jpg" alt="-w1079"></p>
<p>而这个工具简化了这个流程，只需要将你想添加的 B 站视频的网页链接粘贴到下方，它就会生成小程序跳转的地址（小程序路径），<strong>一步到位</strong>，不需要按照官方提供的流程分成两步操作。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202209788138.jpg" alt="-w1452"></p>
<p>微信公众号 X 小程序助手：<br><em><a target="_blank" rel="noopener" href="https://www.wxmarkdown.com/">https://www.wxmarkdown.com/</a></em></p>
<h2 id="qrbtf-参数化二维码生成器"><a href="#qrbtf-参数化二维码生成器" class="headerlink" title="qrbtf 参数化二维码生成器"></a>qrbtf 参数化二维码生成器</h2><p>我在过往文章中用到的简约好看的二维码，都是使用这个网站生成的。</p>
<p>它有两种生成二维码的方式，一种是上传原始的、丑陋的二维码，另一种是粘贴网址。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202212118607.jpg" alt="-w1435"></p>
<p>对于生成的二维码，它提化了三种下载格式：PNG、JPG 和 SVG。</p>
<p>如果你刚好是一名设计师，会使用矢量设计软件 Adobe illustrator，可以对生成的 SVG 格式的二维码作进一步的改造。</p>
<p>qrbtf 参数化二维码生成器网址：<br><em><a target="_blank" rel="noopener" href="https://qrbtf.com/">https://qrbtf.com/</a></em></p>
<h2 id="泥石流海报生成器"><a href="#泥石流海报生成器" class="headerlink" title="泥石流海报生成器"></a>泥石流海报生成器</h2><p>如果你觉得上面生成的二维码高端过头了，不太符合自己的风格，那么可以试试下面这一款二维码生成器——泥石流海报生成器。  </p>
<p>这个生成器生成的图片示例如下，完美符合许多不懂设计的人口中经常说的：「海报字要大」。</p>
<p>相比上面的 qrbtf，这个生成器生成的图片可以添加更多的<strong>附加信息</strong>，给未扫码的人提前预告一下扫码之后可能会看到的内容。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/ad48d5ee24a85d98495dc681d0d5ad9f.png" alt="ad48d5ee24a85d98495dc681d0d5ad9f"></p>
<p>如果你不喜欢上图这种看起来比较商务的蓝色，没关系，这个工具还有不少其他的颜色供你选择。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202220551931.jpg" alt="-w1435"></p>
<p>泥石流海报生成器：<br><em><a target="_blank" rel="noopener" href="https://graph.readhub.cn/">https://graph.readhub.cn/</a></em></p>
<h2 id="蓝奏云"><a href="#蓝奏云" class="headerlink" title="蓝奏云"></a>蓝奏云</h2><p>一个用来上传各类小于 100 M 的文件分享工具，上传下载不限速。</p>
<p>之所以要用到这个，是因为有时介绍的一些软件，打开它们的官网需要用到木弟子，不方便没有条件访问的朋友下载，我就会将下载下来的安装包上传到蓝奏云，分享出来作为备用链接。</p>
<p>使用蓝奏云还有一个好处在于，它可以在分享的文件下方添加一个「文字描述」，方便我宣传一下自己的公众号。</p>
<p>虽然我平时也羞于向别人推荐我自己的公众号，但如果在这种地方都不敢去宣传自己，那也不要指望谁能帮自己张罗了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202225216956.jpg" alt="-w1435"></p>
<h2 id="Emojityper"><a href="#Emojityper" class="headerlink" title="Emojityper"></a>Emojityper</h2><p>Emojityper，是一个非常有意思的 Emoji 网站，只要输入你想用的 Emoji 对应的英文，例如下图的 computer，它就会返回文本对应的 Emoji，听起来是不是有点绕呢？</p>
<p>说得直白一点，这个在线网站就是一个 <strong>Emoji 搜索工具</strong>，可以很方便地搜索到你想使用的 Emoji 表情。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/05/16202228838725.jpg" alt="-w1569"></p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「点赞&#x2F;在看」鼓励一下我，谢谢。</p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>我的年度目标：公众号达到 1 万关注<br>需要得到你的支持<br>公众号千千万，在比特世界相遇也是一种缘分<br>还没关注的朋友，请点下面👇👇的卡片关注     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/04/27/gong-zhong-hao-xiao-lu-gong-ju-zhi-nan.png" alt="公众号：效率工具指南">   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/05/03/%E5%81%87%E5%A6%82%E6%97%B6%E9%97%B4%E6%9C%89%E6%B8%A9%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/03/%E5%81%87%E5%A6%82%E6%97%B6%E9%97%B4%E6%9C%89%E6%B8%A9%E5%BA%A6/" itemprop="url">假如时间有温度</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-03T14:00:41+08:00">
                2021-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我一直在想，世事无常，该是一种什么样的感觉。直到我读到夏目先生的《我是猫》，先生在书中不无感慨地写道，“<strong>世事变迁就像猫的眼珠一样变幻莫测</strong>”。可此时此刻，我会不由得觉得，世事无常，更像是时间突然间有了温度，“<strong>春观夜樱，夏望繁星，秋赏满月，冬会初雪</strong>”，拥有这般温度的时间毫无疑问是浪漫的，可世事无常所带来的时间的温度，更像是某种意义上的极致，譬如从地球两极瞬移到赤道，或者是一场大爆炸后突兀着的宁静。也许，四季还是那个四季，无非是我一厢情愿的自以为是，时间真的有温度吗？</p>
<p>这次终于可以乘坐高铁回家，可当列车以每小时 250 公里的速度呼啸而过时，我已来不及仔细留意车窗外的风景。我隐隐约约地觉得，外面的山丘变得平缓，时不时穿过漆黑悠长的隧道，平原上点缀着麦田和葡萄架，等到列车横跨着黄河驶过的时候，我终于确信我回到了故乡。而我不得不说，人生的境遇里实在有太多的似曾相识，正如此刻窗外的风，兀自呼啸着撼动着那棵我自小便认识的树。回家后收到的第一个消息是，家族中一位叔叔的儿子，在工作时不慎从高处摔落下来，送到医院以后终于还是没能抢救过来，听长辈们讲，彼时他们正在参加某个人的婚礼，一时间百感交集。</p>
<p>可以说，这是我这么多年来，第一次以一个成年人的身份去面对一个人的离开。因为逝者与我为同一辈人，所以于情于理我都要去吊唁一番。于是，快三十岁的人，第一次有了买花圈、写挽联的经历，甚至我在去见这位叔叔的时候，在脑海中浮现了多次的“还请您节哀顺变”，终于还是没能说出口来。或许是因为事出突然，有太多的身后事需要料理，留给悲伤的时间并不多。在逝者面前焚香、叩拜、鞠躬，虽然有长辈从旁指点，可整套动作还是显得有点僵硬。我终于还是想起来，这个只有 27 岁的年轻人，在我某次回家探亲的时候，自顾自走上前来，面带微笑的自我介绍道，“我是某某某，你不认得我了吗？”</p>
<p>有时候想想，我喜欢怀旧，喜欢念念不忘，或许就是因为我怕，怕生命中每一次告别都是永诀。同样可以认为是第一次的，也许是公墓，是陵园，这种从前只有在电视上见到过的东西。于是，在夕阳的映照下，半边天空被染成金黄色，而在这一片荒凉中，一座六角形的塔静静地矗立着。站在一个高坡上一眼望去，满眼都是密密麻麻的墓碑。我在想，有一天人们会不会建成更加极致的地下宫殿，就如同城市中越来越多的高楼大厦一样，唯一的不同，或许是那具比单人床还要小一点的棺木，或者是和小酒坛差不多大的骨灰盒。独自站在旷野中，风吹着塔角的铃铛不时发出响声，我敲击不锈钢柱子时，它竟然发出了沉钟一般的轰鸣，难道人真的有灵魂吗？</p>
<p>对于死亡，从小到大，我着实经历了不少，小学时爷爷去世，中学时有位同学被歹人杀害，大学时有位同学患白血病不治而亡，工作以后有一位同事因意外而溺水身亡……有时候想想，虽然我的人生，可能并不如别人那般精彩绝伦，可比起失去生命的他们，我能见到更多的人，见到更多的事情，这实在是幸运中的幸运。可或许是因为故事的视角发生了改变，所以，此刻比往常有了更多不由分说的感慨，就好像从前的我，虽然一样是某个事件的亲历者，但那时的我，还不大懂得死亡的意义，都说是人死灯灭，可只有你自己知道，一旦别人彻底地忘记了你，忘记了你在这世上的故事，你就大概的确真的死了罢！我们终其一生，不论记忆以文字还是影像的形式存在，所求者不过是记住别人和被别人记住，人生如朝露也好，如雪泥鸿爪也罢，也许，珍惜此时此刻，方能无惧参商永隔的痛苦吧……</p>
<p>很多年前，作为长孙的我，举着高过我头顶的引魂幡走在前面，风裹挟着引魂幡的纸穗呼呼作响，那时，我还不知道再也见不到一个人，将会是多么难过的一件事情。后来，我偶尔会回想起，夏天做完农活回来，坐在凉席上吃西瓜的情形，就是在那个时候，爷爷开始埋怨头上有白头发，而我则被拉去帮爷爷找白头发。再后来，我偶尔会想有个人帮我找白头发，可明明我还没到三十岁啊，直到我看到三叔后脑勺开始变白，我终于惊觉，这是二十年前的事情了。有时候想想，我人生中最美好的那几年，同这二十年的长度相比，何尝不是沧海一粟呢？人生时常如此，你觉得几十年特别漫长，可二十年你还不是就这样“弹指一挥间”，而人生又特别短暂，短暂到我们怕这次见了就再见不着彼此。这样想来，拉黑或者删除一个人，成本简直低廉到无法想象，因为失去得太容易，大家就不会有这种看似突兀的想法。浮生倥偬，失散在风里的是沙，而失散在水里的是萍，失散的人们，会有引魂幡前来招魂，然后各自相认吗？</p>
<p>所以，时间有温度吗？我想，该是有的，因为我们会在时间的长河里放下一盏浮灯，它承载着我们记忆深处最温暖的回忆。可也许这只是我们的一厢情愿，时间自顾自地往前走，从来不在乎人的记忆到底如何，就如同窗外呼啸而过的风，它并不懂得人类内心深处的那些情感，所以，更多的时候，我以为，时间是没有温度的，是冰冷的，是荒凉的，就像我在陵园里看到的夕阳一般冰冷，即使它被晚霞映得金黄。有时候，我会期待时间走得稍微慢一点，出于我的自私，我希望我此刻爱着的、曾经爱过的人们，都能老去地稍微慢一点，因为我怕再见不到那个人，因为我怕时间凝固成冰，因为我怕我终有一天要忘记，因为我怕我永远都赶不上时间，这或许是我想在此时此刻赋予时间的温度，如同人的正常体温 37 度，或许，它是如此的平静甚至是普通，可是啊，活着真的很好啊。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/79/">79</a><a class="extend next" rel="next" href="/page/16/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1579</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
