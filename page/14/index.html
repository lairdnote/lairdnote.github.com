<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/14/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/14/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E5%A4%95%E9%9B%BE%E8%8A%B1%E5%9B%AD%EF%BC%9A%E4%BB%8E%E5%BB%BA%E7%AD%91%E4%B8%AD%E8%AF%BB%E5%87%BA%E7%9A%84%E7%88%B1%E6%83%85%E5%92%8C%E7%BE%8E%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E5%A4%95%E9%9B%BE%E8%8A%B1%E5%9B%AD%EF%BC%9A%E4%BB%8E%E5%BB%BA%E7%AD%91%E4%B8%AD%E8%AF%BB%E5%87%BA%E7%9A%84%E7%88%B1%E6%83%85%E5%92%8C%E7%BE%8E%E5%AD%A6/" itemprop="url">夕雾花园：从建筑中读出的爱情和美学</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-26T01:13:32+00:00">
                2021-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>“古巴比伦王颁布了汉谟拉比法典，刻在黑色的玄武岩，距今已经三千七百多年”。多年以前，周杰伦在 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vx411G7Aj/">《爱在西元前》</a> 里这样喃喃道，古巴比伦、楔形文字、玄武岩石板、底格里斯河、汉谟拉比法典……千年以后，一切已无法考据，这些如图腾符号一般神秘的意象，留给后人的只有无限的遐想。据传，公元前 6 世纪，新巴比伦国王尼布甲尼撒二世，迎娶了米底的公主安美依迪丝为王后。公主美丽可人，深受国王宠爱，可没过多久，公主就因为思念家乡而满怀愁绪。为此，国王召集工匠依照米底山区的景致修建了空中花园。最终，这座被誉为“古代七大奇迹”之一的神秘建筑，凭借它巧夺天工的园林景色俘获了公主的欢心。当空中花园渐渐淹没在滚滚黄沙里，这段无人知晓的爱，大概会被永远淹没在史书文卷，直到一个叫做方文山的词人发现它，然后写出来。在几乎同时代的周朝，周幽王烽火戏诸侯，只为博褒姒一笑。故事总是相似的，只是我们更愿意相信，那就是爱。</p>
<p><img src="https://i.loli.net/2021/08/27/vL3PmCX9TUfuqN1.jpg" alt="巴比伦“空中花园”"></p>
<p>在更为久远的公元前 4 世纪，彼时庞贝城刚刚开始兴建。这个背靠地中海的小渔村，依托着天然的港口优势，在短短几十年里，逐渐成为仅次于意大利古罗马城的第二大城市。它北距罗马 300 千米，西接著名的西西里岛，南通希腊与北非，有着丝毫不亚于古罗马的斗兽场、太阳神神庙、大剧院、巫师堂、蒸汽浴室、商铺以及娱乐场所，吸引了无数来自周中海周边城邦的贵族和富商。庞贝城以北，有一座维苏威火山，这座活火山千年来一直在不断喷发，甚至庞贝古城本身就是建筑在硬化的火山熔岩上面。公元 62 年 2 月 8 日，一次强烈的地震令庞贝古城中的大量建筑塌毁，人们重建了庞贝古城，比以前更加追求奢侈豪华。历史定格在公元 79 年 8 月 24 日这一天，维苏威火山突然爆发，厚约 6 米的火山灰完全将这座城市从地球上抹去。<a target="_blank" rel="noopener" href="https://music.163.com/#/song?id=1842802205">许嵩</a> 对此发问，“如果火山喷发，是灾难还是壮美？”。也许，在那一瞬间，真的有人攥着新鲜的玫瑰，准备向喜欢的人求爱。火山喷发的刹那，庞贝是一颗千年的琥珀，时间自此被凝固和封印。</p>
<p><img src="https://i.loli.net/2021/08/27/bte7TPhu15aErHv.jpg" alt="重见天日的庞贝古城"></p>
<p>不管是神秘莫测的空中花园，还是重见天日的庞贝古城，某种程度上，我们更愿意相信，那些亦真亦假的美丽传说。也许，这是因为它比建筑本身更具有说服力。因此，巴黎圣母院有过卡西莫多与艾丝梅拉达的故事，沧浪亭有过<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1088581/">《浮生六记》</a>里的伉俪情深，泰姬陵有过沙·贾汗的一夜白头，布达拉宫有过松赞干布和文成公主的相敬如宾，埃菲尔铁塔有过古斯塔夫·埃菲尔的望眼欲穿……世上以爱为名的建筑不在少数，或为古堡、或为陵墓、或为高塔、或为教堂……即使随着时间的流逝，建筑会褪去自身的光芒，而透过这些故事所折射出的爱情的光华，则永远不会褪去，还有什么比历经风雨洗礼的建筑更能表达爱的深沉呢？电影 <a target="_blank" rel="noopener" href="https://movie.douban.com/subject/30238379/">《夕雾花园》</a> 同样讲述了一个关于建筑的故事，假如园林艺术可以当做一种建筑的话。于是，爱情、战争、艺术、救赎、悬疑……种种元素交织在一起，像极了这座园林里一草一木、一砖一瓦。透过石头和木头，去打量某段扑朔迷离的历史，这本身就是一种『借景』，谁还能记得起，在兴庆宫的花萼相辉楼，李白曾经写过某一首诗呢？</p>
<p><img src="https://i.loli.net/2021/08/27/D2mPAnxp3Zlo6hv.jpg" alt="从一方天地中借景"></p>
<p>妹妹云红，年轻时曾和姐姐云林一起前往日本旅行，并在那里见到了日式庭院，自此在心里埋下了一份庭院情结。后来，日本发动对马来西亚的侵略战争，姐妹俩被抓到同一个集中营里。姐姐云林，白天目睹日军对妹妹的暴行，夜晚聆听妹妹对日本园林的畅想。此时此刻，人生的苦难与艺术的理想，像极了一幅太极图，互不相溶而又紧紧相依。再后来，姐姐死里逃生，而妹妹却命丧矿井。带着这份深深的内疚感，云林决心替妹妹建造一座日式园林。就这样，女主结识了日本皇家园艺师中村有朋。中村并没有接受女主的园艺委托，而是让女主参与夕雾花园的修建工作，正是在这个过程中，中村教给了云林『借景』的智慧，所谓『借景』，是指在一个视觉范围内，借由远方的山，眼前的树，天上的云与雾，呼应人工打造的花园，创造出浑然天成的自然框景。所以，对于这个电影而言，云林是从过往的美好回忆、未来的无限期许中借景；中村是从和云林的相处中借景；导演是从时间、氛围、景致、阅历中借景。由此，云林和中村互相实现了自我救赎，云林能放下过去的执念努力生活下去，中村能够放下国家战争的罪恶感潜心钻研园艺，而我们能有幸看到这样一个故事。</p>
<p><img src="https://i.loli.net/2021/08/27/Fv8x1ObSHcuiX2w.jpg" alt="回忆中可爱的妹妹"></p>
<p>如果单纯用爱情来定义这部电影，显然是狭隘而片面的，因为我认为它表达了某种关乎艺术、心灵的东西。从无印良品到优衣库，日式的美学，始终让人联想到侘寂或者无用这样的字眼，甚至连同今年的东京奥运会开幕式，都被人们吐槽充满了阴间的味道。对于云林而言，中村是一个侵略者的身份，不管他是不是日军的间谍，不管他是不是知道集中营的位置，因为他们国家的铁蹄踏入自己的家园，亲人因此而走向毁灭，这是不折不扣的事实。可天使和魔鬼谁又真正分得清楚呢？云林曾经这样问妹妹云红，“日本人这样对待我们，为何你还喜欢他们的庭园”，云红说，“我爱的是花园，而不是建造它的人”。所以，对我而言，这部电影的基调是残酷而又不乏温柔的，战争带给人们的伤痛是真实而残酷的，而实现一种心灵层面上的宁静、尊重自然、尊重生命则是平静而温柔的。日式庭院，在战争时期对人们而言是毫无用处的，甚至修建这样一座庭院并不能让妹妹活过来，可正是这样一份来自侵略者国度的艺术理想，支撑着姐妹俩熬过那些人生中至暗的时刻。</p>
<p><img src="https://i.loli.net/2021/08/27/jl9D7bTKYJGMXIH.jpg" alt="我们活在疯狂的世界"></p>
<p>透过云林被汗水浸透的衣服，中村第一次看见她背上的鞭痕，中村说，从那一刻开始，他就想为眼前的这个女人负责。刺青、折纸、浮世绘，这些非常日系的意象，仿佛故事里纠缠的线索一般，无一不在告诉观众，这是个谜一般的男人。正因为如此，他只能在隐秘的森林深处消失不见，恰如这个故事本身充满冲突和对立，只能选择戛然而止。有时候我会问自己，不能在当下验证和确认的爱，是否就要因此而阻断，甚至遥遥无期直至搁浅。我只知道，电影里是这样处理的，中村以一种私密而残忍的方式，将他对云林的爱，一针一针地钉在她的身上，那片由鞭痕演变而来的刺青。多年以后，经历过时间濯洗的云林，战争带给她的伤痛早已烟消云散，她终于能读懂那个男人的良苦用心。可正如那些被她扯下的折纸一般，当她像从前一样站在门口，凝视着这框架里嵌入的一方天地、一草一木、一花一叶，完成一次『借景』，可那个人此刻又在哪里呢？如果爱上一个来自侵略者国家的人，这样的爱算不算对妹妹、对战争带来的伤痛的背叛？而如果向殖民地的女人吐露国家的秘密，这样的爱又是否是对国家的背叛？年轻时，我们总以为爱情是奋不顾身，可爱与不爱，一个人说了不算啊……</p>
<p><img src="https://i.loli.net/2021/08/27/Ygl9JcErsHGD3SF.jpg" alt="林深不见“中村”"></p>
<p>回过头看历史的时候，我们总以为“奋六世之余烈”的大秦帝国，理应是正义的一方，因为历史常常由赢家来书写，一旦你赢了，你怎么说都行，因为后人并不关心真相。一如历史上古罗马帝国横跨亚、欧、非三块大陆，蒙古帝国全盛时期版图甚至辐射到波兰，英国皇家海军一度在海上建立起“日不落”帝国……再后来，人们只记住了联合国五常，我们本以为这个世界不会再有战争，可塔利班还是在阿富汗打了起来。我不认为，战争与伤痛，就只能带来仇恨，就像朝鲜与韩国、印度和巴基斯坦，可能在我们有生之年都不会迎来和解，如果战争不能让人意识到爱与和平的珍贵，相反，它深化了人们内心的仇恨与愤怒，我以为，这才是对那些因为战争而死去的人的辜负和背叛。所以，身处乱世，一座庭院或者建筑，其本身是一种侘寂之美、无用之美，却能在痛苦与艰难中为内心寻得一处安宁，而这正是我看完 <a target="_blank" rel="noopener" href="https://movie.douban.com/subject/30238379/">《夕雾花园》</a> 后想表达的一种观点。无论爱在西元前还是西元后，站在庞贝古城前的你我，是否可以从此刻启程，回到人物饱满、情节充沛的某个瞬间，那一年，汉谟拉比用楔形文字刻下第一部法典，我静静地看着你，完全没想过防卫，拥抱的刹那，庞贝古城仿佛从未消失过一样……</p>
<p><img src="https://i.loli.net/2021/08/27/IpXbBhykijmU1t2.jpg" alt="彼岸浮灯"></p>
<p>这世间的有些废墟相当壮观，而我对它们曾经的丰功伟绩知之甚少；这世间的有些故居格外亲切，而它们的主人对于历史进程的影响微乎其微。中国传统文学中的抒情主题，占比最多的怀古之情、兴亡之叹，所以，陈子昂登幽州台，发出前无古人、后无来者的慷慨悲歌；苏东坡赤壁遨游，感慨人生如梦，一樽还酹江月；辛弃疾登京口北固亭，梦回金戈铁马，气吞万里如虎……可能，从废墟中寻找某种感同身受的历史幻想，这才是中国文人群体如同着魔一般的集体症候，而将这一现象延伸到更大的世界，也许，全人类都是这样。谁能说刺客信条系列游戏，不是将人类几千年的历史，放在 Animus 这样一个沉浸式的 VR 设备中重新演绎呢？当艾吉欧·奥迪托雷漫步在古罗马的街道，人们总会不由自主地想到，凯撒在长老院遇刺身死、古罗马斗兽场里的三千斯巴达勇士……罗马不是一天建成的，而条条大路通罗马，这种由废墟而产生的莫名的情结，始终萦绕在人们的心头，帕特农神庙、圆明园、庞贝古城、乞力马扎罗雪山……世间有太多的风景，还未来得及亲眼去看就已经消失不见，无论是天然的景致，还是人造的景观，其实和人类本身一样，都要面临消逝的结局，唯一的不同的是，在时间尺度上它们显得更为永恒一点，相比六十年产权的现代化住宅，我还是更喜欢，这些废墟里慢悠悠地流淌着的故事。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E4%BD%BF%E7%94%A8%20Python%20%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E9%98%B2%E7%96%AB%E5%81%A5%E5%BA%B7%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E4%BD%BF%E7%94%A8%20Python%20%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E9%98%B2%E7%96%AB%E5%81%A5%E5%BA%B7%E7%A0%81/" itemprop="url">使用 Python 自动识别防疫健康码</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-19T06:13:32+00:00">
                2021-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>这个月月初的时候，朋友兴奋地和我描述着他的计划——准备带孩子到宁夏自驾游。朋友感慨道，“小孩只在书本上见过黄河、见过沙漠，这样的人生多少有一点遗憾”，可正如新冠病毒会变异为德尔塔一样，生活里唯一不变的变化本身，局部地区疫情卷土重来，朋友为了孩子的健康着想，不得不取消这次计划，因为他原本就想去宁夏看看的。回想过去这一年多，口罩和二维码，是每天打交道最多的东西。也许，这会成为未来几年里的常态。在西安，不管是坐公交还是地铁，都会有人去检查防疫二维码，甚至由此而创造了不少的工作岗位。每次看到那些年轻人，我都有种失落感，因为二十九岁高龄的我，已然不那么年轻了，而这些比我更努力读书、学历更高的年轻人，看起来在做着和学历&#x2F;知识并不相称的工作。也许，自卑的应该是我，因为国家刚刚给程序员群体定性——<a target="_blank" rel="noopener" href="http://www.mohrss.gov.cn/SYrlzyhshbzb/jiuye/gzdt/202108/t20210816_420736.html">新生代农民工</a>。可是，我这个农民工，今天想做一点和学历&#x2F;知识相称的事情，利用 Python 来自动识别防疫二维码。</p>
<h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>对于防疫二维码而言，靠肉眼去看的话，其实主要关注两个颜色，即标识健康状态的颜色和标识疫苗注射状态的颜色。与此同时，为了追踪人的地理位置变化，防疫&#x2F;安检人员还会关注地理位置信息，因此，如果要自动识别防疫二维码，核心就是读出其中的颜色以及文字信息。对于颜色的识别，我们可以利用 <a target="_blank" rel="noopener" href="https://opencv.org/">OpenCV</a> 中的 <a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html">inRange()</a> 函数来实现，只要我们定义好对应颜色的 <a href="">HSV</a> 区间即可；对于文字的识别，我们可以利用 <a target="_blank" rel="noopener" href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 库来进行提取。基于以上原理，我们会通过 <a target="_blank" rel="noopener" href="https://opencv.org/">OpenCV</a> 来处理摄像头的图像，只要我们将手机二维码对准摄像头，即可以完成防疫二维码的自动识别功能。考虑到检测不到二维码或者颜色识别不到这类问题，程序中增加了蜂鸣报警的功能。写作本文的原因，单纯是我觉得这样好玩，我无意借此来让人们失业。可生而为人，说到底不能像机器一样活着，大家不都追求有趣的灵魂吗？下面是本文中使用到的第三方 Python 库的清单：</p>
<ul>
<li>pyzbar &#x3D;&#x3D; 0.1.8</li>
<li>opencv-contrib-python &#x3D;&#x3D; 4.4.0.46</li>
<li>opencv-python &#x3D;&#x3D; 4.5.3.56</li>
<li>paddleocr &#x3D;&#x3D; 2.2.0.2</li>
<li>paddlepaddle &#x3D;&#x3D; 2.0.0</li>
</ul>
<h1 id="图块检测"><a href="#图块检测" class="headerlink" title="图块检测"></a>图块检测</h1><p>下面是一张从手机上截取的防疫二维码图片，从这张图片中我们看出，整个防疫二维码，可以分为三个部分，即：上方的定位信息图块，中间的二维码信息图块，以及下方的核酸检验信息图块。</p>
<p><img src="https://i.loli.net/2021/08/19/eqzajLoMHEidy5t.jpg" alt="“西安一码通” 防疫二维码"></p>
<p>对于二维码的检测，我们可以直接使用 <a target="_blank" rel="noopener" href="https://github.com/NaturalHistoryMuseum/pyzbar/">pyzbar</a> 这个库来解析，可如果直接对整张图进行解析，因为其中的干扰项实在太多，偶尔会出现明明有二维码，结果无法进行解析的情况。所以，我们可以考虑对图片进行切分，而切分的依据就是图中的这三个图块。这里，我们利用二值化函数 <a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/threshold/threshold.html">threshold()</a> 和 轮廓提取函数 <a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/shapedescriptors/find_contours/find_contours.html?highlight=findcontours">findContours()</a> 来实现图块的检测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度化 &amp; 二值化</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, binary = cv2.threshold(gray, <span class="number">135</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 检测轮廓，获得对应的矩形</span></span><br><span class="line">contours = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-<span class="number">2</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    block_rect = cv2.boundingRect(contours[i]) </span><br></pre></td></tr></table></figure>

<p>这里有一个感触颇深的地方，在检测图块的过程中，博主发现中间和底部这两个图块，其检测要更为简单一点，因为它有明显的边界、属于规则的矩形，而上方的图块，因为带有装饰性的纹理，以及灰色的过渡区，二值化并不能检测到其边缘，如下图所示，地铁上使用的二维码，相比商场里使用的二维码，轮廓线要更为清晰一点。所以，这里选择一个什么样的阈值来做二值化，个人感觉是需要反复去尝试的。考虑到要兼容这种轮廓不规则的图块，实际上我使用了一点小技巧，即：在得到下面两个图块以后，利用高度的换算关系，人为地生成上方图块的矩形范围。</p>
<p><img src="https://i.loli.net/2021/08/19/6gdQlwoDncJAvLV.jpg" alt="“西安一码通” 灰度化 &amp; 二值化"></p>
<p>那么，这是否说明，代表美的设计，在代表绝对理性的算法面前，其实更像是一种噪音。也许，它们各自的领域不同、观点不同，可都一样在为这个世界发光发热，生活不止一种真相，世界不止一种回声，有微小的差异，同样有宏大的统一。</p>
<h1 id="二维码检测"><a href="#二维码检测" class="headerlink" title="二维码检测"></a>二维码检测</h1><p>好了，我们可以注意到，一旦完成图块的切分，此时，二维码位于中间这个图块，检测二维码在这里并不是重点，因为检测这个二维码是第一步，按照这个二维码所在的矩形去检测中心的的色彩，这是这里的重点，因为这个二维码解析以后就是一个 URL 地址，本身并没有包含任何信息，我们想要知道一个人是否健康，唯一的办法就是检测中间的色彩。其实，理论上剩余两个图块同样需要检测色彩，可考虑到三者在含义的表达上是一致的，即三者拥有相同的颜色，我们只需要处理其中一个即可。下面是利用 <a target="_blank" rel="noopener" href="https://github.com/NaturalHistoryMuseum/pyzbar/">pyzbar</a> 库对二维码区块进行解析，获取二维码信息、二维码所在的矩形等信息的代码片段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测二维码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_qrcode</span>(<span class="params">image, block</span>):</span><br><span class="line">    block_image, block_rect, _ = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    gray = cv2.cvtColor(block_image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    qrcodes = decode(gray, [ZBarSymbol.QRCODE])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(qrcodes) &gt; <span class="number">0</span>:</span><br><span class="line">        qrcode = qrcodes[<span class="number">0</span>]</span><br><span class="line">        qrcodeData = qrcode.data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        x, y, w, h = qrcode.rect</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, qrcodeData, (abs_x, abs_y, w, h)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，通过 <a target="_blank" rel="noopener" href="https://github.com/NaturalHistoryMuseum/pyzbar/">pyzbar</a> 这个库，我们不单单可以获取到二维码的信息，同时还可以获得二维码在图块中的矩形范围，由此我们可以推算出，二维码在整张图片中的矩形范围，我们会绘制一个矩形来标识二维码的位置，这样使用者就可以清楚的知道，我们的的确确检测到了二维码。</p>
<h1 id="色彩检测"><a href="#色彩检测" class="headerlink" title="色彩检测"></a>色彩检测</h1><p>一旦我们确定了二维码的矩形范围，接下来的工作，就是在这个矩形范围里检测颜色啦！譬如一个人如果健康状态，二维码的中间部分会显示为绿色。如果一个人完成了疫苗的注射，二维码边上的区域会显示为金色。所以，基于这样的原理，我们只需要检测对应区域是否有对应的颜色即可，这里主要利用了<code>HSV</code>颜色模型，不同于<code>RGB</code>颜色模型，<code>HSV</code>颜色模型利用色相、饱和度和亮度三个指标来描述颜色，是一种把<code>RGB</code>色彩空间中的点放在倒圆锥体上的表示方法。其中：</p>
<ul>
<li>H，即 Hue，表示色相，它通过角度来度量，因此，它的取值范围是0 到 360 度，如下图所示，红色对应 0 度，绿色对应 120 度，蓝色对应 240 度：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/jGVkTzscKUabeDf.jpg" alt="HSV 颜色模型：色相"></p>
<ul>
<li>S，即 Saturation，表示饱和度，用 0 到 100% 之间的数值表示，如果用下面的倒圆锥体来表示，则 S 表示的是色彩点到所在圆形切面圆心的距离与该圆半径的比值：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/UoSRreKhx2Af39d.jpg" alt="HSV 颜色模型：倒圆锥体"></p>
<ul>
<li>V，即 Value，表示亮度，同样用 0 到 100% 之间的数值表示，参考上面的倒圆锥体，可以了解到，V 表示的是色彩点所在圆形切面圆心与该圆圆心在垂直距离上的比值：</li>
</ul>
<p>此时此刻，你有没有回想起小时候调电视机画面时的经历呢？</p>
<p><img src="https://i.loli.net/2021/08/20/vHSp6CmZQWnjBVk.jpg" alt="找不到合适的图，简单怀旧一下？"></p>
<p>对于<code>HSV</code>颜色模型，我们可以参考下面的取值范围：</p>
<p><img src="https://i.loli.net/2021/08/19/FfocQAgdOzrhpjm.png" alt="HSV 颜色模型：参考范围"></p>
<p>以红色为例，其 H 分量取值范围为：0 到 10；S 分量取值范围为：43 到 255；V 分量取值范围为：46 到 255。<a target="_blank" rel="noopener" href="https://opencv.org/">OpenCV</a> 中的 <a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/da/d97/tutorial_threshold_inRange.html">inRange()</a> 函数，可以判断某个 HSV 数组（此时图片使用一个数组来表示）是否在某个给定的区间范围内。于是，我们的思路就是：定义好目标颜色的 HSV 区间，同时提供一份 HSV 格式的图片数据。此时，其实现逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 颜色范围定义</span></span><br><span class="line">color_dist = &#123;</span><br><span class="line">    <span class="string">&#x27;red&#x27;</span>: &#123;<span class="string">&#x27;Lower&#x27;</span>: np.array([<span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>]), <span class="string">&#x27;Upper&#x27;</span>: np.array([<span class="number">6</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">&#x27;blue&#x27;</span>: &#123;<span class="string">&#x27;Lower&#x27;</span>: np.array([<span class="number">100</span>, <span class="number">80</span>, <span class="number">46</span>]), <span class="string">&#x27;Upper&#x27;</span>: np.array([<span class="number">124</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">&#x27;green&#x27;</span>: &#123;<span class="string">&#x27;Lower&#x27;</span>: np.array([<span class="number">35</span>, <span class="number">43</span>, <span class="number">35</span>]), <span class="string">&#x27;Upper&#x27;</span>: np.array([<span class="number">90</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">    <span class="string">&#x27;golden&#x27;</span>: &#123;<span class="string">&#x27;Lower&#x27;</span>: np.array([<span class="number">26</span>, <span class="number">43</span>, <span class="number">46</span>]), <span class="string">&#x27;Upper&#x27;</span>: np.array([<span class="number">34</span>, <span class="number">255</span>, <span class="number">255</span>])&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测颜色</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_color</span>(<span class="params">image, color</span>):</span><br><span class="line">    <span class="comment"># gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 灰度</span></span><br><span class="line">    gs = cv2.GaussianBlur(image, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯模糊</span></span><br><span class="line">    hsv = cv2.cvtColor(gs, cv2.COLOR_BGR2HSV)  <span class="comment"># HSV</span></span><br><span class="line">    erode_hsv = cv2.erode(hsv, <span class="literal">None</span>, iterations=<span class="number">2</span>) <span class="comment"># 腐蚀</span></span><br><span class="line">    inRange_hsv = cv2.inRange(erode_hsv, color_dist[color][<span class="string">&#x27;Lower&#x27;</span>], color_dist[color][<span class="string">&#x27;Upper&#x27;</span>])</span><br><span class="line">    contours = cv2.findContours(inRange_hsv.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(contours) &gt; <span class="number">0</span>:</span><br><span class="line">        draw_color_area(image, contours)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        winsound.Beep(<span class="number">440</span>, <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里，我们先对图片做了一次高斯模糊、然后将其转换为 HSV 格式，经过侵蚀以后传给 <code>inRange()</code>函数，这样我们就得到了所有符合这个区间范围的点。接下来，单单找到颜色还不行，我们还需要根据这些点得到一个轮廓，此时，<code>findContours()</code>函数再次登场，为了让使用者更直观地找到对应的颜色区域，我们这里使用下面的方法将其“画”出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 标记颜色区域</span><br><span class="line">def draw_color_area(image, contours):</span><br><span class="line">    max, index = 0, -1</span><br><span class="line">    for i in range(len(contours)):</span><br><span class="line">        area = cv2.contourArea(contours[i])</span><br><span class="line">        if area &gt; max:</span><br><span class="line">            max = area</span><br><span class="line">            index = i</span><br><span class="line">    if index &gt;= 0:</span><br><span class="line">        rect = cv2.minAreaRect(contours[index])</span><br><span class="line">        cv2.ellipse(image, rect, color_marker, 2, 8)</span><br><span class="line">        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, color_marker, 2, 8, 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以中间部分的二维码图块为例，此时，我们可以得到下面的结果，这是做了两次颜色检测得到的，第一次检测绿色，第二次检测金色：</p>
<p><img src="https://i.loli.net/2021/08/19/wt6y4gEocnhkM5K.png" alt="“西安一码通” 防疫二维码：颜色检测"></p>
<h1 id="OCR-识别"><a href="#OCR-识别" class="headerlink" title="OCR 识别"></a>OCR 识别</h1><p><code>OCR</code>识别没有太多悬念，因为我们直接使用 <a target="_blank" rel="noopener" href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 即可，因为我们已经完成对图块的切分，只需要依次对图片进行检验即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install paddlepaddle==2.0.0 -i https://mirror.baidu.com/pypi/simple</span><br><span class="line">python -m pip install paddleocr</span><br></pre></td></tr></table></figure>

<p>在安装的过程中，可能会得到这样的错误信息：<code>Microsoft Visual C++ 14.0 is required</code>。如果你安装了 Visual Studio 依然提示错误，解决方案就是找到 Visual Studio 安装包，然后勾选那些和 Microsoft Visual C++ 14.0 相关的可选的安装项，再安装了这些必要组件以后，重新使用<code>pip</code>安装即可。</p>
<p><img src="https://i.loli.net/2021/08/20/Iqms8YS6G7l4zrC.png" alt="“Microsoft Visual C++ 14.0 is required” 错误信息"></p>
<p>因为 <a target="_blank" rel="noopener" href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 接受的是<code>PIL</code>库中的<code>Image</code>类型，所以，在拆分图块的时候，实际上是为每个图块生成了一个对应的文件。此时，OCR 识别部分的代码实现如下。首先，我们需要初始化 PaddleOCR ，首次运行会自动下载训练好的模型文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PaddleOCR</span></span><br><span class="line">ocr = PaddleOCR() </span><br></pre></td></tr></table></figure>

<p>这里，我们通过<code>detect_text</code>来检测每个图块的文字，并在原始图片中标记出文字位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测文字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_text</span>(<span class="params">image, block</span>):</span><br><span class="line">    _, block_rect, block_file = block</span><br><span class="line">    block_x, block_y, _, _ = block_rect</span><br><span class="line">    result = ocr.ocr(block_file)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> result:</span><br><span class="line">        boxes = line[<span class="number">0</span>]</span><br><span class="line">        texts = line[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        x = <span class="built_in">int</span>(boxes[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(boxes[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        w = <span class="built_in">int</span>(boxes[<span class="number">2</span>][<span class="number">0</span>]) - x</span><br><span class="line">        h = <span class="built_in">int</span>(boxes[<span class="number">2</span>][<span class="number">1</span>]) - y</span><br><span class="line">        abs_x = block_x + x</span><br><span class="line">        abs_y = block_y + y</span><br><span class="line">        cv2.rectangle(image, (abs_x, abs_y), (abs_x + w, abs_y + h), color_marker, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">yield</span> texts</span><br></pre></td></tr></table></figure>

<p>以底部图块的检测结果为例，其文字位置标记及文字识别结果如下图所示：</p>
<p><img src="https://i.loli.net/2021/08/20/XSTfimvkc2yPOAR.png" alt="通过 OCR 识别出来的文字位置"></p>
<p><img src="https://i.loli.net/2021/08/20/VP2YouclhKLX58j.png" alt="通过 OCR 识别出来的文字信息"></p>
<h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p>到现在为止，主要的部分我们已经编写完成，接下来，我们只需要接入摄像头，从摄像头捕捉图像即可。这里，请允许在下推荐一个非常好用的软件：<a target="_blank" rel="noopener" href="https://ivcam.en.softonic.com/">iVCam</a>，它可以让手机摇身一变成为摄像头，从而可以让我们模拟扫描二维码的场景。使用 OpenCV 捕捉来自摄像头的图片非常简单，大家可以参考我曾经的博客：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2997581895/">视频是不能P的系列：OpenCV人脸检测</a>，这里我们直接给出代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_video</span>():</span><br><span class="line">    cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, image = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">           <span class="comment"># 检测画面中的图块</span></span><br><span class="line">            blocks = <span class="built_in">list</span>(detect_blocks(image))</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 处理每个图块</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">                image = handle_block(image, block)</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 展示处理结果</span></span><br><span class="line">            cv2.imshow(<span class="string">&#x27;QRCode Detecting&#x27;</span>, image)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 按 Q 退出</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    cap.release() </span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以看到下面的结果。可以注意到，在实际应用中，通过视频采集的图像会受到环境光照、拍摄角度等因素的影响，受此影响，我们的图块检测在这个环节表现不佳，它甚至把整张图片当成了一个图块，这直接导致最重要的二维码没有检测出来。百度的 <a target="_blank" rel="noopener" href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> 表现倒是可圈可点，识别速度和准确性还是非常出色的。对于视频这种级别的输入，特别是在人流量较大的商场、车站等场所，对于识别准确性、可靠性都有着非比寻常的要求，如果要考虑这个思路的落地，应该在图像采集的预处理、图像检测的算法上去下功夫，特别是在拆分图块这个环节，识别的准确性还会受到二维码样式的影响，而这些显然是这篇博客背后的故事啦！正所谓，”路漫漫其修远兮，吾将上下而求索”，如果大家对这个项目感兴趣的话，可以到 <a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2021/tree/master/src/GreenQRCode">Github</a> 上做进一步的了解。</p>
<p><img src="https://i.loli.net/2021/08/20/dxtOhKCr8YFLmoW.jpg" alt="通过摄像头检测防疫二维码"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>写完这篇博客的时候，我不由地会想，也许，屏幕前的某个人会在看完这篇博客以后，一脸鄙夷地说道，就这？可这的确就是基础性研究的现状，即：投入了时间和精力，并不一定能得到满意的结果。我们从小到大接受的关于成功的理念，无非都是“只要功夫深，铁杵磨成针”、“吃得苦中苦，方为人上人”……可不知道为什么，这种理念在被一点一点的打破，某种意义上来讲，国家和个人在这个时代面对的选择是相似的，在选择挣快钱还是挣慢钱这个问题上。多年以前，在实验室里捣腾化学试剂的我，曾经一度认为做实验、分析数据、写报告这些事情是枯燥而无用的，因为在当时看来，这些东西距离实际应用都挺遥远的。可是，此刻我大概不得不承认，这些基础工作的重要性。的确，写算法、做模型，这些事情都是科学家去做的事情，我们普通人只要奉行“拿来主义”就好，可当 OpenCV 就放在你手里，而你依然做不好这件事情的时候，大概还是我输了罢，说“认真你就输了”的人，真的真的真的认真过吗？</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/Docker-Compose-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E4%B8%8E%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Docker-Compose-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E4%B8%8E%E5%88%86%E4%BA%AB/" itemprop="url">你不可不知的容器编排进阶技巧</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-14T14:13:32+00:00">
                2021-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在团队内推广<code>Docker Compose</code>有段时间啦，值得庆幸的是，最终落地效果还不错，因为说到底，大家都不大喜欢，那一长串复杂而枯燥的命令行参数。对我而言，最为重要的一点，团队内使用的技术变得更加透明化、标准化，因为每个微服务的配置信息都写在<code>docker-compose.yml</code>文件中，任何人都可以快速地构建出一套可用的服务，而不是每次都要去找具体的某一个人。我想说，这其实是一个信息流如何在团队内流动的问题。也许，我们有文档或者<code>Wiki</code>，可新人能不能快速融入其中，这才是检验信息流是否流动的唯一标准。就这样，团队从刀耕火种的<code>Docker</code>时代，进入到使用服务编排的<code>Docker Compose</code>时代。接下来，能否进入<code>K8S</code>甚至是云原生的时代，我终究不得而知。今天我想聊聊，在使用<code>Docker Compose</code>的过程中，我们遇到的诸如容器的<strong>启动顺序</strong>、<strong>网络模式</strong>、<strong>健康检查</strong>这类问题，我有一点<code>Docker Compose</code>的进阶使用技巧想和大家分享。</p>
<h1 id="容器的启动顺序"><a href="#容器的启动顺序" class="headerlink" title="容器的启动顺序"></a>容器的启动顺序</h1><p>使用服务编排以后，大家最关心的问题是，如果服务间存在依赖关系，那么如何保证容器的启动顺序？我承认，这是一个真实存在的问题，譬如，你的应用依赖某个数据库，理论上数据库要先启动，抑或者是像<code>Redis</code>、<code>Kafka</code>、<code>Envoy</code>这样的基础设施，总是要优先于应用服务本身启动。</p>
<p><img src="https://i.loli.net/2021/08/15/LnAh6GSdMJ2NkVx.png" alt="假如章鱼的这些脚互相影响会怎么样？"></p>
<p>熟悉<code>Docker Compose</code>的同学，也许会想到<code>depends_on</code>这个选项，可如果大家亲自去尝试过就会知道，这终究只是我们的一厢情愿。为什么呢？因为这个<code>depends_on</code>主要是看目标容器是不是处于<code>running</code>的状态，所以，在大多数情况下，我们会注意到<code>Docker Compose</code>并不是按我们期望的顺序去启动的，因为目标容器在某一瞬间的确已经是<code>running</code>的状态了，那这样简直太尴尬了有木有啊！我们从一个简单的例子开始：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      /bin/bash -c &#x27;</span></span><br><span class="line"><span class="string">      sleep 5;</span></span><br><span class="line"><span class="string">      echo &quot;sleep over&quot;;&#x27;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，为了证明<code>city_service</code>服务不会等待<code>redis_server</code>服务，我故意让子弹飞了一会儿，结果如何呢？我们一起来看看：</p>
<p><img src="https://i.loli.net/2021/08/15/BqDRtbJkpVcno3s.png" alt=" Docker Compose 启动顺序：一厢情愿"></p>
<p>果然，我没有骗各位，<code>city_service</code>服务不会等待<code>redis_server</code>服务。我们知道，<code>Redis</code>提供的命令行接口中，有一个<code>PING</code>命令，当<code>Redis</code>可以正常连接的时候，它会返回一个<code>PONG</code>，也许，这就是乒乓球的魅力所在。基于这个想法，我们继续修改<code>docker-compose.yml</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      /bin/bash -c &#x27;</span></span><br><span class="line"><span class="string">      while ! nc -z redis_server 6379;</span></span><br><span class="line"><span class="string">      do</span></span><br><span class="line"><span class="string">        echo &quot;wait for redis_server&quot;;</span></span><br><span class="line"><span class="string">        sleep 1;</span></span><br><span class="line"><span class="string">      done;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="string">echo</span> <span class="string">&quot;redis_server is ready!&quot;</span><span class="string">;</span></span><br><span class="line">      <span class="string">echo</span> <span class="string">&quot;start city_service here&quot;</span><span class="string">;</span></span><br><span class="line">      <span class="string">&#x27;</span></span><br><span class="line"><span class="string">networks:</span></span><br><span class="line"><span class="string">  backend:</span></span><br></pre></td></tr></table></figure>
<p>这里，我们用了一种取巧的方法，<code>Ubuntu</code>中的<code>nc</code>命令可以对指定主机、指定端口进行检测，换言之，我们简单粗暴的认为，只要<code>6379</code>这个端口可以访问，就认为<code>Redis</code>准备就绪啦，因为我们没有办法在<code>city_service</code>这个容器中调用<code>redis-cli</code>，这个做法本身并不严谨，我们这里更多的是验证想法：</p>
<p><img src="https://i.loli.net/2021/08/15/Hhx4R7obZL5FBrv.png" alt="Docker Compose 启动顺序：检测 Redis"></p>
<p>可以注意到，此时，<code>city_service</code>服务会等待<code>redis_server</code>服务，直到<code>redis_server</code>服务就绪。所以，要解决服务编排时，容器的启动顺序的问题，本质上就是把需要等待的服务、端口以及当前服务的启动命令，统一到容器的入口中。为此，官方提供了 <a target="_blank" rel="noopener" href="https://github.com/vishnubob/wait-for-it">wait-for-it</a> 这个方案，官方关于容器启动顺序的文档，可以参考：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/startup-order/">Startup Order</a>。对于上面的例子，我们可以这样改写<code>docker-compose.yml</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_server</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/wait-for-it.sh&quot;</span>, <span class="string">&quot;redis_server:6379&quot;</span>, <span class="string">&quot;--&quot;</span>, <span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;CityService.dll&quot;</span>]</span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure>
<p>此时，启动容器时的效果如下，因为这个方案依赖 <a target="_blank" rel="noopener" href="http://netcat.sourceforge.net/">Netcat</a> 这样一个工具，所以，我们的容器中还需要加入这个工具，此时，可以使用下面的脚本片段：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:buster-slim as wait-for-it</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y <span class="string">&quot;wait-for-it&quot;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=wait-for-it /usr/bin/wait-for-it .</span></span><br></pre></td></tr></table></figure>

<p>不过，不太明白为什么这里一直提示路径不对：</p>
<p><img src="https://i.loli.net/2021/08/16/jgbwuVHeJNvG5BY.png" alt="Docker Compose 启动顺序：wait-for-it.sh"></p>
<p>个人建议，最好将这个语句写在<code>Dockerfile</code>，或者试提供一个类似于<code>entrypoint.sh</code>的脚本文件。关于这个方案的更多细节，大家可以参考<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/startup-order/">官方文档</a>，写这篇文章的时候，我不由得感慨：<code>Shell</code>脚本真的是太难学了(逃……。所以，点到为止。刚刚提到过，我个人觉得这种主机 + 端口号的检测方式不够严谨，因为一个端口可以<code>PING</code>通，并不代表服务一定是可用的，所以，在接下来的内容里，我会介绍基于健康检查的思路。</p>
<h1 id="容器的健康检查"><a href="#容器的健康检查" class="headerlink" title="容器的健康检查"></a>容器的健康检查</h1><p>不知道大家有没有这样的经历，就是你明明看到一个容器的状态变成<code>Up</code> ，可对应的微服务就是死活调不通。面对来自前端同事的戏谑与嘲讽，你不禁仰天长叹一声，开始在容器里翻箱倒柜，一通操作如虎。过了许久，你终于发现是容器内部出现了始料不及的错误。看来，容器状态显示为<code>Up</code>，并不代表容器内的服务就是可用的啊！果然，还是需要一种机制来判断容器内的服务是否可用啊！等等，这不就是传说中的健康检查？恭喜你，答对了！</p>
<p><img src="https://i.loli.net/2021/08/15/fplPBvICiEOYsKR.jpg" alt=" Docker 经典集装箱形象"></p>
<p>在<code>Docker</code>及<code>Docker Compse</code>中，均原生支持 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#healthcheck">健康检查</a> 机制，一旦一个容器指定了<code>HEALTHCHECK</code>选项，<code>Docker</code>会定时检查容器内的服务是否可用。我们都知道，一个普通的 Docker 容器，无非是开始、运行中、停止这样三种状态，而提供了<code>HEALTHCHECK</code>选项的<code>Docker</code>容器，会在这个基础上增加健康(<strong>healthy</strong>)和非健康(<strong>unhealthy</strong>)两种状态，所以，我们应该用这两个状态来判断容器内的服务是否可用。下面是一个指定了<code>HEALTHCHECK</code>选项的容器示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span>-buster-slim</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> /app/publish .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;CityService.dll&quot;</span>]</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost:80/city || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>可以注意到，<code>Docker</code>原生的健康机制，需要通过<code>CMD</code>的方式来执行一个命令行，如果该命令行返回 0 ，则表示成功；返回 1，则表示失败。</p>
<p>此处，我们还可以配置以下三个参数，<code>--interval=&lt;间隔&gt;</code>表示健康检查的间隔，默认为 30 秒；<code>--timeout=&lt;时长&gt;</code>表示健康检查命令超时时间，超过该时间即表示<code>unhealthy</code>，默认为 30 秒；<code>--retries=&lt;次数&gt;</code>表示连续失败的次数，超过该次数即表示<code>unhealthy</code>。对于我们这里的<code>ASP.NET Core</code>应用而言，如果程序正常启动，显然这个地址是可以调通的，我们可以用这个来作为一个“探针”。</p>
<p><img src="https://i.loli.net/2021/08/14/QnuPZ8vsCYKbVHm.png" alt=" Docker 健康检查：healthy "></p>
<p>我们可以注意到，在容器启动的第 14 秒，其状态为：<code>health：starting</code>。而等到容器启动的第 16 秒，其状态则为：<code>healthy</code>，这表明我们的服务是健康的。此时此刻，如果我们耍点小心思，让<code>curl</code>去访问一个不存在的地址会怎么样呢？可以注意到，此时状态变成了：<code>unhealthy</code>:</p>
<p><img src="https://i.loli.net/2021/08/14/oNtX8G7UAqEDIzS.png" alt="Docker 健康检查：unhealthy "></p>
<p><code>HEALTHCHECK</code>指令除了可以直接写在<code>Dockerfile</code>中以外，还可以直接附加到<code>docker run</code>命令上，还是以上面的项目作为示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run  --name city_service -d -p 8081:80  city_service \</span><br><span class="line">--health-cmd=&quot;curl -fs http://localhost:80/city || exit 1&quot; \</span><br><span class="line">--health-interval=3s \</span><br><span class="line">--health-timeout=5s \</span><br><span class="line">--health-retries=3 </span><br></pre></td></tr></table></figure>
<p>甚至，我们还可以使用下面的命令来查询容器的健康状态：<code>docker inspect --format=&#39;&#123;&#123;json .State.Health&#125;&#125;&#39; &lt;ContainerID&gt;</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unhealthy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;FailingStreak&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Log&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;Start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-08-14T15:27:50.3325424Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;End&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-08-14T15:27:50.3813102Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;ExitCode&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;Output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过，我个人感觉这个<code>curl</code>的写法非常别扭，尤其是当我试图在<code>docker-compose</code>中写类似命令的时候，我觉得稍微复杂一点的健康检查，还是交给脚本语言来实现吧！例如，下面是官方提供的针对<code>MongoDB</code>的健康检查的脚本<code>docker-healthcheck.sh</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -eo pipefail </span><br><span class="line">host=&quot;$(hostname --ip-address || echo &#x27;127.0.0.1&#x27;)&quot; </span><br><span class="line">if mongo --quiet &quot;$host/test&quot; --eval &#x27;quit(db.runCommand(&#123; ping: 1 &#125;).ok ? 0 : 2)&#x27;; then </span><br><span class="line">   exit 0</span><br><span class="line">fi </span><br><span class="line">   exit 1</span><br></pre></td></tr></table></figure>
<p>此时，<code>HEALTHCHECK</code>可以简化为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD bin/bash docker-healthcheck.sh</span></span><br></pre></td></tr></table></figure>
<p>更多的示例，请参考：<a target="_blank" rel="noopener" href="https://github.com/docker-library/healthcheck/">docker-library&#x2F;healthcheck&#x2F;</a> 以及 <a target="_blank" rel="noopener" href="https://github.com/rodrigobdz/docker-compose-healthchecks">rodrigobdz&#x2F;docker-compose-healthchecks</a>。</p>
<p>其实，对于容器的启动顺序问题，我们还可以借助检查检查的思路来解决，因为<code>depends_on</code>并不会等待目标容器进入<code>ready</code>状态，而是等目标容器进入<code>running</code>状态。这样，就回到了我们一开始描述的现象：一个容器明明都变为<code>Up</code>状态了，可为什么接口就是死活调不通呢？因为我们无法界定这样一个<code>ready</code>状态。考虑到<code>depends_on</code>可以指定<code>condition</code>，此时，我们可以这样编写<code>docker-compose.yml</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis_server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;redis-cli&quot;</span>, <span class="string">&quot;ping&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">city_service</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">redis_server:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br></pre></td></tr></table></figure>
<p>简单来说，我们使用了<code>Redis</code>内置的命令对<code>redis_server</code>服务进行健康检查，而<code>city_service</code>服务则依赖于<code>redis_server</code>服务的健康状态，只有当<code>Redis</code>准备就绪了以后，<code>city_service</code>才会开始启动。下面是实际启动过程的截图，看看是不是和我们想的一样：</p>
<p><img src="https://i.loli.net/2021/08/15/HKvjmoCdznlW6FV.png" alt=" Docker 健康检查：容器启动顺序"></p>
<p>果然，奇怪的知识有增加了呢，我们唯一需要解决的问题，就是怎么给某一个服务做健康检查，以上！</p>
<h1 id="容器的网络模式"><a href="#容器的网络模式" class="headerlink" title="容器的网络模式"></a>容器的网络模式</h1><p>接下来，我们来说说<code>Docker</code>里的网络模式，特别是当我们使用<code>docker-compose</code>来编排一组服务的时候，假设我们有一个目录<code>app</code>，在这个牡蛎里我们放置了服务编排文件<code>docker-compose.yml</code>，默认情况下，<code>Docker-Compose</code>会创建一个一个名为<code>app_default</code>的网络，并且这个网络是<code>bridge</code>，即网桥模式的一个网络。什么是网桥模式呢？你可能会感到困惑，而这要从<code>Docker</code>中的网络模式开始说起，这里简单下常用的几种：</p>
<ul>
<li>host 模式，或叫做主机模式，可以认为容器和主机使用相同的端口进行访问，因为容器和主机在同一个网络下，此模式下，意味着通过<code>-p</code>绑定的端口失效，因为所有容器都使用主机的网络，所以容器间可以相互通信，此模式通过<code>--network=host</code>指定。</li>
<li>bridge 模式，或叫做网桥模式，这是<code>Docker</code>中默认的网络设置，此模式下，容器和主机有各自的 IP&#x2F;端口号，两者之间通过一个虚拟网桥进行通信，虚拟网桥的作用类似于物理交换机。因此，不同容器间的网络是相互隔离的，此模式通过<code>--network=bridge</code>指定。</li>
<li>none 模式，通俗讲就是无网络模式，意味着容器是一个封闭的环境，无法通过主机访问外部的网络，这种模式在那种讲究保密性质、封闭式开发的场合应该会有一点用，可这都 2021 年了，难道你还能把互联网上的软件全部下载下来吗？此模式通过<code>--network=none</code>指定。</li>
<li>container 模式，或叫做共享模式，通俗来讲，就是指一个容器共享某个已经存在的容器的<code>Network Namespace</code>，此时，该容器将不会拥有属于自己的 IP&#x2F;端口号等资源，因为这种模式可以节约一定的网络资源，此模式通过<code>--network=&lt;Container_ID&gt;/&lt;Container_Name&gt;</code>指定。</li>
</ul>
<p>为了帮助大家理解和区分这四种模式，博主绘制了下面的图示来补充说明：</p>
<p><img src="https://i.loli.net/2021/08/16/DJq3CBrmktaRNex.png" alt="容器的网络模式(主机、容器、网桥)示意图"></p>
<p>通过以上的图文信息反复加深印象，相信大家可以找出点规律：</p>
<ul>
<li>如果你的容器网络与主机网络不需要隔离，那么选择主机模式(<strong>host</strong>)</li>
<li>如果你的应用运行在不同的容器里，并且这些容器间需要相互通信，那么选择网桥模式(<strong>bridge</strong>)</li>
<li>如果你的应用需要运行在一个隔绝外界网络的环境中，那么选择无网络模式(<strong>none</strong>)</li>
<li>如果你希望在节省网络资源的同时，实现不同容器间的通信，那么选择容器模式(<strong>container</strong>)</li>
</ul>
<p>以上四种网络模式，除了可以在<code>docker run</code>的时候指定以外，我们还可以在<code>docker-compose.yml</code>文件中指定。例如，下面表示的是一个主机模式的容器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cache_server:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cache_server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>

<p>大多数情况下，我们只需要连接到<code>docker0</code>这个虚拟网卡即可，而如果你想为某个容器或者一组容器单独建立这样一张网卡，此时，就不得不提到<code>Docker</code>中的自定义网络功能，我们一起来看下面的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个网络：test-network</span><br><span class="line">docker network create test-network</span><br><span class="line">// 创建一个Nginx的容器：nginx_8087，使用网络：test-network</span><br><span class="line">docker run -d --name nginx_8087 --network test-network -p 8087:80 nginx:latest</span><br><span class="line">// 创建一个Nginx的容器：nginx_8088</span><br><span class="line">docker run -d --name nginx_8088 -p 8088:80 nginx:latest</span><br><span class="line">// 连接容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network connect test-network nginx_8088</span><br></pre></td></tr></table></figure>
<p>接下来，通过下面的命令，我们可以拿到两个容器的 ID，在此基础上我们看一下两个容器各自分配的 IP 是多少：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; &lt;ContainerID&gt;</span><br></pre></td></tr></table></figure>

<p>此时，我们会发现一个有趣的现象，<code>nginx_8087</code>这个容器，可以获得 IP 地址<code>172.17.0.2</code>，而<code>nginx_8088</code>则无法获得 IP 地址，这是为什么呢？这其实就是我们前面提到过的容器模式(<strong>container</strong>)，此时，<code>nginx_8088</code>这个容器实际上是和<code>nginx_8087</code>共享一个<code>Network Namespace</code>，即使它们有各自的文件系统。同样地，我们可以使用下面的命令来让容器从某个网络中断开：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 断开容器：nginx_8088 至网络：test-network</span><br><span class="line">docker network disconnect test-network nginx_8088</span><br><span class="line">// 删除网络</span><br><span class="line">docker network rm test-network</span><br></pre></td></tr></table></figure>
<p>是否觉得手动维护容器的网络非常痛苦？幸好，我们还有<code>Docker-Compose</code>可以用，上面两个<code>Nginx</code>的容器我们可以这样维护：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<p>此时，我们可以注意到，<code>Docker Compose</code>会创建两个网络，即<code>network_mode_default</code>和<code>network_mode_test-network</code>：</p>
<p><img src="https://i.loli.net/2021/08/16/Sgsbpt1huUlmTQM.png" alt="Docker Compose 中使用自定义网络"></p>
<p>这说明默认网络依然存在，如果我们希望完全地使用自定义网络，此时，我们可以这样修改服务编排文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>
<p>这表示默认网络会采用主机模式，相应地，你需要修改<code>nginx_8087</code>和<code>nginx_8088</code>两个容器的<code>network</code>选项，使其指向<code>default</code>。</p>
<p>除此之外，你还可以使用<code>external</code>指向一个已经存在的网络：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">a-existing-network</span></span><br></pre></td></tr></table></figure>
<p>在<code>Docker</code>中，每个容器都会分配<code>IP</code>，因为这个<code>IP</code>总是不固定的，所以，如果我们希望像虚拟机那样使用一个静态<code>IP</code>的话，可以考虑下面的做法：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx_8087:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8087</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8087</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">  <span class="attr">nginx_8088:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx_8088</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8088</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test-network</span></span><br><span class="line">          <span class="attr">ipv4_address:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">test-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.2</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure>
<p>关于<code>Docker</code>及<code>Docker Compose</code>中的网络驱动，如 <a target="_blank" rel="noopener" href="https://docs.docker.com/network/macvlan/">macvlan</a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/network/overlay/">overlay</a> 等等，这些显然是更加深入的话题，考虑到篇幅，不在这里做进一步的展开，对此感兴趣的朋友可以参考官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/network/">Networking Overview</a> 以及 <a target="_blank" rel="noopener" href="https://docs.docker.com/compose/networking/">Networking in Compose</a>。博主写这篇文章的想法，主要是源于团队内落地<code>Docker-Compose</code>时的一次经历，当时有台虚拟机偶尔会出现<code>IP</code>被篡改的情况，而罪魁祸首居然是<code>Docker-Compose</code>，虽然最终用主机模式勉强解决了这个问题，可终究留下了难以言说的疑问，此刻，大概能稍微对<code>Docker</code>的网络有点了解。果然，越靠近底层，就是越是抽象、越是难以理解。</p>
<h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>本文分享了<code>Docker</code>及<code>Docker-Compose</code>中的进阶使用技巧，主要探索了服务编排场景下容器的启动顺序、健康检查、网络模式三类问题。默认情况下，<code>Docker-Compose</code>的<code>depends_on</code>选项，取决于容器是否处于<code>running</code>状态，因此，当我们有多个服务需要启动时，实际上启动顺序并不会受到<code>depends_on</code>选项的影响，因为此时容器都是<code>running</code>的状态。为了解决这个问题，官方提供了 <a target="_blank" rel="noopener" href="https://github.com/vishnubob/wait-for-it">wait-for-it</a> 的方案，这是一种利用 <a target="_blank" rel="noopener" href="http://netcat.sourceforge.net/">Netcat</a> 对<code>TCP</code>和<code>UDP</code>进行检测的机制，当检测条件被满足的时候，它会执行由用户指定的启动脚本。从这里看，其实已经有了一点健康检查的影子，而官方的健康检查，则允许用户使用更加自由的命令或者脚本去实现检测逻辑，所以，从这个角度上来讲，<code>HEALTHCHECK</code>结合<code>depends_on</code>，这才是实现容器启动顺序控制的终极方案。<code>Docker</code>的网络是一个相对复杂的概念，所以，这里就是简单的介绍了下常见的四种网络模式，更深入的话题比如网络驱动等，还需要花时间去做进一步的探索。本文示例以上传至<a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2021/tree/master/src/DockerTips">Github</a>，供大家参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-08-14-yijia-design-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-08-14-yijia-design-problem/" itemprop="url">宜家的设计问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-14T09:58:50+00:00">
                2021-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="一、序"><a href="#一、序" class="headerlink" title="一、序"></a>一、序</h2><p>宜家是一家优秀的公司，他们为家装和家居设计出模块化、标准化、简约的解决方案。对于大众消费者来说，既保证了基础的品质，又物美价廉。</p>
<p>但是，我一直对宜家的商品展示牌的设计有很大的质疑，分享给大家看看。</p>
<h2 id="二、信息的层次"><a href="#二、信息的层次" class="headerlink" title="二、信息的层次"></a>二、信息的层次</h2><p>苹果的 iOS 7 操作系统从拟物化转向扁平化之后，带动了整个设计理解的改变。大家都习惯去掉各种修饰，用简单的字体，字号来展示重要的信息和信息层次。</p>
<p>宜家也是这样。下图是宜家的餐厅。</p>
<ul>
<li>你一眼能够看到的是餐厅，然后紧接着看到的是热销的商品名、图片、价格。</li>
<li>特价商品的价格有一个特殊的底色。</li>
<li>英文名、售卖的单位相对不重要，用较小的字体显示。</li>
</ul>
<img src="/images/yijia-1.jpg" class="">

<p>这是一个特优秀的、具有良好信息层次的案例。</p>
<h2 id="三、有问题的设计"><a href="#三、有问题的设计" class="headerlink" title="三、有问题的设计"></a>三、有问题的设计</h2><p>但是宜家也有一些有问题的设计，比如他们对于每件商品的介绍图：</p>
<img src="/images/yijia-2.jpg" class="">

<p>在上图中：</p>
<ul>
<li>第一重要的信息是：价格。这个没问题。</li>
<li>第二重要的信息，居然是这个商品的瑞典名，和根据瑞典名的发音直接音译过来的汉字。</li>
<li>第三重要的信息，才是这个商品的中文名：“儿童椅”，可以看到这个明显字体小了一号。</li>
</ul>
<p>把瑞典名和音译名当作第二重要信息，是不对的。因为在中国会瑞典语的人实在太少，同时音译名基本上不具有理解和记忆效果。我去过几十次宜家，没有记住任何他们家的音译名。</p>
<p>类似的问题在很多地方都有，比如这个促销海报墙：</p>
<img src="/images/yijia-3.jpg" class="">

<p>除了最重要价格，接下来加粗黑体的，也是瑞典名和音译的中文。</p>
<p>想知道“贝利帕姆”是什么？你需要再看下一行，你才知道它其实是：“被套和枕套”。这非常糟糕，信息效率很低。而且“被套和枕套”的字体是小一号的，说明设计者认为这个不重要。</p>
<img src="/images/yijia-5.jpg" class="">


<h2 id="四、正确的设计"><a href="#四、正确的设计" class="headerlink" title="四、正确的设计"></a>四、正确的设计</h2><p>那应该怎么改呢？除了价格，最重要的信息就是这个商品的中文意义，所以应该把中文意义大写。瑞典语和音译，不重要，应该用较小的字体。</p>
<p>在宜家也能见到这种正确的设计，如下图：</p>
<img src="/images/yijia-4.jpg" class="">

<p>除了价格，商品名“靠垫”被用了最大的字体，间距和位置也偏中部一些，更容易被注意到。</p>
<p>这就是一个正确的信息层次设计，不过我很好奇这种设计偏少，更多的是有问题的设计。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>“中文意义的商品名” 比 “瑞典名和音译的中文” 更加重要，应该在信息位置和字号上给予更加显眼的展现。</p>
<p>就酱。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-08-10-how-to-sell-product/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-08-10-how-to-sell-product/" itemprop="url">销售如何卖出产品</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-10T15:15:10+00:00">
                2021-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我发现同销售相关的同事聊天的时候，同事总会强调缺少活动，缺少赠品，缺少优​惠。当有了活动、赠品、优惠之后，销售同事又会强调缺少新的活动、缺少新赠品、​缺少新优惠。</p>
<p>在这些同事看来，这些抓手不但是转化成单的必不可少的工具，甚至是​致胜的法宝。​缺少了这个，成单会非常受限制。</p>
<p>我能理解这种归因，这种归因来源于以下几点：</p>
<ul>
<li>相比没有赠品或者优惠。这部分的加成确实对转化率能够有一个明显的提升。这其实类似于产品降价。很明显，价格越低，转化率就会越高。</li>
<li>消费者与销售沟通的最后，都会秉着占便宜的心态，寻求赠品或者优惠。这种习惯是中国长久以来的双 11 等各种营销活动给培养起来的。在消费者看来，没有优惠是奇怪的。但是因为消费者每次都这么问，销售就会被反复心理暗示：顾客看重赠品和优惠。</li>
<li>从人性来讲，个体在提升 KPI 的时候，寻求外部资源，特别是免费资源是一种常见的行为。销售为了提升转化，在没有任何成本的情况下，他要求运营持续提供新活动、新赠品、新优惠是一种看起来只有加分没有减分的事情。</li>
</ul>
<p>但是，以上理由都不能证明，这种事情是最好的销售手段。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这种强调活动、赠品、优惠的销售活动有两个巨大的问题。</p>
<p>问题一：它模糊了销售的宣传主体。销售会潜意识觉得用户是为优惠和赠品买单，而不是为产品本身买单。所以这会弱化产品本身的宣传。而产品才是用户真正购买的东西，不强调这部分的内容，本身会影响用户对于产品的理解和认知。销售应该花大力气介绍产品本身是如何好，而不是花大力气介绍赠品有多好。</p>
<p>问题二：它带来了巨大的运营、产研和供应链成本。</p>
<ul>
<li>任何新花样的活动都是需要运营、研发与供应链配合才能上线的。如果一次活动仅仅用几周就下线，这就造成极大的人力浪费。</li>
<li>任何新的赠品都是需要供应链研发或采购的。这也需要付出足够的精力才能做好。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们应该不断给销售强化宣传产品本身的价值。产品本身的价值可以通过多种方式来反复介绍。比如我们可以介绍：</p>
<ul>
<li>产品研发的过程。</li>
<li>产品获奖的新闻。</li>
<li>用户优秀体验的案例。</li>
<li>询问用户对于这类产品的需求，对于我们解决方案的疑惑。</li>
<li>我们对于用户的理解，对于产品的理解。</li>
</ul>
<p>以上信息，需要做到不过度营销、骚扰，不让用户反感。</p>
<p>我们要相信：用户下单，本质上还是基于对产品本身的喜爱和认可，没有别的。</p>
<p>当然，最后我们可能需要有一个优惠来关单，这是有效的，但没必要反复改变这个优惠。所以，我们要控制关单相关的资源和成本，让销售把精力都放在介绍产品本身上。</p>
<p>以上。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/blog-theme-dark-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/blog-theme-dark-mode/" itemprop="url">博客主题可以自动切换深色模式啦</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-08T19:05:00+00:00">
                2021-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>有时候我也很佩服自己，这么简单的一个功能，写写也就几个小时，一年多前就想搞了，竟然给我拖到现在才装上去。拖延症，恐怖如斯！</p>
<p>以前我对深色模式其实不怎么感冒，主要感觉开了也没啥用，就系统界面变黑了，其他 App 里还是白色的，等于没开。不过这几年大部分应用的适配都跟上来了，体验也就好起来了，晚上玩手机看着不那么刺眼，挺好的。</p>
<p>现在浏览器网页也支持检测用户的系统主题色，所以我也凑个热闹，给博客加上了自动切换浅色&#x2F;深色主题的功能。适配过程还是挺顺利的，记录一下供参考。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/blog-theme-dark-mode/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%20gRPC%20%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%20gRPC%20%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86/" itemprop="url">ASP.NET Core 搭载 Envoy 实现 gRPC 服务代理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-08T14:49:47+00:00">
                2021-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在构建以 gRPC 为核心的微服务架构的过程中，博主曾经写过一篇名为 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2167892202/">ASP.NET Core gRPC 打通前端世界的尝试</a> 的文章，主要是希望打通 gRPC 和 前端这样两个异次元世界，因为无论我们构建出怎样高大上的微服务架构，最终落地的时候，我们还是要面对当下前后端分离的浪潮。所以，在那篇文章中，博主向大家介绍过 gRPC-Web 、gRPC-Gateway 、封装 API 、<a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/Grpc.Gateway">编写中间件</a> 这样四种方案。我个人当时更喜欢编写中间件这种方案，甚至后来博主进一步实现了 gRPC 的 “扫描” 功能。</p>
<p>当时，博主曾模糊地提到过，Envoy 可以提供容器级别的某种实现，这主要是指 Envoy 独有的 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">gRPC-JSON Transcoder</a> 功能。考虑到 Envoy 是一个同时支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2 的代理软件，所以，它天然地支持基于 HTTP&#x2F;2 实现的 gRPC。所谓 gRPC-JSON Transcoder，其实指 Envoy 充当了 JSON 到 Protobuf 间互相转换的角色，而它利用的正是 Envoy 中的 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">过滤器</a> 这一重要组件。好了，在今天这篇文章中，博主就为大家介绍一下这种基于 Envoy 的方案，如果大家困惑于如何把 gRPC 提供给前端同事使用，不妨稍事休息、冲一杯卡布奇诺，一起来探索这广阔无垠的技术世界。</p>
<h1 id="从-Envoy-说起"><a href="#从-Envoy-说起" class="headerlink" title="从 Envoy 说起"></a>从 Envoy 说起</h1><p>开辟鸿蒙，始有天地。上帝说，要有光，于是，就有了光。而故事的起源，则要追溯到我们最早提出的那个问题：假设我们有下面的 gRPC 服务，我们能否让它像一个 JSON API 一样被调用？ 通过查阅 Protobuf 的 <a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto3#json">官方文档</a>，我们可以发现 Protobuf 与 JSON间存在着对应关系，这是两者可以相互转化的前提。博主在编写 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/qinyuanpei/Grpc.Gateway/blob/master/src/Grpc.Gateway/GrpcExtensions.cs">中间件</a> 时，同样借助了 Protobuf 暴露出来的接口 <a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn">MessageParser</a>：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> csharp_namespace = <span class="string">&quot;GrpcService&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> greet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，这个 gPRC 服务如何和 Envoy 这个代理服务器产生关联呢？首当其冲的自然是一个路由啦：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">&quot;/greet&quot;</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">timeout:</span> </span><br><span class="line">      <span class="attr">seconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>这表示以 <code>/greet</code> 开头的请求会被路由到 <code>grpc_service</code> 这个集群，如果按照一般的 Envoy 使用流程，接下来，我们只需要配置对应的集群节点即可。我们前面提到过，Envoy 的这个 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">gRPC-JSON Transcoder</a> 功能，是通过过滤器来实现的，更确切地说，它是一个 HTTP 级别的过滤器，所以，我们继续耐心往下看：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.grpc_json_transcoder</span></span><br><span class="line">  <span class="attr">typed_config:</span></span><br><span class="line">    <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder</span></span><br><span class="line">    <span class="attr">proto_descriptor:</span> <span class="string">&quot;/etc/descriptor/greet.pb&quot;</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;greet.Greeter&quot;</span></span><br><span class="line">    <span class="attr">print_options:</span></span><br><span class="line">      <span class="attr">add_whitespace:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_primitive_fields:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">always_print_enums_as_ints:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">preserve_proto_field_names:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">auto_mapping:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure>
<p>可以注意到，这里使用了一个叫做 <code>envoy.filters.http.grpc_json_transcoder</code> 的过滤器。对于这个过滤器而言，核心的、需要注意的地方有两个：</p>
<ul>
<li><code>proto_descriptor</code> 指向一个 Protobuf 的描述文件，这是一个二进制文件，可以由<code>protoc</code>编译器生成。</li>
<li><code>services</code> 表示一组服务，必须按照 <code>包名.服务名</code> 的格式进行填写，这里的示例为：<code>greet.Greeter</code>。</li>
</ul>
<p>关于如何生成二进制的 Protobuf 描述文件，我们专门放在下一节来讲，在此基础上，我们只要增加集群即可完成 Envoy 的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc_service</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LOGICAL_DNS</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="attr">dns_lookup_family:</span> <span class="string">V4_ONLY</span></span><br><span class="line">  <span class="attr">http2_protocol_options:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">upstream_connection_options:</span></span><br><span class="line">    <span class="attr">tcp_keepalive:</span></span><br><span class="line">      <span class="attr">keepalive_time:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">grpc_service</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">grpc_service</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>完整的 Envoy 配置文件，请参考 <a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2021/tree/master/src/EnvoyGrpc">这里</a>，不再占用篇幅进行说明。</p>
<h1 id="准备描述文件"><a href="#准备描述文件" class="headerlink" title="准备描述文件"></a>准备描述文件</h1><p>生成 Protobuf 的二进制描述文件，需要借助 <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">protoc</a> 这个命令行工具，此前我们介绍 gRPC 生态中的 gRPC-Web、gRPC-Gateway 时曾经接触过它。Envoy 正是通过这个描述文件来处理 <code>JSON</code> 和 <code>Protobuf</code> 的相互转换，博主猜测这里可能用到了类似 <a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/reference/csharp/class/google/protobuf/message-parser?hl=zh-cn">MessageParser</a> 的东西，Envoy 从这个二进制的描述文件中获取 gRPC 的元数据信息，并由此从 <code>JSON</code> 构建出 <code>Protobuf</code>。这里，我们还是以本文开始的 <code>.proto</code>文件为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --descriptor_set_out=./Protos/descriptor/greet.pb --include_imports Protos\greet.proto</span><br></pre></td></tr></table></figure>
<p>这条命令行的含义是，为 <code>Protos\greet.proto</code> 生成对应的服务描述文件 <code>/Protos/descriptor/greet.pb</code>。下图即为博主生成的服务描述文件：</p>
<p><img src="https://i.loli.net/2021/08/08/lhPofJFKytHGWja.png" alt="通过命令行生成 Protobuf 描述文件"></p>
<p>此时，我们只需要将其放到 Envoy 的目录中即可，本文中的示例位于以下路径：<code>/etc/descriptor/greet.pb</code>。好了，现在 Envoy 和 gRPC 均已就绪，我们通过 <code>docker-compose</code> 对服务进行编排：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoygateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">grpcservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">GrpcService/GrpcService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br></pre></td></tr></table></figure>
<p>启动服务后，如果我们像调用 gRPC 服务中的 <code>SayHello()</code>方法，此时，对应的路由为：<code>/greet.Greeter/SayHello</code>，即：<code>包名.服务名/方法名</code>。好了，我们用 Postman 或者 Apifox 对接口进行测试：</p>
<p><img src="https://i.loli.net/2021/08/08/RZpux1nwWDh6eJK.png" alt="像调用一个 JSON API 一样调用 gRPC "></p>
<p>至此，我们实现一开始的目的，通过 Envoy 代理 gRPC 服务以后，对于前端而言，它已不再关心，这个服务背后的服务提供者到底是什么？因为对它而言，JSON API 还是 Protobuf 已经完全没有差别。博主曾经评价它是容器级别的方案，因为它可以将多个 gRPC 服务统一到一个入口中，非常适合充当整个微服务的网关，如果你正在使用 gRPC，相信我，这会是一条必由之路。</p>
<p>目前，博主所在的公司，已经全面采用了这种方案，而博主则进一步在团队中推广了<code>Docker-Compose</code>，换言之，我们将多个微服务通过<code>Docker-Compose</code>进行编排，并通过 Envoy 为所有微服务提供统一入口，唯一的遗憾是，通过<code>protoc</code>生成服务描述文件这个过程没有纳入到 CI&#x2F;CD 环节，靠手动生成、复制服务描述文件，到底还是会有点失落呢？如果结合前面分享过的 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/731808750/">Envoy 身份认证</a>，整个微服务架构终于看起来形成闭环啦！</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了 Envoy 中的 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter">gRPC-JSON Transcoder</a> 功能，它可以将一个 gRPC 服务代理成一个 JSON API，从而方便前端或者是客户端去消费一个 gRPC 服务。其原理是，Envoy 中可以通过配置过滤器来实现 JSON 和 Protobuf 的相互转换，这一过程依赖 Protobuf 的元数据，故而，我们需要通过命令行工具<code>protoc</code>生成服务描述文件，我们只需要在 Envoy 中添加相关配置，就可以像调用一个 JSON API 一样调用 gRPC。至此， gRPC 与 Web 世界彻底打通，我们可以用我们熟悉的技术去消费一个 gRPC 服务。博主的 <a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/Grpc.Gateway">Grpc.Gateway</a> 实现了类似的功能，如果大家感兴趣，欢迎大家前去体验一番。好了，以上就是这篇博客的全部内容啦，谢谢大家，祝各位晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E5%86%8D%E8%AF%9DAOP%EF%BC%8C%E4%BB%8E%E7%AE%80%E5%8C%96%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%E8%AF%B4%E8%B5%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E5%86%8D%E8%AF%9DAOP%EF%BC%8C%E4%BB%8E%E7%AE%80%E5%8C%96%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%E8%AF%B4%E8%B5%B7/" itemprop="url">再话 AOP，从简化缓存操作说起</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-04T12:49:47+00:00">
                2021-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>AOP，即：<strong>面向切面编程</strong>，关于这个概念，博主其实写过好几篇<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/tags/AOP/">博客</a>啦！从这个概念，我们可以引申出诸如代理模式、动态代理、装饰器模式、过滤器、拦截器等等相互关联的概念。从实现方式上而言，微软官方的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/previous-versions/dotnet/articles/ms973857(v=msdn.10)?redirectedfrom=MSDN">.NET Remoting</a> 提供了真实代理和透明代理的支持，我们熟悉的 <code>WebService</code> 和 <code>WCF</code> 均和这项技术息息相关，作为最早的分布式 RPC 解决方案，其本身更是与客户端的动态代理密不可分。或许，各位曾经接触过 <code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a target="_blank" rel="noopener" href="https://www.postsharp.net/">PostSharp</a> 等等这些支持 AOP 特性的库，那么，我们是否已经抵达了 AOP 的边界呢？事实上，如果你仔细研究过 <code>Stub</code> 和 <code>Mock</code> 这样两个术语，你就发现 AOP 的应用范围远比我们想象的宽广。今天这篇文章，我不打算再介绍一遍这些第三方库的“<strong>奇技淫巧</strong>”，我更想聊聊，如何通过 AOP 来简化一个缓存操作。</p>
<p>缓存，一个面试时命中率 100%的话题，曾记否？来自面试官的灵魂发问三连：<strong>缓存击穿</strong>、<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>。与此同时，缓存是一个令人爱恨交加的东西，其一致性、持久化、高可用等等，均是实际应用中需要去考虑的东西。狭义的缓存主要指 <a target="_blank" rel="noopener" href="https://redis.io/">Redis</a>、<a target="_blank" rel="noopener" href="https://www.memcached.org/">Memcached</a> 等分布式缓存系统，而广义的缓存则可以是 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/response?view=aspnetcore-5.0">HTTP 响应缓存</a>、EF&#x2F;EF Core 查询缓存、二级缓存等等。我们都知道，使用缓存可以显著地提升软件性能，而究其本质，则是因为减少了和数据库交互的频次。于是，我们注意到，大多数的缓存代码，都是下面这样的风格：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheKey = <span class="string">&quot;GetAllStudents&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line"><span class="keyword">var</span> cacheValue = distributedCache.GetString(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(cacheValue))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 未命中缓存：从数据库查询数据 + 写缓存</span></span><br><span class="line">    students = repository.GetAll().ToList();</span><br><span class="line">    <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(students));</span><br><span class="line">    distributedCache.Set(cacheKey, bytes);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 命中缓存：读缓存</span></span><br><span class="line">    students = JsonConvert.DeserializeObject&lt;List&lt;Student&gt;&gt;(cacheValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> students;</span><br></pre></td></tr></table></figure>

<p>正所谓：大道至简，“<strong>高端的食材，往往只需要最朴素的烹饪方式</strong>”。故而，最朴素的思想就是，首先从缓存中查询数据，如果数据存在则直接返回，否则从数据库中查询数据，并执行一次写缓存操作。这的确是个朴实无华的方案，因为我们每一次都要写这样的代码，其程度丝毫不亚于永远不会缺席的 <code>xxx != null</code>。写到这里，博主不由得陷入了沉思：难道真的没有更简单点的方案了吗？后来的故事大家都知道了，我们可以在方法的参数上附加 <code>[NotNull]</code> 特性。所以，接下来，我们会用类似的方案来解决缓存的问题，换言之，我们可以把我们经常写、写到不愿意再写的代码交给代理类来做，既然缓存本质上是为了查询数据，那我们就只需要关心查询数据这个行为本身。具体怎么实现的呢？我们一起来看下面的代码。</p>
<p>此时此刻，假设我们有这样一个接口：<code>IFakeService</code>，它通过<code>GetColors()</code>方法返回一组颜色：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Cacheable(CacheKeyPrefix = <span class="string">&quot;Fake&quot;</span>, Expiration = 180)</span>]</span><br><span class="line">    <span class="function">List&lt;<span class="built_in">string</span>&gt; <span class="title">GetColors</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望，在调用这个方法的时候，可以对其返回值进行缓存，所以，可以注意到，这里添加了一个<code>[Cacheable]</code>的特性。其定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CacheableAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CacheKeyPrefix &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Expiration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>CacheKeyPrefix</code>用于指定缓存键名前缀，<code>Expiration</code>用于指定缓存过期时间，单位为秒。接下来，博主通过<code>DispatchProxy</code>来实现动态代理，它可以视为<code>RealProxy</code>在后.NET 时代的替代品：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CacheInterceptor</span>&lt;<span class="title">TCacheService</span>&gt; : <span class="title">DispatchProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> TCacheService _realObject =&gt; ServiceProvider.GetRequiredService&lt;TCacheService&gt;();</span><br><span class="line">    <span class="keyword">private</span> ICacheSerializer _cacheSerializer =&gt; ServiceProvider.GetRequiredService&lt;ICacheSerializer&gt;();</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _distributedCache =&gt; ServiceProvider.GetRequiredService&lt;IDistributedCache&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IServiceProvider ServiceProvider &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">Invoke</span>(<span class="params">MethodInfo targetMethod, <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] cacheValue;</span><br><span class="line">        <span class="keyword">var</span> returnType = targetMethod.ReturnType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// void &amp;&amp; Task</span></span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">typeof</span>(<span class="keyword">void</span>) || returnType == <span class="keyword">typeof</span>(Task))</span><br><span class="line">            <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">            returnType = targetMethod.ReturnType.GetGenericArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cacheableAttribute = targetMethod.GetCustomAttribute&lt;CacheableAttribute&gt;();</span><br><span class="line">        <span class="keyword">if</span> (cacheableAttribute != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cacheKey = GetCacheKey(cacheableAttribute, targetMethod);</span><br><span class="line">            cacheValue = _distributedCache.Get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">                <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                    <span class="keyword">return</span> Task.FromResult(_cacheSerializer.Deserialize(cacheValue, returnType));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _cacheSerializer.Deserialize(cacheValue, returnType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dynamic</span> returnValue = targetMethod.Invoke(_realObject, args);</span><br><span class="line">            cacheValue = _cacheSerializer.Serialize(returnValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Task&lt;T&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (IsAsyncReturnValue(targetMethod))</span><br><span class="line">                cacheValue = _cacheSerializer.Serialize(returnValue.Result);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cacheOptions = <span class="keyword">new</span> DistributedCacheEntryOptions() &#123; </span><br><span class="line">              AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(cacheableAttribute.Expiration) </span><br><span class="line">            &#125;;</span><br><span class="line">            _distributedCache.Set(cacheKey, cacheValue, cacheOptions);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetMethod.Invoke(_realObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，最为关键的地方是<code>Invoke()</code>方法，它负责对被代理对象的方法进行拦截，这里的被代理对象，其实就是<code>_realObject</code>，即真实对象，因为，我们最终调用的，实际上是真实对象上对应的方法。因为<code>DispatchProxy</code>在创建代理对象时，要求这个代理基类，即这里的拦截器，必须要有一个无参的构造函数。所以，我们这里用属性注入的方式来注入<code>IServiceProvider</code>。说回这个方法，首先，我们会判断它的返回值类型是不是<code>void</code>或者<code>Task</code>，因为无返回值的方法本身就不需要缓存。接下来，我们会检查当前方法上是否附加了<code>[Cacheable]</code>特性，因为我们只需要处理有这个特性的方法。接下来，通过<code>GetCacheKey()</code>方法来生成一个唯一的键名，通过这个键名我们就可以在缓存中查询数据啦，该方法的实现细节如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetCacheKey</span>(<span class="params">CacheableAttribute cacheableAttribute, MethodInfo methodInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> segments = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(cacheableAttribute.CacheKeyPrefix))</span><br><span class="line">        segments.Add(cacheableAttribute.CacheKeyPrefix);</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.DeclaringType.FullName.Replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>));</span><br><span class="line"></span><br><span class="line">    segments.Add(methodInfo.Name);</span><br><span class="line"></span><br><span class="line">    methodInfo.GetParameters().ToList().ForEach(x =&gt; segments.Add(x.Name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;_&quot;</span>, segments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于分布式缓存，博主这里使用的是微软提供的<code>IDistributedCache</code>这个接口，接下来的事情就变得朴实无华起来，因为它和我们一开始写的代码一脉相承，唯一的不同是，这里考虑了<code>Task&lt;T&gt;</code>这种异步的返回值类型，同时对序列化&#x2F;反序列化进行了抽象，即这里注入的<code>ICacheSerializer</code>接口，注意到<code>IDistributedCache</code>接口的<code>Set()</code>方法需要传入一个<code>byte[]</code>，显然二进制的序列化方案如 <a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers?hl=zh-cn">Protobuf</a> 、<a target="_blank" rel="noopener" href="https://msgpack.org/">MessagePack</a> 会更加得心应手一点。所以，我们将这一层单独抽象出来。至此，我们已经完成了最核心的部分。</p>
<p>对于一开始的<code>IFakeService</code>，我们提供一个简单的实现，并通过让线程阻塞的方式来模拟一个耗时操作：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeService</span> : <span class="title">IFakeService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetColors</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Yellow&quot;</span>, <span class="string">&quot;Green&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个简单的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入IFakeService、ICacheSerializer、IDistributedCache</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;IFakeService, FakeService&gt;();</span><br><span class="line">services.AddTransient&lt;ICacheSerializer, JsonCacheSerializer&gt;();</span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Configuration = <span class="string">&quot;localhost:6379&quot;</span>;</span><br><span class="line">    options.InstanceName = <span class="string">&quot;Caching.AOP.Test&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> fakeServiceProxy = DispatchProxy.Create&lt;IFakeService, CacheInterceptor&lt;IFakeService&gt;&gt;();</span><br><span class="line">(fakeServiceProxy <span class="keyword">as</span> CacheInterceptor&lt;IFakeService&gt;).ServiceProvider = serviceProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    <span class="keyword">var</span> colors = fakeServiceProxy.GetColors();</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123;i&#125;</span> - Invoke GetColors used <span class="subst">&#123;stopWatch.Elapsed.TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们可以得到下面的结果，可以注意到，第一次调用的时候，因为缓存不存在，调用的时间相对更长一点，而当缓存存在的时候，调用的时间会明显缩短。</p>
<p><img src="https://i.loli.net/2021/08/04/FdafGyS7zrl53W1.png" alt="有无缓存对调用时长的影响"></p>
<p>虽然这个性能提升与缓存不无关系，可对于调用者来说，它完全不用关心缓存里有没有数据这件事情，它只需要像往常一样调用接口方法即可，这就是 AOP 之于缓存的意义所在，为了证明我没有说谎，我们可以看到 Redis 中对应的数据：</p>
<p><img src="https://i.loli.net/2021/08/04/wkAQGMRKr8xuol3.png" alt="Redis中对应的缓存数据"></p>
<p>需要说明的是，这个思路同样可以扩展到<code>Unity</code>、<code>Castle</code>、<code>AspectCore</code>、<a target="_blank" rel="noopener" href="https://www.postsharp.net/">PostSharp</a> 这些第三方库，实现方式上大同小异，大家可以结合自己的业务场景做相应的调整。其实，从业务上抽离出通用组件、功能作为公共库或者下沉到框架中，是及其自然而然的一件事情。这里面最关键的问题是，基础组件或者框架相对于业务方的职责范围，因为如果基础组件或者框架做得太多，业务上往往难以定制或者扩展；而如果基础组件或者框架做得太少，业务上就要写大量的辅助代码。写这篇文章的原因是，我对于一个缓存方案设计上的疑问，业务上想要缓存一张表中的数据，至少需要写 20 行代码，在下觉得这简直太离谱了，更不用说，业务方还要关心这个缓存是否可用。有人说，一个合格的前任就应该像死了一样，那么，我是不是可以说，一个合格的中间件，就应该像它从来没有来过一样，你甚至都感觉不到它的存在，可事实上它总是无所不在。也许，这听起来有点科幻的色彩，可这的确是我期待的某种自洽的、优雅的设计思路。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分享了通过 AOP 来简化缓存操作的一种思路，考虑到常规的缓存代码写法，读&#x2F;写缓存与业务代码严重耦合在一起，而博主心目中的缓存应该像水、电、煤气一样普普通通，你只需要告诉我哪些数据需要缓存，而无需关心这些数据怎么缓存。基于这样一种考虑，博主基于<code>DispatchProxy</code>实现了一个针对缓存的 AOP 方案，我们只需要在接口上打上<code>[Cachable]</code>标签，它会自动对方法的返回值进行缓存，从而简化我们平时使用缓存的流程。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994">Catcher Wong</a> 大佬在其缓存框架 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/p/10806607.html">EasyCaching</a> 同样集成了这一特性，如果大家有类似的使用场景，可以直接使用这个<a target="_blank" rel="noopener" href="https://github.com/dotnetcore/EasyCaching">框架</a>。如果大家对此有更好的想法或者思路，欢迎大家在评论区留言，本文示例已上传至 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/Caching.AOP">Github</a>，供大家学习或者参考。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/several-certificates-got-recently/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/several-certificates-got-recently/" itemprop="url">最近考的几个证：软考、N1 和驾照</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-02T08:16:00+00:00">
                2021-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>学习使我快乐。才怪。</p>
<p>要不是为了多少增加点竞争力，我又何必折腾自己去考这些证。快要大学毕业找工作了，最近这段时间明显感觉自己比以前焦虑了不少。俗话说得好，打不过就加入。虽然也不知道这些证以后能不能派上用场，不过总比没有好，万一用上那就是赚了。</p>
<p>这次考的几个其实我都没有花很多时间准备，不过所幸还是都拿到手了。所以记录一下感想，也顺便给博客除除草。在网上说这些其实无异于增加实名上网的风险……不过 fxck it，随他去吧。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/several-certificates-got-recently/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%B4%97%E8%A1%A3%E9%9A%8F%E6%83%B3%E6%9B%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%B4%97%E8%A1%A3%E9%9A%8F%E6%83%B3%E6%9B%B2/" itemprop="url">洗衣随想曲</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-01T16:13:48+00:00">
                2021-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>对我而言，洗衣服是周末的例行活动，尤其是在炎热的夏天。也许，你会自顾自地说，衣服不必攒到周末去洗，如果你愿意下班后腾出一点时间。可人的惰性，正如在太阳底下会流汗一般寻常，如果我愿意，你也许会早一点看到，这些只在周末显得安静的文字。</p>
<p>换这部手机时，店家附赠了一只蓝牙音响，带着物尽其用的想法，先后用它来听网易云、听微信读书、听 TED。于是，在一刹那间，水龙头里的流水声、拧干衣服时的水花声、我脑海里的闪念的低吟声，都成为这只麦克风的伴奏。我开始黯然失色，这听来听去，大概是在听寂寞在唱歌。果然，微信听书的效果并不好，那机械而平静的合成音，甚至还不如地铁上的播报充满感情。最为致命的问题，微信听书像极了听老师讲课：书读完了吗？读完了！还记得讲了什么吗？完全不记得！</p>
<p>现实生活可不像武侠世界，没有那么多无招胜有招的奇遇。所以，有一段时间，我总觉得用听书这种方式来读书，像极了姜太公钓鱼——愿者上钩。五柳先生，好读书而不求甚解，因为观其大略，而这连看都不愿意看一眼，简直就是自欺欺人。如此反复折磨自我，发现听演讲居然是最适合打发时间的方式，特别是洗衣服的这段时间。仔细一想，大概是演讲更能做到声情并茂，古人一桌、一椅、一扇、一抚尺，就能讲一个沉浸感十足的故事。而我们从文字到图片再到视频，仿佛都不足以表达自我。在百家争鸣的战国时代，不管是合纵&#x2F;连横的策略，还是法、儒、墨、兵各家，我们能听见不同的声音，虽然表达方式不过是竹简。</p>
<p>可今天，我们好像陷入了一个信息黑洞，网络上的信息越来越嘈杂，原本代表着开放与连接的互联网，在一个又一个的小圈子里，正在走向越来越封闭的局面。譬如，喝茶与喝咖啡，从生物学上来讲这两个行为间并无差异，可人与人之间就是会形成所谓的鄙视链，甚至连咖啡本身都会形成这种鄙视链，手冲和速溶，本质上有什么不一样吗？圈子文化的盛行，让圈子本身更加封闭，隐形门槛的提高，让圈子外的人更加不能理解圈内人的行为，比如汉服与 JK，本质上不就是一件衣服吗？可人定要分出个山(寨)与正(品)的差别。人与人的关系，大致可以理解为相互炫耀、相互鄙视，而不同群体间的互相鄙视，其实加速了整个互联网的割裂，男女对立、饭圈文化……，无一不是这种割裂感的具体产物。</p>
<p>鲁迅先生写道，“<strong>人类的悲欢并不相通，我只是觉得他们吵闹</strong>”。人类想要互相理解彼此，除了感同身受以外，大概只有放下强烈的个人意识这一条路。可做一个精致的利己主义者，又有什么不好吗？只要我们不因为远方的声音让这个世界频频陷入大火，自私一点又有什么关系呢？罗曼蒂克不会消亡，只是我们对罗曼蒂克的要求变得越来越高。翻开历史，人类几千年的文明，一样是在这种割裂和封闭的状态下延续着，梁武帝从信佛到灭佛，汉武帝罢黜百家独尊儒术，商鞅因法而兴由法而灭……儒家与道家尚不能共治，巴基斯坦和印度更是势如水火……人们推倒了篱墙，再重新筑起篱墙，周而复始，反反复复。我由衷地想念那个百家争鸣的时代，人们有耻食周栗的觉悟、有伯牙绝弦的深情、有横槊赋诗的豪情……古人寿命不及我们、生活不如我们，可这几千年的精神世界，都是他们留给我们的。</p>
<p>不同于被生活磨去棱角的年轻人，一开口就是房子、车子和孩子。要知道，子在过去可是一种敬词，孔孟不必多说，老庄无须多言，前有张子连横六国，后有苏子遨游赤壁，这是否意味着，古人的精神世界远比我们丰富，毕竟我们都太枯燥了。有时候，我在地铁上看到别人面无表情地刷着抖音，如果说圈子本身让我们变得狭隘，那么信息茧房无疑会让我们变得愚蠢。你说，这个地球是不是变得越来越小，可明明我们还没有走过所有地方，不曾见过亚马逊的热带雨林，不曾见过极地的奇幻光影，不曾见过东非的荒漠草原……我们实在太容易相信那就是全部了，因为别人都这样过每一天，因为随大流不需要花时间思考什么，因为只此一次的生命实在过于短暂……越来越觉得，结婚就是用高昂的沉没成本，来阻止人们试错，每一步都走得小心翼翼的人，步步生莲，莲是三寸金莲的莲，虽然我们有耐克、有鸿星尔克、有美特斯邦威。</p>
<p>我喜欢逛西安这座城市的书店，因为传统书店愈发没落的今天，它需要找到一种物质和精神上的平衡，可人何尝又不是这样？每当我漫步在不同的商场，我忽然觉得，我们只是以为自己有那么多的选择，越来越多的餐饮像是流水线一般，我们寻找的那份属于自己的独特，早已在机器的转动声中消失殆尽。于是，人们开始复兴手工制作，越来越多的商家，开始在招牌上加上手工的字样。也许，现代和传统就是这样两个相互鄙视的圈子，它们互相鄙视，而又反复横跳。其实，单以甜点而论，我更喜欢中式的点心，大概是因为那些西式点心的名称，说起来要更绕口一点。泡芙、圣代、提拉米苏……像极了你学英语时的样子，每一个单词都认识，放到一起简直不知所云。以前，我在挑选饮料方面选择困难，因为总是记不住那些眼花缭乱的名字，后来手机里装了大众点评，忽然发现，每家商场里的店铺都差不多呢，这大概是一种进步，因为你没有选择。</p>
<p>当年我有一位高中同学，特别喜欢郭德纲的相声，报菜名、说绕口令的技艺相当纯熟，毕业后留在苏州的学而思，据说是变成了一名老师。近来教育培训行业政策有变动，不知道他是否还有心情饶舌一番。说回听书这件小事，那时，听一位作家讲金庸先生的越女剑，联想到武侠的没落，大概有几分道理可言。为什么漫威的超级英雄在这个时代更受欢迎，因为超级英雄们获得能的方式更现代化一点，无论是神话、科技、变异，这都是我们这个时代可以理解的东西，所以，我们能接受通过蛛丝发射器飞檐走壁的蜘蛛侠，唯独接受不了同样靠轻功飞檐走壁的大侠们。因为，没有人能说得清武功的来源。在一个武术成为观赏性项目的时代，我们对武功的理解，不会比神话时代好多少，我们都听过卧薪尝胆的故事，听过博浪飞锥的故事，听过图穷匕首的故事……如果世上真的有武功，大概就像我们认为的战争，对于没有亲身经历的人而言，永远都只能活在想象里，那么，武侠的起源到底从哪里开始呢？</p>
<p>在 B 站看到 30 多年前的西安，隐隐约约可以认出永宁门、大雁塔和钟楼，弹幕里有人打出无人机的字眼，原来，航拍这个词的含义已经等同于无人机，不管那个时候有没有无人机。同样地，现在的小孩会问，怎么通过座机打电话，我会不由得想起初&#x2F;高中住校那几年，和家里联络基本都是靠座机。后来，我们有了直板手机、智能手机，再不必担心两百条短信会用完，再不必掐着时间给家里打电话，可再没有那样愿意陪你发短信的人，一个月下来甚至都打不了几个电话，流量从 5 块钱 30 兆一直涨到几十块钱，可对我来说，无非还是写写字、读读书，和过去相比并没有什么不同。人啊，总有些东西，在默默提醒着你：你在一天天地老去，永远都 18 岁，那比科幻电影还要科幻，除非你能从卷福手里拿到时间宝石。如果回到过去，你会如何和过去的自己谈判呢？我只知道，金庸先生穿越回吴越争霸的时代，他让阿青从白猿身上学到了武功。越王勾践卧薪尝胆、三千越甲吞吴的故事，父亲从小就同我讲过，可他也许不知道金庸先生的这个版本。</p>
<p>阿青被范蠡带入宫中，传授越国剑士精妙剑法，自此帮助越王勾践打败吴国、洗雪前耻，范蠡得以与情人西施重逢，可偏偏阿青喜欢上来了范蠡，没有人能阻挡阿青手中的竹棒，除了西施绝世的容貌，原来她比范蠡描述的还要美。虽然阿青放弃了寻仇，可棒头的内劲儿还是伤到了西施，自此西施落下来心口疼痛的毛病。这大概就是金庸先生心目中武功的缘起，范蠡西施放舟太湖、悠游终生，自此世上有了江湖，果然，这个说法像雷神之锤一样相当有说服力，“那些都是很好很好的，可是我偏偏不喜欢”，某种意义上来讲，功成身退的范蠡比张仪、韩信、商鞅要幸运得多，而这正是历史的迷人之处。什么？你问我衣服洗完了没有？当然洗完了！因为这些闪念，对于一个双子座而言，就像穿衣吃饭一般寻常，唯一的困难在于，我要将它写出来、同时让你看懂，以上！果然是标准的日式结尾呢！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-8-1-mactips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-8-1-mactips/" itemprop="url">提升电脑操作效率的一点心得</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-01T13:00:00+00:00">
                2021-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>文&#x2F;彭宏豪，笔名&#x2F;安哥拉<br>本文首发于公众号「效率工具指南」    </p>
<p>Hello 大家好，我是安哥。</p>
<p>买了 Mac 将近一年，老实说，有点惭愧，我在 Mac 上的操作效率，还是不如用了好多年的 Windows 系统，明明一个在 Windows 上很简单的操作，在 Mac 上可能要多折腾几下，有些甚至到现在还搞不明白。</p>
<p>有点后悔之前为啥不买一个方便携带和移动的 Macbook 了，至少使用的时间能更多一些，而且体验也不会像现在那么隔裂——在公司用 Windows 系统，在家用 macOS 系统。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801201429397.png" alt="image-20210801201429397"></p>
<h2 id="同时打开多个标签页"><a href="#同时打开多个标签页" class="headerlink" title="同时打开多个标签页"></a>同时打开多个标签页</h2><p>我使用电脑上的浏览器，有个习惯，喜欢打开超多的标签页，而且时常因为写文章或者截图的原因，会把某个标签页从众多的标签页中拖拽出来，单独在一个新的浏览器窗口中打开，类似下图右侧的「个人博客」页面。</p>
<p>当浏览器打开的窗口一多，我就会觉得切换起来有些麻烦，至少不如我在 Windows 系统上操作起来那么溜——Windows 底部的任务栏可以很方便地查看我们打开的浏览器窗口。</p>
<p>那么 macOS 上如何快速调出类似下图的页面，方便我们在多个浏览器窗口之间切换呢？</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801202020238.png" alt="image-20210801202020238"></p>
<p>目前我使用的方法是，使用系统的「桌面与屏幕保护程序」中附带的一个小功能「<strong>触发角</strong>」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801202731155.png" alt="image-20210801202731155"></p>
<p>我将桌面右下角的触发角设置为「应用程序窗口」，这样当我处于任意一个浏览器窗口激活的状态下，将鼠标移动到桌面的右下角，就能快速显示我打开的所有浏览器窗口的缩略图，方便我们在同一个应用中的不同窗口间切换。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801202840081.png" alt="image-20210801202840081"></p>
<h2 id="将常用内容添加到置顶列表中"><a href="#将常用内容添加到置顶列表中" class="headerlink" title="将常用内容添加到置顶列表中"></a>将常用内容添加到置顶列表中</h2><p>这是我长期将文章分发到多个平台的过程中，逐渐摸索出来的一点小心得：</p>
<p>在一些内容平台，为了让更多的人知道，你当前在看的这篇文章，首发于我的公众号「效率工具指南」。我一般会在文章开头添加这段<strong>重复的文本内容</strong>：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801203847407.png" alt="image-20210801203847407"></p>
<p>对于常用的文本内容，除了可以使用输入法的「自定义短语」，通过设置快捷键快捷输入，还可以考虑使用「<strong>剪贴板管理</strong>」工具，将常用的文本内容添加到置顶列表中，在需要的时候呼出面板，点击复制，同样可以快速粘贴。</p>
<p>在 Mac 上，我使用的剪贴板管理工具是之前介绍过的 PasteNow，由国内的开发者 @图拉鼎 开发，真的非常好用。</p>
<p>PasteNow 中就内置了「<strong>剪贴板内容置顶</strong>」的功能，你可以将你平时经常会用到的重复性内容，添加到软件的置顶列表中。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210801204128263.png" alt="image-20210801204128263"></p>
<p>这样在你需要用到这段重复性内容的时候，按下 <strong>Command + Shift + V</strong>（选择性粘贴）呼出 PasteNow 的面板，切换到置顶列表，双击要用到的重复性内容，就可以将内容快速添加到指定位置，真的很方便。</p>
<p>Windows 上通过输入法添加「自定义短语」，达到快速插入重复性内容的方法，可参考我之前发布的文章：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BgWZaQ_JK7SxIvJS1p8v2Q">Windows自带的功能这么好用，还装什么第三方软件？</a></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和各位分享的 Mac 上两个高效操作的小心得，希望对你有帮助。    </p>
<p>如果你也知道一些好用的高效操作技巧，欢迎在下方的评论区留言分享，我们下次再见。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP-NET-Core-%E6%90%AD%E8%BD%BD-Envoy-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81(JWT)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP-NET-Core-%E6%90%AD%E8%BD%BD-Envoy-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81(JWT)/" itemprop="url">ASP.NET Core 搭载 Envoy 实现微服务身份认证(JWT)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-25T01:41:24+00:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在构建以 gRPC 为核心的微服务架构的过程中，得益于 Envoy 对 gRPC 的“<strong>一等公民</strong>”支持，我们可以在过滤器中对 gRPC 服务进行转码，进而可以像调用 Web API 一样去调用一个 gRPC 服务。通常情况下， RPC 会作为微服务间内部通信的信使，例如，Dubbo、Thrift、gRPC、WCF 等等更多是应用在对内通信上。所以，一旦我们通过 Envoy 将这些 gRPC 服务暴露出来，其性质就会从对内通信变为对外通信。我们知道，对内和对外的接口，无论是安全性还是规范性，都有着相当大的区别。博主从前的公司，对内的 WCF 接口，长年处于一种”<strong>裸奔</strong>“的状态，属于没有授权、没有认证、没有文档的“<strong>三无产品</strong>”。那么，当一个 gRPC 服务通过 Envoy 暴露出来以后，我们如何保证接口的安全性呢？这就是今天这篇博客的主题，即 Envoy 作为网关如何提供身份认证功能，在这里，我们特指通过JWT，即 Json Web Token 来对接口调用方进行身份认证。</p>
<h1 id="搭建-Keycloak"><a href="#搭建-Keycloak" class="headerlink" title="搭建 Keycloak"></a>搭建 Keycloak</h1><p>对于 <a target="_blank" rel="noopener" href="https://jwt.io/">JWT</a> ，即 Json Web Token ，我想大家应该都非常熟悉了，它是目前最流行的跨域认证解决方案。考虑到，传统的 Session 机制，在面对集群环境时，扩展性方面表现不佳。在日益服务化、集群化的今天，这种无状态的、轻量级的认证方案，自然越来越受到人们的青睐。在 ASP.NET Core 中整合JWT非常简单，因为有各种第三方库可以帮助你生成令牌，你唯一需要做的就是配置授权&#x2F;认证中间件，它可以帮你完成令牌校验这个环节的工作。除此以外，你还可以选择更重量级的 <a target="_blank" rel="noopener" href="https://identityserver4.readthedocs.io/en/latest/">Identity Server 4</a>，它提供了更加完整的身份认证解决方案。在今天这篇博客里，我们使用的 <a target="_blank" rel="noopener" href="https://www.keycloak.org/">Keycloak</a>，一个类似 Identity Server 4 的产品，它提供了一个更加友好的用户界面，可以更加方便的管理诸如客户端、用户、角色等等信息。其实，如果从头开始写不是不可以，可惜博主一时间无法实现 <a target="_blank" rel="noopener" href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets">JWKS</a>，所以，就请大家原谅在下拾人牙慧，关于 JWKS ，我们会在下一节进行揭晓。接触微服务以来，在做技术选型时，博主的一个关注点是，这个方案是否支持容器化。所以，在这一点上，显然是 Keycloak 略胜一筹，为了安装 Ketcloak ，我们准备了如下的服务编排文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7070:8080&quot;</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>.env</code>文件放置了服务编排文件中使用到的环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># KEYCLOAK</span><br><span class="line">KEYCLOAK_USER=admin</span><br><span class="line">KEYCLOAK_PASS=admin</span><br><span class="line"># POSTGRESQL</span><br><span class="line">POSTGRESQL_DB=keycloak</span><br><span class="line">POSTGRESQL_USER=keycloak</span><br><span class="line">POSTGRESQL_PASS=keycloak</span><br></pre></td></tr></table></figure>

<p>此时，我们运行<code>docker compose up</code>命令就可以得到一个 Keycloak 环境，它将作为我们整个微服务里的认证中心，负责对用户、角色、权限、客户端等进行管理。于此同时，接口消费方可以通过 Keycloak 获取令牌、JWKS，而 Envoy 正是利用 JWKS 来对令牌进行校验的。这个 JWKS 到底是何方神圣，我们暂且按下不表。在正式使用 Keycloak 前，我们需要做一点简单的配置工作，具体来说，就是指创建用户、角色和客户端，我们一起来看一下。</p>
<p>首先，是创建一个用户，这里以《天龙八部》中壮志未酬的“<strong>慕容龙城</strong>”为例：</p>
<p><img src="https://i.loli.net/2021/07/23/U9Pm3HFLn1y6dYB.png" alt=" Keycloak 创建用户"></p>
<p>《天龙八部》中提到，“<strong>慕容龙城</strong>”一心想光复大燕，可惜时不我与，正好遇上宋太祖建立宋朝，即使他创造出“<strong>斗转星移</strong>”的武功绝学，依然免不了郁郁而终的结局。慕容龙城算是第一代创业者，我们准备一个<code>Developer</code>的角色：</p>
<p><img src="https://i.loli.net/2021/07/23/H8xy3BYDz1XmWf9.png" alt=" Keycloak 创建角色"></p>
<p>在权限系统的设计中，角色总是需要和用户关联在一起。同样地，在 Keycloak 中，我们需要给“<strong>慕容龙城</strong>”分配一个<code>Developer</code>的角色：</p>
<p><img src="https://i.loli.net/2021/07/23/ZDui9X3weq5NMs8.png" alt=" Keycloak 分配角色"></p>
<p>到了“<strong>慕容复</strong>”这一代，“<strong>慕容垂</strong>”假借死亡之名秘密活动，而活跃在台前的“<strong>慕容复</strong>”，实际上是作为慕容家族的“<strong>代理人</strong>”出现。在今天这篇文章中，Envoy 会充当认证服务的代理，因为我们希望 Envoy 可以对所有进站的 API 请求进行统一的认证。所以，这里，我们还需要创建一个客户端：<code>envoy-client</code>，并为其分配客户端角色：</p>
<p><img src="https://i.loli.net/2021/07/23/MJC3dVkE7UxopyO.png" alt=" Keycloak 创建客户端"></p>
<p>OK，我们都知道，<a target="_blank" rel="noopener" href="https://oauth.net/2/">OAuth 2.0</a> 有这样四种认证方式：密码模式、客户端模式、简化模式、授权码模式。这四种认证方式如何在 Keycloak 中实现呢？目前，博主基本搞清楚了前面两种。我们在创建完客户端以后，可以通过设置访问类型来决定客户端使用哪种认证方式，目前已知，当访问类型的取值为<code>public</code>时，表示密码模式。当访问类型的取值为<code>confidential</code>时，表示客户端模式。这里，我们以客户端模式为例：</p>
<p><img src="https://i.loli.net/2021/07/23/le5rstobVOh91m3.png" alt=" Keycloak 客户端模式"></p>
<p>此时，我们就可以拿到一个重要的信息：<code>client_secret</code>，如果大家使用过客户端模式，就会知道它是获取令牌的重要参数之一。好了，当我们有了这些信息以后，该怎么样去获取令牌呢？我们只需要用 POST 的方式，将<code>grant_type</code>、<code>client_id</code>、<code>client_secret</code>、<code>username</code>、<code>password</code>、<code>scope</code>传过去即可：</p>
<p><img src="https://i.loli.net/2021/07/23/S5rgmZaGEqQkHUK.png" alt="从 Keycloak 获取令牌 "></p>
<p>如果需要刷新令牌，则只需要再追加一个<code>refresh_token</code>参数即可，它是我们第一次获取到的令牌：</p>
<p><img src="https://i.loli.net/2021/07/23/ukdNami5yMERWDc.png" alt="从 Keycloak 刷新令牌"></p>
<p>可能大家会疑惑，博主是从哪里知道这些 API 的端点地址的呢？其实，和 Identity Server 4 类似， Keycloak 提供了一个用于服务发现的接口地址：<code>/auth/realms/master/.well-known/openid-configuration</code>，通过这个接口地址，我们可以获得一份 API 列表：</p>
<p><img src="https://i.loli.net/2021/07/23/bDYNASUw23qLyml.png" alt=" Keycloak 提供的 “服务发现” 能力"></p>
<p>可以注意到，图中有我们需要的换取令牌的接口，以及提供 JWKS 的接口：<code>/auth/realms/master/protocol/openid-connect/certs&quot;</code>，尤其第二点，它对于对我们进行下一个步骤意义重大，Envoy 能不能承担起微服务认证的重担，就看它的啦，至此， Keycloak 的搭建工作已经完成。</p>
<h1 id="配置-Envoy"><a href="#配置-Envoy" class="headerlink" title="配置 Envoy"></a>配置 Envoy</h1><p>在上一节内容中，博主卖了一个关子，说要等到这一节再说 JWKS 是何方神圣？不过，博主以为，“<strong>饭要一口一口吃，步子迈太大，咔，容易扯着蛋</strong>”，我们还是先来说说 JWT ，因为只要你了解了它的结构，你才能了解如何去检验一个令牌。我们说，JWT，是 JSON Web Token 的简称，那这个 JSON 到底体现在哪里呢？而这要从 JWT 的结构开始说起。</p>
<p><img src="https://i.loli.net/2021/07/23/Tdag82VsSGJxD9u.png" alt="JSON Web Token 结构说明图"></p>
<p>这是一张来自 <a target="_blank" rel="noopener" href="https://jwt.io/">JWT</a> 官网的截图，博主认为，这张图非常清晰地展示出了 JWT 的加密过程，我们熟悉的这个令牌，其实是由<code>header</code>、<code>payload</code>和<code>signature</code>三个部分组成，其基本格式为：<code>header.payload.signature</code>，细心的朋友会发现，图中生成的令牌中含有两个<code>.</code>。其中，<code>header</code>部分是一个 JSON 对象，表示类型(<strong>typ</strong>)及加密算法(<strong>alg</strong>)，常见的加密算法主要有 HMAC、RSA、ECDSA 三个系列。<code>payload</code>部分同样是一个 JSON 对象，主要用来存放实际需要传递的数据。目前，JWT 官方规定了以下7个备选字段：</p>
<ul>
<li>iss，即 issuer，表示：令牌签发人</li>
<li>exp，即 expiration time，表示：令牌过期时间</li>
<li>sub，即 subject，表示：令牌主题</li>
<li>aud，即 audience，表示：令牌受众</li>
<li>nbf，即 Not Before，表示：令牌生效时间</li>
<li>iat，即 Issued At，表示：令牌签发时间</li>
<li>jti，即 JWT ID，表示：令牌编号</li>
</ul>
<p>需要注意的是，<code>header</code>和<code>payload</code>这两部分，默认是不加密的，这意味着任何人都可以读到这里的信息，所以，一个重要的原则是，不要在<code>payload</code>中存放重要的、敏感的信息。无论是<code>header</code>还是<code>payload</code>，最终都需要通过 <a target="_blank" rel="noopener" href="https://www.base64url.com/">Base64URL</a> 算法将其转化为普通的字符串，该算法和 <a target="_blank" rel="noopener" href="https://www.sojson.com/base64.html">Base64</a> 算法类似，唯一的不同点在于它会对<code>+</code>、<code>/</code> 和 <code>=</code> 这三个符号进行替换，因为这三个符号在网址中有着特殊的含义。</p>
<p><img src="https://i.loli.net/2021/07/23/zDx765FpRMaP8mK.png" alt="Base64 &amp; Base64URL 算法对比"></p>
<p>第三部分，<code>signature</code>，即通常意义上的签名，主要是防止数据篡改。对于 HMAC 系列的加密算法，需要指定一个密钥，以 HMACSHA256 算法为例，其签名函数为：<code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code>。对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥，以 ECDSASHA512 算法为例，其签名函数为：<code>ECDSASHA512(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), PublicKey, PrivateKey)</code>。一旦计算出签名，就可以将这三部分合成一个令牌，而这就是 JWT 的产生原理，而如果我们对第一节中获得的令牌进行解密，我们就会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/07/23/mpVo8vasYWL4gPN.png" alt="解密 Keycloak 生成的令牌"></p>
<p>所以，JSON Web Token 中的 JSON，其实是指 <code>header</code> 和 <code>payload</code> 这两个 JSON 对象，并且我们可以注意到，Keycloak 中生成的令牌实际上携带了更多的信息，例如，客户端、IP 地址、<code>realm_access</code> 以及 <code>resource_access</code>等等，所以。 JWT 其实是一个相对宽松的规范，在实现<code>payload</code>这部分时，可以结合实际场景做更多的扩展，唯一的要求还是那句话，不要在<code>payload</code>中存放重要的、敏感的信息。至此，我们讲清楚了 JWT 的底层原理。</p>
<p>OK，解释清楚了 JWT，我们再来说 JWKS，这位又是何方神圣呢？我们提到，JWT 至少需要一个密钥或者一对公&#x2F;私钥来进行签名的校验，因为对于<code>header</code>和<code>payload</code>这两个部分而言，它的加密算法始终都是 Base64URL，所以，我们总是可以反推出原始的 JSON 字符串。接下来，我们只需要按签名函数计算签名即可，对于 HMAC 系列的加密算法，需要指定一个密钥；对于 RSA 和 ECDSA 这两个系列的加密算法，需要指定公钥和私钥。由此，我们就可以计算出一个签名，此时，我们只需要比较两个签名是否一致即可。</p>
<p><img src="https://i.loli.net/2021/07/23/N6ybGazKBUSfE2H.png" alt=" JWT 校验过程示意图"></p>
<p>通过 JWKS 的 <a target="_blank" rel="noopener" href="https://auth0.com/docs/tokens/json-web-tokens/json-web-key-sets">官网</a>，我们可以了解到一件事情，那就是 JWKS 本质上是 Json Web Key Set 的简称，顾名思义，这是一组可以校验任意 JWT 的公钥，并且这些 JWT 必须是通过 RS256 算法进行签名的，RS256 则是我们上面这张图里的 RSA 非对唱加密算法，它需要一个公钥和一个私钥，通常强况下，私钥用来生成签名，公钥用来校验签名。这个 JWKS 呢？同样是一个 JSON 对象，它只有一个属性<code>keys</code>，以 Keycloak 中获得的 JWKS 为例：</p>
<p><img src="https://i.loli.net/2021/07/24/lQrXThYCvk9RPLm.png" alt=" Keycloak 产生的 JWKS"></p>
<p> 关于 JWKS 的规范，大家可以通过 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7517">RFC7515</a> 来了解，作为一种通用的规范，Identity Server 4 和 Keycloak 都实现了这一规范，所以，就今天这篇博客而言，不管是哪一种方案，它都可以和 Envoy 配合得天衣无缝。为什么这样说呢？因为我们在 Envoy 中实现 JWT 认证，其核心还是 JWKS 这一套规范。博主没有选择从头开始实现这一切，就在于这个 JWKS 有特别多的细节。总之，我们只需要知道，通过 JWKS 可以对一个令牌进行验证，而 Envoy 刚好有这样一个过滤器，下面是 Envoy 中对应的配置项：</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.jwt_authn</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication</span></span><br><span class="line">      <span class="attr">providers:</span></span><br><span class="line">        <span class="attr">jwt_provider:</span></span><br><span class="line">          <span class="attr">issuer:</span> <span class="string">&quot;http://192.168.50.162:7070/auth/realms/master&quot;</span></span><br><span class="line">          <span class="attr">audiences:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;account&quot;</span></span><br><span class="line">          <span class="attr">forward:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">remote_jwks:</span></span><br><span class="line">            <span class="attr">http_uri:</span></span><br><span class="line">              <span class="attr">uri:</span> <span class="string">&quot;http://192.168.50.162:7070/auth/realms/master/protocol/openid-connect/certs&quot;</span></span><br><span class="line">              <span class="attr">cluster:</span> <span class="string">keycloak</span></span><br><span class="line">              <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">&quot;/api/w&quot;</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">            <span class="attr">prefix:</span> <span class="string">&quot;/api/c&quot;</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="attr">provider_name:</span> <span class="string">jwt_provider</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.http.router</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，我们这里配置了一个叫做<code>envoy.filters.http.jwt_authn</code>的过滤器，并为这个过滤器指定了一个叫做<code>jwt_provider</code>的认证提供者，其中的<code>issuer</code>和<code>audiences</code>，我们在讲解 JWT 结构的时候提到过，最为关键的是<code>remote_jwks</code>，我们通过 Keycloak 的服务发现功能，可以获得这个地址，我们将其配置到 Envoy 中即可，Envoy 可以通过它来验证一个 JWT 的令牌，而下面的规则，表示哪些路由需要认证，这里我们假设需要对<code>/api/w</code>和<code>/api/c</code>这两个端点进行认证。所以，可以预见的是，我们可以为整个网关配置统一的认证流程，无论我们有多少个微服务。以往我们都是通过 ASP.NET Core 里的过滤器来实现应用级的认证服务，而此时此刻，我们有了容器级别的认证服务，基础设施从框架提升到了容器层面。除此以外，我们还需要为 Envoy 定义一个集群，这样读取远程 JWKS 的请求才会被正确地转发过去：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">keycloak</span></span><br><span class="line">    <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">    <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">    <span class="attr">load_assignment:</span></span><br><span class="line">      <span class="attr">cluster_name:</span> <span class="string">keycloak</span></span><br><span class="line">      <span class="attr">endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">            <span class="attr">address:</span></span><br><span class="line">              <span class="attr">socket_address:</span></span><br><span class="line">                <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.50</span><span class="number">.162</span></span><br><span class="line">                <span class="attr">port_value:</span> <span class="number">7070</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如此，整个认证服务相关的基础设施均已准备就绪，所谓“万事俱备，只欠东风”，我们还需要定义资源 API 供调用者消费，所以，接下来，我们来看看 API 如何编写。</p>
<h1 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h1><p>编写 API 非常简单，我们直接用 ASP.NET Core 创建两个项目即可，这里是两个服务：<code>CityService</code> 和 <code>WeatherService</code>。</p>
<p>首先，是 <code>CityService</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CityController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Cities = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;中卫&quot;</span>, <span class="string">&quot;西安&quot;</span>, <span class="string">&quot;苏州&quot;</span>, <span class="string">&quot;安庆&quot;</span>, <span class="string">&quot;洛阳&quot;</span>, <span class="string">&quot;银川&quot;</span>, <span class="string">&quot;兰州&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;CityController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityController</span>(<span class="params">ILogger&lt;CityController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">dynamic</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> rnd = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">var</span> city =  Cities[rnd.Next(Cities.Length)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> &#123; City = city, Now = DateTime.Now &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，是 <code>WeatherService</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;Freezing&quot;</span>, <span class="string">&quot;Bracing&quot;</span>, <span class="string">&quot;Chilly&quot;</span>, <span class="string">&quot;Cool&quot;</span>, <span class="string">&quot;Mild&quot;</span>, <span class="string">&quot;Warm&quot;</span>, <span class="string">&quot;Balmy&quot;</span>, <span class="string">&quot;Hot&quot;</span>, <span class="string">&quot;Sweltering&quot;</span>, <span class="string">&quot;Scorching&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherController</span>(<span class="params">ILogger&lt;WeatherController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">      &#123;</span><br><span class="line">        Date = DateTime.Now.AddDays(index),</span><br><span class="line">        TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">        Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">      &#125;)</span><br><span class="line">      .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这两个服务如何实现容器化、反向代理等等的细节，大家可以参考博主前面几篇文章，本文示例已托管到 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyJwt">Github</a>，供大家做进一步的参考。</p>
<h1 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h1><p>这段时间最大的收获便是，学会了通过<code>docker-compose</code>对服务进行编排，虽然目前还有点悬而未决的东西，可一旦接触了这种略显“<strong>高端</strong>”的技巧，便再不愿回到刀耕火种、敲命令行维护<code>docker</code>环境的时代。等有时间了，博主会考虑写一点<code>docker</code>或者<code>docker-compose</code>使用技巧的文章，当然这些都是以后的事情啦！我们要活在当下啊，还是看看这个<code>docker-compose.yaml</code>文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6060:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6061:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="attr">city_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">CityService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span><span class="type">![Envoy</span><span class="string">-Jwt-Keycloak-16.png](https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line">  <span class="attr">weather_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">WeatherService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line">  <span class="attr">keycloak:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/keycloak/keycloak:14.0.0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KEYCLOAK_USER:</span> <span class="string">$&#123;KEYCLOAK_USER&#125;</span></span><br><span class="line">      <span class="attr">KEYCLOAK_PASSWORD:</span> <span class="string">$&#123;KEYCLOAK_PASS&#125;</span></span><br><span class="line">      <span class="attr">DB_VENDOR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_ADDR:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_DATABASE:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7070:8080&quot;</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;POSTGRESQL_DB&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;POSTGRESQL_USER&#125;</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;POSTGRESQL_PASS&#125;</span></span><br></pre></td></tr></table></figure>

<p>等所有的服务都启动起来以后，我们来验证下这个网关，是不是真的像我们期待的那样。注意到，Envoy 对外暴露出来的端口是<code>6060</code>，这里我们以<code>CItyService</code>为例：</p>
<p>首先，是不带令牌直接访问接口，我们发现接口返回了<code>401</code>状态码，并提示：<strong>Jwt is missing</strong>。</p>
<p><img src="https://i.loli.net/2021/07/24/Bg5r8dAIbEp4eFy.png" alt=" 不携带令牌，Envoy 认证失败"></p>
<p>我们带上令牌会怎么样呢？可以注意到，接口成功地返回了数据，这表示我们的目的达到了，这些经由 Envoy 代理的 API 接口，今后都必须携带令牌进行访问：</p>
<p><img src="https://i.loli.net/2021/07/24/rCcUBWDyJVtOxkd.png" alt="携带令牌，Envoy 返回数据"></p>
<p>因为 Keycloak 这个认证中心是独立于我们的应用单独存在的，所以，我们可以直接在 Keycloak 中设置令牌的过期时间、为用户分配角色、为不同的资源设置范围等等，而这一切都不需要应用程序或者 Envoy 做任何调整，开发者只需要认真地写好每一个后端服务即可，这是否就是传说中的基础设施即服务呢？</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文主要分享了如何利用 Envoy 实现容器级别的 JWT 认证服务，在实现过程中，我们分别了解了 JWT 和 JWKS 这两个概念。其中，JWT 即JSON Web Token，是目前最为流行的跨域认证方案，一个 JWT 通常由 <code>header</code>、<code>payload</code> 和 <code>signature</code> 三个部分组成，JWT 的 JSON 主要体现在<code>header</code>和<code>payload</code>这两个 JSON 对象上，通过 Base64Url 算法实现串化，而 <code>signature</code> 部分则是由<code>header</code>和<code>payload</code>按照签名函数进行生成，主要目的是防止数据篡改。JWKS 可以利用密钥或者公&#x2F;私钥对令牌进行验证，利用这一原理，Envoy 中集成了 JWKS ，它表示一组可以校验任意 JWT 的公钥，同样是一个 JSON 对象。为了获得可用的 JWKS，我们可以通过 Identity Server 4 或者 Keycloak 中提供的地址来获得这一信息，方便起见，本文选择了更为便捷的 Keycloak。最终，我们实现了一个通用的、容器级别的认证网关，调用方在消费这些 API 资源时都必须带上从认证中心获得的令牌，进而达到保护 API 资源的目的，更好地保障系统和软件安全。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-7-18-music/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-7-18-music/" itemprop="url">解锁 QQ 音乐/网易云音乐加密格式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-18T14:00:00+00:00">
                2021-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>文&#x2F;彭宏豪，笔名&#x2F;安哥拉<br>本文首发于「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mx6D5aBmiR_2odM24_flcw">效率工具指南</a>」    </p>
<p>Hello 大家好，我是安哥。</p>
<p>用过 QQ 音乐或网易云音乐的朋友，尤其是充过会员的，可能都遇到过这么一种情况：会员期间下载的音乐，会员过期后就无法正常播放。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718190828421.png" alt="image-20210718190828421"></p>
<p>如果你查看 QQ 音乐本地下载的音乐文件，会发现它们的格式比较特殊——qmc3，这种特殊格式是 QQ 音乐弄的<strong>加密格式</strong>，相比常见的 mp3 格式，这种加密格式有两个 bug：只能使用 QQ 音乐播放；会员过期后，就无法正常播放。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718190936600.png" alt="image-20210718190936600"></p>
<p>如果换成网易云音乐，对应的加密格式为 ncm。</p>
<p>此外，如果你想把 qmc3&#x2F;ncm 格式的音乐上传到公众号后台，它也会提示「不支持该音频格式」。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718201117624.png" alt="image-20210718201117624"></p>
<p>为了解决这个问题，今天给大家介绍两个相关的工具，希望对你有帮助。</p>
<h2 id="unlock-music"><a href="#unlock-music" class="headerlink" title="unlock-music"></a>unlock-music</h2><p>这是一个<strong>在线解锁加密格式</strong>的工具，将加密过的音乐文件上传到网页，稍等一会，就能得到解密后的 mp3 格式的文件。</p>
<p>这个工具支持解锁网易云音乐、QQ 音乐、酷狗音乐和酷我音乐。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718201933235.png" alt="image-20210718201933235"></p>
<p><strong>unlock-music 网站网址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://unlock-music-ix.netlify.app/">https://unlock-music-ix.netlify.app/</a></em></p>
<p>这个网址后续可能会失效，如果你想得到这个工具的最新地址，可以在 GitHub 收藏这个工具对应的项目，在页面的右侧就可以看到这个工具的网址。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718202829609.png" alt="image-20210718202829609"></p>
<p>除了网页版，这个工具还推出了适用于不同浏览器的插件，目前支持 Chrome、微软的 Edge 和火狐浏览器。打开浏览器的应用商店，输入「<strong>音乐解锁</strong>」即可找到。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718203342218.png" alt="image-20210718203342218"></p>
<p><strong>unlock-music GitHub 项目地址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://github.com/unlock-music/unlock-music">https://github.com/unlock-music/unlock-music</a></em></p>
<h2 id="一起听音乐呀"><a href="#一起听音乐呀" class="headerlink" title="一起听音乐呀"></a>一起听音乐呀</h2><p>这是一个集合了 QQ 音乐和网易云音乐曲库的在线网站，搜索歌曲无需登录，在搜索框中输入曲目名称或歌手，在下方返回的结果中，点击每首词最右侧的<strong>下载按钮</strong>，就可以得到 mp3 格式的文件。</p>
<p>相比前面介绍的工具，这个在线网站一步到位，省去了上传转换的步骤。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718210628700.png" alt="image-20210718210628700"></p>
<p>这个在线网站之前支持同时登录 QQ 音乐和网易云账号，现在只支持登录网易云账号。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718211742416.png" alt="image-20210718211742416"></p>
<p>对于 QQ 音乐，这个工具存在一个限制：下载 VIP 音乐，需要先登录 QQ 音乐账号，但目前无法登录，因此也就无法通过这个工具免费下载会员专享的音乐了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210718211900971.png" alt="image-20210718211900971"></p>
<p><strong>一起听音乐呀 在线网址：</strong></p>
<p><em><a target="_blank" rel="noopener" href="http://y.jsososo.com/#/">http://y.jsososo.com/#/</a></em></p>
<p>这个工具也推出了适用于电脑端的客户端，支持 Windows 和 macOS 系统，感兴趣的朋友可以前去下载，这里就不赘述了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>介绍这两个工具，并不是在鼓励大家不在音乐 App 中充会员，只是希望各位在一些视频或者文章中使用音乐时，可以更方便一些。</p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<p>以上，希望有帮助。    </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/vue-router-score-code.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/vue-router-score-code.html" itemprop="url">vue-router 源码解析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-15T16:00:00+00:00">
                2021-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是针对 vue-router <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router/releases/tag/v3.5.2">v3.5.2</a> 版本的一次源码解析，由于水平有限，有些地方写得比较混乱，还望多多包涵。</p>
<p>希望本文能够给那些想阅读 vue-router 源代码却又不知从何上手的同学们给予一些帮助。</p>
<h2 id="一、-new-Router-时发生了什么？"><a href="#一、-new-Router-时发生了什么？" class="headerlink" title="一、 new Router 时发生了什么？"></a>一、 new Router 时发生了什么？</h2><p>对应源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src&#x2F;index.js</a>，下面讲一下它做了哪些操作：</p>
<h3 id="1-声明一些变量"><a href="#1-声明一些变量" class="headerlink" title="1. 声明一些变量"></a>1. 声明一些变量</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前实例</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">app</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 存在多实例的话则保存</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">apps</span> = []</span><br><span class="line"><span class="comment">// 传入的配置</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">options</span> = options</span><br><span class="line"><span class="comment">// 存放已注册的一些导航守卫</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">beforeHooks</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">resolveHooks</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">afterHooks</span> = []</span><br><span class="line"><span class="comment">// 创建 matcher</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">matcher</span> = <span class="title function_">createMatcher</span>(options.<span class="property">routes</span> || [], <span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-创建-matcher"><a href="#2-创建-matcher" class="headerlink" title="2. 创建 matcher"></a>2. 创建 <code>matcher</code></h3><p><code>createMatcher</code> 的源码位置在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-matcher.js">src&#x2F;create-matcher.js</a>，这个方法的整体是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createMatcher</span>(<span class="params"></span></span><br><span class="line"><span class="params">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span><br><span class="line"><span class="params">  router: VueRouter</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Matcher</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathList, pathMap, nameMap &#125; = <span class="title function_">createRouteMap</span>(routes)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addRoutes</span>(<span class="params">routes</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addRoute</span>(<span class="params">parentOrRoute, route</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getRoutes</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">match</span>(<span class="params"></span></span><br><span class="line"><span class="params">    raw: RawLocation,</span></span><br><span class="line"><span class="params">    currentRoute?: Route,</span></span><br><span class="line"><span class="params">    redirectedFrom?: Location</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Route</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">redirect</span>(<span class="params">record: RouteRecord, location: Location</span>): <span class="title class_">Route</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">alias</span>(<span class="params"></span></span><br><span class="line"><span class="params">    record: RouteRecord,</span></span><br><span class="line"><span class="params">    location: Location,</span></span><br><span class="line"><span class="params">    matchAs: string</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Route</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">_createRoute</span>(<span class="params"></span></span><br><span class="line"><span class="params">    record: ?RouteRecord,</span></span><br><span class="line"><span class="params">    location: Location,</span></span><br><span class="line"><span class="params">    redirectedFrom?: Location</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Route</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是两点：</p>
<ol>
<li>根据传入的路由配置生成三张表：<code>pathList</code>、 <code>pathMap</code>、 <code>nameMap</code>，这样后面就可以更高效地访问路由表。</li>
<li>返回一些方法，让它可以获取，操作这三张表。</li>
</ol>
<h3 id="3-根据路由配置生成三张表"><a href="#3-根据路由配置生成三张表" class="headerlink" title="3. 根据路由配置生成三张表"></a>3. 根据路由配置生成三张表</h3><p><code>createRouteMap</code> 的源码位置在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-route-map.js">src&#x2F;create-route-map.js</a>，可以点开来对照看。</p>
<p>我们先不管其它逻辑，只关注它在第一次时是如何生成这三张表的，其核心逻辑是如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">addRouteRecord</span>(pathList, pathMap, nameMap, route, parentRoute)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里给循环调用了 <code>addRouteRecord</code> 方法，它就在同一个文件中，总结一下它做了如下操作：</p>
<ol>
<li>首先检查是否有配置 <code>pathToRegexpOptions</code> 参数，这个属性值是路由高级匹配模式中（<code>path-to-regexp</code>）的参数。</li>
<li>调用 <code>normalizePath</code> 将 <code>path</code> 标准化，比较重要的是这里会将子路由的 <code>path</code> 父路由的 <code>path</code> 拼接在一起。</li>
<li>处理 <code>caseSensitive</code> 参数，它也是 <code>path-to-regexp</code> 中的参数。</li>
<li>声明一个 <code>RouteRecord</code> ，主要代码：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">record</span>: <span class="title class_">RouteRecord</span> = &#123;</span><br><span class="line">  <span class="attr">path</span>: normalizedPath,</span><br><span class="line">  <span class="comment">// 用于匹配该路由的正则</span></span><br><span class="line">  <span class="attr">regex</span>: <span class="title function_">compileRouteRegex</span>(normalizedPath, pathToRegexpOptions),</span><br><span class="line">  <span class="comment">// 该路由对应的组件，注意这里与 &lt;router-view&gt; 的 name 有关联</span></span><br><span class="line">  <span class="attr">components</span>: route.<span class="property">components</span> || &#123; <span class="attr">default</span>: route.<span class="property">component</span> &#125;,</span><br><span class="line">  <span class="comment">// 路由别名</span></span><br><span class="line">  <span class="attr">alias</span>: route.<span class="property">alias</span></span><br><span class="line">    ? <span class="keyword">typeof</span> route.<span class="property">alias</span> === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">      ? [route.<span class="property">alias</span>]</span><br><span class="line">      : route.<span class="property">alias</span></span><br><span class="line">    : []</span><br><span class="line">  <span class="comment">// other property</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果该路由存在子路由，则递归调用 <code>addRouteRecord</code> 添加路由记录。</li>
<li>将这条 <code>RouteRecord</code> 存入 <code>pathList</code> 。</li>
<li>将这条记录以 <code>path</code> 作为 <code>key</code> 存入 <code>pathMap</code> 。</li>
<li>如果存在 <code>alias</code> ，则用 <code>alias</code> 作为 <code>path</code> 再添加一条路由记录。</li>
<li>如果存在 <code>name</code> ，则以 <code>name</code> 作为 <code>key</code> 存入 <code>nameMap</code>。</li>
</ol>
<p>到这里，已经搞懂如何生成这三张表了。</p>
<h3 id="4-使用一些方法来操作这三张表"><a href="#4-使用一些方法来操作这三张表" class="headerlink" title="4. 使用一些方法来操作这三张表"></a>4. 使用一些方法来操作这三张表</h3><p>接着我们回到 <code>createMatcher</code> 方法内部，可以看到它返回的一些方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createMatcher</span>(<span class="params"></span></span><br><span class="line"><span class="params">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span><br><span class="line"><span class="params">  router: VueRouter</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Matcher</span> &#123;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部无非就是根据这三张表来做一些匹配或者改动而已，后面也基本会提到，这里就先略过。<br>​</p>
<p>到这里 <code>createMatcher</code> 的操作就基本讲完了，下面我们回到 <code>new Router</code> 本身。</p>
<h3 id="5-检查-mode-，使用对应的路由模式"><a href="#5-检查-mode-，使用对应的路由模式" class="headerlink" title="5. 检查 mode ，使用对应的路由模式"></a>5. 检查 <code>mode</code> ，使用对应的路由模式</h3><p>根据传入的路由配置创建一系列的数据表后，下面就要根据不同的 <code>mode</code> 来做不同的操作，核心代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知，hash 是默认值</span></span><br><span class="line"><span class="keyword">let</span> mode = options.<span class="property">mode</span> || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用了 history 但不支持 pushState 的情况也需要回退到 hash</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">fallback</span> =</span><br><span class="line">  mode === <span class="string">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.<span class="property">fallback</span> !== <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">fallback</span>) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非浏览器环境(比如SSR)，则使用 abstract</span></span><br><span class="line"><span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;abstract&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">mode</span> = mode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的 mode 构建不同的 history</span></span><br><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HTML5History</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HashHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>, <span class="variable language_">this</span>.<span class="property">fallback</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">AbstractHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于三种 mode 有何不同下面会讲。</p>
<p>到这里， <code>new Router()</code> 的整个过程就基本讲完了。</p>
<h2 id="二、-use-Router-时发生了什么？"><a href="#二、-use-Router-时发生了什么？" class="headerlink" title="二、 use Router 时发生了什么？"></a>二、 use Router 时发生了什么？</h2><p>我们知道仅仅通过 <code>new Router()</code> 来构造一个 vue-router 实例后，还需要通过 <code>Vue.use(router)</code> 才能真正在项目中使用它，下面就来讲讲这过程到底发生了什么？</p>
<h3 id="1-Vue-use-源码"><a href="#1-Vue-use-源码" class="headerlink" title="1. Vue.use 源码"></a>1. Vue.use 源码</h3><p>在这之前，我们先来看看 Vue.use 做了哪些操作，它的源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue/blob/HEAD/src/core/global-api/use.js">src&#x2F;core&#x2F;global-api&#x2F;use.js</a>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initUse</span>(<span class="params">Vue: GlobalAPI</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins =</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_installedPlugins</span> || (<span class="variable language_">this</span>.<span class="property">_installedPlugins</span> = [])</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.<span class="title function_">indexOf</span>(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = <span class="title function_">toArray</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.<span class="title function_">unshift</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.<span class="property">install</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.<span class="property">install</span>.<span class="title function_">apply</span>(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.<span class="title function_">push</span>(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不长，就是接受一个 <code>plugin</code> ，这个 <code>plugin</code> 要么是一个函数，要么就是一个有 <code>install</code> 方法的对象，然后 Vue 会调用这方法，并且将当前 Vue 作为参数传入，以便插件对 Vue 来进行扩展，最后将 <code>plugin</code> 传入 <code>installedPlugins</code> 中，防止重复调用。</p>
<h3 id="2-安装-Router"><a href="#2-安装-Router" class="headerlink" title="2. 安装 Router"></a>2. 安装 Router</h3><p>然后我们看看在 Vue 安装 VueRouter 时，VueRouter 会做哪些操作，它的源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/install.js">src&#x2F;install.js</a>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">View</span> <span class="keyword">from</span> <span class="string">&#x27;./components/view&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&#x27;./components/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">Vue</span>) &#123;</span><br><span class="line">  <span class="comment">// 防止重复执行</span></span><br><span class="line">  <span class="keyword">if</span> (install.<span class="property">installed</span> &amp;&amp; _Vue === <span class="title class_">Vue</span>) <span class="keyword">return</span></span><br><span class="line">  install.<span class="property">installed</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 Vue 存起来并 export 供其它文件使用</span></span><br><span class="line">  _Vue = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isDef</span> = (<span class="params">v</span>) =&gt; v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">registerInstance</span> = (<span class="params">vm, callVal</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.<span class="property">$options</span>.<span class="property">_parentVnode</span></span><br><span class="line">    <span class="comment">// router-view 才有 registerRouteInstance 属性</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="title function_">isDef</span>(i) &amp;&amp;</span><br><span class="line">      <span class="title function_">isDef</span>((i = i.<span class="property">data</span>)) &amp;&amp;</span><br><span class="line">      <span class="title function_">isDef</span>((i = i.<span class="property">registerRouteInstance</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="title function_">i</span>(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册一个全局 mixin</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_routerRoot</span> = <span class="variable language_">this</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_router</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span></span><br><span class="line">        <span class="comment">// 调用 router.init()，后面会讲</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_router</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="comment">// 使 _router 变成响应式</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property">util</span>.<span class="title function_">defineReactive</span>(<span class="variable language_">this</span>, <span class="string">&#x27;_route&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_router</span>.<span class="property">history</span>.<span class="property">current</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经初始化，继承父组件的 _routerRoot</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_routerRoot</span> = (<span class="variable language_">this</span>.<span class="property">$parent</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">_routerRoot</span>) || <span class="variable language_">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册实例，实际上是挂载 &lt;router-view&gt;</span></span><br><span class="line">      <span class="title function_">registerInstance</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 离开时卸载</span></span><br><span class="line">      <span class="title function_">registerInstance</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 $router 和 $route 挂载到 Vue 原型上，这样就能在任意 Vue 实例中访问</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>.<span class="property">_router</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$route&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>.<span class="property">_route</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局组件</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;RouterView&#x27;</span>, <span class="title class_">View</span>)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;RouterLink&#x27;</span>, <span class="title class_">Link</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 Vue 合并策略新增几个相关的生命周期</span></span><br><span class="line">  <span class="keyword">const</span> strats = <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">optionMergeStrategies</span></span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.<span class="property">beforeRouteEnter</span> =</span><br><span class="line">    strats.<span class="property">beforeRouteLeave</span> =</span><br><span class="line">    strats.<span class="property">beforeRouteUpdate</span> =</span><br><span class="line">      strats.<span class="property">created</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到它调用了 <code>router.init()</code> 这个方法，它的源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src&#x2F;index.js</a>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">init (<span class="attr">app</span>: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">	    <span class="comment">// 开发环境下检查是否已安装</span></span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">assert</span>(</span><br><span class="line">        install.<span class="property">installed</span>,</span><br><span class="line">        <span class="string">`not installed. Make sure to call \`Vue.use(VueRouter)\` `</span> +</span><br><span class="line">          <span class="string">`before creating root instance.`</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前 app 实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">apps</span>.<span class="title function_">push</span>(app)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 app 销毁时需要在 apps 中移除，由 issue #2639 提出</span></span><br><span class="line">    app.$once(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// clean out app from this.apps array once destroyed</span></span><br><span class="line">      <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">apps</span>.<span class="title function_">indexOf</span>(app)</span><br><span class="line">      <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) <span class="variable language_">this</span>.<span class="property">apps</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// ensure we still have a main app or null if no apps</span></span><br><span class="line">      <span class="comment">// we do not release the router so it can be reused</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">app</span> === app) <span class="variable language_">this</span>.<span class="property">app</span> = <span class="variable language_">this</span>.<span class="property">apps</span>[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">app</span>) <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">teardown</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">app</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">app</span> = app</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的 history，由之前 new Router 时根据不同 mode 来创建</span></span><br><span class="line">    <span class="keyword">const</span> history = <span class="variable language_">this</span>.<span class="property">history</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> <span class="title class_">HTML5History</span> || history <span class="keyword">instanceof</span> <span class="title class_">HashHistory</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handleInitialScroll</span> = routeOrError =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = history.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> expectScroll = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">scrollBehavior</span></span><br><span class="line">        <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">          <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">setupListeners</span> = routeOrError =&gt; &#123;</span><br><span class="line">        history.<span class="title function_">setupListeners</span>()</span><br><span class="line">        <span class="title function_">handleInitialScroll</span>(routeOrError)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">      history.<span class="title function_">transitionTo</span>(</span><br><span class="line">        history.<span class="title function_">getCurrentLocation</span>(),</span><br><span class="line">        setupListeners,</span><br><span class="line">        setupListeners</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line">    <span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">    history.<span class="title function_">listen</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">apps</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        app.<span class="property">_route</span> = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>相信现在对安装 VueRouter 时的大致流程已经很清楚了，我们还看到了它会调用一些很重要的方法，这些方法会从后面的问题中继续深入探讨。</p>
<h2 id="三、-切换路由时发生了什么"><a href="#三、-切换路由时发生了什么" class="headerlink" title="三、 切换路由时发生了什么"></a>三、 切换路由时发生了什么</h2><p>下面我们看看 vue-router 在切换路由时做了哪些操作，首先回想一下我们平时使用 vue-router 时有哪些操作可以切换路由？</p>
<h4 id="切换路由的几种方式"><a href="#切换路由的几种方式" class="headerlink" title="切换路由的几种方式"></a>切换路由的几种方式</h4><p>我们可以通过以下方式切换不同的路由：</p>
<ol>
<li>手动触发 URL 更新</li>
<li>点击 <code>router-link</code></li>
<li>通过 <code>this.$router</code> 的 <code>push</code> 、<code>replace</code> 等方法</li>
</ol>
<h5 id="1-手动触发-URL-更新"><a href="#1-手动触发-URL-更新" class="headerlink" title="1. 手动触发 URL 更新"></a>1. 手动触发 URL 更新</h5><p>只要我们更新了 <code>URL</code> ，vue-router 都会相应执行切换路由的逻辑，能更新 <code>URL</code> 操作有以下：</p>
<ul>
<li>如支持 <code>history</code> api<ul>
<li>history.pushState</li>
<li>history.replaceState</li>
<li>history.back</li>
<li>history.go</li>
</ul>
</li>
<li><code>location.href = &#39;xxx&#39;</code></li>
<li><code>location.hash = &#39;xxx&#39;</code></li>
</ul>
<p>vue-router 是如何监听这些操作的呢？其实只要监听 <code>popstate</code> 或者 <code>hashchange</code> 就可以了，不过这部分留到后面讲 <code>history</code> 实现时再仔细讲，这里先略过。</p>
<h5 id="2-通过-router-link-切换"><a href="#2-通过-router-link-切换" class="headerlink" title="2. 通过 router-link 切换"></a>2. 通过 <code>router-link</code> 切换</h5><p>还有就是通过 <code>router-link</code> 组件的方式来切换，这个组件相信大家已经很熟悉了，它的源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/link.js">src&#x2F;components&#x2F;link.js</a>，我们直接看最关键的部分：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件处理，不一定是 click，取决于用户传入的 event</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断用户触发该事件时的行为，具体看下面的 guardEvent 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">guardEvent</span>(e)) &#123;</span><br><span class="line">    <span class="comment">// 使用不同的方式来切换路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">replace</span>) &#123;</span><br><span class="line">      router.<span class="title function_">replace</span>(location, noop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.<span class="title function_">push</span>(location, noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="keyword">const</span> on = &#123; <span class="attr">click</span>: guardEvent &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">event</span>)) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">event</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    on[e] = handler</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  on[<span class="variable language_">this</span>.<span class="property">event</span>] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">guardEvent</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 不处理有媒体键的情况</span></span><br><span class="line">  <span class="comment">// 比如 a 标签可以通过按住 shift 点击链接在新窗口打开，这时候原本的窗口不做任何处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">metaKey</span> || e.<span class="property">altKey</span> || e.<span class="property">ctrlKey</span> || e.<span class="property">shiftKey</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 调用了 preventDefault 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">defaultPrevented</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果是 button，并且不是使用左键单击也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">button</span> !== <span class="literal">undefined</span> &amp;&amp; e.<span class="property">button</span> !== <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果给 a 标签设置了 _blank 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">currentTarget</span> &amp;&amp; e.<span class="property">currentTarget</span>.<span class="property">getAttribute</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = e.<span class="property">currentTarget</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\b_blank\b/i</span>.<span class="title function_">test</span>(target)) <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消默认行为，这里要判断是因为在诸如 weex 环境中没有该方法</span></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">preventDefault</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显， <code>router-link</code> 本质上也是通过 router 的方法来切换路由，那下面就来看看 router 的方法。</p>
<h5 id="3-通过-router-的方法切换"><a href="#3-通过-router-的方法切换" class="headerlink" title="3. 通过 router 的方法切换"></a>3. 通过 router 的方法切换</h5><p>通过 router 方法来切换路由主要是三个：</p>
<ol>
<li><code>push</code></li>
<li><code>replace</code></li>
<li><code>go</code></li>
</ol>
<p>当然还有其它的，比如 <code>resolve</code> ，但这个方法并不是切换路由，但只是把对应路由信息返回过来，这里就不谈了。</p>
<p>其实不同的 <code>mode</code> 它们的实现是不一样的，这里我们就拿最常用的 <code>hash</code> 模式来讲，其它 <code>mode</code> 的方法实现会在后面将不同的 <code>mode</code> 的差异时讨论。</p>
<p>下面是这些方法在 <code>hash</code> 模式下的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">pushHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">            <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">    location,</span><br><span class="line">    <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">replaceHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">      <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">    &#125;,</span><br><span class="line">    onAbort</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">go</span>(<span class="params">n: number</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了 <code>go</code> 之外（它是通过事件监听器），都是在调用 <code>transitionTo</code> 这个方法，下面我们就看看这个方法的内部。</p>
<h4 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h4><h5 id="1-调用-transitionTo-方法"><a href="#1-调用-transitionTo-方法" class="headerlink" title="1. 调用 transitionTo 方法"></a>1. 调用 transitionTo 方法</h5><p>前面我们得知切换路由实际上都在调用 <code>transitionTo</code> ，它是一个 <code>History</code> 基类的方法，三种 <code>mode</code> 都是共用的同一个，下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">transitionTo</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> route</span><br><span class="line">  <span class="comment">// 这里要 try 一下是因为 match 方法内部会在有 redirect 属性时调用它</span></span><br><span class="line">  <span class="comment">// 但用户提供的 redirect 方法可能会发生报错，所以这里需要捕获到错误回调方法</span></span><br><span class="line">  <span class="comment">// 具体看 issues #3201</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这是根据当前位置匹配路由，下面会讲</span></span><br><span class="line">    route = <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">match</span>(location, <span class="variable language_">this</span>.<span class="property">current</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errorCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>(e)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 依然要抛出异常，让用户得知</span></span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录之前的路由，后面会用到</span></span><br><span class="line">  <span class="keyword">const</span> prev = <span class="variable language_">this</span>.<span class="property">current</span></span><br><span class="line">  <span class="comment">// 这个才是真正切换路由的方法，下面会讲</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">confirmTransition</span>(</span><br><span class="line">    <span class="comment">// 传入准备切换的路由</span></span><br><span class="line">    route,</span><br><span class="line">    <span class="comment">// 切换之后的回调</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">updateRoute</span>(route)</span><br><span class="line">      <span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">      onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">      <span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>()</span><br><span class="line">      <span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">afterHooks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">        hook &amp;&amp; <span class="title function_">hook</span>(route, prev)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">ready</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ready</span> = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readyCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">cb</span>(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发生错误的回调</span></span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onAbort 回调</span></span><br><span class="line">      <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">        <span class="title function_">onAbort</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onError 回调</span></span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; !<span class="variable language_">this</span>.<span class="property">ready</span>) &#123;</span><br><span class="line">        <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">        <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isNavigationFailure</span>(err, <span class="title class_">NavigationFailureType</span>.<span class="property">redirected</span>) || prev !== <span class="variable constant_">START</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">ready</span> = <span class="literal">true</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">readyErrorCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">cb</span>(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段方法中我们得知，要切换路由首先调用 <code>match</code> 方法来匹配到待切换的路由，下面我们看看实现。</p>
<h5 id="2-调用-match-方法匹配路由"><a href="#2-调用-match-方法匹配路由" class="headerlink" title="2. 调用 match 方法匹配路由"></a>2. 调用 <code>match</code> 方法匹配路由</h5><p>在 <code>transitionTo</code> 中调用的是 <code>router</code> 的 <code>match</code> 方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match (<span class="attr">raw</span>: <span class="title class_">RawLocation</span>, current?: <span class="title class_">Route</span>, redirectedFrom?: <span class="title class_">Location</span>): <span class="title class_">Route</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">matcher</span>.<span class="title function_">match</span>(raw, current, redirectedFrom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而它实际上是调用了 <code>matcher</code> 的 <code>match</code> 方法，这个方法我们之前在 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">创建 match</a> 这一小节有提到过，下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">match</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 待切换的路由，取值为 字符串 或者 Location 对象</span></span></span><br><span class="line"><span class="params">  raw: RawLocation,</span></span><br><span class="line"><span class="params">  <span class="comment">// 当前的路由</span></span></span><br><span class="line"><span class="params">  currentRoute?: Route,</span></span><br><span class="line"><span class="params">  <span class="comment">// 使用重定向方式切换时才会传入</span></span></span><br><span class="line"><span class="params">  redirectedFrom?: Location</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Route</span> &#123;</span><br><span class="line">  <span class="comment">// 将待切换的路由转换成一个标准的 Location 对象</span></span><br><span class="line">  <span class="comment">// 例如：path 补全、合并 params 等</span></span><br><span class="line">  <span class="keyword">const</span> location = <span class="title function_">normalizeLocation</span>(raw, currentRoute, <span class="literal">false</span>, router)</span><br><span class="line">  <span class="comment">// 待切换路由的 name</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="comment">// 有 name 属性的时候直接通过 nameMap 获取，根本无需遍历，非常高效</span></span><br><span class="line">    <span class="keyword">const</span> record = nameMap[name]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(record, <span class="string">`Route with name &#x27;<span class="subst">$&#123;name&#125;</span>&#x27; does not exist`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该路由不存在，创建一个空的路由记录</span></span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> <span class="title function_">_createRoute</span>(<span class="literal">null</span>, location)</span><br><span class="line">    <span class="comment">// 获取可以从父路由中继承的 param 参数</span></span><br><span class="line">    <span class="keyword">const</span> paramNames = record.<span class="property">regex</span>.<span class="property">keys</span></span><br><span class="line">      .<span class="title function_">filter</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> !key.<span class="property">optional</span>)</span><br><span class="line">      .<span class="title function_">map</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> key.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  params 需要为对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> location.<span class="property">params</span> !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      location.<span class="property">params</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承父路由的 param 参数</span></span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; <span class="keyword">typeof</span> currentRoute.<span class="property">params</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> currentRoute.<span class="property">params</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> location.<span class="property">params</span>) &amp;&amp; paramNames.<span class="title function_">indexOf</span>(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          location.<span class="property">params</span>[key] = currentRoute.<span class="property">params</span>[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 path 和 param 合并为 URL</span></span><br><span class="line">    location.<span class="property">path</span> = <span class="title function_">fillParams</span>(</span><br><span class="line">      record.<span class="property">path</span>,</span><br><span class="line">      location.<span class="property">params</span>,</span><br><span class="line">      <span class="string">`named route &quot;<span class="subst">$&#123;name&#125;</span>&quot;`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建路由记录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_createRoute</span>(record, location, redirectedFrom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.<span class="property">path</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是通过 path 跳转，则需要通过遍历 pathList 匹配对应的路由</span></span><br><span class="line">    location.<span class="property">params</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pathList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = pathList[i]</span><br><span class="line">      <span class="keyword">const</span> record = pathMap[path]</span><br><span class="line">      <span class="comment">// 检查路径与当前遍历到的路由是否匹配，该方法下面会讲</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">matchRoute</span>(record.<span class="property">regex</span>, location.<span class="property">path</span>, location.<span class="property">params</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_createRoute</span>(record, location, redirectedFrom)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找不到匹配的则创建一条空的路由记录</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createRoute</span>(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是通过 <code>path</code> 的方式跳转，由于 <code>path</code> 可能会携带一些 <code>params</code> 的信息，前面我们已经提到过<a href="#%E4%B8%80%E3%80%81-new-router-%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">初始化路由</a>信息时，会为每条路由生成一个正则表达式，所以这里就可以根据这个正则来检查是否符合当前路由，也就是上面提到 <code>matchRoute</code> 作用，下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">matchRoute</span>(<span class="params">regex: RouteRegExp, path: string, params: <span class="built_in">Object</span></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">const</span> m = path.<span class="title function_">match</span>(regex)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">    <span class="comment">// 不匹配则直接退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!params) &#123;</span><br><span class="line">    <span class="comment">// 如果匹配并且该路由没有声明 param 参数，则匹配成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将使用正则匹配到的 param 参数放入 params 对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = m.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = regex.<span class="property">keys</span>[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      <span class="comment">// Fix #1994: using * with props: true generates a param named 0</span></span><br><span class="line">      params[key.<span class="property">name</span> || <span class="string">&#x27;pathMatch&#x27;</span>] =</span><br><span class="line">        <span class="keyword">typeof</span> m[i] === <span class="string">&#x27;string&#x27;</span> ? <span class="title function_">decode</span>(m[i]) : m[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，关于如何匹配对应的路由已经讲完了，下面我们讲讲匹配到之后它还会做什么？</p>
<h5 id="3-调用-confirmTransition-方法"><a href="#3-调用-confirmTransition-方法" class="headerlink" title="3. 调用 confirmTransition 方法"></a>3. 调用 confirmTransition 方法</h5><p>前面我们在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 时讲到它拿到匹配的路由之后，就会调用 <code>confirmTransition</code> 方法，下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为待跳转路由有可能是一个异步组件，所以设计成有回调的方法</span></span><br><span class="line"><span class="title function_">confirmTransition</span>(<span class="params">route: Route, onComplete: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 跳转前的的路由（from）</span></span><br><span class="line">  <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">current</span></span><br><span class="line">  <span class="comment">// 待跳转的路由（to）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pending</span> = route</span><br><span class="line">  <span class="comment">// 错误时的回调</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">abort</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// changed after adding errors with</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span></span><br><span class="line">    <span class="comment">// redirect and aborted navigation would produce an err == null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isNavigationFailure</span>(err) &amp;&amp; <span class="title function_">isError</span>(err)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">errorCbs</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">errorCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">cb</span>(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="literal">false</span>, <span class="string">&#x27;uncaught error during route navigation:&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onAbort &amp;&amp; <span class="title function_">onAbort</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lastRouteIndex = route.<span class="property">matched</span>.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> lastCurrentIndex = current.<span class="property">matched</span>.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 判断是否相同路径</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="title function_">isSameRoute</span>(route, current) &amp;&amp;</span><br><span class="line">    <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">    lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">    route.<span class="property">matched</span>[lastRouteIndex] === current.<span class="property">matched</span>[lastCurrentIndex]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 依旧切换</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>()</span><br><span class="line">    <span class="comment">// 报一个重复导航的错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationDuplicatedError</span>(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 from 和 to的 matched 数组拿到新增、更新、销毁的部分，以便执行组件的生命周期</span></span><br><span class="line">  <span class="comment">// 该方法下面会仔细讲</span></span><br><span class="line">  <span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = <span class="title function_">resolveQueue</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">matched</span>,</span><br><span class="line">    route.<span class="property">matched</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line">  <span class="comment">// 这里的顺序可以看回前面讲的完整的导航解析流程，具体实现下面会讲</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">Array</span>&lt;?<span class="title class_">NavigationGuard</span>&gt; = [].<span class="title function_">concat</span>(</span><br><span class="line">    <span class="comment">// in-component leave guards</span></span><br><span class="line">    <span class="title function_">extractLeaveGuards</span>(deactivated),</span><br><span class="line">    <span class="comment">// global before hooks</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">beforeHooks</span>,</span><br><span class="line">    <span class="comment">// in-component update hooks</span></span><br><span class="line">    <span class="title function_">extractUpdateHooks</span>(updated),</span><br><span class="line">    <span class="comment">// in-config enter guards</span></span><br><span class="line">    activated.<span class="title function_">map</span>(<span class="function">(<span class="params">m</span>) =&gt;</span> m.<span class="property">beforeEnter</span>),</span><br><span class="line">    <span class="comment">// async components</span></span><br><span class="line">    <span class="title function_">resolveAsyncComponents</span>(activated)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">iterator</span> = (<span class="params">hook: NavigationGuard, next</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">    <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">    <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationCancelledError</span>(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">      <span class="title function_">hook</span>(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">        <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">        <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>(<span class="literal">true</span>)</span><br><span class="line">          <span class="title function_">abort</span>(<span class="title function_">createNavigationAbortedError</span>(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isError</span>(to)) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>(<span class="literal">true</span>)</span><br><span class="line">          <span class="title function_">abort</span>(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">          <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">          (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> to.<span class="property">path</span> === <span class="string">&#x27;string&#x27;</span> || typeofto.<span class="property">name</span> === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">          <span class="title function_">abort</span>(<span class="title function_">createNavigationRedirectedError</span>(current, route))</span><br><span class="line">          <span class="comment">// 判断切换类型</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.<span class="property">replace</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">replace</span>(to)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">push</span>(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">          <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">          <span class="title function_">next</span>(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">abort</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行队列，下面仔细讲</span></span><br><span class="line">  <span class="title function_">runQueue</span>(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">    <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = <span class="title function_">extractEnterGuards</span>(activated)</span><br><span class="line">    <span class="keyword">const</span> queue = enterGuards.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">resolveHooks</span>)</span><br><span class="line">    <span class="title function_">runQueue</span>(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationCancelledError</span>(current, route))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">null</span></span><br><span class="line">      <span class="title function_">onComplete</span>(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">handleRouteEntered</span>(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-构造导航守卫队列"><a href="#4-构造导航守卫队列" class="headerlink" title="4. 构造导航守卫队列"></a>4. 构造导航守卫队列</h5><p>我们知道在切换路由时需要执行一系列的导航守卫和路由相关的生命周期，下面就讲讲它的实现，其实也是在 <code>confirmTransition</code> 这个方法中。<br>​</p>
<p>第一步就是构造队列，关于它们执行的顺序可以看回文档。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line"><span class="comment">// 注意：这里只是完整迭代导航解析流程中的 2~6 步</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">Array</span>&lt;?<span class="title class_">NavigationGuard</span>&gt; = [].<span class="title function_">concat</span>(</span><br><span class="line">  <span class="comment">// 调用此次失活的部分组件的 beforeRouteLeave</span></span><br><span class="line">  <span class="title function_">extractLeaveGuards</span>(deactivated),</span><br><span class="line">  <span class="comment">// 全局的 before 钩子</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">beforeHooks</span>,</span><br><span class="line">  <span class="comment">// 调用此次更新的部分组件的 beforeRouteUpdate</span></span><br><span class="line">  <span class="title function_">extractUpdateHooks</span>(updated),</span><br><span class="line">  <span class="comment">// 调用此次激活的路由配置的 beforeEach</span></span><br><span class="line">  activated.<span class="title function_">map</span>(<span class="function">(<span class="params">m</span>) =&gt;</span> m.<span class="property">beforeEnter</span>),</span><br><span class="line">  <span class="comment">// 解析异步组件</span></span><br><span class="line">  <span class="title function_">resolveAsyncComponents</span>(activated)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>还记得前面我们讲了 <code>updated, deactivated, activated</code> 这三个数组是从 <code>resolveQueue</code> 方法中获取：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = <span class="title function_">resolveQueue</span>(</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">matched</span>,</span><br><span class="line">  route.<span class="property">matched</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveQueue</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span><br><span class="line"><span class="params">  next: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span></span><br><span class="line"><span class="params"></span>): &#123;</span><br><span class="line">  <span class="attr">updated</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecord</span>&gt;,</span><br><span class="line">  <span class="attr">activated</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecord</span>&gt;,</span><br><span class="line">  <span class="attr">deactivated</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecord</span>&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(current.<span class="property">length</span>, next.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current[i] !== next[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">updated</span>: next.<span class="title function_">slice</span>(<span class="number">0</span>, i),</span><br><span class="line">    <span class="attr">activated</span>: next.<span class="title function_">slice</span>(i),</span><br><span class="line">    <span class="attr">deactivated</span>: current.<span class="title function_">slice</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理很简单，只需要对比 <code>current</code> 和 <code>next</code> 的 <code>match</code> 数组，就能拿到以下数组：</p>
<ol>
<li><code>updated</code>：有交集的部分</li>
<li><code>activated</code>：next 有并且 current 没有的部分</li>
<li><code>deactivated</code>：current 有并且 next 没有的部分</li>
</ol>
<p>下面是队列中各项的实现</p>
<ol>
<li>调用 <code>extractLeaveGuards(deactivated)</code> 执行销毁的组件 <code>beforeRouteLeave</code> 生命周期：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractLeaveGuards</span>(<span class="params">deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title class_">Array</span>&lt;?<span class="title class_">Function</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 最后一个参数为 true 是因为这个生命周期要倒序执行，先执行子路由的再执行父路由的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">extractGuards</span>(deactivated, <span class="string">&#x27;beforeRouteLeave&#x27;</span>, bindGuard, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用全局的 <code>beforeHooks</code> ，其实也就是存放用户通过 <code>beforeEach</code> 注册的数组：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeEach (<span class="attr">fn</span>: <span class="title class_">Function</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">registerHook</span>(<span class="variable language_">this</span>.<span class="property">beforeHooks</span>, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 <code>extractUpdateHooks(updated)</code> 执行更新的组件：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractUpdateHooks</span>(<span class="params">updated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title class_">Array</span>&lt;?<span class="title class_">Function</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">extractGuards</span>(updated, <span class="string">&#x27;beforeRouteUpdate&#x27;</span>, bindGuard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用所有激活组件的 <code>beforeEnter</code> 生命周期：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activated.<span class="title function_">map</span>(<span class="function">(<span class="params">m</span>) =&gt;</span> m.<span class="property">beforeEnter</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>调用 <code>resolveAsyncComponents(activated)</code> 来解析异步组件：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveAsyncComponents</span>(<span class="params">matched: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个队列钩子函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于标记是否异步组件</span></span><br><span class="line">    <span class="keyword">let</span> hasAsync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 待加载的组件数量</span></span><br><span class="line">    <span class="keyword">let</span> pending = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否加载错误</span></span><br><span class="line">    <span class="keyword">let</span> error = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法下面会讲，主要作用是依次遍历传入的 matched 数组相关的 component</span></span><br><span class="line">    <span class="title function_">flatMapComponents</span>(matched, <span class="function">(<span class="params">def, _, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否异步组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">&#x27;function&#x27;</span> &amp;&amp; def.<span class="property">cid</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        hasAsync = <span class="literal">true</span></span><br><span class="line">        pending++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件的 chunk 后执行</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="title function_">once</span>(<span class="function">(<span class="params">resolvedDef</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isESModule</span>(resolvedDef)) &#123;</span><br><span class="line">            resolvedDef = resolvedDef.<span class="property">default</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将它变成一个 vue 组件</span></span><br><span class="line">          <span class="comment">// save resolved on async factory in case it&#x27;s used elsewhere</span></span><br><span class="line">          def.<span class="property">resolved</span> =</span><br><span class="line">            <span class="keyword">typeof</span> resolvedDef === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">              ? resolvedDef</span><br><span class="line">              : _Vue.<span class="title function_">extend</span>(resolvedDef)</span><br><span class="line">          <span class="comment">// 把解析好的组件更新到当前路由记录中</span></span><br><span class="line">          match.<span class="property">components</span>[key] = resolvedDef</span><br><span class="line">          pending--</span><br><span class="line">          <span class="comment">// 如果已经加载完则调用 next 进入下一个队列</span></span><br><span class="line">          <span class="keyword">if</span> (pending &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件失败后执行</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="title function_">once</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 报个错</span></span><br><span class="line">          <span class="keyword">const</span> msg = <span class="string">`Failed to resolve async component <span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;reason&#125;</span>`</span></span><br><span class="line">          process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(<span class="literal">false</span>, msg)</span><br><span class="line">          <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            error = <span class="title function_">isError</span>(reason) ? reason : <span class="keyword">new</span> <span class="title class_">Error</span>(msg)</span><br><span class="line">            <span class="title function_">next</span>(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是调用 webpack 方法加载这个组件，返回的是一个 Promise</span></span><br><span class="line">          res = <span class="title function_">def</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">          <span class="comment">// 这里才真正加载这个组件</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> res.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            res.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// new syntax in Vue 2.3</span></span><br><span class="line">            <span class="keyword">const</span> comp = res.<span class="property">component</span></span><br><span class="line">            <span class="keyword">if</span> (comp &amp;&amp; <span class="keyword">typeof</span> comp.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              comp.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是异步则直接 next</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAsync) <span class="title function_">next</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步加载这一块其实涉及比较多，深入讲的话还要讲 <code>webpack</code> ，所以这里只讲大概的流程，以后有机会的话再深入讲解。</p>
<p>可以看到执行导航守卫都是通过调用一个 <code>extractGuards</code> 方法，下面是它的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// records: routerRecord 数组</span></span><br><span class="line"><span class="comment">// name 钩子的名字</span></span><br><span class="line"><span class="comment">// bind 就是 bindGuard 方法，下面会讲</span></span><br><span class="line"><span class="comment">// reverse 是否倒序执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extractGuards</span>(<span class="params"></span></span><br><span class="line"><span class="params">  records: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span><br><span class="line"><span class="params">  name: string,</span></span><br><span class="line"><span class="params">  bind: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  reverse?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Array</span>&lt;?<span class="title class_">Function</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> guards = <span class="title function_">flatMapComponents</span>(records, <span class="function">(<span class="params">def, instance, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> guard = <span class="title function_">extractGuard</span>(def, name)</span><br><span class="line">    <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(guard)</span><br><span class="line">        ? guard.<span class="title function_">map</span>(<span class="function">(<span class="params">guard</span>) =&gt;</span> <span class="title function_">bind</span>(guard, instance, match, key))</span><br><span class="line">        : <span class="title function_">bind</span>(guard, instance, match, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">flatten</span>(reverse ? guards.<span class="title function_">reverse</span>() : guards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在仔细讲这个方法内部逻辑前，要先搞清楚这三个方法的内部： <code>extractGuard</code> 、 <code>bindGuard</code> 、 <code>flatMapComponents</code> ：</p>
<p><code>extractGuard</code> 很简单，其实就是获取 vue 组件实例中特定的生命周期：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extractGuard</span>(<span class="params"></span></span><br><span class="line"><span class="params">  def: <span class="built_in">Object</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  key: string</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">NavigationGuard</span> | <span class="title class_">Array</span>&lt;<span class="title class_">NavigationGuard</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> def !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// extend now so that global mixins are applied.</span></span><br><span class="line">    def = _Vue.<span class="title function_">extend</span>(def)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> def.<span class="property">options</span>[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bindGuard</code> 的作用就是返回一个函数，这个函数会调用组件特定生命周期，给后续执行队列时调用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guard：某个生命周期钩子</span></span><br><span class="line"><span class="comment">// instance：执行的 vue 实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bindGuard</span>(<span class="params">guard: NavigationGuard, instance: ?_Vue</span>): ?<span class="title class_">NavigationGuard</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 这时只是返回这个方法，没有立即调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">boundRouteGuard</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 调用这个钩子</span></span><br><span class="line">      <span class="keyword">return</span> guard.<span class="title function_">apply</span>(instance, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>flatMapComponents</code> 顾名思义就是跟组件相关的，它的作用是依次遍历传入的 <code>matched</code> 数组相关的组件，并调用传入的回调的返回值作为自己的返回值，所以它的返回值是调用者决定的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatMapComponents</span>(<span class="params">matched, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">flatten</span>(</span><br><span class="line">    matched.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(m.<span class="property">components</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(m.<span class="property">components</span>[key], m.<span class="property">instances</span>[key], m, key)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在再回过头来看 <code>extractGuards</code> 就很清晰了，它的作用就是通过 <code>flatMapComponents</code> 遍历所有 <code>match</code> 数组中的组件，并通过 <code>extractGuard</code> 拿到这些组件的特定生命周期，然后通过 <code>bindGuard</code> 返回一个可以调用这个生命周期的函数，然后利用 <code>flatten</code> 将它们扁平化，根据 <code>reverse</code> 决定是否倒序返回这些函数数组。</p>
<p>最后这些函数全部放在 <code>queue</code> 中，这就是构造整个队列的过程了。</p>
<h5 id="5-执行队列"><a href="#5-执行队列" class="headerlink" title="5. 执行队列"></a>5. 执行队列</h5><p>构造完队列，下面就要开始执行这个队列了，在这之前我们先来看看 <code>runQueue</code> 的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">runQueue</span>(<span class="params"></span></span><br><span class="line"><span class="params">  queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;,</span></span><br><span class="line"><span class="params">  fn: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  cb: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= queue.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">cb</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue[index]) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(queue[index], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">step</span>(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">step</span>(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">step</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也不复杂，首先从 0 开始按顺序遍历 <code>queue</code> 中的每一项，在调用 <code>fn</code> 时作为第一个参数传入，当使用者调用了第二个参数的回调时，才进入下一次项，最后遍历完 <code>queue</code> 中所有的项后，调用 <code>cb</code> 回到参数。</p>
<p>下面是执行这个队列的过程：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行队列</span></span><br><span class="line"><span class="comment">// queue 就是上面那个队列</span></span><br><span class="line"><span class="comment">// iterator 传入 to、from、next，只有执行 next 才会进入下一项</span></span><br><span class="line"><span class="comment">// cb 回调函数，当执行完整个队列后调用</span></span><br><span class="line"><span class="title function_">runQueue</span>(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">  <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">  <span class="keyword">const</span> enterGuards = <span class="title function_">extractEnterGuards</span>(activated)</span><br><span class="line">  <span class="keyword">const</span> queue = enterGuards.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">resolveHooks</span>)</span><br><span class="line">  <span class="title function_">runQueue</span>(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationCancelledError</span>(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">onComplete</span>(route)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleRouteEntered</span>(route)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>iterator</code> 的定义在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 这一小节中已经有提到了，这里拷贝一份过来：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">iterator</span> = (<span class="params">hook: NavigationGuard, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">  <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">  <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationCancelledError</span>(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">    <span class="title function_">hook</span>(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">      <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">      <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="title function_">abort</span>(<span class="title function_">createNavigationAbortedError</span>(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isError</span>(to)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="title function_">abort</span>(to)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">        <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">          (<span class="keyword">typeof</span> to.<span class="property">path</span> === <span class="string">&#x27;string&#x27;</span> || typeofto.<span class="property">name</span> === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">        <span class="title function_">abort</span>(<span class="title function_">createNavigationRedirectedError</span>(current, route))</span><br><span class="line">        <span class="comment">// 判断切换类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.<span class="property">replace</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">replace</span>(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">push</span>(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">        <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">        <span class="title function_">next</span>(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">abort</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们留意到这里其实是嵌套执行了两次 <code>runQueue</code> ，这是因为我们前面构造的 <code>queue</code> 只是 vue-router 完整的导航解析流程中的 第 2<del>6 步，而接下来就要执行第 7</del>9 步：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这时候异步组件已经解析完成</span></span><br><span class="line"><span class="comment">// 下面是构造 beforeRouteEnter 和 beforeResolve 守卫的队列</span></span><br><span class="line"><span class="keyword">const</span> enterGuards = <span class="title function_">extractEnterGuards</span>(activated)</span><br><span class="line"><span class="keyword">const</span> queue = enterGuards.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">resolveHooks</span>)</span><br><span class="line"><span class="title function_">runQueue</span>(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">pending</span> !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationCancelledError</span>(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 这里是调用 transitionTo 传入的 onComplete 回调</span></span><br><span class="line">  <span class="comment">// 在这里会做一些更新路由、URL、调用 afterHooks、onReady 等回调，下面就讲</span></span><br><span class="line">  <span class="title function_">onComplete</span>(route)</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>) &#123;</span><br><span class="line">    <span class="comment">// 下次更新 DOM 时触发 handleRouteEntered</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">app</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO 不太明白这个方法的内部</span></span><br><span class="line">      <span class="title function_">handleRouteEntered</span>(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="6-执行-confirmTransition-后的操作"><a href="#6-执行-confirmTransition-后的操作" class="headerlink" title="6. 执行 confirmTransition 后的操作"></a>6. 执行 <code>confirmTransition</code> 后的操作</h5><p>到这里 <code>confirmTransition</code> 方法就已经执行完了，最后会调用 <code>transitionTo</code> 传入的 <code>onComplete</code> 方法，之前就有提到：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">updateRoute</span>(route)</span><br><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">ensureURL</span>()</span><br><span class="line"><span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">afterHooks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">  hook &amp;&amp; <span class="title function_">hook</span>(route, prev)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">ready</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ready</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">readyCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(route)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了几步：更新当前路由、调用传入的 <code>onComplete</code> 、更新 <code>URL</code> 、调用 <code>afterHooks</code> 、 <code>onReady</code> 钩子。</p>
<p>而如果 <code>confirmTransition</code> 执行失败的话，则会执行传入的 <code>onAbort</code> ：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">  <span class="title function_">onAbort</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (err &amp;&amp; !<span class="variable language_">this</span>.<span class="property">ready</span>) &#123;</span><br><span class="line">  <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">  <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="title function_">isNavigationFailure</span>(err, <span class="title class_">NavigationFailureType</span>.<span class="property">redirected</span>) ||</span><br><span class="line">    prev !== <span class="variable constant_">START</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ready</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">readyErrorCbs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是调用传入的 <code>onAbort</code> 回调，执行 <code>onError</code> 钩子。</p>
<p>到这里整个 <code>transitionTo</code> 方法的执行过程已经讲完了，导航守卫和一些钩子函数也已经全部执行完毕。<br>​</p>
<h5 id="7-更新路由信息"><a href="#7-更新路由信息" class="headerlink" title="7. 更新路由信息"></a>7. 更新路由信息</h5><p>接着我们看看它是如何更新当前路由信息的，也就是 <code>updateRoute</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">updateRoute</span>(<span class="params">route: Route</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = route</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">cb</span>(route)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是更新一下 <code>current</code> 的指向，接着调用 <code>cb</code> 这个回调函数并且将当前路由传入，那这个 <code>cb</code> 是什么东西呢？它是在 <code>listen</code> 方法中被赋值的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">listen</span>(<span class="params">cb: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而哪里调用了这个 <code>listen</code> 方法呢？我们看回之前在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时初始化那里的一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line"><span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">history.<span class="title function_">listen</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">apps</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="property">_route</span> = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以到这里，我们通过 <code>this.$route</code> 拿到的路由就已经变成跳转的路由了。<br>​</p>
<h5 id="8-更新-URL"><a href="#8-更新-URL" class="headerlink" title="8. 更新 URL"></a>8. 更新 URL</h5><p>接着就是更新 <code>URL</code> 了，在 <code>transitionTo</code> 这里它是先调用了 <code>onComplete</code> 方法，然后再调用 <code>ensureURL</code> 方法来更新浏览器上的 <code>URL</code> ，对应源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">ensureURL</span>()</span><br></pre></td></tr></table></figure>

<p>由于我们这里是以 <code>hash</code> 模式来展开的，所以我们看看它的 <code>push</code> 方法里传入的 <code>onComplete</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">pushHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">            <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>pushHash</code> 这里实际到后面已经可以更新 <code>URL</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于：src/util/push-state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) &#123;</span><br><span class="line">  <span class="title function_">saveScrollPosition</span>()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="variable language_">window</span>.<span class="property">history</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = <span class="title function_">extend</span>(&#123;&#125;, history.<span class="property">state</span>)</span><br><span class="line">      stateCopy.<span class="property">key</span> = <span class="title function_">getStateKey</span>()</span><br><span class="line">      history.<span class="title function_">replaceState</span>(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.<span class="title function_">pushState</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: <span class="title function_">setStateKey</span>(<span class="title function_">genStateKey</span>())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushHash</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    <span class="title function_">pushState</span>(<span class="title function_">getUrl</span>(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以后面再执行 <code>ensureURL</code> 时就不需要再更新一遍了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ensureURL</span>(<span class="params">push ? : boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">fullPath</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getHash</span>() !== current) &#123;</span><br><span class="line">        push ? <span class="title function_">pushHash</span>(current) : <span class="title function_">replaceHash</span>(current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难道这个 <code>ensureURL</code> 就是多此一举吗？也不是，在其他地方调用就会更新 <code>URL</code> 的，比如 <code>transitionTo</code> 检查是否跳转至相同路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="title function_">isSameRoute</span>(route, current) &amp;&amp;</span><br><span class="line">  <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">  lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">  route.<span class="property">matched</span>[lastRouteIndex] === current.<span class="property">matched</span>[lastCurrentIndex]</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">ensureURL</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">abort</span>(<span class="title function_">createNavigationDuplicatedError</span>(current, route))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里更新了 <code>URL</code> 以后，还会调用 <code>handleScroll</code> 来滚动相关的操作，如：保存当前滚动位置、根据传入的 <code>scrollBehavior</code> 设置当前滚动位置，不过这里就不展开讲了。</p>
<p>另外，更新 <code>URL</code> 这部分行为也是根据不同的路由模式有所区别，后面的章节会详情讲解。</p>
<h5 id="9-渲染对应的路由视图"><a href="#9-渲染对应的路由视图" class="headerlink" title="9. 渲染对应的路由视图"></a>9. 渲染对应的路由视图</h5><p>除了更新 <code>URL</code> 以外，我们还要渲染当前路由对应的视图，那这又是如何做到的呢？我们知道 vue-router 是通过一个叫 <code>router-view</code> 的组件来渲染，下面看看它的实现，它的源码在：<a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/view.js">src&#x2F;components&#x2F;view.js</a>，我们先粗略看一下它的 <code>render</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">_, &#123;</span></span><br><span class="line"><span class="params">    props,</span></span><br><span class="line"><span class="params">    children,</span></span><br><span class="line"><span class="params">    parent,</span></span><br><span class="line"><span class="params">    data</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// used by devtools to display a router-view badge</span></span><br><span class="line">    data.<span class="property">routerView</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// directly use parent context&#x27;s createElement() function</span></span><br><span class="line">    <span class="comment">// so that components rendered by router-view can resolve named slots</span></span><br><span class="line">    <span class="keyword">const</span> h = parent.<span class="property">$createElement</span></span><br><span class="line">    <span class="keyword">const</span> name = props.<span class="property">name</span></span><br><span class="line">    <span class="comment">// 拿到当前路由</span></span><br><span class="line">    <span class="keyword">const</span> route = parent.<span class="property">$route</span></span><br><span class="line">    <span class="comment">// 缓存路由视图，keepAlive 时会用到</span></span><br><span class="line">    <span class="keyword">const</span> cache = parent.<span class="property">_routerViewCache</span> || (parent.<span class="property">_routerViewCache</span> = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determine current view depth, also check to see if the tree</span></span><br><span class="line">    <span class="comment">// has been toggled inactive but kept-alive.</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent.<span class="property">_routerRoot</span> !== parent) &#123;</span><br><span class="line">        <span class="keyword">const</span> vnodeData = parent.<span class="property">$vnode</span> ? parent.<span class="property">$vnode</span>.<span class="property">data</span> : &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.<span class="property">routerView</span>) &#123;</span><br><span class="line">            depth++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.<span class="property">keepAlive</span> &amp;&amp; parent.<span class="property">_directInactive</span> &amp;&amp; parent.<span class="property">_inactive</span>) &#123;</span><br><span class="line">            inactive = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.<span class="property">$parent</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.<span class="property">routerViewDepth</span> = depth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是渲染已经缓存的视图</span></span><br><span class="line">    <span class="keyword">if</span> (inactive) &#123;</span><br><span class="line">        <span class="keyword">const</span> cachedData = cache[name]</span><br><span class="line">        <span class="keyword">const</span> cachedComponent = cachedData &amp;&amp; cachedData.<span class="property">component</span></span><br><span class="line">        <span class="keyword">if</span> (cachedComponent) &#123;</span><br><span class="line">            <span class="comment">// #2301</span></span><br><span class="line">            <span class="comment">// pass props</span></span><br><span class="line">            <span class="keyword">if</span> (cachedData.<span class="property">configProps</span>) &#123;</span><br><span class="line">                <span class="title function_">fillPropsinData</span>(</span><br><span class="line">                    cachedComponent,</span><br><span class="line">                    data,</span><br><span class="line">                    cachedData.<span class="property">route</span>,</span><br><span class="line">                    cachedData.<span class="property">configProps</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">h</span>(cachedComponent, data, children)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// render previous empty view</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">h</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到对应的视图组件</span></span><br><span class="line">    <span class="keyword">const</span> matched = route.<span class="property">matched</span>[depth]</span><br><span class="line">    <span class="keyword">const</span> component = matched &amp;&amp; matched.<span class="property">components</span>[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render empty node if no matched route or no config component</span></span><br><span class="line">    <span class="keyword">if</span> (!matched || !component) &#123;</span><br><span class="line">        cache[name] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">h</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache component</span></span><br><span class="line">    cache[name] = &#123;</span><br><span class="line">        component</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach instance registration hook</span></span><br><span class="line">    <span class="comment">// this will be called in the instance&#x27;s injected lifecycle hooks</span></span><br><span class="line">    data.<span class="property">registerRouteInstance</span> = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// val could be undefined for unregistration</span></span><br><span class="line">        <span class="keyword">const</span> current = matched.<span class="property">instances</span>[name]</span><br><span class="line">        <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">            matched.<span class="property">instances</span>[name] = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also register instance in prepatch hook</span></span><br><span class="line">    <span class="comment">// in case the same component instance is reused across different routes</span></span><br><span class="line">    ;</span><br><span class="line">    (data.<span class="property">hook</span> || (data.<span class="property">hook</span> = &#123;&#125;)).<span class="property">prepatch</span> = <span class="function">(<span class="params">_, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        matched.<span class="property">instances</span>[name] = vnode.<span class="property">componentInstance</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register instance in init hook</span></span><br><span class="line">    <span class="comment">// in case kept-alive component be actived when routes changed</span></span><br><span class="line">    data.<span class="property">hook</span>.<span class="property">init</span> = <span class="function">(<span class="params">vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            vnode.<span class="property">data</span>.<span class="property">keepAlive</span> &amp;&amp;</span><br><span class="line">            vnode.<span class="property">componentInstance</span> &amp;&amp;</span><br><span class="line">            vnode.<span class="property">componentInstance</span> !== matched.<span class="property">instances</span>[name]</span><br><span class="line">        ) &#123;</span><br><span class="line">            matched.<span class="property">instances</span>[name] = vnode.<span class="property">componentInstance</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the route transition has already been confirmed then we weren&#x27;t</span></span><br><span class="line">        <span class="comment">// able to call the cbs during confirmation as the component was not</span></span><br><span class="line">        <span class="comment">// registered yet, so we call it here.</span></span><br><span class="line">        <span class="title function_">handleRouteEntered</span>(route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> configProps = matched.<span class="property">props</span> &amp;&amp; matched.<span class="property">props</span>[name]</span><br><span class="line">    <span class="comment">// save route and configProps in cache</span></span><br><span class="line">    <span class="keyword">if</span> (configProps) &#123;</span><br><span class="line">        <span class="title function_">extend</span>(cache[name], &#123;</span><br><span class="line">            route,</span><br><span class="line">            configProps</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">fillPropsinData</span>(component, data, route, configProps)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(component, data, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>router-view</code> 是通过 <code>$route</code> 变量来获取当前组件的，而在前面 <a href="#_7-%E6%9B%B4%E6%96%B0%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF">7. 更新路由信息</a> 时有提到会更新 <code>_route</code> 变量，而它在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时就已经用 <code>$route</code> 包装成响应式了，这里自然也就可以渲染对应的组件了。</p>
<h2 id="四、-动态添加路由实现"><a href="#四、-动态添加路由实现" class="headerlink" title="四、 动态添加路由实现"></a>四、 动态添加路由实现</h2><p>我们在开发时可能会遇到一些比较复杂的场景，需要动态添加路由，最常见的例子就是根据后端返回的不同用户角色去配置不同的前端路由，那下面就讲讲它在 vue-router 内部是如何实现的。<br>​</p>
<p>我们只需要使用 <code>router.addRoute</code> 方法就能新增一条路由记录，之前我们在讲 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">2. 创建 matcher</a> 有看到这个方法的定义，下面是它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addRoute</span>(<span class="params">parentOrRoute, route</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否有传入父路由，有则取，无则 undefined</span></span><br><span class="line">  <span class="keyword">const</span> parent =</span><br><span class="line">    <span class="keyword">typeof</span> parentOrRoute !== <span class="string">&#x27;object&#x27;</span> ? nameMap[parentOrRoute] : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 插入一条路由，由于这里可能只会传入一个参数，所以需要判断一下</span></span><br><span class="line">  <span class="title function_">createRouteMap</span>([route || parentOrRoute], pathList, pathMap, nameMap, parent)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有父路由并且父路由存在别名的情况下，需要给这个别名路由也新增一条子路由</span></span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    <span class="title function_">createRouteMap</span>(</span><br><span class="line">      <span class="comment">// $flow-disable-line route is defined if parent is</span></span><br><span class="line">      parent.<span class="property">alias</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">alias</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">path</span>: alias,</span><br><span class="line">        <span class="attr">children</span>: [route]</span><br><span class="line">      &#125;)),</span><br><span class="line">      pathList,</span><br><span class="line">      pathMap,</span><br><span class="line">      nameMap,</span><br><span class="line">      parent</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较重要的是调用 <code>createRouteMap</code> 来创建路由，它的实现之前在 <a href="#_3-%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%B8%89%E5%BC%A0%E8%A1%A8">3. 根据路由配置生成三张表</a> 有提到，不过当时只关注它如何生成三张表，在现在这种情况下调用它的区别在于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三张表都无需新增，直接拿之前的</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">pathList</span>: <span class="title class_">Array</span>&lt;string&gt; = oldPathList || []</span><br><span class="line"><span class="keyword">const</span> <span class="attr">pathMap</span>: <span class="title class_">Dictionary</span>&lt;<span class="title class_">RouteRecord</span>&gt; = oldPathMap || <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nameMap</span>: <span class="title class_">Dictionary</span>&lt;<span class="title class_">RouteRecord</span>&gt; = oldNameMap || <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>好了，可以看到新增一条路由规则十分简单，只需要对 <code>pathList</code> 、 <code>pathMap</code> 、 <code>nameMap</code> 进行改动就好了。</p>
<h2 id="五、-三种路由模式的实现"><a href="#五、-三种路由模式的实现" class="headerlink" title="五、 三种路由模式的实现"></a>五、 三种路由模式的实现</h2><p>vue-router 的核心逻辑已经讲得差不多了，就剩下三种路由模式之间的差异，这一小节就来仔细讲讲它们各自的内部实现。<br>​</p>
<h4 id="相同的部分"><a href="#相同的部分" class="headerlink" title="相同的部分"></a>相同的部分</h4><p>我们知道三种路由模式都是 <code>History</code> 的派生类，源码位置在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/history/base.js">src&#x2F;history&#x2F;base.js</a>，我们先来看看它们一些比较重要的公用方法：</p>
<ul>
<li>onReady</li>
<li>onError</li>
<li>transitionTo</li>
<li>confirmTransition</li>
<li>updateRoute</li>
</ul>
<p>其实这些方法在前文中已经或多或少有提到了，其余的那些也只是做一些更新变量的操作，这里也不谈了。</p>
<p>其实还有一个非常重要的就是构造函数，它主要是做一些实例变量的初始化，这里混个眼熟就好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">router: Router, base: ? string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span> = router</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">base</span> = <span class="title function_">normalizeBase</span>(base)</span><br><span class="line">    <span class="comment">// start with a route object that stands for &quot;nowhere&quot;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable constant_">START</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ready</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">readyCbs</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">readyErrorCbs</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errorCbs</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span> = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们就讲讲它们不同的地方。</p>
<h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>hash 应该是最常用的一种模式了，它也是浏览器环境下的默认模式，至于它的特点相信大家也很熟悉了，就是利用 <code>URL</code> 中的 <code>hash</code> 值来做路由，这种模式兼容性是最好的。<br>​</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>我们先来看看它在初始化时会做哪些操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">router: Router, base: ? string, fallback : boolean</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(router, base)</span><br><span class="line">    <span class="comment">// check history fallback deeplinking</span></span><br><span class="line">    <span class="keyword">if</span> (fallback &amp;&amp; <span class="title function_">checkFallback</span>(<span class="variable language_">this</span>.<span class="property">base</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">ensureSlash</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不多，首先是检查是否因为回退而使用 hash 模式，如果是的话则调用 <code>checkFallback</code> 检查它的返回值，如果为 <code>true</code> 则不调用 <code>ensureSlash</code> 。<br>​</p>
<p>下面是 <code>checkFallback</code> 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkFallback</span>(<span class="params">base</span>) &#123;</span><br><span class="line">  <span class="comment">// 这个方法位于 src/history/html5.js，用于获取 URL 中的路径部分</span></span><br><span class="line">  <span class="comment">// http://a.com/user/routes =&gt; /user/routes</span></span><br><span class="line">  <span class="comment">// http://a.com/#/user/routes =&gt; /#/user/routes</span></span><br><span class="line">  <span class="keyword">const</span> location = <span class="title function_">getLocation</span>(base)</span><br><span class="line">  <span class="comment">// 检查是否以 /## 开头，如果不是，则重定向至以 /## 开头</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\/#/</span>.<span class="title function_">test</span>(location)) &#123;</span><br><span class="line">    <span class="comment">// http://a.com/user/routes =&gt; http://a.com/#/user/routes</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="title function_">cleanPath</span>(base + <span class="string">&#x27;/#&#x27;</span> + location))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说当我们使用了 <code>history</code> 模式但由于不支持需要回退到 <code>hash</code> 模式时，它会自动重定向到符合 <code>hash</code> 模式下的 <code>url</code> ，接着再执行 <code>ensureSlash</code> 方法。</p>
<p>下面是 <code>ensureSlash</code> 方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://a.com/#/user/routes =&gt; /user/routes</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getHash</span>(<span class="params"></span>): string &#123;</span><br><span class="line">  <span class="comment">// We can&#x27;t use window.location.hash here because it&#x27;s not</span></span><br><span class="line">  <span class="comment">// consistent across browsers - Firefox will pre-decode it!</span></span><br><span class="line">  <span class="keyword">let</span> href = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">  <span class="keyword">const</span> index = href.<span class="title function_">indexOf</span>(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">  <span class="comment">// empty path</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  href = href.<span class="title function_">slice</span>(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> href</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">replaceHash</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    <span class="title function_">replaceState</span>(<span class="title function_">getUrl</span>(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="title function_">getUrl</span>(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureSlash</span>(<span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">const</span> path = <span class="title function_">getHash</span>()</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">replaceHash</span>(<span class="string">&#x27;/&#x27;</span> + path)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是判断一下 <code>hash</code> 部分是否以 <code>/</code> 开头，如果不是则要重定向到以 <code>/</code> 开头的 <code>URL</code> 。<br>​</p>
<p>这样就能解释我们在使用 vue-router 开发项目时，为什么打开调试页面 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 后会自动把 url 修改为 <a target="_blank" rel="noopener" href="http://localhost:8080/#/">http://localhost:8080/#/</a> 了。</p>
<h5 id="push-和-replace"><a href="#push-和-replace" class="headerlink" title="push 和 replace"></a>push 和 replace</h5><p><code>hash</code> 模式的 <code>push</code> 方法我们在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节已经提到过了，其实 <code>replace</code> 也是大同小异，下面是这两个方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">pushHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">            <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">replace</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">replaceHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">            <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>replace</code> 方法跟 <code>push</code> 方法不同的地方是它调用的是 <code>replaceHash</code> 而不是 <code>pushHash</code> ，下面是 <code>replaceHash</code> 方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceHash</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    <span class="title function_">replaceState</span>(<span class="title function_">getUrl</span>(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="title function_">getUrl</span>(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法在 src/util/push-state.js 中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) &#123;</span><br><span class="line">  <span class="title function_">saveScrollPosition</span>()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="variable language_">window</span>.<span class="property">history</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = <span class="title function_">extend</span>(&#123;&#125;, history.<span class="property">state</span>)</span><br><span class="line">      stateCopy.<span class="property">key</span> = <span class="title function_">getStateKey</span>()</span><br><span class="line">      history.<span class="title function_">replaceState</span>(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.<span class="title function_">pushState</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: <span class="title function_">setStateKey</span>(<span class="title function_">genStateKey</span>())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">replaceState</span>(<span class="params">url?: string</span>) &#123;</span><br><span class="line">  <span class="title function_">pushState</span>(url, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以它们在更新 <code>URL</code> 时的区别在于调用的是 <code>push</code> 还是 <code>replace</code> 方法。<br>​</p>
<h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>而 <code>go</code> 方法就更直接了，实际上就是调用 <code>history.go</code> 这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">go</span>(<span class="params">n: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道大家会不会疑惑，这里没有调用 <code>transitionTo</code> 方法， <code>vue-router</code> 是如何知道需要更新路由的呢？<br>​</p>
<p>这就是就得不得说一下 <code>setupListeners</code> 这个方法了。</p>
<h5 id="setupListeners"><a href="#setupListeners" class="headerlink" title="setupListeners"></a>setupListeners</h5><p>还记得在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节的 <code>init</code> 方法里有这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line"><span class="keyword">if</span> (history <span class="keyword">instanceof</span> <span class="title class_">HTML5History</span> || history <span class="keyword">instanceof</span> <span class="title class_">HashHistory</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleInitialScroll</span> = (<span class="params">routeOrError</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = history.<span class="property">current</span></span><br><span class="line">    <span class="keyword">const</span> expectScroll = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">scrollBehavior</span></span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">      <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setupListeners</span> = (<span class="params">routeOrError</span>) =&gt; &#123;</span><br><span class="line">    history.<span class="title function_">setupListeners</span>()</span><br><span class="line">    <span class="title function_">handleInitialScroll</span>(routeOrError)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">  history.<span class="title function_">transitionTo</span>(</span><br><span class="line">    history.<span class="title function_">getCurrentLocation</span>(),</span><br><span class="line">    setupListeners,</span><br><span class="line">    setupListeners</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>history</code> 或者 <code>hash</code> 模式下初始化时也会调用一下 <code>transitionTo</code> ，而这里传入的 <code>onComplete</code> 回调就会调用 <code>setupListeners</code> 方法，为什么要这么做呢？我们直接看 <code>setupListeners</code> 里面是什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setupListeners</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="variable language_">this</span>.<span class="property">router</span></span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.<span class="property">options</span>.<span class="property">scrollBehavior</span></span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">push</span>(<span class="title function_">setupScroll</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleRoutingEvent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">current</span></span><br><span class="line">        <span class="comment">// 检查当前 URL 是否符合 hash 模式的规则，如果符合会直接重定向一下</span></span><br><span class="line">        <span class="comment">// 由于重定向后还是会再触发一下当前方法，这次就没必要执行了</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">ensureSlash</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(<span class="title function_">getHash</span>(), <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">                <span class="title function_">handleScroll</span>(<span class="variable language_">this</span>.<span class="property">router</span>, route, current, <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">                <span class="title function_">replaceHash</span>(route.<span class="property">fullPath</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventType = supportsPushState ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(eventType, handleRoutingEvent)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(eventType, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是做了两件事情：</p>
<ol>
<li>监听 <code>popstate</code> 或者 <code>hashchange</code> 事件，触发时会执行一下 <code>transitionTo</code>​</li>
<li>在 <code>listeners</code> 中存入两个回调：处理滚动相关、取消监听第 1 点中的事件</li>
</ol>
<p>也就是说 vue-router 除了调用 <code>push</code> 或者 <code>replece</code> 这些方法以外，它也支持通过其它方式来切换路由，只要这个操作会触发 <code>popstate</code> 或者 <code>hashchange</code> 事件，比如下面这些方式：</p>
<ul>
<li>如支持 <code>history</code> api<ul>
<li>history.pushState</li>
<li>history.replaceState</li>
<li>history.back</li>
<li>history.go</li>
</ul>
</li>
<li><code>location.hash = &#39;#/a&#39;</code></li>
</ul>
<p>当然这个事件监听器会在应用实例销毁时取消监听，避免产生副作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">teardown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// clean up event listeners</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/2341</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">cleanupListener</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">cleanupListener</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span> = []</span><br><span class="line">    <span class="comment">// reset current history route</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/3294</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable constant_">START</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pending</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><p><code>history</code> 模式是基于 HTML5 History API 实现的，不过在生产环境上使用它还需要在服务器上配置路由转发才行，不过这仍是大部分项目的选择，毕竟这样比较好看，不像 hash 模式这么奇葩。</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>我们看看 <code>history</code> 模式在初始化时会做哪些操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">router: Router, base: ? string</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(router, base)</span><br><span class="line">    <span class="comment">// getLocation 方法在前面已经讲过，主要用于获取 URL 中的路径部分</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_startLocation</span> = <span class="title function_">getLocation</span>(<span class="variable language_">this</span>.<span class="property">base</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是初始化了一个 <code>_startLocation</code> 变量，这个变量的作用后面会讲到。<br>​</p>
<h5 id="push-和-replace、go"><a href="#push-和-replace、go" class="headerlink" title="push 和 replace、go"></a>push 和 replace、go</h5><p>其实 <code>history</code> 模式的这几个方法与 <code>hash</code> 模式是一模一样的，区别是它们在调用 <code>pushState</code> 时传入的 <code>URL</code> 不一样而已，关于 <code>pushState</code> 方法的定义前面已经讲过了。</p>
<h5 id="setupListeners-1"><a href="#setupListeners-1" class="headerlink" title="setupListeners"></a>setupListeners</h5><p><code>setupListeners</code> 与 <code>hash</code> 模式也是大同小异，区别在于它在判断 <code>URL</code> 与当前路由是否一致时有点不同：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handleRoutingEvent = () =&gt; &#123;</span><br><span class="line">  const current = this.current</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  if (!ensureSlash()) &#123;</span></span><br><span class="line"><span class="deletion">-    return</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="addition">+  const location = getLocation(this.base)</span></span><br><span class="line"><span class="addition">+  if (this.current === START &amp;&amp; location === this._startLocation) &#123;</span></span><br><span class="line"><span class="addition">+    return</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">  this.transitionTo(location, (route) =&gt; &#123;</span><br><span class="line">    if (supportsScroll) &#123;</span><br><span class="line">      handleScroll(router, route, current, true)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a>abstract 模式</h4><p><code>abstract</code> 我们可能用得比较少，它主要是用在 <code>node</code> 环境下，也就是说在该模式下不会调用一切与浏览器相关的 <code>api</code> ，那它就只能用别的地方去维护当前 <code>URL</code> 与路由历史，由于不是很长，我直接放在一起讲了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AbstractHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">History</span> &#123;</span><br><span class="line">  <span class="attr">index</span>: number</span><br><span class="line">  <span class="attr">stack</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Route</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">router: Router, base: ?string</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(router, base)</span><br><span class="line">    <span class="comment">// 堆栈，用于维护路由历史</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = []</span><br><span class="line">    <span class="comment">// 当前所在路由在 stack 中的索引</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由存入栈中，index + 1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">index</span> + <span class="number">1</span>).<span class="title function_">concat</span>(route)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">index</span>++</span><br><span class="line">        onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由替换之前路由所在的位置，index 不变</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">index</span>).<span class="title function_">concat</span>(route)</span><br><span class="line">        onComplete &amp;&amp; <span class="title function_">onComplete</span>(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(<span class="params">n: number</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = <span class="variable language_">this</span>.<span class="property">index</span> + n</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span> || targetIndex &gt;= <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="variable language_">this</span>.<span class="property">stack</span>[targetIndex]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">confirmTransition</span>(</span><br><span class="line">      route,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = <span class="variable language_">this</span>.<span class="property">current</span></span><br><span class="line">        <span class="comment">// 将跳转至的路由索引指向 index</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">index</span> = targetIndex</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">updateRoute</span>(route)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">afterHooks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">          hook &amp;&amp; <span class="title function_">hook</span>(route, prev)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isNavigationFailure</span>(err, <span class="title class_">NavigationFailureType</span>.<span class="property">duplicated</span>)) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">index</span> = targetIndex</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getCurrentLocation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> current ? current.<span class="property">fullPath</span> : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">ensureURL</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// noop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文完，感谢阅读。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/composition-api-score-code.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/composition-api-score-code.html" itemprop="url">composition-api 源码解析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-14T16:00:00+00:00">
                2021-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>本文是针对 composition-api <a target="_blank" rel="noopener" href="https://github.com/vuejs/composition-api/releases/tag/v1.0.0-rc.6">v1.0.0-rc.6</a> 版本的一次源码解析，主要是想探析以下两点：</p>
<ol>
<li>Vue 在安装 composition-api 时做了些什么？</li>
<li>Vue 在执行每个组件的 <code>setup</code> 方法时做了什么？</li>
</ol>
<p>好了，废话不多说，我们直接开始。</p>
<h2 id="一、安装过程"><a href="#一、安装过程" class="headerlink" title="一、安装过程"></a>一、安装过程</h2><h3 id="1-检测是否已安装"><a href="#1-检测是否已安装" class="headerlink" title="1. 检测是否已安装"></a>1. 检测是否已安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/install.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isVueRegistered</span>(<span class="title class_">Vue</span>)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是检查是否重复安装，如果是则在开发环境中发出警告，主要是调用了 <code>isVueRegistered</code> 方法来进行检测，下面是它的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtimeContext.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PluginInstalledFlag</span> = <span class="string">&#x27;__composition_api_installed__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isVueRegistered</span>(<span class="params">Vue: VueConstructor</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hasOwn</span>(<span class="title class_">Vue</span>, <span class="title class_">PluginInstalledFlag</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过检测 Vue 的 <code>__composition_api_installed__</code>   这个属性来 <code>composition-api</code> 是否已经安装。</p>
<p>那很明显后来真正安装 composition-api 时会设置这个属性。</p>
<h3 id="2-检测-Vue-版本"><a href="#2-检测-Vue-版本" class="headerlink" title="2. 检测 Vue 版本"></a>2. 检测 Vue 版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span>.<span class="property">version</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Vue</span>.<span class="property">version</span>[<span class="number">0</span>] !== <span class="string">&#x27;2&#x27;</span> || <span class="title class_">Vue</span>.<span class="property">version</span>[<span class="number">1</span>] !== <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`[vue-composition-api] only works with Vue 2, v<span class="subst">$&#123;Vue.version&#125;</span> found.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;[vue-composition-api] no Vue version found&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在开发环境中判断 Vue 的版本，必须是 2.x 的版本才能使用 composition-api。</p>
<h3 id="3-添加-setup-这个-option-api"><a href="#3-添加-setup-这个-option-api" class="headerlink" title="3. 添加 setup 这个 option api"></a>3. 添加 setup 这个 option api</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">optionMergeStrategies</span>.<span class="property">setup</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parent: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  child: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">mergedSetupFn</span>(<span class="params">props: any, context: any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeData</span>(</span><br><span class="line">      <span class="keyword">typeof</span> parent === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">parent</span>(props, context) || &#123;&#125; : <span class="literal">undefined</span>,</span><br><span class="line">      <span class="keyword">typeof</span> child === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">child</span>(props, context) || &#123;&#125; : <span class="literal">undefined</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着通过 Vue 的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/mixins.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5">自定义选项合并策略</a> 来添加 <code>setup</code> 这个 api。</p>
<p>ps：是否还有同学不知道我们可以自定义 Vue 的 options 呢？可以尝试利用这个 api 来实现一个 <code>asyncComputed</code> 和 <code>multiWatch</code> 来玩玩哦！</p>
<h3 id="4-设置已安装标记"><a href="#4-设置已安装标记" class="headerlink" title="4. 设置已安装标记"></a>4. 设置已安装标记</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtimeContext.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PluginInstalledFlag</span> = <span class="string">&#x27;__composition_api_installed__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setVueConstructor</span>(<span class="params">Vue: VueConstructor</span>) &#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; vueConstructor &amp;&amp; <span class="title class_">Vue</span>.<span class="property">__proto__</span> !== vueConstructor.<span class="property">__proto__</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;[vue-composition-api] another instance of Vue installed&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  vueConstructor = <span class="title class_">Vue</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>, <span class="title class_">PluginInstalledFlag</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到过，就是在这里设置一个表示已经安装的标记。</p>
<h3 id="5-设置全局混合"><a href="#5-设置全局混合" class="headerlink" title="5. 设置全局混合"></a>5. 设置全局混合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">beforeCreate</span>: functionApiInit</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后添加一个全局的 <code>mixin</code> ，在每个组件的 <code>beforeCreate</code> 生命周期执行一下 <code>functionApiInit</code> 方法。</p>
<p>以上就是安装 composition-api 做的事，关于 <code>functionApiInit</code> 的内容我们在下一小节中详细讲解 。</p>
<h2 id="二、执行-setup"><a href="#二、执行-setup" class="headerlink" title="二、执行 setup"></a>二、执行 setup</h2><p>我们知道  composition-api 主要是新增了一个 <code>setup</code> 选项，以及一系列 hooks，而 <code>steup</code> 也不是简单调用一下就完事，在这之前需要做一些事，比如传入的两个参数： <code>props</code> 、 <code>ctx</code> 是怎么来的，以及 <code>setup</code> 的返回值为何可以在 <code>template</code> 中使用等等。</p>
<p>前面讲了 compsition-api 会在每个组件的 <code>beforeCreate</code> 时执行一下 <code>functionApiInit</code> 方法 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">beforeCreate</span>: functionApiInit</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面是这个方法主要做的事。</p>
<h3 id="1-检测是否有-render"><a href="#1-检测是否有-render" class="headerlink" title="1. 检测是否有 render"></a>1. 检测是否有 render</h3><p>第一步是检测是否定义 <code>render</code> 方法，如果有 <code>render</code> 方法，则修改它内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">const</span> $options = vm.<span class="property">$options</span></span><br><span class="line"><span class="keyword">const</span> &#123; setup, render &#125; = $options</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (render) &#123;</span><br><span class="line">  <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">  $options.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params">...args: any</span>): any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">activateCurrentInstance</span>(vm, <span class="function">() =&gt;</span> render.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>activateCurrentInstance</code> 的作用就是设置当前实例，所以我们可以在 <code>render</code> 中通过 <code>getCurrentInstance</code> 访问到当前实例。</p>
<p>ps：值得说明的是即便我们写的是 <code>template</code> ，但到了目前这个阶段这里它已经被转换成 <code>render</code> 函数了。</p>
<h3 id="2-检测是否有-setup"><a href="#2-检测是否有-setup" class="headerlink" title="2. 检测是否有 setup"></a>2. 检测是否有 setup</h3><p>如果没有定义 <code>setup</code> ，说明这个组件没有使用 <code>composition-api</code> ，这时候则直接跳过该组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!setup) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setup !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;The &quot;setup&quot; option should be a function that returns a object in component definitions.&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-在-data-方法初始化-setup"><a href="#3-在-data-方法初始化-setup" class="headerlink" title="3. 在 data 方法初始化 setup"></a>3. 在 data 方法初始化 setup</h3><p>如果存在 <code>setup</code> ，就会修改这个组件的 <code>data</code> 方法，在初始化真正的 <code>data</code> 方法之前先初始化一下 <code>setup</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    data</span><br><span class="line">&#125; = $options</span><br><span class="line"><span class="comment">// wrapper the data option, so we can invoke setup before data get resolved</span></span><br><span class="line">$options.<span class="property">data</span> = <span class="keyword">function</span> <span class="title function_">wrappedData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">initSetup</span>(vm, vm.<span class="property">$props</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">        (data <span class="title function_">as</span>(<span class="attr">this</span>: <span class="title class_">ComponentInstance</span>, <span class="attr">x</span>: <span class="title class_">ComponentInstance</span>) =&gt; object).<span class="title function_">call</span>(</span><br><span class="line">            vm,</span><br><span class="line">            vm</span><br><span class="line">        ) :</span><br><span class="line">        data || &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得 Vue 初始化 <code>data</code> 的时机是什么时候吗？答案是在 <code>beforeCreate</code> 和 <code>created</code> 之间，所以 <code>setup</code> 也是一样。</p>
<h3 id="4-初始化-setup"><a href="#4-初始化-setup" class="headerlink" title="4. 初始化 setup"></a>4. 初始化 setup</h3><p><code>initSetup</code> 方法内部还做了挺多事的，下面是这个方法的全貌，先简单瞄一眼，我们后面会一步步拆解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initSetup</span>(<span class="params">vm: ComponentInstance, props: Record &lt; any, any &gt; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> setup = vm.<span class="property">$options</span>.<span class="property">setup</span>!</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="title function_">createSetupContext</span>(vm)</span><br><span class="line">    <span class="comment">// fake reactive for `toRefs(props)`</span></span><br><span class="line">    <span class="title function_">def</span>(props, <span class="string">&#x27;__ob__&#x27;</span>, <span class="title function_">createObserver</span>())</span><br><span class="line">    <span class="comment">// resolve scopedSlots and slots to functions</span></span><br><span class="line">    <span class="comment">// @ts-expect-error</span></span><br><span class="line">    <span class="title function_">resolveScopedSlots</span>(vm, ctx.<span class="property">slots</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">binding</span>: <span class="title class_">ReturnType</span> &lt; <span class="title class_">SetupFunction</span> &lt; <span class="title class_">Data</span>, <span class="title class_">Data</span> &gt;&gt; | <span class="literal">undefined</span> | <span class="literal">null</span></span><br><span class="line">    <span class="title function_">activateCurrentInstance</span>(vm, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// make props to be fake reactive, this is for `toRefs(props)`</span></span><br><span class="line">        binding = <span class="title function_">setup</span>(props, ctx)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!binding) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isFunction</span>(binding)) &#123;</span><br><span class="line">        <span class="comment">// keep typescript happy with the binding type.</span></span><br><span class="line">        <span class="keyword">const</span> bindingFunc = binding</span><br><span class="line">        <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">render</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// @ts-expect-error</span></span><br><span class="line">            <span class="title function_">resolveScopedSlots</span>(vm, ctx.<span class="property">slots</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">activateCurrentInstance</span>(vm, <span class="function">() =&gt;</span> <span class="title function_">bindingFunc</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(binding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isReactive</span>(binding)) &#123;</span><br><span class="line">            binding = <span class="title function_">toRefs</span>(binding) <span class="keyword">as</span> <span class="title class_">Data</span></span><br><span class="line">        &#125;</span><br><span class="line">        vmStateManager.<span class="title function_">set</span>(vm, <span class="string">&#x27;rawBindings&#x27;</span>, binding)</span><br><span class="line">        <span class="keyword">const</span> bindingObj = binding</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(bindingObj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="attr">bindingValue</span>: any = bindingObj[name]</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isRef</span>(bindingValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="title function_">isReactive</span>(bindingValue)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isFunction</span>(bindingValue)) &#123;</span><br><span class="line">                        bindingValue = bindingValue.<span class="title function_">bind</span>(vm)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isObject</span>(bindingValue)) &#123;</span><br><span class="line">                        bindingValue = <span class="title function_">ref</span>(bindingValue)</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasReactiveArrayChild</span>(bindingValue)) &#123;</span><br><span class="line">                        <span class="comment">// creates a custom reactive properties without make the object explicitly reactive</span></span><br><span class="line">                        <span class="comment">// NOTE we should try to avoid this, better implementation needed</span></span><br><span class="line">                        <span class="title function_">customReactive</span>(bindingValue)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = <span class="title function_">ref</span>(bindingValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">asVmProperty</span>(vm, name, bindingValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">assert</span>(</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="string">`&quot;setup&quot; must return a &quot;Object&quot; or a &quot;Function&quot;, got &quot;<span class="subst">$&#123;<span class="built_in">Object</span>.prototype.toString</span></span></span><br><span class="line"><span class="subst"><span class="string">        .call(binding)</span></span></span><br><span class="line"><span class="subst"><span class="string">        .slice(<span class="number">8</span>, -<span class="number">1</span>)&#125;</span>&quot;`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-初始化-context"><a href="#4-1-初始化-context" class="headerlink" title="4.1. 初始化 context"></a>4.1. 初始化 context</h4><p>这个 <code>ctx</code> 是 <code>setup</code> 中接受的第二个参数，这个对象里面的内容是怎么生成的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = <span class="title function_">createSetupContext</span>(vm)</span><br></pre></td></tr></table></figure>

<p>下面是 <code>createSetupContext</code> 所做的事，首先是定义 <code>ctx</code> 对象中所有的 <code>key</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    <span class="attr">slots</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">as</span> <span class="title class_">SetupContext</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propsPlain = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;refs&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;listeners&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;isServer&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ssrContext&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> propsReactiveProxy = [<span class="string">&#x27;attrs&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> methodReturnVoid = [<span class="string">&#x27;emit&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>接下来就是给这些属性利用 <code>Object.defineProperty</code> 做一层代理，当然它们都是只读的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">propsPlain.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> srcKey = <span class="string">`$<span class="subst">$&#123;key&#125;</span>`</span></span><br><span class="line">  <span class="title function_">proxy</span>(ctx, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> vm[srcKey],</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Cannot assign to &#x27;<span class="subst">$&#123;key&#125;</span>&#x27; because it is a read-only property`</span>, vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>另外两个 <code>propsReactiveProxy</code> 和 <code>methodReturnVoid</code> 也差不多，这里就略过了。</p>
<h4 id="4-2-响应式-props"><a href="#4-2-响应式-props" class="headerlink" title="4.2. 响应式 props"></a>4.2. 响应式 props</h4><p>接着就是将 <code>props</code> 对象进行一遍 Observer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">def</span>(props, <span class="string">&#x27;__ob__&#x27;</span>, <span class="title function_">createObserver</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reactivity/reactive.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createObserver</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> observe &lt; any &gt; &#123;&#125;.<span class="property">__ob__</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <code>createObserver</code> 拿到一个把空对象经过 Vue. Observer 后的 <code>__ob__</code> 属性，也就是当前 <code>Observer</code> 实例对象，如果同学们对于 Vue Observer 的原理还不太熟悉，可以看这里 <a target="_blank" rel="noopener" href="http://caibaojian.com/vue-design/art/7vue-reactive.html#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E7%9A%84-ob-%E5%B1%9E%E6%80%A7">数据对象的 </a>，本文就不赘述了。</p>
<p>然后给 <code>props</code> 新增一个 <code>__ob_</code> 属性，指向前面拿到的这个 <code>__ob__</code> 。</p>
<h4 id="4-3-解析-slots"><a href="#4-3-解析-slots" class="headerlink" title="4.3. 解析 slots"></a>4.3. 解析 slots</h4><p>接着就是把当前实例的 <code>slots</code> 给代理到前面定义的 <code>ctx.slots</code> 中，这时候它只是一个空对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">resolveScopedSlots</span>(vm, ctx.<span class="property">slots</span>)</span><br></pre></td></tr></table></figure>

<p>下面是 <code>resolveScopedSlots</code> 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resolveScopedSlots</span>(<span class="params"></span></span><br><span class="line"><span class="params">    vm: ComponentInstance,</span></span><br><span class="line"><span class="params">    slotsProxy: &#123;</span></span><br><span class="line"><span class="params">        [x: string]: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentVNode = (vm.<span class="property">$options</span> <span class="keyword">as</span> any).<span class="property">_parentVnode</span></span><br><span class="line">    <span class="keyword">if</span> (!parentVNode) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prevSlots = vmStateManager.<span class="title function_">get</span>(vm, <span class="string">&#x27;slots&#x27;</span>) || []</span><br><span class="line">    <span class="keyword">const</span> curSlots = <span class="title function_">resolveSlots</span>(parentVNode.<span class="property">data</span>.<span class="property">scopedSlots</span>, vm.<span class="property">$slots</span>)</span><br><span class="line">    <span class="comment">// remove staled slots</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; prevSlots.<span class="property">length</span>; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = prevSlots[index]</span><br><span class="line">        <span class="keyword">if</span> (!curSlots[key]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> slotsProxy[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy fresh slots</span></span><br><span class="line">    <span class="keyword">const</span> slotNames = <span class="title class_">Object</span>.<span class="title function_">keys</span>(curSlots)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; slotNames.<span class="property">length</span>; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = slotNames[index]</span><br><span class="line">        <span class="keyword">if</span> (!slotsProxy[key]) &#123;</span><br><span class="line">            slotsProxy[key] = <span class="title function_">createSlotProxy</span>(vm, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vmStateManager.<span class="title function_">set</span>(vm, <span class="string">&#x27;slots&#x27;</span>, slotNames)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是将父组件的 <code>slots</code> 数组（真正被使用的）代理到 <code>ctx.slots</code> 中，并且在这个 <code>slots</code> 数组有变化时 <code>ctx.slots</code> 也会相应地更新。</p>
<h4 id="4-4-执行-setup"><a href="#4-4-执行-setup" class="headerlink" title="4.4. 执行 setup"></a>4.4. 执行 setup</h4><p>终于到了最重要的关头，开始执行 <code>setup</code> 了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activateCurrentInstance</span>(vm, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// make props to be fake reactive, this is for `toRefs(props)`</span></span><br><span class="line">  binding = <span class="title function_">setup</span>(props, ctx)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>activateCurrentInstance</code> 之前讲过了，就是使组件的 <code>setup</code> 内部可以通过 <code>getCurrentInstance</code> 访问当前实例，相信真正使用过 <code>composition-api</code> 的同学们都知道这个方法的便利性了，但不知道同学们是否遇到过 <code>getCurrentInstance</code> 方法返回 <code>null</code> 值的情况呢？如果想知道为什么，可以看这篇文章：<a target="_blank" rel="noopener" href="https://4ark.me/post/87ba8d8b.html">《从 Composition API 源码分析 getCurrentInstance() 为何返回 null》</a>。</p>
<p>然后将前面得到的 <code>props</code> 和 <code>ctx</code> 传进去，最后将返回值赋值给 <code>binding</code> 。</p>
<h4 id="4-6-处理-setup-返回值"><a href="#4-6-处理-setup-返回值" class="headerlink" title="4.6. 处理 setup 返回值"></a>4.6. 处理 setup 返回值</h4><p>处理返回值前需要先对它进行类型判断，有三种条件分支：</p>
<ol>
<li>为空，直接返回</li>
<li>是一个函数，当成 <code>render</code> 方法处理</li>
<li>是一个普通对象，做一系列转换</li>
</ol>
<p>如果返回值是一个函数，则把它当成 <code>render</code> 方法处理，当然在这之前需要重新调用一下 <code>resolveScopedSlots</code> 检测 <code>slots</code> 的更新，并且调用 <code>activateCurrentInstance</code>  ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isFunction</span>(binding)) &#123;</span><br><span class="line">  <span class="comment">// keep typescript happy with the binding type.</span></span><br><span class="line">  <span class="keyword">const</span> bindingFunc = binding</span><br><span class="line">  <span class="comment">// keep currentInstance accessible for createElement</span></span><br><span class="line">  vm.<span class="property">$options</span>.<span class="property">render</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-expect-error</span></span><br><span class="line">    <span class="title function_">resolveScopedSlots</span>(vm, ctx.<span class="property">slots</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">activateCurrentInstance</span>(vm, <span class="function">() =&gt;</span> <span class="title function_">bindingFunc</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps：也可以直接在 <code>setup</code> 中返回 <code>JSX</code> 哦，因为 Babel 会把它变成一个函数。</p>
<p>但通常我们是在 <code>setup</code> 返回一个对象，然后可以直接在 <code>template</code> 中使用这个这些值，所以我们看看返回值是一个对象的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(binding)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isReactive</span>(binding)) &#123;</span><br><span class="line">        binding = <span class="title function_">toRefs</span>(binding) <span class="keyword">as</span> <span class="title class_">Data</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmStateManager.<span class="title function_">set</span>(vm, <span class="string">&#x27;rawBindings&#x27;</span>, binding)</span><br><span class="line">    <span class="keyword">const</span> bindingObj = binding</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(bindingObj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">bindingValue</span>: any = bindingObj[name]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isRef</span>(bindingValue)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">isReactive</span>(bindingValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isFunction</span>(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = bindingValue.<span class="title function_">bind</span>(vm)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isObject</span>(bindingValue)) &#123;</span><br><span class="line">                    bindingValue = <span class="title function_">ref</span>(bindingValue)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasReactiveArrayChild</span>(bindingValue)) &#123;</span><br><span class="line">                    <span class="comment">// creates a custom reactive properties without make the object explicitly reactive</span></span><br><span class="line">                    <span class="comment">// NOTE we should try to avoid this, better implementation needed</span></span><br><span class="line">                    <span class="title function_">customReactive</span>(bindingValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isArray</span>(bindingValue)) &#123;</span><br><span class="line">                bindingValue = <span class="title function_">ref</span>(bindingValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">asVmProperty</span>(vm, name, bindingValue)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先如果返回的对象是经过 <code>reactive</code> 的，则要调用 <code>toRefs</code> 将它的子属性变成 <code>ref</code> 包装过的，然后调用 <code>vmStateManager.set</code> 将这些属性存放起来，以供别的地方使用。</p>
<p>然后遍历这个对象，经过一系列类型判断和处理后，将它的子属性设置为当前实例的变量，这样我们就可以在 <code>templte</code> 或者通过 <code>this.xxx</code> 去访问这些变量。</p>
<p>这里的类型处理简单总结一下就是：</p>
<ol>
<li>如果属性值是一个函数，则这个函数被调用时已经 <code>this</code> 就是当前实例</li>
<li>如果属性值一个非对象非函数的值，则会自动经过 <code>ref</code> 包装</li>
<li>如果属性值是一个普通对象且有子属性值为经过 <code>reactive</code> 后的数组，则要将这个普通对象也要转换为经过 <code>reactive</code> 包装才行，所以我们在开发时要避免如下情况：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">obj</span>: &#123;</span><br><span class="line">            <span class="attr">arr</span>: <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在开发环境下判断返回值不是对象是抛出一个错误。到此 <code>setup</code> 函数的执行就完了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 composition-api 的安装和执行过程就讲完了，下面我们来简单总结一下，composition-api 在安装时会做以下事情：</p>
<ol>
<li>通过检查 Vue 的 <code>__composition_api_installed__</code> 属性来判断是否重复安装</li>
<li>检查 Vue 版本是否 2.x</li>
<li>使用合并策略添加 <code>setup</code> api</li>
<li>标记安装</li>
<li>利用全局混入来对 <code>setup</code> 进行初始化</li>
</ol>
<p>而在执行 <code>setup</code> 时会做以下事情：</p>
<ol>
<li>检查当前组件是否使用 <code>render</code> 方法，如果有则在这之前标记当前实例，以便 <code>render</code> 方法内部可以通过 <code>getCurrentInstance</code> 方法访问到当前实例。</li>
<li>检查当前组件有 <code>setup</code> api，没有则直接返回，否则在初始化 <code>data</code> 时先初始化一下 <code>setup</code></li>
<li>而初始化 <code>setup</code> 做的事就是构造 <code>setup</code> 接受的两个参数：props、ctx</li>
<li>然后执行 <code>setup</code> ，根据它的返回值类型进行相应的处理</li>
</ol>
<p>当然，compsition-api 真正的魅力在于 hooks，下次我就来讲讲 composition-api 的一系列 hooks 是如何实现的，这也能帮助我们更好地利用这些 hooks 方法来编写更优雅、可复用的代码。</p>
<p>本文就到此，感谢你的阅读。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/vuex-score-code.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/vuex-score-code.html" itemprop="url">vuex 源码解析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-14T16:00:00+00:00">
                2021-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>本文是针对 vuex <a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex/releases/tag/v3.6.2">v3.6.2</a> 版本的一次源码解析，主要是想研究以下几点：</p>
<ol>
<li>vuex 的初始化过程</li>
<li>vuex 的数据状态如何存放</li>
<li>调用一个 mutation 时做了什么</li>
<li>mapState、mapActions 这些绑定函数的实现</li>
</ol>
<h2 id="一、初始化过程"><a href="#一、初始化过程" class="headerlink" title="一、初始化过程"></a>一、初始化过程</h2><p>我们平时使用 vuex 的时候需要先通过 new 一个 <code>Vuex.Store</code> 来创建一个 store，下面我们就看看在构造一个 store 时需要经过哪些操作，我们先来看看它的构造函数，它的源码在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vuex/blob/HEAD/src/store.js">src&#x2F;store.js</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Vue</span> <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Vue</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">Vue</span>) &#123;</span><br><span class="line">      <span class="title function_">install</span>(<span class="variable language_">window</span>.<span class="property">Vue</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="title function_">assert</span>(<span class="title class_">Vue</span>, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">      <span class="title function_">assert</span>(</span><br><span class="line">        <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">        <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="title function_">assert</span>(</span><br><span class="line">        <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Store</span>,</span><br><span class="line">        <span class="string">`store must be called with the new operator.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store internal state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_actions</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_actionSubscribers</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_mutations</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_wrappedGetters</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_modulesNamespaceMap</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_subscribers</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_watcherVM</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_makeLocalGettersCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">boundDispatch</span>(<span class="params">type, payload</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch.<span class="title function_">call</span>(store, type, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strict mode</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strict</span> = strict</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>.<span class="property">state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init root module.</span></span><br><span class="line">    <span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line">    <span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">    <span class="title function_">installModule</span>(<span class="variable language_">this</span>, state, [], <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line">    <span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">    <span class="title function_">resetStoreVM</span>(<span class="variable language_">this</span>, state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply plugins</span></span><br><span class="line">    plugins.<span class="title function_">forEach</span>(<span class="function">(<span class="params">plugin</span>) =&gt;</span> <span class="title function_">plugin</span>(<span class="variable language_">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> useDevtools =</span><br><span class="line">      options.<span class="property">devtools</span> !== <span class="literal">undefined</span> ? options.<span class="property">devtools</span> : <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">devtools</span></span><br><span class="line">    <span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">      <span class="title function_">devtoolPlugin</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不是很长，下面我们逐段分析一下这个构造函数中做了哪些操作。</p>
<h3 id="1-自动安装"><a href="#1-自动安装" class="headerlink" title="1. 自动安装"></a>1. 自动安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Vue</span> <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Vue</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">Vue</span>) &#123;</span><br><span class="line">      <span class="title function_">install</span>(<span class="variable language_">window</span>.<span class="property">Vue</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">_Vue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span> &amp;&amp; _Vue === <span class="title class_">Vue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">        <span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Vue</span> = _Vue</span><br><span class="line">  <span class="title function_">applyMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new Store</code> 的时候如果还未安装，并且已经有全局引入 Vue 的情况下，就会自动安装，但如果已经安装，则无需再次安装。</p>
<p>安装的时候会执行一下 <code>applyMixin</code> ，它的源码位在 <a target="_blank" rel="noopener" href="https://github1s.com/vuejs/vuex/blob/HEAD/src/mixin.js">src&#x2F;mixin.js</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">Vue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> version = <span class="title class_">Number</span>(<span class="title class_">Vue</span>.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">      <span class="attr">beforeCreate</span>: vuexInit</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">    <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">    <span class="keyword">const</span> _init = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">      options.<span class="property">init</span> = options.<span class="property">init</span> ? [vuexInit].<span class="title function_">concat</span>(options.<span class="property">init</span>) : vuexInit</span><br><span class="line">      _init.<span class="title function_">call</span>(<span class="variable language_">this</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">vuexInit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">store</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span> =</span><br><span class="line">        <span class="keyword">typeof</span> options.<span class="property">store</span> === <span class="string">&#x27;function&#x27;</span> ? options.<span class="title function_">store</span>() : options.<span class="property">store</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.<span class="property">parent</span> &amp;&amp; options.<span class="property">parent</span>.<span class="property">$store</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span> = options.<span class="property">parent</span>.<span class="property">$store</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是只做了一件事：将 store 挂载到 <code>$store</code> ，所以我们可以在 <code>vue</code> 组件中通过 <code>$store</code> 访问到 store。</p>
<h3 id="2-异常检测"><a href="#2-异常检测" class="headerlink" title="2. 异常检测"></a>2. 异常检测</h3><p>如果是在开发环境的话，就会做一些检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="title function_">assert</span>(<span class="title class_">Vue</span>, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">  <span class="title function_">assert</span>(</span><br><span class="line">    <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">    <span class="string">`vuex requires a Promise polyfill in this browser.`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="title function_">assert</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Store</span>, <span class="string">`store must be called with the new operator.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-初始化内部变量"><a href="#3-初始化内部变量" class="headerlink" title="3. 初始化内部变量"></a>3. 初始化内部变量</h3><p>然后定义了一系列内部变量，这些变量后面都会讲到的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; plugins = [], strict = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line"><span class="comment">// store internal state</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">false</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_actions</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_actionSubscribers</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_mutations</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_wrappedGetters</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_modulesNamespaceMap</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_subscribers</span> = []</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_watcherVM</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_makeLocalGettersCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="variable language_">this</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">boundDispatch</span>(<span class="params">type, payload</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.<span class="title function_">call</span>(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strict mode</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">strict</span> = strict</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>.<span class="property">state</span></span><br></pre></td></tr></table></figure>

<p>这里有几点比较值得关注的，下面来逐一讲讲。</p>
<h4 id="3-1-构造-modules"><a href="#3-1-构造-modules" class="headerlink" title="3.1. 构造 modules"></a>3.1. 构造 modules</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_modules</span> = <span class="keyword">new</span> <span class="title class_">ModuleCollection</span>(options)</span><br></pre></td></tr></table></figure>

<p>它会通过 new 一个 ModuleCollection 并传入 options 得到 modules，ModuleCollection 内部会递归注册所有的子模块。</p>
<p>最终返回一个类似如下的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">_children</span>: &#123;</span><br><span class="line">        <span class="attr">subModule1</span>: <span class="title class_">Module</span> &#123;</span><br><span class="line">            <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">_children</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">state</span>: &#123;</span><br><span class="line">                …&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">subModule2</span>: <span class="title class_">Module</span> &#123;</span><br><span class="line">            <span class="attr">runtime</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">_children</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">                …&#125;,</span><br><span class="line">            <span class="attr">state</span>: &#123;</span><br><span class="line">                …&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_rawModule</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: &#123;</span><br><span class="line">            <span class="attr">subModule1</span>: &#123;</span><br><span class="line">                <span class="attr">state</span>: &#123;</span><br><span class="line">                    …&#125;,</span><br><span class="line">                <span class="attr">mutations</span>: &#123;</span><br><span class="line">                    …&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attr">subModule2</span>: &#123;</span><br><span class="line">                <span class="attr">state</span>: &#123;</span><br><span class="line">                    …&#125;,</span><br><span class="line">                <span class="attr">mutations</span>: &#123;</span><br><span class="line">                    …&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这里先不用太纠结，大概知道就好。</p>
<h4 id="3-2-包装-dispatch-和-commit"><a href="#3-2-包装-dispatch-和-commit" class="headerlink" title="3.2. 包装 dispatch 和 commit"></a>3.2. 包装 dispatch 和 commit</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind commit and dispatch to self</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="variable language_">this</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">boundDispatch</span>(<span class="params">type, payload</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.<span class="title function_">call</span>(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里之所以要把 <code>dispatch</code> 和 <code>commit</code> 方法包装一下，是为了确保无论如何调用这两个方法， <code>this</code> 始终指向 store 实例。</p>
<p>因为在 js 中，不管是有意或者无意，能够改变 <code>this</code> 指向的操作太多了，所以 <code>vuex</code> 考虑到了这一点。</p>
<h3 id="4-初始化-module"><a href="#4-初始化-module" class="headerlink" title="4. 初始化 module"></a>4. 初始化 module</h3><p>接着就会使用前面得到的 <code>_module</code>   来初始化 module，传入的是 <code>_module.root</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init root module.</span></span><br><span class="line"><span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line"><span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line"><span class="title function_">installModule</span>(<span class="variable language_">this</span>, state, [], <span class="variable language_">this</span>.<span class="property">_modules</span>.<span class="property">root</span>)</span><br></pre></td></tr></table></figure>

<p>同样它只需要传入 root 模块，方法内会去检测如果存在子模块则会递归调用去初始化所有子模块。</p>
<p>下面是 <code>installModule</code> 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">installModule</span>(<span class="params">store, rootState, path, <span class="variable language_">module</span>, hot</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store.<span class="property">_modules</span>.<span class="title function_">getNamespace</span>(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">namespaced</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">_modulesNamespaceMap</span>[namespace] &amp;&amp; __DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">        <span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;namespace&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="subst"><span class="string">          <span class="string">&#x27;/&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">        )&#125;</span>`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    store.<span class="property">_modulesNamespaceMap</span>[namespace] = <span class="variable language_">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = <span class="title function_">getNestedState</span>(rootState, path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    store.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`[vuex] state field &quot;<span class="subst">$&#123;moduleName&#125;</span>&quot; was overridden by a module with the same name at &quot;<span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="subst"><span class="string">              <span class="string">&#x27;.&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">            )&#125;</span>&quot;`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Vue</span>.<span class="title function_">set</span>(parentState, moduleName, <span class="variable language_">module</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="variable language_">module</span>.<span class="property">context</span> = <span class="title function_">makeLocalContext</span>(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachMutation</span>(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    <span class="title function_">registerMutation</span>(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachAction</span>(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.<span class="property">root</span> ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.<span class="property">handler</span> || action</span><br><span class="line">    <span class="title function_">registerAction</span>(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachGetter</span>(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    <span class="title function_">registerGetter</span>(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">forEachChild</span>(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">installModule</span>(store, rootState, path.<span class="title function_">concat</span>(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-初始化-root-模块"><a href="#4-1-初始化-root-模块" class="headerlink" title="4.1 初始化 root 模块"></a>4.1 初始化 root 模块</h4><p>由于这个方法是会递归调用的，我们先来看看它在初始化根模块时会执行的逻辑，首先它会调用 <code>makeLocalContext</code> 构造出属于当前模块的一个上下文，也就是我们平时在 <code>action</code> 中获取的那个 <code>ctx</code> 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> local = (<span class="variable language_">module</span>.<span class="property">context</span> = <span class="title function_">makeLocalContext</span>(store, namespace, path))</span><br></pre></td></tr></table></figure>

<p>接着会处理当前模块的 <code>mutations</code> 、 <code>actions</code> 、 <code>getters</code> ，以及如果有子模块的话就递归调用 <code>installModule</code> 对子模块进行相同的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="title function_">forEachMutation</span>(<span class="keyword">function</span> (<span class="params">mutation, key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> namespacedType = namespace + key</span><br><span class="line">  <span class="title function_">registerMutation</span>(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">forEachAction</span>(<span class="keyword">function</span> (<span class="params">action, key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> type = action.<span class="property">root</span> ? key : namespace + key</span><br><span class="line">  <span class="keyword">var</span> handler = action.<span class="property">handler</span> || action</span><br><span class="line">  <span class="title function_">registerAction</span>(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">forEachGetter</span>(<span class="keyword">function</span> (<span class="params">getter, key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> namespacedType = namespace + key</span><br><span class="line">  <span class="title function_">registerGetter</span>(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">forEachChild</span>(<span class="keyword">function</span> (<span class="params">child, key</span>) &#123;</span><br><span class="line">  <span class="title function_">installModule</span>(store, rootState, path.<span class="title function_">concat</span>(key), child, hot)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-初始化子模块"><a href="#4-2-初始化子模块" class="headerlink" title="4.2. 初始化子模块"></a>4.2. 初始化子模块</h4><p>而对于子模块，会额外执行一些其它逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set state</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">var</span> parentState = <span class="title function_">getNestedState</span>(rootState, path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">var</span> moduleName = path[path.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  store.<span class="title function_">_withCommit</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;[vuex] state field &quot;&#x27;</span> +</span><br><span class="line">            moduleName +</span><br><span class="line">            <span class="string">&#x27;&quot; was overridden by a module with the same name at &quot;&#x27;</span> +</span><br><span class="line">            path.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>) +</span><br><span class="line">            <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">set</span>(parentState, moduleName, <span class="variable language_">module</span>.<span class="property">state</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是将子模块的 <code>state</code> 设置到父模块的 <code>state</code> 中去，这也是为什么我们可以通过这种方式来获取子模块的 <code>state</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">subModule1</span>: &#123;</span><br><span class="line">        <span class="attr">count1</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">subModule2</span>: &#123;</span><br><span class="line">        <span class="attr">count2</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-初始化命名空间模块"><a href="#4-3-初始化命名空间模块" class="headerlink" title="4.3. 初始化命名空间模块"></a>4.3. 初始化命名空间模块</h4><p>对于使用命名空间的情况，在这基础上还会执行额外的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace = store.<span class="property">_modules</span>.<span class="title function_">getNamespace</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register in namespace map</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">namespaced</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">_modulesNamespaceMap</span>[namespace] &amp;&amp; (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>((<span class="string">&quot;[vuex] duplicate namespace &quot;</span> + namespace + <span class="string">&quot; for the namespaced module &quot;</span> + (path.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        store.<span class="property">_modulesNamespaceMap</span>[namespace] = <span class="variable language_">module</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <code>getNamespace</code> 拿到命名空间的名称，其实就是在模块名后面加一个 <code>/</code> ，比如： <code>subModule/</code> ，当然如果没有开启 <code>namespaced</code> ，拿到的其实是空字符串。然后将它作为 <code>key</code> 存入 <code>_modulesNamespaceMap</code> 中，有什么作用后面会讲到。</p>
<h4 id="4-4-初始化-mutation、action、getter"><a href="#4-4-初始化-mutation、action、getter" class="headerlink" title="4.4. 初始化 mutation、action、getter"></a>4.4. 初始化 mutation、action、getter</h4><p>对于所有模块，初始化   <code>mutation</code> 、 <code>action</code> 、 <code>getter</code> 都是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="title function_">forEachMutation</span>(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  <span class="title function_">registerMutation</span>(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先将每个 <code>mutation</code> 的 <code>key</code> 与当前模块的命名空间名称拼接在一起，然后调用 <code>registerMutation</code> 将整个 store、拼接后的 mutation key、mutation 方法、还有当前模块上下文传入，下面是 <code>registerMutation</code> 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerMutation</span>(<span class="params">store, type, handler, local</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store.<span class="property">_mutations</span>[type] || (store.<span class="property">_mutations</span>[type] = [])</span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedMutationHandler</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">    handler.<span class="title function_">call</span>(store, local.<span class="property">state</span>, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是将这些 <code>mutation</code> 通通传入 store.__mutations 这个数组中，不过这里你可能会好奇为什么 <code>_mutations[type]</code> 是一个数组，这是因为可能会不同模块中（没开启命名空间的情况）存在多个同名的 mutation，这时候需要调用所有同名的 mutation，其实 action 也是这样的。</p>
<p>这里的初始化仅仅只是包装一层使它们与命名空间的 key 关联在一起、以及在调用时自动传入一些模块上下文的参数而已。 同样的， <code>action</code> 和 <code>getter</code> 初始化过程都差不多，都是经过包装过存入 <code>_actions</code> 和 <code>_wrappedGetters</code> 中，当然由于 <code>action</code> 是支持异步的，所以需要额外处理一下 <code>Promise</code> 。</p>
<h3 id="5-初始化-state"><a href="#5-初始化-state" class="headerlink" title="5. 初始化 state"></a>5. 初始化 state</h3><p>初始化完 module 以后就会处理 <code>state</code> 里的数据，使它变成响应式，同时处理前面经过包装的 <code>getter</code> ，使它变成类似于 <code>computed</code> 意义的东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line"><span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line"><span class="title function_">resetStoreVM</span>(<span class="variable language_">this</span>, state)</span><br></pre></td></tr></table></figure>

<p>下面是 <code>resetStoreVM</code> 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resetStoreVM</span>(<span class="params">store, state, hot</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store.<span class="property">_vm</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.<span class="property">getters</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// reset local getters cache</span></span><br><span class="line">  store.<span class="property">_makeLocalGettersCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store.<span class="property">_wrappedGetters</span></span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">  <span class="title function_">forEachValue</span>(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">    <span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">    computed[key] = <span class="title function_">partial</span>(fn, store)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(store.<span class="property">getters</span>, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> store.<span class="property">_vm</span>[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line">  <span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line">  <span class="comment">// some funky global mixins</span></span><br><span class="line">  <span class="keyword">const</span> silent = <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = <span class="literal">true</span></span><br><span class="line">  store.<span class="property">_vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">$$state</span>: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = silent</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new vm</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">strict</span>) &#123;</span><br><span class="line">    <span class="title function_">enableStrictMode</span>(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        oldVm.<span class="property">_data</span>.<span class="property">$$state</span> = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-处理-state"><a href="#5-1-处理-state" class="headerlink" title="5.1. 处理 state"></a>5.1. 处理 state</h4><p>原来 <code>vuex</code> 是直接 new 一个 Vue 实例来实现状态响应式，不过这样做无可厚非，毕竟 <code>vuex</code> 本来就是 Vue 专用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// silent 是取消 Vue 所有的日志与警告</span></span><br><span class="line"><span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line"><span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line"><span class="comment">// some funky global mixins</span></span><br><span class="line"><span class="keyword">const</span> silent = <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = <span class="literal">true</span></span><br><span class="line">store.<span class="property">_vm</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">$$state</span>: state</span><br><span class="line">  &#125;,</span><br><span class="line">  computed</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">silent</span> = silent</span><br></pre></td></tr></table></figure>

<h4 id="5-2-处理-getters"><a href="#5-2-处理-getters" class="headerlink" title="5.2. 处理 getters"></a>5.2. 处理 getters</h4><p>而 <code>getter</code> 的本质就是一个 <code>computed</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind store public getters</span></span><br><span class="line">store.<span class="property">getters</span> = &#123;&#125;</span><br><span class="line"><span class="comment">// reset local getters cache</span></span><br><span class="line">store.<span class="property">_makeLocalGettersCache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> wrappedGetters = store.<span class="property">_wrappedGetters</span></span><br><span class="line"><span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line"><span class="title function_">forEachValue</span>(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  <span class="comment">// direct inline function use will lead to closure preserving oldVm.</span></span><br><span class="line">  <span class="comment">// using partial to return function with only arguments preserved in closure environment.</span></span><br><span class="line">  computed[key] = <span class="title function_">partial</span>(fn, store)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(store.<span class="property">getters</span>, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> store.<span class="property">_vm</span>[key],</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-调用所有-plugin"><a href="#6-调用所有-plugin" class="headerlink" title="6. 调用所有 plugin"></a>6. 调用所有 plugin</h3><p>这个没什么好说的，就是把所有插件都调用一遍，传入 <code>this</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply plugins</span></span><br><span class="line">plugins.<span class="title function_">forEach</span>(<span class="function">(<span class="params">plugin</span>) =&gt;</span> <span class="title function_">plugin</span>(<span class="variable language_">this</span>))</span><br></pre></td></tr></table></figure>

<h3 id="7-devtools"><a href="#7-devtools" class="headerlink" title="7. devtools"></a>7. devtools</h3><p>最后是一些 vue devtools 相关的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useDevtools =</span><br><span class="line">  options.<span class="property">devtools</span> !== <span class="literal">undefined</span> ? options.<span class="property">devtools</span> : <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">devtools</span></span><br><span class="line"><span class="keyword">if</span> (useDevtools) &#123;</span><br><span class="line">  <span class="title function_">devtoolPlugin</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/plugins/devtool.js</span></span><br><span class="line"><span class="keyword">const</span> target =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">    ? <span class="variable language_">window</span></span><br><span class="line">    : <span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">    ? <span class="variable language_">global</span></span><br><span class="line">    : &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> devtoolHook = target.<span class="property">__VUE_DEVTOOLS_GLOBAL_HOOK__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">devtoolPlugin</span>(<span class="params">store</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!devtoolHook) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  store.<span class="property">_devtoolHook</span> = devtoolHook</span><br><span class="line"></span><br><span class="line">  devtoolHook.<span class="title function_">emit</span>(<span class="string">&#x27;vuex:init&#x27;</span>, store)</span><br><span class="line"></span><br><span class="line">  devtoolHook.<span class="title function_">on</span>(<span class="string">&#x27;vuex:travel-to-state&#x27;</span>, <span class="function">(<span class="params">targetState</span>) =&gt;</span> &#123;</span><br><span class="line">    store.<span class="title function_">replaceState</span>(targetState)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  store.<span class="title function_">subscribe</span>(</span><br><span class="line">    <span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">      devtoolHook.<span class="title function_">emit</span>(<span class="string">&#x27;vuex:mutation&#x27;</span>, mutation, state)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">prepend</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  store.<span class="title function_">subscribeAction</span>(</span><br><span class="line">    <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">      devtoolHook.<span class="title function_">emit</span>(<span class="string">&#x27;vuex:action&#x27;</span>, action, state)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">prepend</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是初始化 vuex 的整个过程了，不过有些地方只是粗略讲了一下，下面针对各种细节再深入探讨。</p>
<h2 id="二、调用-mutation-过程"><a href="#二、调用-mutation-过程" class="headerlink" title="二、调用 mutation 过程"></a>二、调用 mutation 过程</h2><p>下面讲讲调用某个  mutation 时会发生什么，比如我们使用如下代码调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;subModule1/increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先会进入之前讲过的包装后的 <code>commit</code> ，它确保无论怎么调用 <code>this</code> 始终指向当前 store 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会调用真正的 <code>commit</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">commit</span>(<span class="params">_type, _payload, _options</span>) &#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        payload,</span><br><span class="line">        options</span><br><span class="line">    &#125; = <span class="title function_">unifyObjectStyle</span>(</span><br><span class="line">        _type,</span><br><span class="line">        _payload,</span><br><span class="line">        _options</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> mutation = &#123;</span><br><span class="line">        type,</span><br><span class="line">        payload</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="variable language_">this</span>.<span class="property">_mutations</span>[type]</span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">commitIterator</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">            <span class="title function_">handler</span>(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_subscribers</span></span><br><span class="line">        .<span class="title function_">slice</span>() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> <span class="title function_">sub</span>(mutation, <span class="variable language_">this</span>.<span class="property">state</span>))</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; options &amp;&amp; options.<span class="property">silent</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class="line">            <span class="string">&#x27;Use the filter functionality in the vue-devtools&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面讲过可能会存在多个同名的 mutation，所以这里依次调用它们，但是为什么要先经过 <code>_withCommit</code> 方法呢？看它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_withCommit</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> committing = <span class="variable language_">this</span>.<span class="property">_committing</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_committing</span> = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果开启了严格模式，它会监听 state 值的变更，只要不是通过 mutation 内部来修改 state 值就会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enableStrictMode</span>(<span class="params">store</span>) &#123;</span><br><span class="line">  store.<span class="property">_vm</span>.$watch(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">$$state</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">assert</span>(</span><br><span class="line">          store.<span class="property">_committing</span>,</span><br><span class="line">          <span class="string">`do not mutate vuex store state outside mutation handlers.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">sync</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、mapState、mapActions-这些绑定函数的实现"><a href="#三、mapState、mapActions-这些绑定函数的实现" class="headerlink" title="三、mapState、mapActions 这些绑定函数的实现"></a>三、mapState、mapActions 这些绑定函数的实现</h2><p>先来看看这四个方法的定义，它们的源码都在 src&#x2F;helpers.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, mutations</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, actions</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>它们都先经过一个叫 <code>normalizeNamespace</code> 的方法处理，顾名思义这个方法是解析命名空间的，我们知道 <code>mapXXX</code> 这些方法可以接受一个或者两个参数，正常情况下第一个参数为 state module 的命名空间，第二个参数则是需要获取的内容，但是也支持只传入第一个参数，则这时候命名空间为 root。</p>
<p>所以这个方法的实现就简单了，只需要判断第一个参数是否为字符串，如果是的话则把它当成 map 处理，否则正常处理，并且在最后加上一个 <code>/</code> ，这个在前面初始化命名空间模块时就有提到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalizeNamespace</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.<span class="title function_">charAt</span>(namespace.<span class="property">length</span> - <span class="number">1</span>) !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">      namespace += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这四个方法的实现都大同小异，这里就只记录 <code>mapState</code> 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="title function_">isValidMap</span>(states)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">&#x27;[vuex] mapState: mapper parameter must be either an Array or an Object&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">normalizeMap</span>(states).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="keyword">function</span> <span class="title function_">mappedState</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> state = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">let</span> getters = <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span></span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapState&#x27;</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="variable language_">module</span>.<span class="property">context</span>.<span class="property">state</span></span><br><span class="line">        getters = <span class="variable language_">module</span>.<span class="property">context</span>.<span class="property">getters</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? val.<span class="title function_">call</span>(<span class="variable language_">this</span>, state, getters)</span><br><span class="line">        : state[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].<span class="property">vuex</span> = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其核心原理就是将传入的 <code>states</code> 进行序列化，然后在当前命名空间对应的模块中获取到这些值，其中还要判断一下是否为函数，是的话则调用该函数并且传入当前模块中的 <code>state</code> 和 <code>getters</code> ，将函数的返回存入对象中，最后返回。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://liyucang-git.github.io/2019/07/21/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">vuex 源码解析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E9%97%A8%E6%88%B7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%8ELow%20Code%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E9%97%A8%E6%88%B7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%8ELow%20Code%E5%AE%9E%E8%B7%B5/" itemprop="url">门户可视化搭建与Low Code实践</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-13T13:22:13+00:00">
                2021-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>偏中后台管理系统或者集成平台的应用入口，经常需要在应用入口进行<strong>个性化的展示</strong>。从用户角度来看，支持个性化的定制，可以有效提升用户的幸福感，提升使用或工作效率；从产品提供商来看，提供个性化定制服务的能力，也是提升产品力的一种方式。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffca8d1d514a42bcacbf5f1bb1716016~tplv-k3u1fbpfcp-watermark.image" alt="image001.png"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/%E9%97%A8%E6%88%B7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%8ELow%20Code%E5%AE%9E%E8%B7%B5/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83%EF%BC%9A%E4%B8%80%E6%9B%B2%E5%B9%95%E6%9C%AB%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8C%BD%E6%AD%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%B5%AA%E5%AE%A2%E5%89%91%E5%BF%83%EF%BC%9A%E4%B8%80%E6%9B%B2%E5%B9%95%E6%9C%AB%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8C%BD%E6%AD%8C/" itemprop="url">浪客剑心：一曲幕末时代的挽歌</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-12T00:53:48+00:00">
                2021-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>近日，Netflix 官方宣布，浪客剑心·最终章：追忆篇 将于 7 月 30 日上线，这意味着这部横跨十年时间、被誉为漫改巅峰的系列电影，终于要迎来它的落幕。人对于时间的感觉，难免会相对迟钝一点。如果将思绪拉回到 2011 年，对我来说，人生中无数闪光的时刻，无一不是从这一刻开始：第一次拥有互相喜欢的人、第一次拥有属于我的电脑、第一次在图书馆里借满 100 本书……每次听别人说到漫威十年，我总觉得一切无比陌生。回想起来，第一次到电影院看电影，始于 Lemon 同学请我吃石锅拌饭，对于漫威英雄们的了解，更多的是事后诸葛亮，而唯有浪客剑心系列，一直陪伴着我走过这兵荒马乱的十年。所以，当这个系列走向终点的时候，我果然还是想说点自以为是的话，因为在时代的波涛里，每一个小人物的命运，都不过是艰难挣扎着活下去。</p>
<p>也许，不光是此刻屏幕前的你，就连我自己完全想象不出，有一天我会对日本的影视作品产生兴趣。过去的我，是一个被人称为“不适合在现代社会”的“怪人”。彼时，我喜欢苏轼烟雨任平生的豁达，喜欢稼轩气吞万里如虎的豪迈，喜欢纳兰容若秋风画扇的悲凉……更多的时候，我是一个偏理想化、偏浪漫主义的文艺青年。在我越来越模糊的时光回忆里，全然没有火影忍者、海贼王这些日漫作品的身影，因为在喜欢安静的我看来，这些动漫人物总是在互相“攻伐”，或许是因为日&#x2F;韩的语言听起来更像是“吵架”，我一度认为这些东西是聒噪而喧嚣的。直到后来，接触到半泽直树、Legal High、白色巨塔这类影视作品，终于对日本人那种听起来像是“吵架”的表演风格有所了解，而像宫崎骏、新海诚、米林宏昌等动画导演的作品，则是后来一点点接触到的，甚至连鬼灭系列完全都是一个偶然，单纯是因为，我想找一个类似无皇刃谭的作品。</p>
<p><img src="https://i.loli.net/2021/07/17/h4q9frIXGyATeZS.jpg" alt="绯村剑心与雪代缘战斗"></p>
<p>第一次看浪客剑心的时候，我全然不知它是一部漫改作品。当时，除了感觉人物造型有点 cosplay 以外，更多的时候，我喜欢把当作日式古装片&#x2F;武侠片。庆幸的是，浪客剑心对于幕末&#x2F;明治时期的社会氛围一直刻画地不错，即使后来浪客剑心更为人所称道的，是 垣谷健治 从中国功夫电影中借鉴到的动作设计。动画版的浪客剑心，或被称之为：明治剑客浪漫谭。也许，是因为 100 多年的历史不远不近，更适合人们去肆意想象。所以，当我们提起明治亦或者民国，我们总是期待，那是一个浪漫的时代。浪客剑心的开场，是鸟羽伏见之战，电影中我们记住的，或许是剑心傲娇地将刀插在地上，因为最终赢得这场战争的，是剑心背后的新政府军。可历史永远比想象更残酷，末代幕府将军德川庆喜，在苍茫夜色中逃往大阪城的时候，是否会不时想起，在大坂夏之阵中独自对抗德川大军的真田幸村。历史是何其地相似，可当你恍然间惊觉，原来泛黄的书页已翻过三百余年。</p>
<p><img src="https://i.loli.net/2021/07/09/hMPNtmfHd8FKOrn.jpg" alt="鸟羽伏见战场"></p>
<p>有人说，日本幕府的毁灭始于黑船事件，自此以后便是让日本快速崛起的明治维新。如果把黑船(枪炮)看作西方工业革命的象征，明治维新无疑就是一场西洋枪炮与东瀛武士刀的角逐。所以，在这样一种背景下，浪客剑心里的矛盾冲突，其实都是新时代与旧时代的一次碰撞。禁刀令下，一个曾经双手沾满鲜血的刽子手——绯村拔刀斋，手握一柄逆刃刀，试图斩断一切囿于过去的亡魂，等到他终于放下心中的罪孽感，不再执着于过去发生的一切，脸上的十字刀疤终于消失不见。你告诉我，还有比听起来比这个更浪漫的故事吗？绯村剑心，本名心太，幼年时父母因混乱而死，在被人贩子运送途中遭山贼袭击，幸得飞天御剑流第十三代传人比古清十郎搭救并收为弟子，传授其飞天御剑流剑术。比古清十郎认为心太这个名字太过柔弱，不适合一名剑客，故将其改名为剑心。多年后，剑心与师父的意见向左，师父认为，<strong>剑是凶器，剑术就是杀人伎俩，无论是用多么华丽的词藻去粉饰终究是事实</strong>。</p>
<p><img src="https://i.loli.net/2021/07/09/dFegZqaQ23J8VCP.jpg" alt="剑心与师傅比古清十郎"></p>
<p>而在一个动荡的乱世，剑术固然可以锄强扶弱，可更多的或许是成为政客手里的杀人工具。一心想亲手拯救人民于水火的剑心，在下山后遇到了桂小五郎、高杉晋作等维新志士组成的奇兵队，自此成为专门暗杀幕府政要的刽子手，其出众的剑术令幕府闻风丧胆，人称刽子手拔刀斋。其实，在时代的洪流里，不管是作为刽子手的拔刀斋，还是作为浪人的剑心，其实都是一个时代的牺牲品。志志雄真实和剑心，本质上都属于同一类人，不同的是，志志雄是在新时代建立后被抛弃的人，因为身体被大面积烧伤而无法正常排汗，内心燥热的火焰终于要随无限刃而喷薄欲出，他从国外购买了铁甲舰、手下集结了十本刀，决心将这个新时代变成炼狱。明治维新，是两个新旧时代的碰撞，在这样一个大背景下，传统的武士、刽子手大量被抛弃。不管是鹈堂刃卫，还是志志雄真实，都失去了存在下去的意义，他们被鲜血和执念吞噬，试图用最极端的方式来证明自己的存在，在武侠的世界里，追求武功天下第一，是每一个习武之人的毕生追求，可禁刀令一出，大家都生活在充满法制、文明的时代，曾经的一切都仿佛不复存在。</p>
<p><img src="https://i.loli.net/2021/07/09/VtUchpjIKZeBrWL.jpg" alt="武士刀 &amp; 警棍"></p>
<p>这种失落感相当真实，多年以前，徐克拍摄《黄飞鸿》时，曾用“铁布衫”严振东的死，表达过这种在坚船利炮面前的无力感。纵观整个浪客剑心系列，除了第一部的反派武田观柳以外，几乎没有绝对的反派。有一个人，和这些囿于过去、不愿放过自己的人形成强烈对比，那就是斋藤一，这个被称为“壬生狼”的前新选组成员，永远奉行着“恶即斩”的主观标准。在每个被人潮推着向前走的时代，没有人能独善其身，可毫无疑问，斋藤一会是适应能力最强的那一类人。显然，剑心是那种愿意向前看，可依然对过去无法释怀的那一类人。有时候，我们会在文学作品中遇到隐形主角，譬如袁崇焕之于碧血剑，而浪客剑心的隐形主角，我以为应该是替剑心打造逆刃刀的新井赤空，一个铸剑师以匠人的心态打造神兵利器，结果这些刀剑都被用作凶器去杀人。同样地，一名剑客以济世救人的心态加入维新志士这一方，结果在迎接新时代到来的过程中夺去了别人的生命。</p>
<p><img src="https://i.loli.net/2021/07/09/vHI38FRoG9MOVWf.png" alt="新井赤空 &amp; 剑心"></p>
<p>可以说，剑心手上的逆刃刀，其实就是新井赤空的化身，两个人在赎罪这一心理上是高度一致的，甚至剑心内心的挣扎，早已和这把逆刃刀融为一体，逆刃刀固然会伤到自己，而一个人敢于直视自己的内心，未尝不会被这份鲜血淋漓灼伤，当剑心面对一个又一个的敌人，当剑心身上的秘密一点点被揭开，剑心面对的其实一条自我灵魂的救赎之路。电影中的逆刃刀一共有两把，第一把被称之为“影打”，属于试验品。在和“天剑”宗次郎对决的过程中被名刀虎彻斩断。第二把被称之为“真打”，属于千锤百炼的真品。在关键时刻让剑心打败十本刀之一的“刀狩”泽下条张。在京都大火篇中，当剑心准备从泽下条张手中救下伊织时，剑心有过一段阐述个人理念的独白，大意是说在新时代降生的孩子，都是真正的天选之子，值得他用生命去守护。从这里可以看出，即使曾经作为一个血债累累的刽子手，剑心灵魂深处的仁慈从未丢失过，多年后，他依然还是那个选择埋葬山贼和人贩子尸体的少年心太。</p>
<p><img src="https://i.loli.net/2021/07/09/toA6xTNQyYqGIZK.png" alt="剑心对战 “天剑” 宗次郎"></p>
<p>可这个角色让人着迷的地方就在于，剑心身上有着难以融合的关于救赎、杀念和仁慈的混合气质：手执逆刃刀，是为不杀之誓，是为自我救赎；在新时代拒绝传授飞天御剑流剑术，认为神谷活心流的“活人剑”更值得传承下去，是为武者之仁。在我的印象中，剑心只有两次真正动了杀心，一次是从鹈堂刃卫手中救下被“心之一方”麻痹肺部的神谷薰，一次是从“刀狩”下泽条张手中救下新井青空的孩子伊织。有时候，我会想，那个一直让剑心不要再杀人的女人可真狠心。直到后来，我终于明白，雪代巴和神谷薰，都是剑心的剑鞘，一个真正爱你的人，怎么会忍心看着你堕入修罗呢？历史的扑朔迷离，往往来自那些不经意间文过饰非的春秋笔法，浪客剑心的第三部，即传说的完结篇，在这一篇里，伊藤博文宣布，绯村拔刀斋已死，绯村剑心重生。后人已无法知晓，伊藤博文下令向铁甲站舰开炮时的心境，也许在某一瞬间，伊藤博文真的想让剑心，连同这些幕末的亡灵一起葬送于火海。如果是这样，每一个想成为时代弄潮儿的英雄，是否最后都变成了政治家的牺牲品呢？虽然我不得不承认，海滩上明治政府向武士们致敬的这一幕，一旦搭配上飞天的背景音乐，就会成为比少年热血漫还要沸腾的东西。</p>
<p><img src="https://i.loli.net/2021/07/09/R2XldmgBs47wauW.jpg" alt="明治政府向武士们致敬"></p>
<p>美国人曾经拍过一部电影《最后的武士》，描写社会变更时期的武士精神如何走向没落。历史的车轮呼啸而过，传统在飞扬的尘土中转瞬湮没。坂本龙马、大久保利通、西乡隆盛等维新志士，在历史的长河里惊鸿一瞥，人类面对滚滚历史长河时的渺小，大概就像大海中浮沉着的一叶孤舟，无论自身多么想要划向远方，最终亦不得不面对历史的进程。在这部电影结尾，明治天皇被阿汤哥的精神感动，从他手中接过胜元的武士刀，这大概是一种艺术加工。因为真实的历史是往往要更加残酷，此后的许多年里，武士道精神被偷换为军国主义，战争给这个世界带来的伤害可谓历历在目。我们说民国浪漫，是一种“为往圣继绝学，为万世开太平”的浪漫，是那种为了一个民族的未来，而甘愿做孺子牛、上下求索的浪漫。假如剥离这层浪漫的滤镜，将历史放大到一个普通人的生活。或许啊，我们看到的会是 《觉醒年代》 里的饿殍遍野、民生多艰。同样地，我们说明治浪漫，是那如夕阳一般绝美的最后的高光时刻。因为，在每一个时代，都有这样一群人，他们在新与旧，改革与保守，东方与西方的冲突中不断地挣扎。</p>
<p><img src="https://i.loli.net/2021/07/17/yDOkYUMW2i8qanN.jpg" alt="绯村剑心经典红白造型"></p>
<p>时至今日，年轻人对国家的未来充满希望，对个人的未来充满绝望，也许是因为，在时代的潮流中，普通人甚至比不上一朵小浪花，一如被剑心斩杀的雪代巴的未婚夫清里，本质上并无对错可言，无非是阵营不同。在浪客剑心里，年幼的心太对比古清十郎说，“人死了不过都是一具尸体”。多年后，我在日剧《Unnatural》 里找到了对应的答案，中堂医生在庭审时说过的话，“人这种生物，无论是谁，切开来剥开皮都只不过是一团肉，等你死了就知道了”。说到底，我们不过是碰巧活着啦，比古清十郎和高荷惠，都曾劝诫剑心，在救人前要先学会自保。或许，爱情更是如此，我们常说，“自爱沉稳而后爱人”，《仁医》 里穿越到幕末时代的医生南方仁，怀着对生命和历史的温情与敬意，不自觉地参与到幕末的各种历史事件中，并由此领悟到，“世间的一切都是先人赐予我们的，是历史中的每个人战斗、挣扎和牺牲所赢得的，更是由无数的生命奇迹编织而成，所以，我们必须用我们的双手，给予后人更加光明的未来”。剧中南方仁的仁是医者之仁，而坂本龙马的仁是以公义超越私爱，这两者共同构成这部电视剧的主题：仁，而剑心的仁在于止杀(戈)，这是真正的武者之仁。</p>
<p><img src="https://i.loli.net/2021/07/17/gFtbwBVfTsU1oql.jpg" alt="守护世界上最萌的剑心"></p>
<p>兔死狐悲的历史总在不断重复上演，历史上的白起、韩信、伍子胥，莫不如是。所以，对于志志雄真实这样一个悲情人物，总是会让人不由心生感慨。原著中的志志雄，不单单有蓄意谋国的野心，甚至开始探索“石油”这种属于未来的科技，在被明治政府抛弃以后，强忍着身心双重折磨，如丧尸一般存活下来。他建立起一套“弱肉强食”的社会达尔文主义理论，在手下十本刀的帮助下，意图颠覆刚建立不久的明治政府。每一个时代都有想成为“弄潮儿”的人，可更多的时候，不过是让这个世界频频陷入“大火”，时代的车轮呼啸着碾过的时候，牺牲的是无数细小的浪花、尘埃，每一个人都想成为英雄，可成为英雄的代价是什么呢？一将功成万骨枯，太阳从树叶的缝隙中穿过的时候，每一片叶子都合成了叶绿素，可难免会刺痛某个躺在树下乘凉的人的眼睛。不管是人诛篇的雪代缘，还是完结篇的志志雄，时代是需要英雄，可你不必非要成为那样的人，我还是想做一个普通人，因为，活着便能创造新的回忆。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-7-10-databackup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-7-10-databackup/" itemprop="url">吃了没备份数据的亏</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-10T10:00:00+00:00">
                2021-07-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是安哥。</p>
<p>之前曾介绍过用一种搭建个人博客的方法：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649880748&idx=1&sn=fb0ff081986dd788107f7bc867fb1853&chksm=83abfc81b4dc75970614ff85e078d47bb012214f0c4002fa2628651f44e416d0ef31d52dbe6f&token=1045425881&lang=zh_CN#rd">不会代码，如何零成本搭建个人博客？</a>  </p>
<p>这是一种使用 GitHub Pages 来搭建博客的方法，无需租用服务器和域名，完全免费。文章中用到了一款名为 Gridea 的静态博客客户端，以图形化的界面替代了在终端中配置博客、将本地仓库 Push 到 GitHub 的过程，对没有技术基础的人非常友好。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710174625308.png" alt="image-20210710174625308"></p>
<p>我很早之前就用这个方法，创建一个域名为 <code>phh95.github.io</code> 的博客，但后来因为它无法在国内正常访问，我就转移到了<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649893670&idx=1&sn=1f3f91248ade0d5f1bbe3c2046990d63&chksm=83a82f0bb4dfa61d463dfe7af7ecafa21ac0cf1bee21b1b147990b83f657f687d3857db40bf8&token=1045425881&lang=zh_CN#rd">现在的博客</a>，于是这个用 GitHub 托管的博客，就被我遗弃了。</p>
<p>昨天在网上搜东西，突然想起这个被遗弃已久的博客，想着要不要继续往上面发点东西，为了贪图方便，我还是选择使用 Gridea 来发布文章。</p>
<p>从网上下载 Gridea 客户端，配置好仓库信息之后，点击左下角的「同步」按钮，原以为它会先拉取原先存放在远端 GitHub 仓库的数据，把老文章克隆到本地。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/gridea%E5%90%8C%E6%AD%A5.png" alt="gridea同步"></p>
<p>但事情出乎我的意料，这个同步操作的意思是，将本地的数据 Push 到远端的 GitHub 仓库，并直接将远端仓库的数据全部覆盖掉。</p>
<p>哦吼完蛋，就因为这个<strong>误操作</strong>，我以前在这个博客上发布过的几篇旧文章，全部都没了，连过往的提交记录也一并没了，看起来就像是个刚建没多久的新仓库。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710180154841.png" alt="image-20210710180154841"></p>
<p>其实不止是我，还有一些用了 Gridea 的人，也同样遇到了这个问题，在 Gridea 的 GitHub 项目页面中，有位网友在 2019 年就提了一个 issue，比较幸运的是，这位网友在同步之前，还留了一手——备份。</p>
<p>但到了 2021 年，这个遗留已久的问题，还是存在，不过这回我就没那么幸运了，因为没有想到会发生这个问题，也就没有提前将远端仓库的数据备份下来。。。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710180443962.png" alt="image-20210710180443962"></p>
<p>唯一一点值得窃喜的是，还好我放在上面的文章不多，也不重要，没了也没了吧。</p>
<p>经过这件事，也让我想到：有时那么能让我们省去繁琐操作、帮我们避开难题来龙去脉的工具或方法，真的有那么想象中的那么靠谱吗？</p>
<p>现在如果你来问我，「<strong>有哪些学了就会受用一生的技能</strong>」，我会首先推荐：<strong>Git 和 GitHub</strong>，即便你不是程序员。</p>
<h2 id="将软件安装包上传到-GitHub-上"><a href="#将软件安装包上传到-GitHub-上" class="headerlink" title="将软件安装包上传到 GitHub 上"></a>将软件安装包上传到 GitHub 上</h2><p>之前我会为介绍的一些软件提供安装包，也就需要经常用到各种网盘，例如蓝奏云或者飞书的云文档。</p>
<p>但这些网盘的一个缺点在于，每次分享的文件都是独立的，不存在关联，这也导致了你无法查看我之前分享过的其他软件。</p>
<p>此外，还有一点，因为分享的软件不同，每次我都需要去后台，为每个软件单独设置不同的关键词，操作起来比较繁琐。</p>
<p>正好看到图床工具 PicGo 的开发者 PiEgg，在少数派上发表了一篇介绍自己使用 GitHub 的心得《<a target="_blank" rel="noopener" href="https://sspai.com/post/66131">从开源到应用分发，利用 GitHub 你能做这些事</a>》。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710182407268.png" alt="image-20210710182407268"></p>
<p>其中介绍到一个用法，使用 GitHub 的 <strong>release</strong> 功能，将应用作为附件上传到 GitHub，作为一种<strong>分发应用</strong>的方法，省去购买云服务器的费用。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710182538741.png" alt="image-20210710182538741"></p>
<p>受他的启发，我想到，这个 release 不就相当于一个云盘吗？于是我创建了一个名为「<strong>Awesome-Efficiency-Software</strong>」的仓库，将两个应用的安装包作为附件上传到 GitHub 中，效果如下图。</p>
<p>这样做的好处在于，其实前面也说了：你可以看到我过往分享过的软件，而且我也不需要设置多个关键词，每次想要分享软件的时候，可以先上传到这里，再把相同的链接分享给你，就够了。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/image-20210710182906878.png" alt="image-20210710182906878"></p>
<p>Awesome-Efficiency-Software 项目地址：</p>
<p><em><a target="_blank" rel="noopener" href="https://github.com/phh95/Awesome-Efficiency-Software/releases">https://github.com/phh95/Awesome-Efficiency-Software/releases</a></em> </p>
<p>*附：</p>
<p>来自 PicGo 开发者 - PiEgg 的文章《从开源到应用分发，利用 GitHub 你能做这些事》，扫描识别下方的二维码即可阅读：</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/PicGo/QRcode_A%20%E2%80%94%20a1.png" alt="QRcode_A — a1">   </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a><strong>欢迎关注</strong></h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">   </p>
<p>以上就是本次想和你分享的内容。<br>看完文章如果觉得对你有帮助的话，别忘了点击底部的「<strong>点赞&#x2F;在看</strong>」鼓励一下我，谢谢。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ASP.NET-Core%20%E6%90%AD%E8%BD%BD%20Envoy%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7/" itemprop="url">ASP.NET Core 搭载 Envoy 实现微服务的监控预警</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-10T06:41:24+00:00">
                2021-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在构建微服务架构的过程中，我们会接触到服务划分、服务编写以及服务治理这一系列问题。其中，服务治理是工作量最密集的一个环节，无论是服务发现、配置中心、故障转移、负载均衡、健康检查……等等，这一切的一切，本质上都是为了更好地对服务进行管理，尤其是当我们面对数量越来越庞大、结构越来越复杂的集群化环境的时候，我们需要一种科学、合理的管理手段。博主在上一家公司工作的时候，每次一出现线上故障，研发都要第一时间对问题进行排查和处理，而当时的运维团队，对于微服务的监控止步于<code>内存</code>和<code>CPU</code>，无法系统而全面的掌握微服务的运行情况，自然无法从运维监控的角度给研发部门提供方向和建议。所以，今天这篇文章，博主想和大家聊聊，如何利用Envoy来对微服务进行可视化监控。需要说明的是，本文的技术选型为<code>Envoy</code> + <code>ASP.NET Core</code> + <code>Prometheus</code> + <code>Grafana</code>，希望以一种无侵入的方式集成到眼下的业务当中。本文源代码已上传至 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/Regularly-Archive/2021/tree/master/src/EnvoyMonitor">Github</a> ，供大家学习参考。</p>
<h1 id="从-Envoy-说起"><a href="#从-Envoy-说起" class="headerlink" title="从 Envoy 说起"></a>从 Envoy 说起</h1><p>在介绍 Envoy 的时候，我们提到了一个词，叫做<strong>可观测的</strong>。什么叫<strong>可观测的</strong>呢？官方的说法是， Envoy 内置了<code>stats</code>模块，可以集成诸如<code>prometheus/statsd</code>等监控方案，可以集成分布式追踪系统，对请求进行追踪。对于这个说法，是不是依然有种云里雾里的感觉？博主认为，这里用<code>Metrics</code>这个词会更准确点，即<strong>可度量的</strong>，你可以认为， Envoy 提供了某种可度量的指标，通过这些指标我们可以对 Envoy 的运行情况进行评估。如果你使用过 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/what-is/elk-stack">Elastic Stack</a> 中的 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/kibana/">Kibana</a>，就会对指标(<strong>Metrics</strong>)这个词汇印象深刻，因为 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/kibana/">Kibana</a> 正是利用日志中的各种指标进行图表的可视化的。庆幸的是，<a target="_blank" rel="noopener" href="https://grafana.com/">Grafana</a> 中拥有与 <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/kibana/">Kibana</a> 类似的概念。目前， Envoy 中支持三种类型的统计指标：</p>
<ul>
<li><strong>Counter</strong>：即<strong>计数器</strong>，一种只会增加不会减少的无符号整数。例如，总请求数</li>
<li><strong>Gauge</strong>：即<strong>计量</strong>，一种可以同时增加或者同时减少的无符整数。例如，状态码为200的有效请求数</li>
<li><strong>Timer</strong>&#x2F;<strong>Hitogram</strong>：即<strong>计时器</strong>&#x2F;<strong>直方图</strong>，一种无符号整数，最终将产生汇总百分位值。Envoy 不区分计时器（通常以毫秒为单位）和 原始直方图（可以是任何单位）。 例如，上游请求时间（以毫秒为单位）。</li>
</ul>
<p>在今天的这篇文章中，除了 Envoy 以外，我们还需要两位新朋友的帮助，它们分别是<a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a> 和 <a target="_blank" rel="noopener" href="https://grafana.com/">Grafana</a>。其中，Prometheus 是一个开源的完整监控解决方案，其对传统监控系统如 Nagios、Zabbix 等的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。可以说，Prometheus 是完整监控解决方案中当之无愧的后起之秀，它最为人所称道的是它强大的数据模型，在 Prometheus 中所有采集到的监控数据吗，都以指标(<strong>Metrics</strong>)的形式存储在时序数据库中。和传统的关系型数据库中使用的 SQL 不同，Prometheus 定义一种叫做 PromQL 的查询语言，来实现对监控数据的查询、聚合、可视化、告警等功能。</p>
<p><img src="https://i.loli.net/2021/07/12/N4tRgsYJWPLaBlS.png" alt="Prometheus &amp; Grafana 的奇妙组合"></p>
<p>目前，社区中提供了大量的<a target="_blank" rel="noopener" href="https://prometheus.io/docs/instrumenting/exporters/">第三方系统</a>的采集功能的实现，这使得我们可以轻易地对MySQL、PostgresSQL、Consul、HAProxy、RabbitMQ， Redis等进行监控。而 Grafana 则是目前主流的时序数据展示工具，正是因为这个原因， Grafana 总是和 Prometheus 同时出现， Prometheus 中采集到监控数据以后，就可以由 Grafana 赖进行可视化。相对应地，Grafana 中有数据源的概念，除了 Prometheus 以外，它还可以使用来自 Elasticsearch 、InfluxDB 、MySQL 、OpenTSDB 等等的数据。基于这样一种思路，我们需要 Envoy 提供指标信息给 Prometheus ，然后再由 Grafana 来展示这些信息。所以，我们面临的主要问题，其实是怎么拿到 Envoy 中的指标信息，以及怎么把这些指标信息给到 Prometheus 。</p>
<h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>首先，我们来简单阐述一下原理。在 Envoy 的早期版本中，通常是通过 <a target="_blank" rel="noopener" href="https://github.com/statsd/statsd">statsd</a> 来采集 Envoy 中的信息，这些信息会被存储在 Prometheus 中，然后由 Grafana 从 Prometheus 中读取数据并展示为图表。而在 Envoy 最新的版本中，Envoy 本身就可以输出 Prometheus 需要的数据格式，故而就不再需要 <a target="_blank" rel="noopener" href="https://github.com/statsd/statsd">statsd</a> 这样一个监控工具。关于第一种方案，大家可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.servicemesher.com/blog/microservices-monitoring-with-envoy-service-mesh-prometheus-grafana/">Envoy Service Mesh、Prometheus和Grafana下的微服务监控</a>。这里，为了简单起见，我们采用第二种方案来进行集成。在接下来的例子中，我们会部署下面四个服务，我们希望在调用 gRPC 服务的时候，可以在 Grafana 看到相关的监控指标：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># prometheus</span></span><br><span class="line">  <span class="attr">prom:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/prometheus/prometheus:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./Prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:rw</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">2333</span><span class="string">:9090</span></span><br><span class="line">  <span class="comment"># envoy_gateway</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./Envoy/envoy.yaml:/etc/envoy/envoy.yaml</span></span><br><span class="line">  <span class="comment"># grpc_service</span></span><br><span class="line">  <span class="attr">grpc_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">GrpcService/GrpcService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">      <span class="attr">ASPNETCORE_ENVIRONMENT:</span> <span class="string">&quot;Development&quot;</span></span><br><span class="line">  <span class="comment"># grafana</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">“GF_SECURITY_ADMIN_PASSWORD=Gz2020@”</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">“GF_INSTALL_PLUGINS=alexanderzobnin-zabbix-app”</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">prom</span></span><br></pre></td></tr></table></figure>
<p>接下来，为了让 Prometheus 可以直接读取 Envoy 中输出的指标数据，我们需要在其配置文件<code>prometheus.yml</code>中添加一个对应的任务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> </span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">&#x27;codelab-monitor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;envoy&#x27;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/stats/prometheus&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_timeout:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9091&#x27;</span>]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家还记得 Envoy 中提供的管理接口吗？我们说 Envoy 提供了 Prometheus 格式的指标数据，其实就是指 Envoy 管理接口中的 <code>stats/prometheus</code> 接口，它对应的地址为：<code>http://localhost:9091/stats/prometheus</code>，直接访问这个地址，我们就可以得到下面的结果，这就是 Prometheus 需要的指标数据格式：</p>
<p><img src="https://i.loli.net/2021/07/10/PIQHEutC8SZasOF.png" alt=" Prometheus 需要的指标数据格式"></p>
<h1 id="数据源与可视化"><a href="#数据源与可视化" class="headerlink" title="数据源与可视化"></a>数据源与可视化</h1><p>现在，万事俱备，我们通过<code>docker-compose</code>启动服务即可，默认情况下，Prometheus 使用<code>9090</code>端口，Grafana 使用<code>3000</code>端口，其中，Grafana 默认的账号为<code>admin</code>&#x2F;<code>admin</code>，建议大家第一次登录后，及时修改默认的账号密码。</p>
<p><img src="https://i.loli.net/2021/07/12/WD1bSxfy6w7cU8X.png" alt="Prometheus 运行效果展示"></p>
<p><img src="https://i.loli.net/2021/07/10/sQyt21AKm4qr9CY.png" alt="Grafana 运行效果展示"></p>
<p>接下来，我们可以注意到，Prometheus 中两个 target 都已正常启动，这表示它们开始采集数据，我们还可以通过 Graph 菜单来查看当前采集到的数据。</p>
<p><img src="https://i.loli.net/2021/07/12/sbZTMlukpd9SrKc.png" alt="Prometheus 采集数据"></p>
<p>那么，数据采集到 Prometheus 以后，如何在 Grafana 中进行图表的可视化展示呢？首先，我们需要在 Grafana 中添加一个数据源，点击左侧第6个图标就可以找到入口。显然，这里的数据源就是 Prometheus ：</p>
<p><img src="https://i.loli.net/2021/07/12/3dsXEfRqFzHNvMb.png" alt="Grafana 添加数据源"></p>
<p>接下来，我们可以到官方的 <a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards">社区</a> 里找一个 Envoy 的模板，这是一个别人做好的 Dashboard，我们暂时用这个模板来看看效果。随着学习的深入，我们会先从自定义图表开始做起，最终，我们会拥有一个属于自己的 Dashboard 。这里，我们选择一个 Dashboard 模板后，复制其ID，并在 Grafana 中进行导入，导入的时候需要选择数据源，我们选择 Prometheus 即可。接下来，就是见证奇迹的时刻：</p>
<p><img src="https://i.loli.net/2021/07/10/GSNo7xaWLPzeIXT.png" alt="Envoy 监控面板效果展示"></p>
<h1 id="自定义图表"><a href="#自定义图表" class="headerlink" title="自定义图表"></a>自定义图表</h1><p>好了，如果大家阅读过官方文档，就会知道，除了 Prometheus ，像常见的 MySQL、Nginx 等，都可以作为 Grafana 的数据源，如果你需要监控 Nginx 的某个指标，这会是个非常不错的思路。那么。如何按照个人&#x2F;领导的要求，对 Dashboard 进行进一步的定制呢？这就要说到 Grafana 的自定义图表，这里，我们通过下面的例子来进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(envoy_http_rq_total&#123;envoy_http_conn_manager_prefix=&quot;grpc_json&quot;, instance=&quot;192.168.6.120:9902&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>
<p>在 Prometheus 中，采用的是与 <a target="_blank" rel="noopener" href="http://opentsdb.net/">OpenTSDB</a> 类似的时序格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，每一个指标含有多个键值形式的标签。例如，<code>http_requests_total&#123;method=&quot;POST&quot;&#125;</code>表示的是所有 HTTP 请求中的 POST 请求。</p>
<p>此外，除了上文中提到过的 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/concepts/metric_types/#counter">Counter</a> 、 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/concepts/metric_types/#gauge">Gauge</a> 、<a target="_blank" rel="noopener" href="https://prometheus.io/docs/concepts/metric_types/#histogram">Histogram</a> 这三种类型，Prometheus 还支持一种叫做 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/concepts/metric_types/#summary">Summary</a> 的类型。和大多数语言类似，这门被叫做 PromQL 的语言，(1)：支持常见的运算符，例如算术运算符、比较运算符、逻辑运算符、聚合运算符等等。(2)：支持大量的<a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/querying/functions/">内置函数</a>，例如，由浮点型转换为整型的<code>floor</code>和<code>ceil</code>，计算平均速率的<code>rate</code>等等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">floor(avg(http_requests_total&#123;code=&quot;200&quot;&#125;))</span><br><span class="line">ceil(avg(http_requests_total&#123;code=&quot;200&quot;&#125;))</span><br><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>
<p>在这里，我们给出的示例，它表示的是5分钟内 HTTP 请求的平均数目。我们可以在 Prometheus 中的 Graph 菜单对其结果进行查看：</p>
<p><img src="https://i.loli.net/2021/07/12/h5vwA1CjJIqs84T.png" alt="在 Prometheus 中查询 Envoy 指标数据"></p>
<p>通常，我们可以在这里对查询语句做简单的调试，而如果需要将其集成到 Grafana 中，我们就需要在 Grafana 新建一个图表，可以注意到，两者的语法是完全相同的，这里唯一的不同点在于，时间间隔从固定的5分钟变成了一个变量：</p>
<p><img src="https://i.loli.net/2021/07/12/5YzSxcUnIPE43Xm.png" alt="在 Grafana 中查询 Envoy 指标数据"></p>
<p>此时，我们就完成了一个自定义图表的制作，其中的关键有两点，<strong>其一是了解每一个指标的含义，其二是了解每一个内置函数的用法</strong>。革命尚未成功，同志仍须努力。这些内容无法在一篇博客里全部讲到，如果需要做进一步的探索，还是建议大家去看<a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/querying/basics/">官方文档</a>，这里博主可以给大家推荐一个不错的<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/prometheus_practice/promql-summary.md">中文文档</a>。</p>
<h1 id="文本小结"><a href="#文本小结" class="headerlink" title="文本小结"></a>文本小结</h1><p>本文介绍了利用 <a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a> 和 <a target="_blank" rel="noopener" href="https://grafana.com/">Grafana</a> 对 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a> 进行监控预警的方案。在 Envoy 的早期版本中，主流的方案都是通过  <a target="_blank" rel="noopener" href="https://github.com/statsd/statsd">statsd</a> 来采集 Envoy 的指标信息，而在 Envoy 最新版本中，它本身就可以输出 Prometheus 需要的数据格式，我们只需要在 Prometheus 的配置文件中指定<code>stats/prometheus</code>这个地址即可。Prometheus 采用了和 <a target="_blank" rel="noopener" href="http://opentsdb.net/">OpenTSDB</a> 类似的时序格式，每一个指标均含有多个键值形式的标签。Prometheus 在此基础上提供了 PromQL 查询语言，我们可以利用这个查询语言在 Grafana 中制作自定义图表，这些自定义图表可以是一个瞬时数据、可以是一个区间数据，或者是一个纯量数字，因此，我们可以按照自己的喜好去定制整个仪表盘，结合实际的业务场景来决定要关注哪些指标。除此以外，我们还可以在 Prometheus 定义<a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">告警规则</a>，当业务系统出现问题时，可以第一时间通知运维或者研发团队。在后端研发越来越服务化、集群化的今天，我们不能永远都盯着 CRUD 这一亩三分地，更普遍的，可能是针对 Docker、K8S、Redis、MySQL 等等基础设施的监控，扁鹊见蔡桓公的故事大家耳熟能详，防微杜渐，无论过去还是现在甚至将来都是一样的。好了，以上就是这篇博客的全部内容啦，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><a class="extend next" rel="next" href="/page/15/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
