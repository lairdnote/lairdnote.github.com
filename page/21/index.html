<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/21/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/21/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/7b1778ee.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/7b1778ee.html" itemprop="url">升级 IOS 14 的一些坑</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-19T15:37:23+08:00">
                2020-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IOS 14 正式版已经发布差不多一个星期了，也看到社区不少人开始讨论新特性，我当然也要跟上脚步，于是也开始把我的 iPhone 和 iPad 更新了，但这过程中却是踩了不少的坑，先记录下来，让后来者少花一些时间。</p>
<h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>我最终成功更新的过程是：</p>
<ol>
<li>在 Windows 下载最新版本的 iTunes</li>
<li>在 <a target="_blank" rel="noopener" href="https://www.iplaysoft.com/item/ios-ipsw-download">异次元</a> 下载 IOS 14 固件</li>
<li>打开 <code>Service.msc</code> ，将 <code>Remote Desktop Services</code> 设置为启用和自动</li>
<li>Windows 连接手机热点，不要连接宽带网络</li>
<li>在 iTunes 连接手机，按住 Shift 点击更新，选择固件，等待更新</li>
</ol>
<p>PS：先备份好手机数据，以防万一！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>收到推送的当天晚上睡觉前我就在手机和平板上都点了更新，然而等我早上起床打算愉快地体验新系统时，却发现没有更新，进入更新界面才发现下载了不到一半，显示「正在预估剩余时间」，第二天晚上再试了一下，结果还是一样。</p>
<p>既然在手机上更新不了，那就在电脑更新，于是连接到 Mac，点击更新，到最后一步出现「iPad “4Ark 的 iPad” 的软件下载时被损坏，断开后再次连接…」，换了 Windows 也是一样的问题。</p>
<p>于是我自己在网上找 IOS 14 的固件，最初我打算在官方，想着系统固件还是官方的比较安全，结果发现最新版本还是停留在 IOS 13.7，于是在一个相对比较靠谱的 <a target="_blank" rel="noopener" href="https://www.iplaysoft.com/item/ios-ipsw-download">异次元</a> 里把 IOS 和 iPadOs 固件下载回来。</p>
<p>因为我是在 Windows 下载的，所以也就在 Windows 最新版的 iTunes 上面更新，连接上手机，按住 Shift 点击更新，选择固件，结果出现「未能更新 iPhone，发生未知错误 53」，在 <a target="_blank" rel="noopener" href="https://discussionschinese.apple.com/thread/251504194">这里</a> 找到了解决方案，主要是电脑上的网络不要连接宽带，而是连接移动网络的热点。</p>
<p>结果在更新过程中，一直停留在「正在准备 iPhone 以进行软件更新」十几分钟，根据以往的折腾经验，准备工作超过十分钟基本就是有问题的了，于是果然在 <a target="_blank" rel="noopener" href="https://hcwang.pixnet.net/blog/post/40515550">这里</a> 找到了解决方案，主要就是：打开 <code>Service.msc</code> ，将 <code>Remote Desktop Services</code> 设置为启用和自动，重启 iTunes，重新连接手机，这时候终于可以更新了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>前两天还看到社区里的人都是手机上直接升级的，一睡醒就好了，怎么到我这里就一大堆问题 😩</p>
<p>但不管怎么说，这些问题我肯定不是第一个，更不可能是最后一个，本文就是为了让大家不要再浪费时间。</p>
<p>毕竟，周末美好时光，不能白白浪费嘛。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/09/08/2020/airpods-2-are-great/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/08/2020/airpods-2-are-great/" itemprop="url">AirPods 2 到手半个月，我的实际体验如何？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-08T19:51:00+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>先说好，这不是安利文：我没有推荐任何人购买 AirPods 2 的意思。</p>
<p>这篇文章仅旨在向各位分享我入手 AirPods 2 后的<strong>真实使用体验</strong>，有吐槽也有真香。</p>
<p>数码圈有个很奇怪的现象，总有那么些人抢着当「厂商孝子」「精神股东」，批评一句产品好像要了他们的命似的（更好笑的是还会互相扣帽子），对此我实在是难以理解。反正我对数码产品的态度一直都是：喜欢就买，开心就好。</p>
<p>如果你恰巧在考虑是否要入手 AirPods 2，希望这篇文章能对你有所帮助。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/09/08/2020/airpods-2-are-great/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/09/08/2020/dont-buy-a-gaming-laptop-for-college/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/08/2020/dont-buy-a-gaming-laptop-for-college/" itemprop="url">上大学买游戏本，你可能会后悔</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-08T03:50:00+08:00">
                2020-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>如果让我回到两年前，我肯定会告诉当时的自己：不要买游戏本。</p>
<p>好吧我知道，现在都九月份了，准大学生们电脑估计早就到手了，我这里啰嗦几句也没用。虽然估计也没人看，不过就当给以后的同学做个参考吧。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/09/08/2020/dont-buy-a-gaming-laptop-for-college/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/09/05/Dapper.Contrib%E5%9C%A8Oracle%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%95%E5%8F%91ORA-00928%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/Dapper.Contrib%E5%9C%A8Oracle%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%95%E5%8F%91ORA-00928%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/" itemprop="url">Dapper.Contrib 在 Oracle 环境下引发 ORA-00928 异常问题的解决</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-05T14:28:20+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>话说最近这两周里，被迫官宣<strong>996</strong>的生活实在是无趣，在两周时间里安排三周的工作量，倘若用丞相的口吻来说，那便是: <strong>我从未见过有如此厚颜无耻之人</strong>。无法为工作的紧急程度排出优先级，这便是身为肉食者们的<strong>鄙</strong>。古人云：<strong>肉食者鄙，未能远谋</strong>，诚不欺我也。一味地追求快速迭代，“屎”山越滚越高没有人在乎；一味地追求功能叠加，技术债务越来越多没有人在乎。所以，本着“多一事不如少一事”的原则，直接通过 Dapper 写 SQL 语句一样没有问题，因为被压榨完以后的时间只能写这个。在今天的这篇博客里，我想和大家分享的是，<code>Dapper.Contrib</code>在操作 Oracle 数据库时引发 <strong>ORA-00928: 缺失 SELECT 关键字</strong> 这一错误背后的根本原因，以及 Dapper 作为一个轻量级 ORM 在设计上做出的取舍。</p>
<h1 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h1><p>在使用 <code>Dapper.Contrib</code> 操作 Oracle 数据库的时候，通过 Insert() 方法来插入一个实体对象，此时，会引发 <strong>ORA-00928: 缺失 SELECT 关键字</strong> 这种典型的 Oracle 数据库错误，对于经常使用 Dapper 的博主而言，对于 <code>@</code> 还是 <code>:</code> 这种无聊的语法还是有一点经验的，在尝试手写 SQL 语句后，发现使用 Dapper 提供的 <code>Execute()</code> 扩展方法一点问题都没有，初步判定应该是 <code>Dapper.Contrib</code> 这个扩展库的问题，在翻阅 <code>Dapper</code> 的源代码以后，终于找到了问题的根源所在，所以，下面请跟随博主的目光，来一起解读解读 <code>Dapper.Contrib</code> 这个扩展库，相信你看完以后就会明白，为什么这里会被 Oracle 数据库摆上一道，以及为什么它至今都不考虑合并 Oracle 数据库相关的 PR。</p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>众所周知，<code>Dapper</code> 的核心其实就是一个 SqlMapper ，它提供的 Query() 和 Execute() 接口本身都是附加在 <code>IDbConnection</code> 接口上的扩展方法，所以，最基础的 <code>Dapper</code> 用法其实是伴随着 SQL 语句和以匿名对象为主的参数化查询，这可以说是 Dapper 的核心，而 <code>Dapper.Contrib</code> 在这个基础上提供了 Get()、Insert()、Delete() 和 Update() 等等常见的 CRUD 方法，这些方法都针对的是单主键的表，让 <code>Dapper</code>有了一点 ORM 的感觉，可惜的是 <code>Dapper.Contrib</code> 的实现是不完整的，主要是指下面两个方面，即：第一，官方未能提供 Oracle 版本的 <code>ISqlAdapter</code>。第二，兼容不同数据库自增 ID 的实现，让官方在处理 Id 的参数化查询时束手束脚，对 <code>ISqlAdapter</code> 的设计并不全面。</p>
<h2 id="Oracle-版本的-ISqlAdapter"><a href="#Oracle-版本的-ISqlAdapter" class="headerlink" title="Oracle 版本的 ISqlAdapter"></a>Oracle 版本的 ISqlAdapter</h2><p>首先，第一个结论，<code>Dapper.Contrib</code> 没有实现 Oracle 版本的 <code>ISqlAdapter</code> 。关于这个接口，我们可以在 <code>SqlMapperExtensions</code> 这个类中找到定义，而 <code>Dapper.Contrib</code> 内部实际上是维护了一个字典 <code>AdapterDictionary</code> ，在 <code>SqlMapperExtensions.cs</code> 文件的第 62 行 ~ 第 73 行，我们可以注意到，其内部提供了 6 种 <code>ISqlAdapter</code> 的实现，且默认为 <code>SqlServerAdapter</code> ：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ISqlAdapter DefaultAdapter = <span class="keyword">new</span> SqlServerAdapter();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, ISqlAdapter&gt; AdapterDictionary</span><br><span class="line">    = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, ISqlAdapter&gt;(<span class="number">6</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          [<span class="string">&quot;sqlconnection&quot;</span>] = <span class="keyword">new</span> SqlServerAdapter(),</span><br><span class="line">          [<span class="string">&quot;sqlceconnection&quot;</span>] = <span class="keyword">new</span> SqlCeServerAdapter(),</span><br><span class="line">          [<span class="string">&quot;npgsqlconnection&quot;</span>] = <span class="keyword">new</span> PostgresAdapter(),</span><br><span class="line">          [<span class="string">&quot;sqliteconnection&quot;</span>] = <span class="keyword">new</span> SQLiteAdapter(),</span><br><span class="line">          [<span class="string">&quot;mysqlconnection&quot;</span>] = <span class="keyword">new</span> MySqlAdapter(),</span><br><span class="line">          [<span class="string">&quot;fbconnection&quot;</span>] = <span class="keyword">new</span> FbAdapter()</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>一个自然而然的问题是，这个 <code>ISqlAdapter</code> 接口是做什么的呢？为什么说 <code>Dapper.Contrib</code> 没有实现 Oracle 版本的 ISqlAdapter 呢？如果我们看一下 <code>ISqlAdapter</code> 的定义，就可以了解到其作用是告诉 Dapper ，应该怎么样处理数据库里的自增 ID、怎么样表示 <code>Column = Value</code> 这样的结构，以及怎么样处理列名：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">interface</span> <span class="title">ISqlAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Insert</span>(<span class="params">IDbConnection connection, IDbTransaction transaction, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span>? commandTimeout, <span class="built_in">string</span> tableName, <span class="built_in">string</span> columnList, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> parameterList, IEnumerable&lt;PropertyInfo&gt; keyProperties, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">object</span> entityToInsert</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AppendColumnName</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AppendColumnNameEqualsValue</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以 <code>MySqlAdapter</code> 的实现为例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MySqlAdapter</span> : <span class="title">ISqlAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Insert</span>(<span class="params">IDbConnection connection, IDbTransaction transaction, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span>? commandTimeout, <span class="built_in">string</span> tableName, <span class="built_in">string</span> columnList, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> parameterList, IEnumerable&lt;PropertyInfo&gt; keyProperties, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">object</span> entityToInsert</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cmd = <span class="string">$&quot;insert into <span class="subst">&#123;tableName&#125;</span> (<span class="subst">&#123;columnList&#125;</span>) values (<span class="subst">&#123;parameterList&#125;</span>)&quot;</span>;</span><br><span class="line">        connection.Execute(cmd, entityToInsert, transaction, commandTimeout);</span><br><span class="line">        <span class="keyword">var</span> r = connection.Query(<span class="string">&quot;Select LAST_INSERT_ID() id&quot;</span>, transaction: transaction, commandTimeout: commandTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> id = r.First().id;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> propertyInfos = keyProperties <span class="keyword">as</span> PropertyInfo[] ?? keyProperties.ToArray();</span><br><span class="line">        <span class="keyword">if</span> (propertyInfos.Length == <span class="number">0</span>) <span class="keyword">return</span> Convert.ToInt32(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> idp = propertyInfos[<span class="number">0</span>];</span><br><span class="line">        idp.SetValue(entityToInsert, Convert.ChangeType(id, idp.PropertyType), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Convert.ToInt32(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendColumnName</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sb.AppendFormat(<span class="string">&quot;`&#123;0&#125;`&quot;</span>, columnName);</span><br><span class="line">    ｝</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendColumnNameEqualsValue</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sb.AppendFormat(<span class="string">&quot;`&#123;0&#125;` = @&#123;1&#125;&quot;</span>, columnName, columnName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信看到这里的时候，大家会和我一样感到失望，因为 Dapper 的底层依然是在拼 SQL ，尤其是看到 <code>AppendColumnNameEqualsValue()</code> 这个方法的时候，会有一种恍然大明白的感觉，因为 @ 这个符号对于 Dapper 的参数化查询而言，实在是熟悉得不能再熟悉了。我们都知道为 Dapper 写 SQL 语句的时候，要对 Oracle 区别对待，因为这个奇葩非要用 <code>:</code> 这个奇怪的符号。回到我们一开始的问题，为啥 <code>Dapper.Contrib</code> 在 Oracle 环境下会提示 <code>ORA-XXXXX</code> 这种鬼都看不明白的错误，因为它在处理 SQL 的语句的时候依然使用的是 <code>@</code> 这个符号。这又是为什么呢？因为当指定的 <code>IDbConnection</code> 在 <code>AdapterDictionary</code> 中不存在的时候，它会使用默认的 <code>SqlServerAdapter</code> ，显然，全世界只有 Oracle 这个奇葩会用 <code>:</code> 这个奇怪的符号。我们不是在调用 Insert() 方法的时候提示这个错误吗？那么 <code>Dapper.Contrib</code> 是怎么实现 <code>Insert()</code> 方法的呢？这个部分实现主要在第 352 行 ~ 第 360 行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adapter = GetFormatter(connection);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allPropertiesExceptKeyAndComputed.Count; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">var</span> property = allPropertiesExceptKeyAndComputed[i];</span><br><span class="line">    adapter.AppendColumnName(sbColumnList, property.Name);  <span class="comment">//fix for issue #336</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; allPropertiesExceptKeyAndComputed.Count - <span class="number">1</span>)</span><br><span class="line">       sbColumnList.Append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显然，这部分是按照属性名去组织 <code>columnList</code> 和 <code>parameterList</code> 的过程，对于 Oracle ，永远是充满吐槽的，比如不加双引号则强制大写的设定，这意味着如果你的表名或者字段名是区分大小写的话，在 Oracle 这里都要加上双引号，这对 <code>Dapper.Contrib</code> 有什么影响呢？原本我们只需要给实体添加<code>[Table]</code>标签即可，而现在你不得不考虑带上反斜杠转义，甚至当你需要为 <code>DBeaver</code> 下载一个 JDBC 的驱动的时候，甲骨文这家公司居然要强制你去注册，对于一个习惯像<code>·.NET Core</code>、<code>GCC</code>、<code>Python</code>、<code>Lua</code> 和 <code>Node</code> 这样开箱即用的人来说，这就像强迫你注册一大堆真实信息，然后发现 API 接口完全无法匹配你的需求一样痛苦。关于 <code>GetFormatter()</code> 方法，它和我们猜想的完全一致：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ISqlAdapter <span class="title">GetFormatter</span>(<span class="params">IDbConnection connection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">var</span> name = GetDatabaseType?.Invoke(connection).ToLower() ?? connection.GetType().Name.ToLower();</span><br><span class="line">   <span class="keyword">return</span> AdapterDictionary.TryGetValue(name, <span class="keyword">out</span> <span class="keyword">var</span> adapter) ? adapter : DefaultAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，在明白了以上种种因果关系以后，我们现在来考虑如何解决 Oracle 的问题。按照人类最直观的思维，既然它没有实现 Oracle 版本的 <code>ISqlAdapter</code> ，我自己实现一个不就好啦：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OracleSqlAdapter</span> : <span class="title">ISqlAdapter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendColumnName</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">        sb.AppendFormat(<span class="string">&quot;&#123;0&#125;&quot;</span>, columnName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendColumnNameEqualsValue</span>(<span class="params">StringBuilder sb, <span class="built_in">string</span> columnName</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">        sb.AppendFormat(<span class="string">&quot;&#123;0&#125; = :&#123;1&#125;&quot;</span>, columnName, columnName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Insert</span>(<span class="params">IDbConnection connection, IDbTransaction transaction, <span class="built_in">int</span>? commandTimeout, <span class="built_in">string</span> tableName, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">string</span> columnList, <span class="built_in">string</span> parameterList, IEnumerable&lt;PropertyInfo&gt; keyProperties, <span class="built_in">object</span> entityToInsert</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">var</span> sql = <span class="string">$&quot;insert into <span class="subst">&#123;tableName&#125;</span> (<span class="subst">&#123;columnList&#125;</span>) values (<span class="subst">&#123;parameterList&#125;</span>)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> connection.Execute(sql, entityToInsert, transaction, commandTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">InsertAsync</span>(<span class="params">IDbConnection connection, IDbTransaction transaction, <span class="built_in">int</span>? commandTimeout, <span class="built_in">string</span> tableName, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">string</span> columnList, <span class="built_in">string</span> parameterList, IEnumerable&lt;PropertyInfo&gt; keyProperties, <span class="built_in">object</span> entityToInsert</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">var</span> sql = <span class="string">$&quot;insert into <span class="subst">&#123;tableName&#125;</span> (<span class="subst">&#123;columnList&#125;</span>) values (<span class="subst">&#123;parameterList&#125;</span>)&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> connection.ExecuteAsync(sql, entityToInsert, transaction, commandTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>坦白说， <code>Dapper.Contrib</code> 这种纯静态类的设计，完全就不给别人留扩展的口子，为此，扩展方法 + 反射搞一个突破口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SqlAdapterrExtensions</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseSqlAdapter</span>&lt;<span class="title">TSqlAdapter</span>&gt;(<span class="params"><span class="keyword">this</span> IDbConnection connection, TSqlAdapter sqlAdapter</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TSqlAdapter : ISqlAdapter, <span class="keyword">new</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> adapters = (Dictionary&lt;<span class="built_in">string</span>, ISqlAdapter&gt;)</span><br><span class="line">            <span class="keyword">typeof</span>(SqlMapperExtensions)</span><br><span class="line">            .GetField(<span class="string">&quot;AdapterDictionary&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)</span><br><span class="line">            ?.GetValue(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> connectionType = connection.GetType().Name.ToLower();</span><br><span class="line">        <span class="keyword">if</span> (adapters != <span class="literal">null</span> &amp;&amp; !adapters.ContainsKey(connectionType))</span><br><span class="line">            adapters?.Add(connectionType, sqlAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们不但可以满足眼下，还可以着眼未来，虽然未来有时候挺遥远，但梦想还是要有的，开闭原则，我做到了！改进后，我们这样处理即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection = <span class="keyword">new</span> OracleConnection(ConnectionStrings.Default);</span><br><span class="line">connection.UseSqlAdapter(<span class="keyword">new</span> OracleSqlAdapter());</span><br></pre></td></tr></table></figure>

<p>此时，我们发现，我们解决了 Insert() 的问题，但随之而来的，Get()、Delete()、Update() 这一系列和主键相关的方法，都因为 <code>Dapper.Contrib</code> 中的主键设计而出现了问题，而这就是我们接下来要讲的主键 Id 参数化问题。</p>
<h2 id="主键-Id-参数化问题"><a href="#主键-Id-参数化问题" class="headerlink" title="主键 Id 参数化问题"></a>主键 Id 参数化问题</h2><p>当我谈起这个问题的时候，我对于 <code>Dapper.Contrib</code> 中支持自增 ID 的坚持是怀疑的，因为在分布式盛行的今天，有大量的分布式 ID 生成方案供我们选择，比如基于 <code>Redis</code> 的号段策略，基于雪花算法的 ID 生成等等。大家会注意到我实现的 OracleSqlAdapter 在实现 Insert() 方法的时候简化了大量代码，这是因为我真的不知道，怎么从 Oracle 中获取一个新生成的 ID，尤其是这个 ID 居然还要依赖一个我听都没有听说过的“序列”，而之所以要在 ISqlAdapter 中实现 Insert() 方法，最根本的原因就是，各个数据库对于自增 ID 的实现是不一样的，比如 MySQL 中使用的是 <code>SCOPE_IDENTITY()</code>，而 MSSQL 中使用的则是 <code>SCOPE_IDENTITY()</code> ，就因为这一点点差异，我们就必须要去折腾一遍，可以说， Dapper.Contrib 不支持 Oracle 的一个重要原因，就是在 Oracle 下实现自增 ID 太麻烦了。</p>
<p>既然大家都不用自增 ID 了，为什么还要在一个通用的 ORM 里折腾这个呢？说实话，我真担心有一天自增 ID 会溢出，谁让每个数据库里的上限都不一样呢？另一方面，既然 Id 在每个数据库的实现都不一样，那么，作为 Id 本身应该考虑放到 <code>ISqlAdapter</code> 接口中由使用者来实现啊，可偏偏 ISqlAdapter 里只定义了一个 Insert() 方法，所以，就算我们实现了 OracleSqlAdapter ，一样无法解决 Insert() 方法以外的其它方法在 Oracle 下面的问题，正因为如此，默认的 @ 符号在 Oracle 环境下下没有被完全替换掉，这就需要修改 Dapper.Contrib 的底层代码，这真的是一个不好的设计，因为使用者完全没有办法通过重写来覆盖某些默认行为，我们一起来看看，需要修改哪些地方：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">dynamic</span> id, </span></span></span><br><span class="line"><span class="params"><span class="function">IDbTransaction transaction = <span class="literal">null</span>, <span class="built_in">int</span>? commandTimeout = <span class="literal">null</span></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GetQueries.TryGetValue(type.TypeHandle, <span class="keyword">out</span> <span class="built_in">string</span> sql))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = GetSingleKey&lt;T&gt;(<span class="keyword">nameof</span>(Get));</span><br><span class="line">        <span class="keyword">var</span> name = GetTableName(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个坏事儿的地方，为什么不用AppendColumnName()方法?</span></span><br><span class="line">        sql = <span class="string">$&quot;select * from <span class="subst">&#123;name&#125;</span> where <span class="subst">&#123;key.Name&#125;</span> = @id&quot;</span>;</span><br><span class="line">        GetQueries[type.TypeHandle] = sql;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dynParams = <span class="keyword">new</span> DynamicParameters();</span><br><span class="line">    <span class="comment">//第二个坏事的地方，什么不用AppendColumnName()方法??</span></span><br><span class="line">    dynParams.Add(<span class="string">&quot;@id&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Insert</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IDbConnection connection, T entityToInsert,</span></span></span><br><span class="line"><span class="params"><span class="function">IDbTransaction transaction = <span class="literal">null</span>, <span class="built_in">int</span>? commandTimeout = <span class="literal">null</span></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//以上代码已省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sbParameterList = <span class="keyword">new</span> StringBuilder(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allPropertiesExceptKeyAndComputed.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第三个坏事的地方，什么不用AppendColumnName()方法???</span></span><br><span class="line">        <span class="keyword">var</span> property = allPropertiesExceptKeyAndComputed[i];</span><br><span class="line">        sbParameterList.AppendFormat(<span class="string">&quot;@&#123;0&#125;&quot;</span>, property.Name);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; allPropertiesExceptKeyAndComputed.Count - <span class="number">1</span>)</span><br><span class="line">            sbParameterList.Append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，仔细阅读 Update() 和 Delete() 两个方法的实现，就会发现它们都非常完美地避开了这一点，就是不知道为什么只有两个方法采用了不同地方式去拼接 SQL ，当然，这里我们会意识到有个列名的问题，尤其是在需要区分大小写的情况下，为此，我们可能需要去定义一个 ColumnAttribute，还能说什么呢？请和我大声地吐槽：<strong>垃圾 Oracle ！</strong>你看，就为了这一点点差异，我们不得不去额外写一点代码，所以，喊了很多年的去 IOE，我表示举双手赞成。</p>
<p>事实上，社区里已经有类似的PR，可因为改动的范围比较大，官方至今都没有考虑过将其合并到主干分支上，所以，这个问题一直没有解决，这是一个悲伤的故事。</p>
<h1 id="相关思考"><a href="#相关思考" class="headerlink" title="相关思考"></a>相关思考</h1><p>在阅读 Dapper 源码的同时，我查阅了一个和 Dapper.Contrib 类似的项目：DapperExtension，我发现这个项目目前处在“荒废”的状态，因为它遇到了相同的问题，即 SQL 这门看起来统一实则相当不统一的语言，因为每一个数据库厂商几乎都在给标准“添砖加瓦“，就以自增 ID 为例，MySQL、MSSQL、Oracle 居然是三种不同的实现方式，尤其是 Oracle 这个奇葩，居然还需要定义一个序列来解决这个问题，这个奇葩给数据库加注释都那么另类，这带来的问题是什么？Dapper.Contrib 无力去实现 Oracle 的自增 ID 而放弃了 Oracle ，所以，即使社区里提交了 PR，因为实现方式有点脏，官方一直没有合并到主干上去。</p>
<p>再回过头来看 Dapper.Contrib 支持自增 ID 的举动，总会觉得有点不合时宜，因为不同数据库自增 ID 的上限不一样不说，现在都普遍在分布式的环境中，数据库的自增 ID 其实是非常鸡肋的功能，而实际应用中常常会用 <code>Redis</code> 、雪花算法等来实现分布式 ID，所以，当你回顾历史发展的趋势的时候，就会感慨有标准化的东西该多好，并不是说这个世界不需要多样性，显然这是一个标准约束性不强的领域，看起来大家都实现了 SQL，无一例外地都夹藏了私货，对于商业行为而言，这无可厚非；可对于这个世界而言，这无疑增加了工作量。</p>
<p>有时候，当一个行业没有什么标准的时候，到底是突破勇气去率先制定标准，还是放弃自我去迎合各种不成文的规则，对于企业而言，是战略上的一种选择；而对于个人而言，其实是人生的一种选择。当彼时青春年少的人们，竞相以标新立异为荣的时候，如果想到有一天，终究要活成千篇一律的人生，为了生活而选择跪着的时候，内心又会有什么不一样的举动呢？</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分析了 Dapper.Contrib 这个扩展库，在搭配 Oracle 数据库使用时遇到 ORA-XXXXX 系列错误的原因及相应地处理方法，这个问题的表象是 Dapper.Contrib 没有实现 OracleSqlAdapter ，而更深层的原因，实际上是 Dapper.Contrib 选择支持自增 ID 而带来的 SQL 标准差异化问题。因为不同的数据库在实现自增 ID 时的机制不同，Oracle 甚至需要引入序列这个概念，这种差异化，增加了 Dapper 各个扩展库维护的工作量，这是官方一直不愿意实现 OracleSqlAdapter 的原因，其次， Dapper.Contrib 底层设计不合理，除了 Insert() 方法以外，其它依赖主键的方法都没有提供扩展接口，导致使用者只能通过修改底层代码的方式解决问题，这严重违反开闭原则。好了，这是一篇利用 996 闲暇(可能是指做梦)写的一篇博客，如果文章中有什么不周到的地方，欢迎大家在博客下面给我留言，谢谢，晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/f05d518.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/f05d518.html" itemprop="url">八月总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T00:05:48+08:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <h2 id="背单词"><a href="#背单词" class="headerlink" title="背单词"></a>背单词</h2><p><img src="https://i.loli.net/2020/08/28/OCf79JkXbP4vQUw.png" alt="image.png"></p>
<p>月初发现这个软件，发现比我之前使用过的所有背单词软件都好用，基于艾宾浩斯记忆曲线，我的方法是同时打开三个软件：</p>
<ul>
<li>List 背单词（上图软件</li>
<li>欧路词典（用来练发音</li>
<li>词根词缀字典（用来记词根，同时还有一个“不拘一格背单词”模块，有趣还方便记忆</li>
</ul>
<p>每天晚上抽一个小时，效果还是挺不错的，希望能继续坚持下去。</p>
<h2 id="手机换屏幕"><a href="#手机换屏幕" class="headerlink" title="手机换屏幕"></a>手机换屏幕</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前的小米 8 的屏幕摔坏了，然后换手机后就一直被闲置，最近老母亲提到她的手机电池不太稳定，就心想着自己动手把这台小米的屏幕换了给她用，之前还没有亲自换过屏幕，还是得自己动手折腾一波。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>之前就看过在官方换需要 740 元，觉得这台手机用了这么久了，不值得花这个钱来“续命”，而且对屏幕要求也不高，能用就行。所以在某宝上找了一个华强北的带框屏幕总成，跟着网上的视频教程一步一步换，结果在第一步（拆后壳）卡了近两个小时，差点把我整疯了。</p>
<p>期间还把开机排线扯断了，然后又在某宝上买了两条排线（备用），就这样等了一天才能继续更换。</p>
<p>最后更换完开机也是各种问题，比如因为音量键卡住导致开机进入 fastboot 界面，还有因为指纹模块没插好导致无法使用指纹。</p>
<p>解决上述问题后，还有一个问题无法解决，就是后壳无法完全贴合，据网上说是因为里面没放平，但觉得这个没什么大碍，反正平时也是戴手机壳，只要不重摔就没事。</p>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>经过三天的折腾，总算是换好了，虽然最后各种问题，但不管怎么说也是尝试过，当然最重要一个原因也是因为这个手机本身并不贵重，就当练练手，否则我还是会选择送去维修店的，毕竟专业的事就应该交给专业的人做。</p>
<h2 id="RSS-阅读"><a href="#RSS-阅读" class="headerlink" title="RSS 阅读"></a>RSS 阅读</h2><p>今年最大一个改变，就是开始习惯 RSS 阅读，这大大减少我需要在不同平台切换的繁琐，改用 RSS 订阅后，能自由订阅自己感兴趣的内容，不受算法推荐的影响，且对各大平台的文章拥有一致的阅读体验。</p>
<h3 id="阅读器"><a href="#阅读器" class="headerlink" title="阅读器"></a>阅读器</h3><p>首先是要找一个用得舒服的 RSS 阅读器，我在前几个月都一直在使用 RSS Reader Prime，这个阅读器的优点是：配色好看，阅读体验很好、支持搜索以前阅读过的文章。</p>
<p>但是后来随着我对 RSS 的需求越来越大，经常需要在不同设备间同步订阅源和阅读历史，虽然该软件自带有 iCloud 同步，但是挺捉急的，经常出现无法同步的问题，于是前段时间趁 Reeder 4 限免，赶紧在三个设备中安装，然后开始我的 RSS 折腾之旅。</p>
<h3 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h3><p>首先 Reeder 支持使用第三方账号登录，如 Feedly、Inoreader 等，但是我尝试过这两者的服务，总觉得有订阅源限制，赶紧不太舒服，且我现在已经订阅超过 100 个 RSS 源，于是在 <a target="_blank" rel="noopener" href="https://diygod.me/ohmyrss/">我有特别的 RSS 使用技巧</a> 这篇文章的安利中，我也自己搭了一个 <a target="_blank" rel="noopener" href="https://github.com/HenryQW/docker-ttrss-plugins">Tiny Tiny RSS</a>，从此不再担心有限制。</p>
<h3 id="定制订阅源"><a href="#定制订阅源" class="headerlink" title="定制订阅源"></a>定制订阅源</h3><p>自建 ttrss 后，就开始折腾如何订阅一些不支持 rss 的网站，那就不得不提 <a target="_blank" rel="noopener" href="https://docs.rsshub.app/">RSSHub</a> 这个开源项目了（与前面那篇文章是同一个作者），我自己 fork 了一份部署在自己的 vps 上，根据自己兴趣添加 RSS 订阅源，其实大部分个人博客都是支持 RSS 订阅的，主要是一些比较奇怪的需求，比如：全文输出内容、筛选分类等。</p>
<p>我还有一个想法，就是把一些英文订阅源的标题翻译成中文，毕竟英文还是比较烂，这样我就能快速寻找感兴趣的文章阅读，而不用一个一个细看，于是我找到一个可用的 google translate 库 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/google-translate-open-api">google-translate-open-api</a>，但在我的套路云上会超时，而在谷歌云则没问题，后来想想这样对我英文提升是无帮助的，所以也就放弃了。</p>
<p>即便 RSSHub 已经足够强大，但由于部署在国内的 vps 上，即便我设置了代理，也会出现无法访问部分需要科学上网的网站，这时候我会使用 <a target="_blank" rel="noopener" href="https://feed43.com/">Feed43</a> 定制这些源，虽然比较土，但也能凑合用。</p>
<h2 id="闯越自动签到"><a href="#闯越自动签到" class="headerlink" title="闯越自动签到"></a>闯越自动签到</h2><p>我们学校实习期需要每天在一个叫做 「闯越顶岗实习管理系统」 的软件上面写日志签到，个人对于这种繁琐且纯属应付的操作实在不能忍受，不过之前有个朋友做了个自动签到的脚本，我也就直接用他的，懒得重复造轮子。</p>
<p>最近突然想搞点业余项目，就估摸着在他的基础上做个更完善的自动签到系统，不仅限于学生自动签到，还打算做一个可以让教师快捷点评的操作，据我了解，教师在上面要逐一对学生的日志点评，操作要更加繁琐，。</p>
<p>而且根据该软件官网上描述，在广东省就有十几家合作技校，如果我做的这个系统能让大家节省这些时间，还是挺有成就感的。</p>
<p>初步想法是做一个 web 的管理后台 + 小程序用户端 ，后面根据实际用户量再考虑要不要做成 SASS 版。</p>
<p>目前基本核心签到功能已经实现，剩下的就是做成一个完整的系统，至于技术栈，尝试一下使用 nest.js + react 。</p>
<h2 id="八佰"><a href="#八佰" class="headerlink" title="八佰"></a>八佰</h2><p><a target="_blank" rel="noopener" href="https://4ark.me/posts/ba-bai-review.html">《八佰》读后感</a></p>
<h2 id="下月计划"><a href="#下月计划" class="headerlink" title="下月计划"></a>下月计划</h2><ol>
<li>微信公众号 RSS 订阅源</li>
<li>在语雀构建自己的知识库</li>
<li>读完《清醒思考的艺术》</li>
</ol>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/ba-bai-review.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/ba-bai-review.html" itemprop="url">《八佰》观后感</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-28T00:03:45+08:00">
                2020-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>这几天在很多社区网站都看到关于《八佰》的评论，趁着周末和女朋友去观看，也算了却她一直说今年因为疫情期间没有去看过电影的遗憾。</p>
<p>其实在之前有了解过这部电影，主要讲述的是 1937 年淞沪会战的最后一役，“八百壮士”奉命坚守上海四行仓库，以少敌多顽强抵抗四天四夜的这段真实历史事件。</p>
<p>因为总所周知的原因，这部电影从去年一直拖到今年才终于上映，最后不可避免地要做一些妥协，但是就上映后的剧情来说还是可以接受的，而且据网上资料所说，电影原本的龙标是 2019 第 88 号（八十八师），但是后来改为 2019 第 800 号（八百壮士），从这两个定制的龙标，能看出国家电影局确实是给了特别优待的。</p>
<p>暂时抛开历史，就电影本身的质量而言，我觉得可以给个 4 星，其中有很多场战斗戏，不乏一些血腥的画面，且整体剧情相对紧凑，战斗总是来得很突然，前一秒还是活生生的人，下一秒就倒下，能如此近距离观看战争的残酷，让我对今天能处在和平的年代感到幸运，也让某些整天想着开战的人看看，还是挺有教育意义的。</p>
<p>因为太关注剧情本身，我从头到尾并没有很关注哪个角色是谁扮演的，以至于后来我甚至没有发现那个特派员居然是黄晓明扮演的，其中也有一些我之前不太感兴趣的演员，但这部戏我认为是超出了他们之前的水平的。</p>
<p>近几年我国的抗日片，有一个通病，那就是故意丑化日本军人，而一味夸大自己，以此鼓吹民族主义。但这部电影并没有，影片中，一名记者去到日军营地时，看见日军戒备森严、言行律己，且对牺牲军人给予厚葬，说明日军的实力不容小觑，没有故意贬低敌人的拍摄方式很值得大家学习。这也凸显中国军方的英勇抗战和为胜利所付出的代价。</p>
<p>这部电影不是要激起民族主义，更不是让我们敌视日本这个国家，而是让我们不要忘记那段历史，从而更加珍惜现在和平的时代，那时候我们之所以被打得这么惨，除了跟日本实力悬殊之外，更多的是国人自己不团结，影片中有一幕给我很大冲击，当时日军正在攻楼，而国军自行组成敢死队高喊自己的家乡和名字，身绑手榴弹前仆后继跳楼与敌人同归于尽，当时对岸围观的人说的一句话：“国人皆如此，倭寇何敢？”。</p>
<p>影片结束时，谢晋元团长按照军队高层命令，率领剩余的“八百壮士”，冲过日军火力封锁的连向英租界的桥。影片到这里就结束了。实际上，后面冲过英租界的“八百壮士”结局更加悲凉，有兴趣可以自行搜寻。这里我想说的希望以后我们能正视我们的历史，更不要扭曲事实，敢于正视自身历史污点的民族，勇于承认错误，才是伟大的民族。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/08/15/NET-Core%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%B1%A0-Object-Pool-%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/15/NET-Core%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%B1%A0-Object-Pool-%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url">.NET Core 中对象池(Object Pool)的使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-15T16:37:23+08:00">
                2020-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>在此前的博客中，博主参考 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 实现了一个基于 RabbitMQ 的事件总线(EventBus)。在这个项目中，它提供了一个持久化连接的类<code>DefaultRabbitMQPersistentConnection</code>，主要解决了 RabbitMQ 在连接断开后自动重连的问题，可实际上我们都知道，RabbitMQ 提供的连接数是有一个上限的，如果频繁地使用短连接的方式，即通过<code>ConnectionFactory</code>的<code>CreateConnection()</code>方法来创建一个连接，从本质上讲，一个<code>Connection</code>对象就是一个 TCP 连接，而<code>Channel</code>则是每个<code>Connection</code>对象下有限的虚拟连接，注意“有限”这个限定词，这意味着<code>Channel</code>和<code>Connection</code>一样，都不能毫无节制的创建下去。此时，官方推荐的做法有两种：(1)：一个<code>Connection</code>对应多个<code>Channel</code>同时保证每个<code>Channel</code>线程独占；(2)：创建一个<code>Connection</code>池同时定期清除无效连接。这里的第二种做法，显然就是我们今天要说的对象池(Object Pool)啦，我们将从这里拉开这篇博客的帷幕。</p>
<h1 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h1><p>首先，我们来回答第一个问题，什么是对象池？简单来说，它就是一种为对象提供可复用性能力的软件设计思路。俗话说<strong>“有借有还，再借不难”</strong>，而对象池就是通过“借”和“还”这样两个动作来保证对象可以被重复使用，进而节省频繁创建对象的性能开销。对象池在游戏设计中使用的更普遍一点，因为游戏中大量存在着像子弹、怪物等等这类可复用的对象，你在玩第一人称射击游戏(FPS)时，总是有源源不断的子弹或者丧尸出现，可事实上这不过是数字世界的循环再生，因为玩家的电脑内存始终都有一个上限。而在数据库的世界里，则存在着一个被称为“连接池”的东西，每当出现数据库无法连接的情况时，经验丰富的开发人员往往会先检查“连接池”是否满了，这其实就是对象池模式在特定领域的具体实现啦，所以，对象池本质上就是负责一组对象创建和销毁的容器，下面是一个基本的对象池示意图：</p>
<p><img src="https://i.loli.net/2020/08/22/lReo7LQa1SODZpc.png" alt="对象池示意图"></p>
<p>可以注意到， 对象池最大的优势就是可以自主地管理“池子”内的每个对象，决定它们是需要被回收还是可以重复使用。我们都知道，创建一个新的对象，需要消耗一定的系统资源，而一旦这些对象可以重复地使用，就能有效地节省系统资源的开销，这对于我们提高系统性能会非常有帮助。也许，现在计算机的硬件水平越来越好，可我们还是要重新拾起这个领域的基础知识，即数据结构、算法、数学和英语。如果你完全理解了对象池模式，你应该可以非常轻松地给出你的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectPool</span>&lt;<span class="title">T</span>&gt; : <span class="title">IObjectPool</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Func&lt;T&gt; _instanceFactory;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentBag&lt;T&gt; _instanceItems;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span>(<span class="params">Func&lt;T&gt; instanceFactory</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _instanceFactory = instanceFactory ?? </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(instanceFactory));</span><br><span class="line">    _instanceItems = <span class="keyword">new</span> ConcurrentBag&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="keyword">if</span> (_instanceItems.TryTake(<span class="keyword">out</span> item)) <span class="keyword">return</span> item;</span><br><span class="line">    <span class="keyword">return</span> _instanceFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T item</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _instanceItems.Add(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：以上代码片段来自微软的一篇文档：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-create-an-object-pool">How to: Create an Object Pool by Using a ConcurrentBag</a>。实际上，除了<code>ConcurrentBag&lt;T&gt;</code>，我们可以选择的数据结构还可以是<code>Stack&lt;T&gt;</code>、<code>Queue&lt;T&gt;</code>以及<code>BlockingCollection&lt;T&gt;</code>，此中差别，大家可以自己去体会。</p>
<h1 id="NET-Core-中的对象池"><a href="#NET-Core-中的对象池" class="headerlink" title=".NET Core 中的对象池"></a>.NET Core 中的对象池</h1><p>在.NET Core 中，微软已经为我们提供了对象池的实现，即<code>Microsoft.Extensions.ObjectPool</code>。它主要提供了三个核心的组件，分别是<code>ObjectPool</code>、<code>ObjectPoolProvider</code>和<code>IPooledObjectPolicy</code>，关于这三者间的关系，我绘制了下面的 UML 图来作为说明：</p>
<p><img src="https://i.loli.net/2020/08/22/M6ojLtqgKc5pfCA.png" alt="ObjectPool核心组件及其关系"></p>
<p>可以注意到，<code>ObjectPool&lt;T&gt;</code>是一个抽象类，它对外提供了 Get()和 Return()两个方法，所谓的“有借有还”，这一点没什么可说的。接下来，<code>ObjectPoolProvider</code>同样是一个抽象类，它的职责就是创建<code>ObjectPool&lt;T&gt;</code>，所以，它提供了两个<code>Create&lt;T&gt;()</code>方法，两者的区别是，无参数版本本质上使用的是<code>DefaultPooledObjectPolicy&lt;T&gt;</code>。顾名思义，它同<code>DefaultObjectPool&lt;T&gt;</code>、<code>DefaultObjectPoolProvider</code>一样，都是微软提供的默认实现，其中<code>IPooledObjectPolicy&lt;T&gt;</code>可以为不同的对象池定义不同的策略，来决定对象如何“借”、是否可以“还”。默认的对象池<code>DefaultObjectPool&lt;T&gt;</code>内部使用<code>ObjectWrapper[]</code>这个数组来管理对象，数组的大小等于 maximumRetained - 1，因为它单独指定了首项，默认情况下，这个 maximumRetained 等于<code>Environment.ProcessorCount * 2</code>，这里主要用到了<code>Interlocked.CompareExchange()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> T <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> item = _firstItem;</span><br><span class="line">  <span class="keyword">if</span> (item == <span class="literal">null</span> || Interlocked.CompareExchange(<span class="keyword">ref</span> _firstItem, <span class="literal">null</span>, item) != item)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> items = _items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      item = items[i].Element;</span><br><span class="line">      <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; Interlocked.CompareExchange(<span class="keyword">ref</span> items[i].Element, <span class="literal">null</span>, item) == item)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = Create();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-inline to improve its code quality as uncommon path</span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">Create</span>()</span> =&gt; _fastPolicy?.Create() ?? _policy.Create();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_isDefaultPolicy || (_fastPolicy?.Return(obj) ?? _policy.Return(obj)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_firstItem != <span class="literal">null</span> || Interlocked.CompareExchange(<span class="keyword">ref</span> _firstItem, obj, <span class="literal">null</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> items = _items;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.Length &amp;&amp; Interlocked.CompareExchange(<span class="keyword">ref</span> items[i].Element, obj, <span class="literal">null</span>) != <span class="literal">null</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要用到<code>Interlocked.CompareExchange()</code>这个方法，对于<code>Get()</code>方法而言，它将<code>items[i].Element</code>和<code>null</code>进行交换，相当于将指定元素设为 null 并返回原始值；而对于<code>Return()</code>方法而言，如果将<code>items[i].Element</code>和<code>obj</code>交换后的值不为 null，则表示指定元素已经“归还”，因为这个方法只有在第一个参数和第三个参数相等时才会发生交换。好了，了解了.NET Core 中对象池的实现以后，我们来一起看看具体的使用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> service = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用DefaultObjectPoolProvider</span></span><br><span class="line">service.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();</span><br><span class="line"><span class="comment">//使用默认策略</span></span><br><span class="line">service.AddSingleton&lt;ObjectPool&lt;Foo&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create&lt;Foo&gt;();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用自定义策略</span></span><br><span class="line">service.AddSingleton&lt;ObjectPool&lt;Foo&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create(<span class="keyword">new</span> FooObjectPoolPolicy());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serviceProvider = _service.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectPool = _serviceProvider.GetService&lt;ObjectPool&lt;Foo&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有借有还，两次是同一个对象</span></span><br><span class="line"><span class="keyword">var</span> item1 = objectPool.Get();</span><br><span class="line">objectPool.Return(item1);</span><br><span class="line"><span class="keyword">var</span> item2 = objectPool.Get();</span><br><span class="line">Assert.AreEqual(item1, item2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有借无还，两次是不同的对象</span></span><br><span class="line"><span class="keyword">var</span> item3 = objectPool.Get();</span><br><span class="line"><span class="keyword">var</span> item4 = objectPool.Get();</span><br><span class="line">Assert.AreEqual(item3, item4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>Foo</code>和<code>FooObjectPoolPolicy</code>是两个非常典型的“工具类”，类似我们所说的“工具人”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> DateTime? CreatedAt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> CreatedBy &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooObjectPoolPolicy</span> : <span class="title">IPooledObjectPolicy</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Foo <span class="title">Create</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo()</span><br><span class="line">    &#123;</span><br><span class="line">      Id = Guid.NewGuid().ToString(<span class="string">&quot;N&quot;</span>),</span><br><span class="line">      CreatedAt = DateTime.Now,</span><br><span class="line">      CreatedBy = <span class="string">&quot;Ezio&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Return</span>(<span class="params">Foo obj</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要控制对象池内的对象如何被创建的时候，你可以考虑实现自定义的<code>IPooledObjectPolicy&lt;T&gt;</code>，否则，<code>DefaultPooledObjectPolicy&lt;T&gt;</code>这个默认实现完全可以满足你的使用，而这就是.NET Core 中对象池的所有用法，一个实现起来并不复杂但是在某些场景下非常有用的软件设计模式。</p>
<h1 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h1><p>好了，回到我们一开始的问题，即：如何解决 RabbitMQ 在多次重连后提示连接数不足的问题。由于 Channel 对象本质上是 Connection 对象上的 TCP 连接的软连接，所以，每当创建一个新的 Channel 的时候，实际上会独占一个 TCP 连接。考虑到在使用 RabbitMQ 的时候，发布消息&#x2F;消费消息每次都是创建一个 Channel，在高并发场景下可能会导致 TCP 连接数被用完，进而出现无法连接或者响应过慢等一系列问题。既然 TCP 连接数是有限的，为什么不考虑复用这些 TCP 连接呢？从这个角度上来看，数据库连接池承担了相同的角色，增加连接数说到底是一种“治标不治本”的做法。在具体实现上，可以考虑 Connection“池”和 Channel“池”，我们我们像官方推荐的做法一样，一个 Connection 对应多个 Channel，实际上只需要实现 Channel“池”。除非在多个 Connection 对应多个 Channel 的情况下，我们需要考虑同时实现 Connection“池”和 Channel“池”。坦白说，我这里一直没能找到实现 Connection“池”的相关资料，高冷的 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/">Catcher</a> 大神只是让我去认真读官方文档，搞清楚 Connection 和 Channel 的关系。而这个 Channel“池”的实现，结合这篇博客里的内容，实现起来是非常简单的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChannelObjectPoolPolicy</span> : <span class="title">IPooledObjectPolicy</span>&lt;<span class="title">IModel</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IConnectionFactory _connectionFactory;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChannelObjectPoolPolicy</span>(<span class="params">IConnectionFactory connectionFactory</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _connectionFactory = connectionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IModel <span class="title">Create</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> connection = _connectionFactory.CreateConnection();</span><br><span class="line">    <span class="keyword">return</span> connection.CreateModel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Return</span>(<span class="params">IModel obj</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj.IsOpen)</span><br><span class="line">    &#123;</span><br><span class="line">      obj?.Dispose();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步是实现<code>IPooledObjectPolicy&lt;IModel&gt;</code>，注意到，这里通过构造函数注入了<code>ConnectionFactory</code>，所以，除了常规的注入项以外，这里还需要注入<code>ConnectionFactory</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IConnectionFactory, ConnectionFactory&gt;(sp =&gt; <span class="keyword">new</span> ConnectionFactory() &#123; </span><br><span class="line">    HostName = <span class="string">&quot;localhost&quot;</span>, </span><br><span class="line">    UserName = <span class="string">&quot;guest&quot;</span>, </span><br><span class="line">    Password = <span class="string">&quot;guest&quot;</span> </span><br><span class="line">&#125;);</span><br><span class="line">services.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt;();</span><br><span class="line">services.AddSingleton&lt;ObjectPool&lt;IModel&gt;&gt;(serviceProvider =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> objectPoolProvider = serviceProvider.GetRequiredService&lt;ObjectPoolProvider&gt;();</span><br><span class="line">  <span class="keyword">var</span> connectionFactory = serviceProvider.GetRequiredService&lt;ConnectionFactory&gt;();</span><br><span class="line">  <span class="keyword">return</span> objectPoolProvider.Create(<span class="keyword">new</span> ChannelObjectPoolPolicy(connectionFactory));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后，我们只需要在 EventBus 里注入<code>ObjectPool&lt;IModel&gt;</code>即可，此时，我们调用 Channel 的画风是下面这样子的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = _channelPool.Get();</span><br><span class="line"><span class="keyword">try</span> &#123;  <span class="comment">//在这里做点什么吧  &#125;</span></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//好借好还，再借不难</span></span><br><span class="line">  _channelPool.Return(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Connection“池”的实现，我认为我的想法还不太成熟，暂时列入未来的思考计划中，所以，这篇博客就先写到这里。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>对象池(ObjectPool)是一种通过复用对象来减少资源开销进而实现提高系统性能的软件设计模式，其核心是控制容器内对象的生命周期来规避系统的主动回收，从对象池中(ObjectPool)“借”出的对象必须要及时“归还”，否则会造成对象池(ObjectPool)中没有可用资源。实现对象池可以考虑<code>ConcurrentBag&lt;T&gt;</code>、<code>Stack&lt;T&gt;</code>、<code>Queue&lt;T&gt;</code>以及<code>BlockingCollection&lt;T&gt;</code>等多种数据结构，而微软在.NET Core 中已经为我们实现了一个简单的对象池，大多数情况下，我们只需要定义自己的<code>IPooledObjectPolicy&lt;T&gt;</code>去决定对象应该怎么样“借”、怎么样“还”。因为此前实现基于 RabbitMQ 的 EventBus 的时候，我们是每次创建一个 Channel，即官方所谓的“短连接”的方式，因为 Channel 本质上是 Connection 在 TCP 连接上的一个虚拟连接，所以，每次创建 Channel 都会占用一个 TCP 连接，当我们系统中的 TCP 连接被用完的时候，就会出现无法连接、连接过慢的问题，为了解决这个问题，我们最终引入了对象池，实际上这里是实现了一个 Channel“池”，关于是否应该实现 Connection“池”，这一点我还没有想好，总而言之，游戏世界里可以复用的 GameObject、各种数据库里的连接池，都是对象池模式在各自领域中的具体实现，这就是这篇博客的内容啦，欢迎大家在评论中留言，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/834cbf1e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/834cbf1e.html" itemprop="url">我以为我不会成为那样的煞笔</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-12T00:37:51+08:00">
                2020-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>多年前在帝吧看过一篇文章，题目大概的意思就是本文的标题，作者貌似叫操笔帝，但不知道是不是我记忆错乱还是怎么的，我居然没有在互联网上找到这篇文章，今晚突然想起了这篇文章， 觉得很适合此刻的心情，就来写一篇差不多的吧。</p>
<p>当我小时候看到别人家里吵架，我心想我以后一定不会像他们这么煞笔，直到我现在为夹在她们中间而感到心累。</p>
<p>当我小时候看到别人脾气暴躁，我心想我以后一定不会像他们这么煞笔，直到我现在还经常无法控制自己的脾气。</p>
<p>当我小时候看到别人自私自利，我心想我以后一定不会像他们这么煞笔，直到我现在做什么都先考虑自己。</p>
<p>当我小时候看到别人精打细算，我心想我以后一定不会像他们这么煞笔，直到我现在也经常盘算如何才不吃亏。</p>
<p>当我小时候看到别人有难不帮，我心想我以后一定不会像他们这么煞笔，直到我现在害怕老同学找我借钱。</p>
<p>当我小时候看到别人冷漠无情，我心想我以后一定不会像他们这么煞笔，直到我现在看到有人晕倒也不敢上去扶。</p>
<p>当我小时候看到别人没有道德，我心想我以后一定不会像他们这么煞笔，直到我现在坐公交都会先找后面的位置。</p>
<p>当我小时候看到别人不合群，我心想我以后一定不会像他们这么煞笔，直到我现在喜欢一个人安静的做自己的事。</p>
<p>我们生活中有形形色色的煞笔，但我们总是在不同的时间里扮演着他们。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html" itemprop="url">太久没更新博客的原因和反思</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-03T00:00:00+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>距离上一篇文章 <a target="_blank" rel="noopener" href="https://4ark.me/post/72566ae3.html">我的 2019 年度总结</a> 发布时间，已经过去大半年了，也就是说 2020 年我把写博客的习惯弄丢了，其实原因很简单，那就是我变懒了。</p>
<p>我曾给自己找过借口，写技术方面的我总觉得自己写的太粗浅，其实这类文章在目前国内平台已经够多了，没必要重复产出这类文章，但是一篇质量好、有深度的文章，又要花费大量的时间，这让我总是望而却步。</p>
<p>还有一种生活类文章，我也考虑过要不要把生活上一些感想记录下来，但是后来总是因为各种原因没有这样做，所以对比去年，今天我在写博客方面变懒惰了，但是我知道写博客是好习惯，所以从现在开始我要重新坚持这个习惯。</p>
<p>我觉得我把写博客这件事还是看得太功利，还没写之前就开始想着会不会有人看，其实博客更多是给以后的自己看。</p>
<p>自勉。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/08/02/2020/the-idolmaster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/02/2020/the-idolmaster/" itemprop="url">THE IDOLM@STER 偶像大师系列个人入坑心得</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-02T19:23:00+08:00">
                2020-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="/the-idolmaster/imas-15th-banner.jpg" alt="imas-15th-banner"></p>
<p>说起来我有多久没写过二次元相关的博客了？恰逢爱马仕 15 周年，前几天追着官方生放重温了 2011 版《偶像大师》动画和剧场版，还有 5 场 LIVE BD 看了个爽（拜此所赐睡眠周末时间只有六小时），正好借此机会写点东西。</p>
<p><del>因为以往的经验告诉我，如果现在拖着不写以后就更写不出来了（</del></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/02/2020/the-idolmaster/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/31/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/31/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%8B/" itemprop="url">利用 MySQL 的 Binlog 实现数据同步与订阅(下)：EventBus 篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-31T12:01:14+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>终于到这个系列的最后一篇，在前两篇博客中，我们分别了介绍了<strong>Binlog</strong>的概念和事件总线(<strong>EventBus</strong>)的实现，在完成前面这将近好几千字的铺垫以后，我们终于可以进入正题，即通过 EventBus 发布 Binlog，再通过编写对应的 EventHandler 来订阅这些 Binlog，这样就实现了我们“最初的梦想”。坦白说，这个过程实在有一点漫长，庆幸的是，它终于还是来了。</p>
<h1 id="Binlog-读取与解析"><a href="#Binlog-读取与解析" class="headerlink" title="Binlog 读取与解析"></a>Binlog 读取与解析</h1><p>首先，我们通过 <a target="_blank" rel="noopener" href="https://github.com/noplay/python-mysql-replication">Python-Mysql-Replication</a> 这个项目来读取 Binlog，直接通过<code>pip install mysql-replication</code>安装即可。接下来，我们编写一个简单的脚本文件，这再次印证那句名言——人生苦短，我用 Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">readBinLog</span>():</span><br><span class="line">    stream = BinLogStreamReader(</span><br><span class="line">        <span class="comment"># 填写IP、账号、密码即可</span></span><br><span class="line">        connection_settings = &#123;</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>, </span><br><span class="line">            <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;passwd&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 每台服务器唯一</span></span><br><span class="line">        server_id = <span class="number">3</span>, </span><br><span class="line">        <span class="comment"># 主库Binlog读写完毕时是否阻塞连接</span></span><br><span class="line">        blocking = <span class="literal">True</span>, </span><br><span class="line">        <span class="comment"># 筛选指定的表</span></span><br><span class="line">        only_tables = [<span class="string">&#x27;order_info&#x27;</span>, <span class="string">&#x27;log_info&#x27;</span>], </span><br><span class="line">        <span class="comment"># 筛选指定的事件</span></span><br><span class="line">        only_events = [DeleteRowsEvent, WriteRowsEvent, UpdateRowsEvent]) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> binlogevent <span class="keyword">in</span> stream:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> binlogevent.rows:</span><br><span class="line">            event = &#123;</span><br><span class="line">                <span class="string">&quot;schema&quot;</span>: binlogevent.schema,</span><br><span class="line">                <span class="string">&quot;table&quot;</span>: binlogevent.table,</span><br><span class="line">                <span class="string">&quot;log_pos&quot;</span>: binlogevent.packet.log_pos</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(binlogevent, DeleteRowsEvent):</span><br><span class="line">                event[<span class="string">&quot;action&quot;</span>] = <span class="string">&quot;delete&quot;</span></span><br><span class="line">                event[<span class="string">&quot;origin&quot;</span>] = <span class="built_in">dict</span>(row[<span class="string">&quot;values&quot;</span>].items())</span><br><span class="line">                event[<span class="string">&quot;current&quot;</span>] = <span class="literal">None</span></span><br><span class="line">                event = <span class="built_in">dict</span>(event.items())</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, UpdateRowsEvent):</span><br><span class="line">                event[<span class="string">&quot;action&quot;</span>] = <span class="string">&quot;update&quot;</span></span><br><span class="line">                event[<span class="string">&quot;origin&quot;</span>] = <span class="built_in">dict</span>(row[<span class="string">&quot;before_values&quot;</span>].items())</span><br><span class="line">                event[<span class="string">&quot;current&quot;</span>] = <span class="built_in">dict</span>(row[<span class="string">&quot;after_values&quot;</span>].items())</span><br><span class="line">                event = <span class="built_in">dict</span>(event.items())</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, WriteRowsEvent):</span><br><span class="line">                event[<span class="string">&quot;action&quot;</span>] = <span class="string">&quot;insert&quot;</span></span><br><span class="line">                event[<span class="string">&quot;origin&quot;</span>] = <span class="literal">None</span></span><br><span class="line">                event[<span class="string">&quot;current&quot;</span>] = <span class="built_in">dict</span>(row[<span class="string">&quot;values&quot;</span>].items())</span><br><span class="line">                event = <span class="built_in">dict</span>(event.items())</span><br><span class="line">    stream.close()</span><br></pre></td></tr></table></figure>

<h1 id="发布-Binlog"><a href="#发布-Binlog" class="headerlink" title="发布 Binlog"></a>发布 Binlog</h1><p>在读取到 Binlog 以后，我们需要将其发布到 EventBus 里，为此，在.NET Core 这边提供一个 Web API 接口，只需要注入<code>IEventBus</code>然后调用<code>Publish()</code>即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Post: /&lt;controller&gt;/Publish</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">Route (<span class="string">&quot;PublishBinLog&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">PublishBinLog</span> (<span class="params">BinLogEventModel&lt;<span class="built_in">dynamic</span>&gt; eventModel</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventModel.action == <span class="string">&quot;insert&quot;</span> &amp;&amp; eventModel.table.StartsWith (<span class="string">&quot;log_&quot;</span>))</span><br><span class="line">        _eventBus.Publish (eventModel.MapTo&lt;WriteLogEvent&gt; ());</span><br><span class="line">    <span class="keyword">if</span> (eventModel.action == <span class="string">&quot;insert&quot;</span> &amp;&amp; eventModel.table == <span class="string">&quot;order_info&quot;</span>)</span><br><span class="line">        _eventBus.Publish (eventModel.MapTo&lt;OrderInfoCreateEvent&gt; ());</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，我们需要在脚本中添加调用 Web API 的逻辑代码，使用我们最熟悉的<code>requests</code>库即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sendBinLog</span>(<span class="params">event</span>):</span><br><span class="line">    url = <span class="string">&quot;https://localhost:44348/EventBus/PublishBinLog&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = json.dumps(event,cls=ComplexEncoder)</span><br><span class="line">        response = session.request(<span class="string">&quot;POST&quot;</span>, url, data=payload, headers=headers, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在这里，在处理 Binlog 的序列化的问题时，我们可能会遇到默认的 JSON 序列化器无法对 event 进行序列化的问题，此时，我们可以编写一个自定义的序列化器，下面是博主目前在使用的序列化器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexEncoder</span>(json.JSONEncoder):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, datetime):</span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(obj, date):</span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(obj, decimal.Decimal):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(obj)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">return</span> obj.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br></pre></td></tr></table></figure>

<h1 id="订阅-Binlog"><a href="#订阅-Binlog" class="headerlink" title="订阅 Binlog"></a>订阅 Binlog</h1><p>现在，为了订阅这些 Binlog，我们来编写对应的 EventHandler，这里我们定义两个 EventHandler，一个用于打印日志编号、日志内容、日志级别等信息，一个用于统计不同级别的日志的数目。代码实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印日志的EventHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WriteLogEventHandler</span> : <span class="title">IEventHandler</span>&lt;<span class="title">WriteLogEvent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ILogger&lt;WriteLogEventHandler&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriteLogEventHandler</span> (<span class="params">ILogger&lt;WriteLogEventHandler&gt; logger</span>)</span> &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span> (<span class="params">WriteLogEvent @<span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        _logger.LogInformation (<span class="string">$&quot;日志编号：<span class="subst">&#123;@<span class="keyword">event</span>.TRANSACTION_ID&#125;</span>，日志级别：<span class="subst">&#123;@<span class="keyword">event</span>.LOG_LEVEL&#125;</span>，主机：<span class="subst">&#123;@<span class="keyword">event</span>.HOST_NAME&#125;</span>，IP：<span class="subst">&#123;@<span class="keyword">event</span>.HOST_IP&#125;</span>，内容：<span class="subst">&#123;@<span class="keyword">event</span>.CONTENT&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析日志的EventHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnalyseLogEventHandler</span> : <span class="title">IEventHandler</span>&lt;<span class="title">WriteLogEvent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;AnalyseLogEventHandler&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnalyseLogEventHandler</span> (<span class="params">ILogger&lt;AnalyseLogEventHandler&gt; logger, IDistributedCache cache</span>)</span> &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span> (<span class="params">WriteLogEvent @<span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cacheCount = _cache.GetString (@event.LOG_LEVEL);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty (cacheCount))</span><br><span class="line">            cacheCount = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cacheCount = (<span class="built_in">int</span>.Parse (cacheCount) + <span class="number">1</span>).ToString ();</span><br><span class="line">        _cache.SetString (@event.LOG_LEVEL, cacheCount);;</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里需要在<code>Startup</code>中注入<code>EventHandler</code>、<code>EventBus</code>以及各种必要的依赖项，你可以手动注册，或者参考下面的代码，实现扫描注册：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IRabbitMQPersistentConnection, DefaultRabbitMQPersistentConnection&gt; ();</span><br><span class="line">services.AddSingleton&lt;IEventBusSubscriptionManager, EventBusSubscriptionManager&gt; (sp =&gt; <span class="keyword">new</span> EventBusSubscriptionManager ());</span><br><span class="line">services.AddSingleton&lt;IConnectionFactory, ConnectionFactory&gt; (sp =&gt; <span class="keyword">new</span> ConnectionFactory () &#123; HostName = <span class="string">&quot;localhost&quot;</span>, UserName = <span class="string">&quot;guest&quot;</span>, Password = <span class="string">&quot;guest&quot;</span> &#125;);</span><br><span class="line">services.AddSingleton&lt;ObjectPoolProvider, DefaultObjectPoolProvider&gt; ();</span><br><span class="line">services.AddControllers ().AddNewtonsoftJson ();</span><br><span class="line">services.AddDistributedMemoryCache (options =&gt; &#123;</span><br><span class="line">    options.ExpirationScanFrequency = TimeSpan.FromMinutes (<span class="number">5</span>);</span><br><span class="line">    options.SizeLimit = <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动注册</span></span><br><span class="line">services.AddEventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动注册</span></span><br><span class="line">services.AddSingleton&lt;IEventBus, RabbitMQEventBus&gt; (sp =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> eventBus = <span class="keyword">new</span> RabbitMQEventBus (sp.GetRequiredService&lt;IRabbitMQPersistentConnection&gt; (), sp.GetRequiredService&lt;IEventBusSubscriptionManager&gt; (), sp.GetRequiredService&lt;ILogger&lt;RabbitMQEventBus&gt;&gt; (), sp, <span class="string">&quot;eventbus-exchange&quot;</span>, <span class="string">&quot;eventbus-queue&quot;</span>);</span><br><span class="line">    eventBus.Subscribe&lt;WriteLogEvent, WriteLogEventHandler&gt;():</span><br><span class="line">    eventBus.Subscribe&lt;WriteLogEvent, AnalyseLogEventHandler&gt;();</span><br><span class="line">    <span class="keyword">return</span> eventBus;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">services.AddTransient&lt;WriteLogEventHandler&gt;();</span><br><span class="line">services.AddTransient&lt;AnalyseLogEventHandler&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一起来看看效果，简直太完美了，我就是不想写中间表啊，这样多好！！！<br><img src="https://i.loli.net/2020/07/31/PRjfiYpWNqHxI7Z.gif" alt="Python 读取 Binlog 演示"><br><img src="https://i.loli.net/2020/07/31/yVZgIn9NifpxTXa.gif" alt=".NET Core 消费 Binlog演示"><br><img src="https://i.loli.net/2020/07/31/iMX5PFCoak7VDv9.png" alt="RabbitMQ Dashboard 演示"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>通过三篇博客的篇幅，我们实现了“利用 MySQL 的 Binlog 实现数据同步与订阅”的想法。在这个过程中，我们了解了 Binlog 的相关概念，参考微软的 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 项目实现了一个基于 RabbitMQ 的 EventBus，而这一切都在这篇博客中完成了最终的“拼合”，通过 <a target="_blank" rel="noopener" href="https://github.com/noplay/python-mysql-replication">Python-Mysql-Replication</a> 实现了 Binlog 解析，而 EventBus 则作为整个事件系统的“上帝”对所有事件处理器(<strong>EventHandler</strong>)进行统一调度，最终我们不需要关心这些事件是如何被发布到 EventBus 中的，只需要知道它对应哪一个 Event 并为它编写对应的 EventHandler 即可，除了这篇博客中提到的 Binlog 以外，实际上它还可以作为系统内的“领域事件”来实现业务上的事件驱动，譬如<code>OrderInfoCreateEvent</code>这个事件可以表示一个订单被创建，而关心订单状态的人则可以通过 EventHandler 来实现订阅，实现类似发短信、发邮件、发微信等等的功能，或者可以让第三方的 Web API 来消费事件中携带的信息。同理，第三方的数据在流入系统时，可以先发布到消息队列中，再通过对应的 EventHandler 来进行异步处理，极大地改善系统接口的吞吐性能，而如果在这中间抽象出来一个数据交换层出来，那么就能收获更多不一样的东西，就在写这篇博客的时候，我在 Github 上的代码被收入了微软的”北极冰川火种计划”，虽然数字世界远比现实世界宽广得多，可能为这个世界减少一点“无用”的数据或者代码，应该一样可以算作是环保行为吧！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/28/2020-07-28-about-user-research/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/28/2020-07-28-about-user-research/" itemprop="url">关于用研岗位的思考</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-28T09:13:21+08:00">
                2020-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <h2 id="什么是用研岗位"><a href="#什么是用研岗位" class="headerlink" title="什么是用研岗位"></a>什么是用研岗位</h2><p>用户研究简称“用研”，是一种主要通过面向用户的各种研究方法，达成对关键问题的信息收集和理解的目标。</p>
<p>这些关键问题可大可小。大的方面可能是确定某个市场需求，小的方面可能是验证某个产品的市场受欢迎程度，也可能是确认产品的某个问题。</p>
<h2 id="用研常用的手段"><a href="#用研常用的手段" class="headerlink" title="用研常用的手段"></a>用研常用的手段</h2><p>用研常用的手段包括以下几种：用户访谈（包括一对一和一对多）、用户使用场景的现场观察、以及用户问卷调查、用户反馈收集等。</p>
<p>我把这些手段分成 2 类：</p>
<ul>
<li>客观数据分析类。包括用户使用场景。</li>
<li>主观数据分析类。包括用户访谈和用户问卷。</li>
</ul>
<p>我们也可以按定性和定量分析，把用研手段分类：</p>
<ul>
<li>定性分析。包括用户访谈和用户使用场景的分析。</li>
<li>定量分析。包括用户问卷，以及用户操作日志分析。</li>
</ul>
<p>下面我稍微展开介绍一下。</p>
<h3 id="用户访谈"><a href="#用户访谈" class="headerlink" title="用户访谈"></a>用户访谈</h3><p>我认为用户访谈是最好的定性分析手段，没有之一。主要是每个用户都有着独特的个体差异。如果我们在访谈前不设置太多访谈目标的话，就可以获得比较多的新的信息点。</p>
<p>这些信息点可能暴露出一些未被发掘的用户需求。也可能发现产品设计当中的不合适的流程。</p>
<p>当然，大部分时候，用户提到的问题要么是太特殊，要么是并不合理，但这没有关系，如果用户访谈中只有一个用户提到，我们就简单记录下来即可。大部分时候用户提的东西都不能直接拿来用，需要消化。</p>
<p>但如果每个用户都提到同样的问题，那我们就要小心了，很可能是我们产品的问题。</p>
<h3 id="用户使用场景的现场观察"><a href="#用户使用场景的现场观察" class="headerlink" title="用户使用场景的现场观察"></a>用户使用场景的现场观察</h3><p>做产品一直讲要“还原用户场景”，而用研就是最直接的呈现出用户场景。这个信息非常非常关键。因为用户可以随便说，但是怎么做才是最重要的，“身体不会撒谎”。</p>
<p>有一个故事，有一个公司做用研，让用户挑他们最喜欢的杯子颜色，结果大家都投的红色。用户做完用研，这个公司说，你们可以走的时候带走一个杯子。结果，大家走的时候都带走的是白色的杯子。</p>
<p>这就是一个用户说的和做的不一样的故事。类似的故事有很多，像可口可乐换口味事件就是历史上成本最大的被用户说的欺骗的故事，详见：<a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/e847c601cc175527072208b9.html">https://wenku.baidu.com/view/e847c601cc175527072208b9.html</a>。</p>
<h3 id="用户问卷"><a href="#用户问卷" class="headerlink" title="用户问卷"></a>用户问卷</h3><p>用户问卷用于定位一个问题后，定量分析用户的一些看法。问卷的设计大多时候都带有调研者的倾向性，所以很容易设置得不合理，这也是乔布斯说他从来不看用户问卷的原因。</p>
<p>但是 NPS（用户净推荐值）是一个很值得做的问卷，主要是这个指标非常标准化，我从在工作的第一天就接触 NPS，这个值的长期变化还是能有效反应出产品的改善。</p>
<h2 id="用研的核心挑战"><a href="#用研的核心挑战" class="headerlink" title="用研的核心挑战"></a>用研的核心挑战</h2><p>用户研究在很多公司都有岗位，但是这个岗位如果只做用户研究，那么很容易做得很差。所以大多数公司都将这个工作综合放到产品经理的工作中。</p>
<p>我也见过很多第三方的用研公司，请一些用户做访谈，然后搞一些问卷，出一个满是图表和数据的报告。看起来很牛逼，但是能够给决策带来支持的信息极少，信息本身的质量也值得商榷。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我认为客观数据分析类：用户使用场景的现场观察、用户操作日志分析是最有价值的用研工作。</p>
<p>用研要做得好，还是应该是最核心的人「亲自参与」或者「重度参与」。</p>
<p>所谓的亲自参与，即核心的人自己做用研。如果是决定产品需求或功能，就让产品经理自己做用研。我们猿辅导的教学端产品经理，就需要自己深入教学环节中去了解老师的需求，以便改进教学端的体验。</p>
<p>如果想节省一些时间，那么也可以选择「重度参与」的方式。「重度参与」的核心是：必须亲眼看到原始数据。比如，我听说在头条，当用研在给用户试用产品的时候，屋子里有一面单面玻璃，后面是相关的产品经理在现场观察。这个时候，用研只是帮忙进行了组织协调工作，核心工作和决策产品经理并没有缺席。</p>
<p>我们在做一些新产品用研的时候，我也要求用研的同学需要把现场录像下来。这些录像也非常有助于大家研究用户为什么那么操作，反复观看和思考。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>用研是一种面向用户获得决策信息的研究方法。</li>
<li>用研最有价值的是用户现场操作的原始数据。</li>
<li>用研的开放性访谈可以获得一些意外的发现。</li>
<li>用研问卷比较难以做决策支持，但 NPS 有一定价值。</li>
<li>用研最好是决策相关人「亲自参与」或者「重度参与」，否则用研结果很难被合理消化并得到推进。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/15/2020/07/openapi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/2020/07/openapi/" itemprop="url">自建一个简易的OpenAPI网关</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T19:30:00+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>网关（API Gateway）是请求流量的唯一入口，可以适配各类渠道和业务，处理各种协议接入、路由与报文转换、同步异步调用等，来管理 API 接口和进行请求流量控制，在微服务架构中，网关尤为重要。</p>
<p><img src="//www.fanhaobai.com/2020/07/openapi/ffc6e25d-7044-467d-8b7c-910831249968.jpeg" alt="预览图">
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/07/15/2020/07/openapi/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/15/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%AD/" itemprop="url">利用 MySQL 的 Binlog 实现数据同步与订阅(中)：RabbitMQ 篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T14:39:07+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>紧接上一篇博客中的思路，这次我们来说说事件总线(EventBus)，回首向来，关于这个话题，我们可能会联想到发布-订阅模式、观察者模式、IObservable<T>与 IObserver<T>、消息队列等等一系列的概念。所以，当我们尝试着去解释这个概念的时候，它到底是什么呢？是一种设计模式？是一组 API 接口？还是一种新的技术？显而易见，发布-订阅模式和观察者模式都是设计模式，而 IObservable<T>与 IObserver<T>、消息队列则是具体的实现方式，就像你可以用委托或者事件去实现一个观察者模式，而 Redis 里同样内置了发布-订阅模型，换言之，这是抽象与具体的区别，消息队列可以用来实现 EventBus，而 EventBus 主要的用途则是系统间的解耦，说到解耦，你可能会对观察者模式和发布-订阅模式这两种模式感到困惑，因为它们实在是太像了，一个最本质的区别在于发布者(主题)是否与订阅者(观察者)存在强依赖关系，而发布-订阅引入了类似主题&#x2F;Topic&#x2F;Channel 的中介者，显然从解耦的角度要更彻底一些，所以，我们今天就来一起实现一个事件总线(EventBus)。</p>
<h1 id="EventBus-整体设计"><a href="#EventBus-整体设计" class="headerlink" title="EventBus 整体设计"></a>EventBus 整体设计</h1><p>通过前面的探讨，我们可以知道，EventBus 其实是针对事件的<code>发布-订阅</code>模式的实现，所以，在设计 EventBus 的时候，我们可以结合<code>发布-定阅</code>模式来作为对照，而一个典型的<code>发布-订阅</code>模式至少需要三个角色，即<code>发布者</code>、<code>订阅者</code>和<code>消息</code>，所以，一般在设计 EventBus 的时候，基本都会从这三个方面入手，提供<strong>发布消息</strong>、<strong>订阅消息</strong>、<strong>退订消息</strong>的接口。由于 EventBus 本身并不负责消费消息，所以，还需要借助<code>IEventHandler&lt;T&gt;</code>来编写对应的事件处理器，这是 EventBus 可以实现业务解耦的重要原因。而为了维护事件和事件处理器的关系，通常需要借助 IoC 容器来注册这些 EventHandler，提供类似<code>Castle</code>或者<code>Autofac</code>从程序集中批量注册的机制，下面是博主借鉴 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 设计的 EventBus，首先是 IEventBus 接口，其定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventBus</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Publish</span>&lt;<span class="title">TEvent</span>&gt; (<span class="params">TEvent @<span class="keyword">event</span></span>) <span class="keyword">where</span> TEvent : EventBase</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Subscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : EventBase</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TH : <span class="title">IEventHandler</span>&lt;<span class="title">T</span>&gt;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Unsubscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TH : IEventHandler&lt;T&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : EventBase</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，这里对事件(<strong>EventBase</strong>)和事件处理器(<strong>EventHandler</strong>)均有一定约束，这是为了整个 EventBus 的实现，在某些 EventBus 的实现中，可能会支持非泛型的<code>EventHandler</code>，以及<code>Func</code>这样的委托类型，这里不考虑这种情形，因为从 Binlog 中获取的数据，基本上都是格式固定的 JSON。关于这部分，下面给出对应的定义：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventHandlerBase</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventHandler</span>&lt;<span class="title">TEvent</span>&gt; : <span class="title">IEventHandlerBase</span> <span class="keyword">where</span> <span class="title">TEvent</span> : <span class="title">EventBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">Handle</span> (<span class="params">TEvent @ebent</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid EventId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Guid.NewGuid ();</span><br><span class="line">    <span class="keyword">public</span> DateTime CreatedAt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = DateTime.UtcNow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而为了维护事件(<strong>EventBase</strong>)和事件处理器(<strong>EventHandler</strong>)间的订阅关系，博主这里定义了<code>IEventBusSubscriptionManager</code>接口，相信以你对<code>发布-订阅</code>模式的理解，你可以非常容易地想到，这里应该会用到一个字典来存储每一个事件以及该事件对应的事件处理器的类型信息。你猜对了，事实上大多数的<code>EventBus</code>都是这样实现的，尤其当你在实现一个基于内存或者进程内通信的<code>EventBus</code>的时候, 到这一步其实已经完成了大多数的功能。理论上你还应该定义一个<code>IEventStore</code>接口，显而易见，这是针对事件的持久化接口，不过当我们选择<code>RabbitMQ</code>的时候，它无形中就自动帮我们实现了这个接口。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventBusSubscriptionManager</span> </span><br><span class="line">&#123;</span><br><span class="line">    EventHandler&lt;EventBusSubscriptionEventArgs&gt; OnSubscribe &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    EventHandler&lt;EventBusSubscriptionEventArgs&gt; OnUnsubscribe &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Subscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : EventBase</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TH : <span class="title">IEventHandler</span>&lt;<span class="title">T</span>&gt;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Unsubscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : EventBase</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TH : <span class="title">IEventHandler</span>&lt;<span class="title">T</span>&gt;</span>;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsEventSubscribed</span>&lt;<span class="title">T</span>&gt; () <span class="keyword">where</span> T : EventBase</span>;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsEventSubscribed</span> (<span class="params"><span class="built_in">string</span> eventName</span>)</span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetEventTypeByName</span> (<span class="params"><span class="built_in">string</span> eventName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span> ()</span>;</span><br><span class="line">    <span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlersForEvent</span>&lt;<span class="title">T</span>&gt; () <span class="keyword">where</span> T : EventBase</span>;</span><br><span class="line">    <span class="function"><span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlersForEvent</span> (<span class="params"><span class="built_in">string</span> eventName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetEventKey</span>&lt;<span class="title">T</span>&gt; () <span class="keyword">where</span> T : EventBase</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IEventBusSubscriptionManager</code>接口主要提供了维护事件(Event)和事件处理器(EventHnadler)两者关系的一系列方法，我个人认为理解起来相对容易一点，实际上看 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 的时候，我每次都是从其中的一个微服务开始研究的，因为这样你才能发现其中的神秘之处，不得不说，平时看那种流水账代码看惯了，看到这样清晰、优雅的代码，内心还是觉得幸福啊，对技术的热爱再度被燃起。</p>
<h1 id="基于-RabbitMQ-的实现"><a href="#基于-RabbitMQ-的实现" class="headerlink" title="基于 RabbitMQ 的实现"></a>基于 RabbitMQ 的实现</h1><h2 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h2><p>好了，下面我们来看如何基于<code>RabbitMQ</code>实现上面定义的<code>IEventBus</code>接口，首当其冲的是<code>Publish()</code>方法的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>&lt;<span class="title">TEvent</span>&gt; (<span class="params">TEvent @<span class="keyword">event</span></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TEvent : EventBase</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_persistentConnection.IsConnected) _persistentConnection.TryConnect ();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = _persistentConnection.CreateModel ()) </span><br><span class="line">    &#123;</span><br><span class="line">        channel.ExchangeDeclare (_exchangeName, <span class="string">&quot;direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> eventName = @event.GetType ().FullName;</span><br><span class="line">        <span class="keyword">var</span> message = JsonConvert.SerializeObject (@event);</span><br><span class="line">        <span class="keyword">var</span> body = Encoding.UTF8.GetBytes (message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> properties = channel.CreateBasicProperties ();</span><br><span class="line">        properties.DeliveryMode = <span class="number">2</span>;</span><br><span class="line">        channel.BasicPublish (exchange: _exchangeName, routingKey: eventName, mandatory: <span class="literal">true</span>, basicProperties: properties, body: body);</span><br><span class="line">        _logger.LogDebug (<span class="string">$&quot;Publish message with RabbmitMQ BasicPublish: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先介绍下<code>RabbitMQ</code>中的两个概念，即<code>Connection</code>和<code>Channel</code>。其中，<code>Connection</code>是操作<code>RabbitMQ</code>的基础，就像我们操作数据库的时候，需要首先建立数据库连接一样。那么，<code>Channel</code>又是什么东西呢？它是真正去操作<code>RabbitMQ</code>的东西。继续以数据库作为例子，那么<code>Channel</code>可以理解为<code>ADO.NET</code>中的<code>Command</code>，即，那个真正负责执行 SQL 语句的家伙。一个典型的使用<code>RabbitMQ</code>的过程，大概是下面这个样子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connectionFactory = <span class="keyword">new</span> ConnectionFactory() &#123; HostName = <span class="string">&quot;Your IP&quot;</span>, UserName = <span class="string">&quot;You User&quot;</span>, Password = <span class="string">&quot;Your Pass&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> connection = connectionFactory.CreateConnection();</span><br><span class="line"><span class="keyword">var</span> channel = connection..CreateModel();</span><br></pre></td></tr></table></figure>
<p>回到我们的 EventBus 中，因为<code>RabbitMQ</code>的链接可能会在一段时间后自动关闭，所以，在微软的 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 项目，它设计了一个支持自动重连的链接持久化类，我们这里同样有这个机制，当发现链接断开的时候，自动尝试重连，而接下来就由我们熟悉的<code>Channel</code>登场啦！这个时候，我们发现又出现了一个新面孔——交换器(<strong>Exchange</strong>)，好吧，这又要引出 RabbitMQ 中消息投递的原理，即 RabbitMQ 中消息并非由发布者直接发送给消费者，而是需要经过交换器这个中介者，虽然你可以直接去读写队列，但是实际应用中通常都不会这么做。其实，在某种意义上，我们的 EventBus 一样承担着中介者的角色，我们只需要关注怎么发布消息，这个消息将由哪一个订阅者来消费完全不需要我来关心，一个典型的消息投递过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/07/31/geWGI6M39fcw2S1.png" alt="RabbitMQ消息投递示意图"></p>
<p>在这里，我们对消息进行序列化以后，按照事件的类型信息生成<code>routingKey</code>，并指定交换器的类型为<code>direct</code>，这是一个 RabbitMQ 中自带的<code>发布-订阅</code>实现，因为交换器会根据<code>routingKey</code>投递消息到对应的队列中，关于 RabbitMQ 中四种交换器的说明，可以在下一节找到答案。注意到在声明交换器的时候，第二个参数被设为 true，这是在 RabbitMQ 需要对这个交换器进行持久化；而第三个参数被设为 false，这是在告诉 RabbitMQ 这个交换器内的消息不允许自动删除；DeliveryMode 设为 2 则表示消息需要持久化到磁盘上，这样即使 RabbitMQ 发生意外宕机，依然可以从磁盘上恢复消息。最终，我们调用<code>BasicPublish()</code>将消息投递到指定的交换机中，这样就完成了事件的发布功能。</p>
<h2 id="Subscribe-Unsubscribe"><a href="#Subscribe-Unsubscribe" class="headerlink" title="Subscribe&#x2F;Unsubscribe"></a>Subscribe&#x2F;Unsubscribe</h2><p>接下来，我们来看<code>Subscribe()</code>和<code>Unsubscribe()</code>两个方法的实现过程。这里实际上需要实现两部分的功能，一个是管理事件(<strong>EventBase</strong>)与事件处理器(<strong>EventHandler</strong>)间的关系，一个是管理消费者、消费者队列与交换器间的关系。因为考虑到后续可能需要实现类似<code>MediatR</code>的进程内通信的功能，所以，我们考虑将这两部分剥离开来，这样方便对<code>EventBus</code>进行扩展。为此，我们定义了<code>IEventSubscriptionManager</code>这个接口，它的定义我们在前面已经见过，最终我们会在<code>EventBus</code>里引用这个中间层，这样可以让<code>EventBus</code>显得更加清爽一点，一起来看它的具体实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> T : EventBase</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TH : IEventHandler&lt;T&gt;</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> eventName = GetEventKey&lt;T&gt; ();</span><br><span class="line">    <span class="keyword">if</span> (_eventHandlers.ContainsKey (eventName) &amp;&amp; !_eventHandlers[eventName].Any (x =&gt; x == <span class="keyword">typeof</span> (TH))) &#123;</span><br><span class="line">        _eventHandlers[eventName].Add (<span class="keyword">typeof</span> (TH));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _eventHandlers[eventName] = <span class="keyword">new</span> List&lt;Type&gt; () &#123; <span class="keyword">typeof</span> (TH) &#125;;</span><br><span class="line">        _eventTypes.Add (<span class="keyword">typeof</span> (T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (OnSubscribe != <span class="literal">null</span>)</span><br><span class="line">        OnSubscribe (<span class="keyword">this</span>, <span class="keyword">new</span> EventBusSubscriptionEventArgs () &#123; EvenType = <span class="keyword">typeof</span> (T), HandlerType = <span class="keyword">typeof</span> (TH) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>&lt;<span class="title">T</span>, <span class="title">TH</span>&gt; ()</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> T : EventBase</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TH : IEventHandler&lt;T&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">var</span> eventName = GetEventKey&lt;T&gt; ();</span><br><span class="line">        <span class="keyword">if</span> (_eventHandlers.ContainsKey (eventName) &amp;&amp; _eventHandlers[eventName].Any (x =&gt; x == <span class="keyword">typeof</span> (TH))) &#123;</span><br><span class="line">            _eventHandlers[eventName].Remove (<span class="keyword">typeof</span> (TH));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_eventHandlers.ContainsKey (eventName) &amp;&amp; !_eventHandlers[eventName].Any ()) &#123;</span><br><span class="line">            _eventHandlers.Remove (eventName);</span><br><span class="line">            _eventTypes.RemoveAll (x =&gt; x.FullName == eventName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (OnUnsubscribe != <span class="literal">null</span> &amp;&amp; !GetHandlersForEvent&lt;T&gt; ().Any ())</span><br><span class="line">            OnSubscribe (<span class="keyword">this</span>, <span class="keyword">new</span> EventBusSubscriptionEventArgs () &#123; EvenType = <span class="keyword">typeof</span> (T), HandlerType = <span class="keyword">typeof</span> (TH) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，<strong>订阅就是注册 EventHandler 到对应的键的过程，而取消订阅就是从对应的键里移除 EventHandler 的过程</strong>。为了确保在订阅或者退订的时候，可以通知到具体的 EventBus 实现者，譬如 RabbitMQ、Kafka 等，我们定义了<code>OnSubscribe</code>和<code>OnUnsubscribe</code>两个委托，实际设计中，我们会在 EventBus 初始化的时候，将这两个委托指向 EventBus 内部订阅和退订的方法。对于订阅，我们需要用到 RabbitMQ 的<code>BasicConsume()</code>方法；而对于取消订阅，我们需要用到 RabbitMQ 的<code>UnbindQueue()</code>方法。下面给出关键部分的代码实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RabbitMQ中订阅指定的routingKey</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartBasicConsume</span> (<span class="params"><span class="built_in">string</span> routingKey</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _logger.LogTrace (<span class="string">&quot;Starting RabbitMQ BasicConsume...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_persistentConnection.IsConnected) _persistentConnection.TryConnect ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> queueName = GetQueueName (routingKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> channel = _persistentConnection.CreateModel ();</span><br><span class="line">    channel.ExchangeDeclare (_exchangeName, <span class="string">&quot;direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.QueueDeclare (queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.QueueBind (queueName, _exchangeName, routingKey, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer (channel);</span><br><span class="line">    consumer.Received += <span class="keyword">async</span> (s, e) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> routingKey = e.RoutingKey;</span><br><span class="line">        <span class="keyword">var</span> message = Encoding.UTF8.GetString (e.Body.ToArray ());</span><br><span class="line">        <span class="keyword">var</span> tasks = ProcessEvent (routingKey, message);</span><br><span class="line">        <span class="keyword">await</span> Task.WhenAll (tasks);</span><br><span class="line">        channel.BasicAck (e.DeliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    channel.BasicConsume (queue: <span class="string">$&quot;Q:<span class="subst">&#123;routingKey&#125;</span>&quot;</span>, autoAck : <span class="literal">false</span>, consumer : consumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用EventHandler处理事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable&lt;Task&gt; <span class="title">ProcessEvent</span> (<span class="params"><span class="built_in">string</span> eventName, <span class="built_in">string</span> message</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_subscriptionManager.IsEventSubscribed (eventName)) &#123;</span><br><span class="line">       <span class="comment">//基于Polly构建超时合重试策略</span></span><br><span class="line">        <span class="keyword">var</span> policy = BuildProcessEventPolicy ();</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> serviceScope = _serviceProvider.CreateScope ()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> handlerType <span class="keyword">in</span> _subscriptionManager.GetHandlersForEvent (eventName)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> handler = serviceScope.ServiceProvider.GetRequiredService (handlerType);</span><br><span class="line">                <span class="keyword">if</span> (handler == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> eventType = _subscriptionManager.GetEventTypeByName (eventName);</span><br><span class="line">                <span class="keyword">var</span> integrationEvent = JsonConvert.DeserializeObject (message, eventType);</span><br><span class="line">                <span class="keyword">var</span> concreteType = <span class="keyword">typeof</span>(IEventHandler&lt;&gt;).MakeGenericType (eventType);</span><br><span class="line"></span><br><span class="line">                _logger.LogInformation (<span class="string">$&quot;Process event \&quot;<span class="subst">&#123;eventName&#125;</span>\&quot; with \&quot;<span class="subst">&#123;handler.GetType().Name&#125;</span>\&quot;...&quot;</span>);</span><br><span class="line">                <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">Task</span>)policy.<span class="title">Execute</span>(<span class="params">(</span>)</span> =&gt; concreteType.GetMethod (<span class="string">&quot;Handle&quot;</span>).Invoke (handler, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; integrationEvent &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RabbitMQ中退订某个事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UnbindQueue</span> (<span class="params"><span class="built_in">string</span> routingKey</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_persistentConnection.IsConnected) _persistentConnection.TryConnect ();</span><br><span class="line">    <span class="keyword">var</span> channel = _persistentConnection.CreateModel ();</span><br><span class="line">    <span class="keyword">var</span> queueName = GetQueueName (routingKey);</span><br><span class="line">    channel.QueueUnbind (queueName, _exchangeName, routingKey, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ProcessEvent()</code>方法是 EventBus 通过一个或多个 EventHandler 处理业务的核心方法。当从 RabbitMQ 中接收到消息时，首先检查当前事件是否已注册。如果已注册，则获取当前事件对应的 EventHandler 集合，然后通过 IoC 容器逐个地取得对应实例，因为在定义 EventHandler 的时候，我们让<code>Handle()</code>方法返回了一个 Task，所以，我们可以顺利成章地使用<code>Task.WhenAll()</code>，而当所有的 EventHandler 都处理完成的时候，我们就可以认为这条消息被处理完了，此时，我们可以手动进行 ACK，这样这条消息就会从队列中移除，至此，我们已经实现了一个完整的 EventBus。</p>
<h1 id="RabbitMQ-进阶与释疑"><a href="#RabbitMQ-进阶与释疑" class="headerlink" title="RabbitMQ 进阶与释疑"></a>RabbitMQ 进阶与释疑</h1><p>我在写这篇博客的时候，周围有很多人都劝我不要用 RabbitMQ，而主要的理由则是 RabbitMQ 的吞吐量不如 Kafka。我怀疑我们有时候会严重地高估自己，“面试造火箭，入职拧螺丝”，这种事情难道还少吗？与其一张嘴就是高并发、高可用，不如诚实一点结合实际来选择，我相信 RabbitMQ 里遇到的问题，可能有一些同样会在 Kafka 里遇到，因为这个世界上就没有最完美的解决方案，对于我写这篇博客的初心而言，我是为了把 Binlog 发布到 RabbitMQ 上，方便第三方来订阅这些数据的“变化”，所以，可靠性是不是要比吞吐量更重要一点呢？好了，下面，我们来看一些“杞人忧天”式的 RabbitMQ 的进阶话题，就是当你熟悉了 RabbitMQ 的 API 以后，需要去着重考虑的东西。</p>
<h2 id="RabbitMQ-丢消息怎么办"><a href="#RabbitMQ-丢消息怎么办" class="headerlink" title="RabbitMQ 丢消息怎么办"></a>RabbitMQ 丢消息怎么办</h2><p>第一个问题是最普遍的一个问题，按照“<strong>生产者 -&gt; 交换器 -&gt; 队列 -&gt; 消费者</strong>”的模式，一旦发生丢消息的情况，无非有三种情况：<strong>生产者丢消息</strong>、<strong>消息队列丢消息</strong>、<strong>消费者丢消息</strong>。下面我们逐个进行分析：</p>
<p>1、对于生产者丢消息，RabbitMQ提供的<code>transaction</code>和<code>confirm</code>机制可以保证生产者不丢消息，<code>transaction</code>机制类似数据库的事务，只有当消息发送成功，事物才会被提交，否则事务被被回滚。因为每次发消息都必须开启事物，所以<code>transaction</code>机制会导致 RabbitMQ 吞吐量降低，一般建议使用<code>confirm</code>机制，即消息被正确投递则发送 ACK 给生产者，否则发送 NACK 给生产者。</p>
<p>2、对于消息队列丢消息，解决方案我们在前面有提到过，主要有两点，<strong>第一，声明队列的时候设置 durable 为 true，这表示这是一个支持持久化的队列。第二，发送消息的时候，设置 DeliveryMode 为 2</strong>，这表示消息支持持久化的磁盘，如果有一天 RabbitMQ 遭遇不幸，消息会被持久化到磁盘上，所以说，习惯性保存是个好习惯啊……</p>
<p>3、对于消费者丢消息，解决方案是手动 ACK，因为只有队列收到 ACK 时，它才会从队列中删除这条消息，否则，这条消息会重新回到队列中，只要它能重新回到队列、重新处理，它怎么会丢呢？你说对吧？</p>
<h2 id="RabbitMQ-重试与超时"><a href="#RabbitMQ-重试与超时" class="headerlink" title="RabbitMQ 重试与超时"></a>RabbitMQ 重试与超时</h2><p>先说结论，关于重试与超时这个话题，我们有两种实现思路，一种是像博主这样，采用 Polly 定义超时+重试的组合策略，然后将这个策略附加到每一个 Handle()方法上，通过程序来实现重试与超时。而第二种思路，则是利用消息&#x2F;队列的 TTL 实现超时，利用死信实现重试，消息 TTL 和队列 TTL 的不同在于，一个队列超时则队列内的消息会被全部清空，而一个消息超时则可以在清空前决定是否要清空。</p>
<p>重试与超时最大的问题其实在于幂等性，因为在以往的实践中，当我们的消费者变成一个第三方的 API 接口的时候，我们很难知道，一个消息到底需要处理多久，我一直不明白，为什么宝洁这样的公司，它一个 API 接口居然能等将近 30 分钟，而更加令人难以忍受的，是大量只能调用一次的接口，这类接口既无法保证能 100%调用成功，同样无法保证，第二次调和第一次调效果完全一样，所以，关于重试与超时这部分，其实应该结合实际业务去设计，因为每个人的诉求可能都不一样。</p>
<h2 id="RabbitMQ-的四种模式"><a href="#RabbitMQ-的四种模式" class="headerlink" title="RabbitMQ 的四种模式"></a>RabbitMQ 的四种模式</h2><p>在实现 EventBus 的过程中，博主用到了<code>direct</code>类型的交换器，并说这是 RabbitMQ 内置的发布-订阅实现，实际上，这里应该有<code>direct</code>、<code>fanout</code>、<code>topic</code>和<code>head</code>四种类型的交换器，下面我们来逐个地进行说明。</p>
<p>1、<code>fanout</code>相当于广播，所有绑定了该交换器的队列都会收到消息。如下图所示：</p>
<p><img src="https://i.loli.net/2020/07/30/I6Ape3W5C1nOvxV.gif" alt="RabbitMQ-fanout模式"></p>
<p>2、<code>direct</code>相当于发布订阅，只有绑定了该交换器且 routingKey 完全匹配的队列会收到消息。如下图所示：</p>
<p><img src="https://i.loli.net/2020/07/31/xcNezCmHov3UL5D.gif" alt="RabbitMQ-driect模式"></p>
<p>3、<code>topic</code>相当于<code>direct</code> + 模糊匹配，所有绑定了该交换器的队列，且 routingKey 符合给定的模式，就会收到消息。如下图所示：</p>
<p><img src="https://i.loli.net/2020/07/31/j6H5dOX4FsJPgxC.gif" alt="RabbitMQ-topic模式"></p>
<p>4、<code>header</code>相当于给每条消息定义了一个“头”，只有当头中的一个键值对(Any)或者全部键值对(All)匹配的时候，才会收到消息，这种实际应用中非常少，如下图所示：</p>
<p><img src="https://i.loli.net/2020/07/31/Q7CkMVsL4jFRtNT.png" alt="RabbitMQ-header模式"></p>
<h2 id="RaabitMQ-的死信机制"><a href="#RaabitMQ-的死信机制" class="headerlink" title="RaabitMQ 的死信机制"></a>RaabitMQ 的死信机制</h2><p>RabbitMQ 中的死信(Dead Letter)机制，我认为是一个非常有意思的东西，因为从实用性的角度来讲，它可以帮助我们实现“延时队列”，虽然在更多的场景下，我们希望消息能被立即处理，因为这样看起来更像一个“实时”的行为。可在实际应用过程中，我们难免会遇到这样一种情况，一条消息经过手动 ACK 以后从队列中移除，结果消费者端问你能不能再消费一次这条消息，所以，Kafka 里就提供了两种策略，即最多一次和至少一次，最多一次保证的是消息不会被重复消费，而至少一次保证的是消息 100%被成功消费。所以，简单来说，在为 RabbitMQ 配置了死信的情况下，可以让部分消息有机会重新进入队列、重新被消费。那么，什么情况下会产生死信呢？主要有下面三种情况：</p>
<ul>
<li>消息被否定确认，使用<code>channel.basicNack</code>或<code>channel.basicReject</code>，并且此时<code>requeue</code>属性被设置为 false。</li>
<li>消息在队列的存活时间超过设置的 TTL 时间。</li>
<li>消息队列的消息数量已经超过最大队列长度。</li>
</ul>
<p>接下来，为了配合死信机制，我们必须要声明死信队列，建议为每一个需要配置死信的事件单独定义一个死信队列，声明方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明死信交换器</span></span><br><span class="line">channel.ExchangeDeclare(<span class="string">&quot;exchange.with.dlx&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="keyword">var</span> args = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line"><span class="comment">//该队列中所有消息都进入死信交换器</span></span><br><span class="line">args.Add(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;exchange.with.dlx&quot;</span>);</span><br><span class="line"><span class="comment">//该队列中指定routingKey的消息进入死信交换器</span></span><br><span class="line">args.Add(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;foo.bar&quot;</span>);</span><br><span class="line">channel.QueueDeclare(<span class="string">&quot;queue.with.dlx&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文参考微软的 <a target="_blank" rel="noopener" href="https://github.com/dotnet-architecture/eShopOnContainers">eShopOnContainers</a> 项目，实现一个基于 RabbitMQ 的事件总线，事件总线是发布-订阅模式的一种延伸，可以在分布式的环境中令消息的发布者、订阅者完美地解耦，是领域驱动设计(DDD)中重要的基础设施之一，对于实现业务上的“事件驱动”非常有帮助。而实现 EventBus 最关键的三个方法，即 Publish()、Subscribe()和 Unsubscribe()，这其中需要了解一部分 RabbitMQ 的知识，所以，在这篇博客中，你可以了解到 RabbitMQ 的四种交换器、死信机制、重试超时机制等等，在此基础上，我们将在下一篇博客中，通过 <a target="_blank" rel="noopener" href="https://github.com/noplay/python-mysql-replication">Python-Mysql-Replication</a> 实现 Binlog 的发布，而一旦我们将 Binlog 发布到消息队列中，本文实现的 EventBus 就可以作为消息的中介者而登场啦，欢迎大家继续关注我的博客，我们下一篇见！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/09/2020-07-09-dodging-energy-vampires-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/09/2020-07-09-dodging-energy-vampires-book/" itemprop="url">如何识别和摆脱精神控制 - 读《情感吸血鬼》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-09T08:40:29+08:00">
                2020-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>第一次听到 PUA 这个词，是从南方周末上看到《”不寒而栗”的爱情：北大自杀女生的聊天记录》的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%85%E4%B8%BD%E8%87%AA%E6%9D%80%E4%BA%8B%E4%BB%B6">报道</a>，然后又接触到精神控制这一类的词汇，当时觉得很惊奇，没想到精神控制能够做到用言语最终让人自杀的地步。</p>
<p>最近看完了一本反精神控制的书《情感吸血鬼 - 如何识别并逃离病态关系》，这本书系统性地介绍了被控制人的性格特点，以及如何保护自己，比较有意思的一本书，给大家分享一下。</p>
<img src="/images/energy-vampires-book.jpg" class="">


<h2 id="什么样的人容易被精神控制"><a href="#什么样的人容易被精神控制" class="headerlink" title="什么样的人容易被精神控制"></a>什么样的人容易被精神控制</h2><p>作者将精神控制者比喻成：情感吸血鬼，我不太喜欢这个词，所以下文中我还是称他们为精神控制者。被控制的人，我们称作高共情者。</p>
<p>作者认为：敏感性高的共情者最可能被精神控制，成为情感吸血鬼的受害者。而高共情者通常是比较会隐藏和改变自己，以适应环境的。这一类人通常在童年的时候经历过一段痛苦的经历。因为经历过痛苦，所以就会渴望关心，也更多时候站在别人的立场上考虑问题，愿意牺牲自己。</p>
<p>北大包丽（化名）就是一个高共情者，她就是因为很平常的一个事情：不是处女，就得接受男友的各种变态的要求：把自己称作狗，拍裸照给男友，答应做绝育手术，最后甚至愿意自杀。</p>
<p>交往的对象 “不是处女” 在现在这个社会是很平常的事情，但是由于包丽的高共情，愿意站在男朋友的角度考虑他的感受，所以愿意为男朋友的感受做出明显过分的自我惩罚。</p>
<p>想想你有没有一段不愿意回忆的童年经历？你有没有在童年缺少支持和认同？有没有需要付出，才可能得到父母的爱？有没有为了讨好别人而改变或者隐藏自己真实的想法？如果有的话，那么其实你也是容易被精神控制的高共情者。</p>
<p>坦白说，我自己就是一个高共情者。敏感，喜欢站在对方角度思考问题，不喜欢冲突，容易妥协。</p>
<h2 id="精神控制的套路"><a href="#精神控制的套路" class="headerlink" title="精神控制的套路"></a>精神控制的套路</h2><p>精神控制的套路其实在北大包丽事件上演绎得很完整。首先，实施精神控制的人通常都很优秀，书中的案例包括公司的 CEO，高管等。控制包丽的牟林翰在北大也是学生会副主席，但这并不代表他们善良。</p>
<p>精神控制者首先是与高共情者建立信任关系，在这个期间，他们会表现得非常友好，让你感受到找到了理想的人。但是其实，这只是精神控制者的套路。他们真实的目的是利用你与他建立的信任，来深入地了解你的一切，从而获得你的缺点，这就是你的伤口。</p>
<p>这个缺点是什么不重要，重要的是精神控制者会声称这个缺点毁了他，让他遭受了巨大的打击，这会让高共情者感觉到内疚。于是，日复一日地，精神控制者往共情者的这个伤口上撒盐，让共情者人格慢慢扭曲。扭曲的效果就是，共情者会真的认为这是一个巨大的缺点，应该为了这个缺点补偿精神控制者。</p>
<p>当共情者愿意为了一个被夸大的缺点补偿精神控制者之后，共情者就坠入了被控制的深渊。精神控制者的要求会逐步升级，从写忏悔书，到下跪，到身体惩罚，到精神惩罚，最终变成精神控制者的奴隶。</p>
<p>北大的包丽先和牟林翰建立了恋爱关系，让牟林翰知道了自己的隐私，从而被牟林翰抓住缺点不断强调，进而认为自己真的应该 “认错并且忏悔”，从而从刚开始的发毒誓，到后面纹身称自己是狗，把牟林翰的微信昵称改成主人，再到后面接受去做绝育手术。从精神控制来说，牟林翰真的像是教科书般的存在。</p>
<h2 id="如何识别和逃离精神控制"><a href="#如何识别和逃离精神控制" class="headerlink" title="如何识别和逃离精神控制"></a>如何识别和逃离精神控制</h2><h3 id="识别精神控制"><a href="#识别精神控制" class="headerlink" title="识别精神控制"></a>识别精神控制</h3><p>精神控制者首先自己的心理就不是健康的，通常他们的行为模式标签包括心理变态、自恋、边缘型人格或反社会的行为倾向，这些人格类型为 B 类。在美国精神病学协会出版的《精神疾病诊断与统计手册》中，B 类人格特征包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8D%E7%A4%BE%E4%BC%9A%E5%9E%8B%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D">反社会型人格障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E5%9E%8B%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D">边缘型人格障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A1%A8%E6%BC%94%E5%9E%8B%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D">表演型人格障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%87%AA%E6%81%8B%E5%9E%8B%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D">自恋型人格障碍</a></li>
</ul>
<p>我查了一下百度百科，牟林翰可能有一部分 边缘型人格障碍 和 自恋型人格障碍 的特征。前者喜欢用表现强烈的情绪反应，贬低、攻击或挖苦对方，同时用自杀、自残自伤等来阻止被抛弃。后者在意社会成就，可能在工作上比较成功。</p>
<p>当精神控制者拿自杀来威胁你的时候，你就要特别小心了，他很可能不是真的想自杀，而是想要拿自杀要挟你。</p>
<h3 id="逃离精神控制"><a href="#逃离精神控制" class="headerlink" title="逃离精神控制"></a>逃离精神控制</h3><p>精神控制者惯用的伎俩就是过度夸大共情者的缺点，当出现这种情况的时候，就应该尽快想办法逃离这种关系。</p>
<p>书中提到很多共情者会经历多次反复，因为内心深处觉得对方可能改变。但是事实上这种人格障碍心理问题可能是来自于遗传或者长期的生活，改变的可能性极低。作者建议大家选择尽快结束掉这种关系，不要抱希望。</p>
<p>共情者因为已经足够为别人着想了，所以在面对这种关系时应该要注意守住自己的边界，不能让自己的一点点小问题被无限放大。同时专注于自己的感受，如果自己感受已经很有压力了，那么这种关系就是不对的。</p>
<h2 id="如何修复自己内心的童年创伤"><a href="#如何修复自己内心的童年创伤" class="headerlink" title="如何修复自己内心的童年创伤"></a>如何修复自己内心的童年创伤</h2><p>作者在最后也提到，大多数共情者与精神控制者一样，都有着一定的心理问题，共情者的问题主要来自于童年的创伤，由于缺少爱而渴望关心。作者在书中也提到了各种心理治疗的方式。我这里摘录两个印象较深的。</p>
<h3 id="表达情绪"><a href="#表达情绪" class="headerlink" title="表达情绪"></a>表达情绪</h3><p>共情者常常压抑自己的负面情绪，但像愤怒、悲伤这一类情绪，都是身体的需要，应该表达出来。如果不表达出来，就会出现一些生理或心理的问题。当你经历痛苦的时候，你必须通过动作、声音和眼泪来进行治愈，这是身体治疗痛苦的天生方法。否则，所有这些能量会卡在你的身体里，导致各种各样的健康问题。</p>
<p>书中介绍了心理治疗师对受害者的一个声音治疗方案，让受害者假想面对精神控制者，说：”某某，你这个 XX 的 XX，你真是个混蛋，我送你踏上疗养之路”。</p>
<h3 id="自我沟通法"><a href="#自我沟通法" class="headerlink" title="自我沟通法"></a>自我沟通法</h3><p>书中介绍了一种通过和幼年的自己假想”对话”的治疗方案，我感觉是一种特殊的表达宣泄式的治疗，具体做法是：</p>
<ul>
<li>第一步：停止。想像一个停止的标志。</li>
<li>第二步：用鼻子深呼吸。让自己放松。</li>
<li>第三步：承认：”哇，我又来了”。帮助自己意识到你的故事。</li>
<li>第四步：获得一个数字。想一个数字，这个数字表示你将遇到的过去的自己的年龄。</li>
<li>第五步：与这个”内在小孩”相遇。创造一个神奇的花园，你和过去的自己相遇，看看他在做什么，你能不能给他爱和安慰。</li>
<li>第六步：告别孩子。让孩子放心，然后你离开，把孩子留在花园。</li>
<li>第七步：你作为一个成年人回到现在。</li>
</ul>
<p>我估计这个方法是帮助那些深受伤害的共情者解压的方法，书中的作者以自己为案例，花了 40 天和过去的自己和解。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>高共情者容易成为精神控制的对象。</li>
<li>高共情者通常在童年有一些不幸，使得他们愿意改变和隐藏自己，获得关爱。</li>
<li>精神控制者通过建立信任、放大共情者的缺点来获得过分的补偿，最终消耗尽共情者的身心。</li>
<li>共情者需要识别出精神控制者并且逃离这种关系，并且通过各种方式缓解情绪，并与自己的过去和解。</li>
</ul>
<p>这就是《情感吸血鬼》一书的小结，推荐给大家。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/07/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/07/%E5%88%A9%E7%94%A8MySQL%E7%9A%84Binlog%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AE%A2%E9%98%85-%E4%B8%8A/" itemprop="url">利用 MySQL 的 Binlog 实现数据同步与订阅(上)：基础篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-07T09:23:59+08:00">
                2020-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>终于等到了周末，在经历了一周的忙碌后，终于可以利用空闲写篇博客。其实，博主有一点困惑，困惑于这个世界早已“堆积”起人类难以想象的“大”数据，而我们又好像执着于去“造”一个又一个“差不多”的“内容管理系统”，从前我们说互联网的精神是开放和分享，可不知从什么时候起，我们亲手打造了一个又一个的“信息孤岛”。而为了打通这些“关节”，就不得不去造一张巨大无比的蜘蛛网，你说这就是互联网的本质，对此我表示无法反驳。我更关心的是这其中最脆弱的部分，即：一条数据怎么从 A 系统流转到 B 系统。可能你会想到<code>API</code>或者<code>ETL</code>这样的关键词，而我今天想说的关键词则是<code>Binlog</code>。假如你经常需要让数据近乎实时地在两个系统间流转，那么你应该停下来听我——一个不甘心整天写<code>CRUD</code>换取<code>996</code>福报的程序员，讲讲如何通过<code>Binlog</code>实现数据同步和订阅的故事。</p>
<h1 id="什么是-Binlog"><a href="#什么是-Binlog" class="headerlink" title="什么是 Binlog"></a>什么是 Binlog</h1><p>首先，来回答第一个问题，什么是 Binlog？Binlog 即 <code>Binary Log</code>，是 MySQL 中的一种二进制日志文件。它可以记录<code>MySQL</code>内部对数据库的所有修改，故，设计 Binlog 最主要的目的是满足数据库主从复制和增量恢复的需要。对于主从复制，想必大家都耳熟能详呢，因为但凡提及数据库性能优化，大家首先想到的所谓的“读写分离”，而无论是物理层面的一主多从，还是架构层面的<code>CQRS</code>，这背后最大的功臣当属<code>主从复制</code>，而实现主从复制的更底层原因，则要从 Binlog 说起。而对于数据库恢复，身为互联网从业者，对于像<code>“rm -f”</code>和<code>“删库”</code>、<code>“跑路”</code>这些梗，更是喜闻乐见，比如像今年的绿盟删库事件，在数据被删除以后，工程师花了好几天时间去抢救数据，这其中就用到了 Binlog。</p>
<p>可能大家会好奇，为什么 Binlog 可以做到这些事情。其实，从 Binlog 的三种模式上，我们就可以窥其一二，它们分别是：<code>Statement</code>、<code>Row</code>、<code>Mixed</code>，其中<code>Statement</code>模式记录的是所有数据库操作对应的 SQL 语句，如 INSERT、UPDATE 、DELETE 等 DML 语句，CREATE 、DROP 、ALTER 等 DDL，所以，从理论上讲，只要按顺序执行这些 SQL 语句，就可以实现不同数据库间的数据复制。而<code>Row</code>模式更关心每一行的变更，这种在实际应用中会更普遍一点，因为有时候更关心数据的变化情况，例如一个订单被创建出来，司机通过 App 接收了某个运输任务等。而<code>Mixed</code>模式可以认为是<code>Statement</code>模式和<code>Row</code>模式的混合体，因为<code>Statement</code>模式和<code>Row</code>模式都有各自的不足，前者可能会导致数据不一致，而后者则会占用大量的存储空间。在实际使用中，我们往往会借助各种各样的工具，譬如官方自带的<code>mysqlbinlog</code>、支持 Binlog 解析的<code>StreamSets</code>等等。</p>
<p>好了，下面我们简单介绍下 Binlog 相关的知识点。在使用 Binlog 前，首先需要确认是否开启了 Binlog，此时，我们可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;LOG_BIN&#x27;</span><br></pre></td></tr></table></figure>
<p>如果可以看到下面的结果，则表示 Binlog 功能已开启。<br><img src="https://i.loli.net/2020/07/19/IRX3DzsPkG1MgnW.png" alt="Binlog已开启示意图"><br>如果 Binlog 没有开启怎么办呢？此时，就需要我们手动来开启，为此我们需要修改 MySQL 的<code>my.conf</code>文件，通常情况下，该文件位于<code>/etc/my.cnf</code>路径，在<code>[mysqld]</code>下写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置Binlog存储目录</span></span><br><span class="line">log_bin                      =    /var/lib/mysql/bin-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置Binlog索引存储目录</span></span><br><span class="line">log_bin_index              =    /var/lib/mysql/mysql-bin.index</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除7天前的Binlog</span></span><br><span class="line">expire_logs_days          = 7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群内MySQL服务器的ID</span></span><br><span class="line">server_id                 = 0002</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置Binlog日志模式</span></span><br><span class="line">binlog_format              = ROW</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以设置下面这些选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置Binlog文件最大的大小</span></span><br><span class="line">max_binlog_size</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置当前多少个事务缓存在内存中</span></span><br><span class="line">binlog_cache_size</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置当前多少个事务暂存在磁盘上</span></span><br><span class="line">binlog_cache_disk_use</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置最大有多少个事务缓存在内存中</span></span><br><span class="line">max_binlog_cache_size</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置选取或者忽略的数据库</span></span><br><span class="line">binlog_do_db/binlog_ingore_db</span><br></pre></td></tr></table></figure>
<p>设置完以后，通过下面的命令重启 MySQL 即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p>通常，我们可以通过下面的命令来获取 Binlog 的当前状态，请注意，<strong>该命令必须要在主库上执行</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS</span><br></pre></td></tr></table></figure>
<p>此时，我们会得到下面的结果：<br><img src="https://i.loli.net/2020/07/19/Xc4B7KZltr9MjAP.png" alt="查看Binlog状态"><br>这里可以得到三个重要的信息，即从日志文件<code>mysql-bin.000388</code>的特定位置<code>135586062</code>开始，可以获得一组新的日志信息，而这些日志信息都是来自数据库实例<code>b1328d03-0b5c-11ea-8ee8-005056a1616f:1-27768340</code>。有了这三个信息以后，我们就可以去查看对应的 BinLog，此时，我们需要使用到下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW BINLOG EVENTS IN &#x27;MYSQL-BIN.000388&#x27; FROM 135586062</span><br></pre></td></tr></table></figure>
<p>此时，ROW 模式下的 Binlog 如下图所示：<br><img src="https://i.loli.net/2020/07/19/YFAb8POCyf4EM3c.png" alt="ROW模式下的Binlog"><br>可以注意到，这些 Binlog 由不同的事件构成。如果你是在 MySQL 终端下输入命令，那么，你还可以使用官方自带的工具<code>mysqlbinlog</code>，博主这里使用的开源的数据库工具<a target="_blank" rel="noopener" href="https://dbeaver.io/">DBeaver</a>，如果你经常需要和不同的数据库打交道，而又不想每一种数据库都去安装一个客户端的话，我认为这是一个非常不错的选择。关于 Binlog 的使用我们就先暂时说到这里，因为还有更重要的事情要做。</p>
<h1 id="Binlog-有什么用"><a href="#Binlog-有什么用" class="headerlink" title="Binlog 有什么用"></a>Binlog 有什么用</h1><h2 id="实现数据库审计"><a href="#实现数据库审计" class="headerlink" title="实现数据库审计"></a>实现数据库审计</h2><p>你可能觉得我明知故问，你刚刚不是说 Binlog 主要用来做主从复制和增量恢复吗？自然，这是 Binlog 在设计之初的主要用途。可我们都知道，事物有时候并不会想着我们期待的方向发展，譬如原子弹成为战争机器、社交软件成为“约炮神器”、共享单车成为“城市垃圾”等等。还记得博主曾经写过一篇关于数据库审计的[博客](<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/1289244227/%E5%90%97%EF%BC%9F%E5%BD%93%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E9%87%8D%E5%86%99%E4%BA%86">https://blog.yuanpei.me/posts/1289244227/吗？当时，我们是重写了</a> EF&#x2F;EF Core 中 DbContext 的 SaveChanges()方法，并借助 ChangeTracker 对获取实体修改前后的值。其实，从现在的角度来看，我们有更好的选择，毫无疑问，Row 模式下的 Binlog 本身就是天然的数据库审计，每一行数据变化前后的情况，我们都可以获得，并且可以区分出它是 Insert ，还是 Update，还是 Delete，所以，Binlog 的第一个用途就是可以用来做数据库审计，因为它发生在数据库层，从某种意义上来讲，消解了 EF 和 Dapper 这种 ORM 间的差异。</p>
<h2 id="实现事件驱动"><a href="#实现事件驱动" class="headerlink" title="实现事件驱动"></a>实现事件驱动</h2><p>其次，我们在实际业务中，常常需要用到”<strong>领域事件</strong>“这个概念，即使项目并没有采用<strong>领域驱动设计(DDD)<strong>的思想，即使项目中并没有采用”</strong>事件驱动</strong>“的业务模式，可事实就是，总有人关心着数据的产生和变更，而能提供给第三方系统订阅自己感兴趣的事件的能力，无疑要比开发一个又一个大同小异的同步接口要好得多，推(<strong>Push</strong>)模式在大多数情况下要比拉(<strong>Pull</strong>)模式要好，为什么呢？因为数据传输的压力更小，更能满足数据实时性的要求。然而，由于没有按照领域模型去设计业务，导致事件代码与业务代码耦合非常严重，基于 Binlog 的事件分发机制显然有更好的普适性。以博主最近处理的业务为例，A 系统中的司机、设备、用户在新建&#x2F;更新更新时，需要把新数据推送到 B 系统，因为这类纯数据类的”变化”没有实际业务意义，所以，人们不舍得为这些变化去分发事件，而要想分发事件，又不得不去面对强耦合带来的阵痛，所以，Binlog 的第二个用途是可以作为事件源来实现事件驱动。</p>
<h1 id="业内主流方案"><a href="#业内主流方案" class="headerlink" title="业内主流方案"></a>业内主流方案</h1><p>如果你觉得通过第一节的内容，可以非常容易地实现 Binlog 的解析，那么，我觉得你并没有想清楚 Binlog 处理过程中的难点在哪里？首先，每次读取 Binlog，必须要知道对应的日志文件和位置，而如果在新的 Binlog 产生前，没有处理完原来的 Binlog，就必须要记录对应的日志文件和位置，而且经过博主本人测试，Binlog 无法直接给查询语句追加过滤条件，来达到筛选某些数据库、表以及事件的目的，而且日志文件的格式会因为模式的不同而不同，最主要的一点是，直接在主库上读取 Binlog 会给数据库带来访问压力，所以，主流的方案，是让客户端伪装成“从库”，关于一点，我们可以配合下面的图片来理解。<br><img src="https://i.loli.net/2020/07/20/N8A24sEK1RnjBdv.png" alt="MySQL主从复制原理"><br>可以注意到，完成主从复制需要一个 Relaylog + 两个线程，即，主库产生的 Binlog，首先由从库的 I&#x2F;O 线程进行读取，这一步会产生 Relaylog，顾名思义，这是一个处在中间状态的中继日志，而中继日志最终会交由从库的 SQL 线程来处理，所以，这是从库执行 SQL 语句的阶段，整个过程是异步化的操作，所以，不会对主库产生太大的压力。如果我们直接读取主库的 Binlog，实际上是把所有压力都转移到主库，不仅需要负责“读”，还需要复杂“写”。主流的方案，目前比较推荐的是阿里的<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal</a>、Zendesk 的<a target="_blank" rel="noopener" href="http://maxwells-daemon.io/">Maxwell</a>、以及来自社区的<a target="_blank" rel="noopener" href="https://github.com/noplay/python-mysql-replication">Python-Mysql-Replication</a>，下面是一个简单的对比，方便大家做技术选型。</p>
<table>
<thead>
<tr>
<th></th>
<th>Cancal</th>
<th>Maxwell</th>
<th>Python-Mysql-Rplication</th>
</tr>
</thead>
<tbody><tr>
<td>开源方</td>
<td>阿里巴巴</td>
<td>Zendesk</td>
<td>社区</td>
</tr>
<tr>
<td>开发语言</td>
<td>Java</td>
<td>Java</td>
<td>Python</td>
</tr>
<tr>
<td>活跃度</td>
<td>活跃</td>
<td>活跃</td>
<td>活跃</td>
</tr>
<tr>
<td>高可用</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>客户端</td>
<td>Java&#x2F;Go&#x2F;PHP&#x2F;Python&#x2F;Rust</td>
<td>无</td>
<td>Python</td>
</tr>
<tr>
<td>消息落地</td>
<td>Kafka&#x2F;RocketMQ 等</td>
<td>Kafka&#x2F;RabbitNQ&#x2F;Redis 等</td>
<td>自定义</td>
</tr>
<tr>
<td>消息格式</td>
<td>自定义</td>
<td>JSON</td>
<td>自定义</td>
</tr>
<tr>
<td>文档详略</td>
<td>详细</td>
<td>详细</td>
<td>详细</td>
</tr>
<tr>
<td>Boostrap</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h1 id="说说我的构想"><a href="#说说我的构想" class="headerlink" title="说说我的构想"></a>说说我的构想</h1><p>众所知周，我是一个有一点“懒惰”的人，考虑到前面两种方案都比较重，即使通过 Docker 来安装。对我来说，这是一个验证想法的过程，所以，我选择的搭配是 RabbitMQ + .NET Core + Python 的方案，因为 Kafka 需要 ZooKeeper，而在验证想法的阶段，自然是越简单越好。我正打算参考微软的 eShopOnContainers 的项目， 实现一个消息总线(EventBus)，恰好这个项目中使用了 RabbitMQ，而且从某种意义上来说，RabbitMQ 更接近传统意义上的消息队列，它提供的重试、确认、死信等这些机制都比较完善，可以让我把精力集中在快速实现上，毕竟你看到这些博客，都是我挤出时间来完成的。选择 Python 就更直接了，因为安装、运行都非常容易，或许 Kafka 的吞吐性能更好，但我觉得掌握核心思想才是最重要的吧！</p>
<p>总而言之，在这里，我选择了自己最熟悉的技术栈。整体思路是，首先，.NET Core + RabbitMQ 实现一个消息总线，并对外提供发布事件的 API 接口。其次，利用 Python-Mysql-Replication 实现一个读取 Binlog 的后台程序，这些 Binlog 最终会以 JSON 的形式发布到 RabbitMQ 上。最后，实现针对特定事件的 IEventHandler<TEvent>接口，消息总线会自动调用这些 Handler 去处理消息。至此，就实现了针对 Binlog 的订阅和消费。众所周知，消息总线的一大优点就是解耦，我们就可以摆脱以往定时轮询 + 打标记(Flag)的宿命轮回，只需要编写对应的 Handler 即可，其实我觉得这是一种思维上的转变，就是”主动”到”被动”的转变，并不是说我们帮客户做得越多越好，而是我们能让客户意识到它可以做哪些事情。同样的，我绘制了一个简单的流程图来作为说明：<br><img src="https://i.loli.net/2020/07/22/5irw4tcNnapVRbD.png" alt="基于RabbitMQ的EventBus实现"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，重复的工作做久了都会感到厌烦的，所以，真正让你摆脱“体力劳动”的只能是换一种高度来看问题。这几年做 2B 业务下来，最大的体会是企业级软件最难的是，如何在各种种类繁多的软件，譬如 OA 、金蝶、用友、SAP 、ERP 、CRM 等中做好一个“配角”，数据如果无法在这张网络中流通，则永远都是一潭死水，而如果要打通各个系统间的数据，则免不了写一个又一个的同步接口。这篇博客以 MySQL 的 Binlog 为切入点，试图通过 Binlog 来实现特定业务的“事件驱动”。Binlog 是实现主从复制的重要机制，而基于这一机制，业界普遍的做法是利用 MySQL 的交换协议，让客户端”伪装”成一个从库，在比较了 Canal 、Maxwell 以及 Python-Mysql-Replication 后，博主选择了. NET Core  + RabbitMQ + Python 的方案，目标是让 Binlog 可以发布到消息总线(EventBus)中供消费者订阅和消费。在下一篇博客中，我们讲介绍基于 RabbitMQ 实现一个消息总线(EventBus)的相关细节，欢迎大家继续关注我的博客，今天这篇博客就先写到这里，大家晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/07/05/2020-07-05-hardware-war-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/2020-07-05-hardware-war-book/" itemprop="url">硬件创新的故事与逻辑 - 读《硬战》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-05T10:12:46+08:00">
                2020-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <img src="/images/hardware-book.jpg" class="">

<p>刚刚看完一本智能硬件的书《硬战》，作者曾经就职于大疆，UBTECH 和 IBM。这本书主要讲的是硬件行业的竞争案例，读起来相对轻松，以下是我的一些感受。</p>
<h2 id="硬件产品的特点"><a href="#硬件产品的特点" class="headerlink" title="硬件产品的特点"></a>硬件产品的特点</h2><p>硬件产品和软件产品有几个很大的区别：</p>
<ul>
<li>【研发周期】。硬件产品研发周期长，拿儿童类的玩教具来说，新品研发通常得 6 - 8 个月。而软件的研发周期通常也就 3 个月以内。</li>
<li>【迭代周期】。硬件产品涉及开模，一个模具通常可以使用 50 万次，前期投入巨大。所以硬件的迭代通常不能很快，即便你上线就立即迭代，因为涉及开模，也得需要至少 3 个月左右。而软件的迭代都是以周为单位，快手就每周发布一个版本。</li>
<li>【管理难度】。硬件产品通常需要依赖方案商和组装厂。这些乙方的配合度是非常关键的。锤子手机当年量产难，一部分原因就是自己的订单量不够大，组装厂没有全力配合。而软件的研发通常不涉及外部合作，所以管理难度会小很多。</li>
<li>【资金投入】。硬件产品的研发周期很长，资金投入大，这就使得行业内普遍不愿意创新。因为你创新的时间和金钱成本都太高。亚马逊做 Echo 音箱做了几代才做好，微软做 Surface 失败了一代继续做下一代，这都需要巨大的决策成本。软件的创新通常只需要两三个人就可以做 MVP 了，投入就只有几个人的工资。</li>
<li>【体验难度】。硬件因为是实体，所以它的售卖需要拿到手里看才能很好地体验。这使得大部分硬件是通过经销商卖出去的，因为经销商有线下的渠道可以让用户体验。软件可不一样，软件你在手机上几乎就可以体验到完整的服务了。</li>
</ul>
<p>以下是整理的表格：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>硬件</th>
<th>软件</th>
</tr>
</thead>
<tbody><tr>
<td>研发周期</td>
<td>长。6-8 个月</td>
<td>长。3个月</td>
</tr>
<tr>
<td>迭代周期</td>
<td>长。3-6 个月</td>
<td>短。1-2周</td>
</tr>
<tr>
<td>管理难度</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>创新难度</td>
<td>高。时间和金钱成本高。</td>
<td>低。可以做 MVP。</td>
</tr>
<tr>
<td>体验难度</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>相对来说，因为时间长资金投入大，硬件如果积累起规模效应和时间窗口，也能积累起足够的壁垒。</p>
<h2 id="硬件的获客"><a href="#硬件的获客" class="headerlink" title="硬件的获客"></a>硬件的获客</h2><p>软件的获客大多是通过线上的方式。</p>
<p>硬件的获客方式其实分为线上和线下两种。线下获客是大部分硬件主流的方式，即走渠道商，通过渠道来获客。但是商品需要给渠道商留够利润。线下获客也可以是像苹果这样的直营店，但是通常只有品牌大到一定程度才可以。</p>
<p>硬件的线上获客最多的，就是通过电商平台了。这个时候，因为用户无法亲手拿到硬件体验，所以文案的能力以及 PS 的能力就变得重要了，价格也变得很重要。淘宝上卖得好的商品，都是质量一般，文案做得好，图拍得好，价格也吸引人的商品。</p>
<p>直播卖货是现在比较火的线上销售模式。相对来说，这种模式是能鼓励大家做优质商品的，因为带货的大 V 需要将商品品质与自己的人设搭配，质量一般的商品反倒不那么受欢迎。大 V 最欢迎的是那些品牌力最好的，价格相对公道即可。</p>
<p>小米当年的获客，算是一个独特的存在。小米核心是靠产品的性价比，通过性价比来获得口碑传播，通过传播来获客，这背后是当时安卓手机给市场留下的 2000 元以内的空间。但是这种方式一方面不太可复制，另一方面增长也会有问题，所以小米现在的获客和华为，Oppo，Vivo 没有太大的差别。小米无疑是成功的，但是小米上市后股价一路下跌，未来的估值到底是多少，还要再看一段时间。</p>
<h2 id="智能硬件落地难"><a href="#智能硬件落地难" class="headerlink" title="智能硬件落地难"></a>智能硬件落地难</h2><p>互联网成就了 BAT，移动互联网成就了美团点评、滴滴、拼多多。那么利用创新能否颠覆硬件行业，成为每一个创业者的梦想，而这里面的技术变化就是：AI。</p>
<p>但是，智能硬件从概念到落地，从来都不像软件那么容易。如果我们看这些年智能硬件的创新，从智能路由器到智能音箱，从陪伴机器人到智能家电（台灯、门锁、摄像头），从智能穿戴设备（耳机、手环、VR&#x2F;AR眼镜、运动相机）到无人机，竞争可以用惨烈来形容，但是真正的赢家却没有几个。</p>
<h2 id="从智能路由器到智能音箱"><a href="#从智能路由器到智能音箱" class="headerlink" title="从智能路由器到智能音箱"></a>从智能路由器到智能音箱</h2><p>智能路由器作为网络带宽的出入口，本来想成为家庭的控制中心，但是最后人们发现，其实这个角色应该是智能音箱。</p>
<p>智能音箱这个设备本身的技术难度又不高，语音识别既可以自己实现，也可以用迅飞的 API。于是，这个生意注定是有布局意识，经受得住亏损补贴的大厂。</p>
<p>经过小爱同学、小度在家、天猫精灵几家补贴式的竞争，最后小的玩家全部被挤出去了。</p>
<p>而就算这样，智能音箱在国内的应用场景也不算高，只能拿来听听新闻和音乐。家庭的各个设备还需要几年的时间才能够一一连上网并且开放给音箱。</p>
<p>我家的小度在家和天猫精灵，基本上都是用来听歌和听故事。小度在家我另外配了一个红外遥控器，可以遥控电视开关。开关窗帘？我太懒了，还没有勤快到专门为了这个更换窗帘的导轨。</p>
<h2 id="陪伴机器人到智能家电"><a href="#陪伴机器人到智能家电" class="headerlink" title="陪伴机器人到智能家电"></a>陪伴机器人到智能家电</h2><p>AI 机器人从傅盛成立<a target="_blank" rel="noopener" href="https://www.ainirobot.com/">猎户星空</a>的时候就被媒体和行业密切关注，从 2014 年开始持续火爆到 2017 年。</p>
<img src="/images/hardware-robot.jpg" class="">

<p>后来人们发现，机器人的能力其实可以拆解成：</p>
<ul>
<li>移动&#x2F;搬运</li>
<li>对话</li>
<li>带屏</li>
</ul>
<p>在 C 端场景下，除了扫地机器人，没有哪个家庭需要一个没事跑来跑去的可以对话&#x2F;带屏的机器，如果这个机器不跑来跑去，那么它其实应该是个智能音箱。</p>
<p>在户外场景下，商场可能需要一个移动的引导机器人？但是我发现更多人对它只是好奇，好看大于实用。因为你又不能真正的给别人带路，无非还就是提供屏幕查询操作。</p>
<p>餐馆方面，送餐机器人可能是一个有用的场景，因为餐馆有移动送餐的需求。但是就算在海底捞，我发现这个机器人使用起来也有诸多限制，更多只是一种尝试。</p>
<img src="/images/hardware-haidilao.jpg" class="">

<p>在教育场景下，很多人把智能音箱变个机器人的人形外观，就当作教育机器人来卖，说什么情感陪伴，智能对话。要打破这个谎言，只需要问机器人两句话就可以：</p>
<ul>
<li>第一句：“望京在哪儿？”</li>
<li>第二句：“怎么过去？”</li>
</ul>
<p>还没有机器人能搞定上下文这种对于 3 岁小孩来说都是基础的对话要求。</p>
<p>智能家电提供的能力也谈不上颠覆，大部分时候就是提供蓝牙和 Wifi 的连接，然后提供一些 App 或接口可以远程控制它。我把我家的冰箱连上网之后就后悔了，因为我完全没兴趣远程调它的温度，还额外占用我的一个路由器的连接数。后来换洗衣机的时候我就学聪明了，都没有尝试联网过。</p>
<p>或许把空调连上智能音箱之后，用语音开关空调和调温度是一个需求。不过我的小度红外遥控器离空调太远，遥控器的学习功能也有问题。为了空调专门再买一个红外遥控器，并且放到离空调近的地方还是太麻烦了。所以只能等换空调的时候，买一个可以连接音箱的空调了。</p>
<h2 id="智能穿戴设备"><a href="#智能穿戴设备" class="headerlink" title="智能穿戴设备"></a>智能穿戴设备</h2><p>大家对穿戴设备兴趣特别高，但最终落地的，现在只有手环。我自己买了第二代的 Apple Watch，Fitbit Force，小米和华为的各种手环，现在用的是华为的手环，只是因为它在游泳的时候计圈相对准一点点。</p>
<p>大部分时候，我只是用手环来看时间和设置定时器。如果只是这些的话，随便哪家的手环都可以用。</p>
<p>NFC 支付功能在手机上其实使用起来更方便，因为你可能忘带手环，但是你绝不会忘带手机。不然你连各种楼都进不去（因为要出示健康宝）。</p>
<p>当前手环的价格也很难说有很大的利润，最终的玩家估计也就只有手机厂家了。把手环作为手机的生态硬件中的一环，以达成更好的体验。我的华为手环还有一个重要功能就是“找手机”，基本上每两天就要用一次。</p>
<h2 id="无人机"><a href="#无人机" class="headerlink" title="无人机"></a>无人机</h2><p>无人机是一个非常值得聊的话题。我们刚刚看到的少有的几个成功的硬件产品：智能音箱、手环都是被大厂抢了生意。放在无人机领域，当然大疆的竞争者并不少。一方面是国内的小米等大厂，另一方面是国外像 GoPro 这种在相机领域拥有优势的公司。最终大疆是如何胜出的呢？</p>
<p>刚刚我们提到，像智能音箱、手环相对核心竞争力不强，在当时的技术下，大家的技术壁垒都不高，在能力相似的情况下，最终赢家是靠价格和补贴完成了竞争。</p>
<p>无人机之所以不一样，我们可以看到 2016 年左右 GoPro 和大疆直接竞争的时候，他们同质化的产品是 GoPro Karma 和 Mavic Pro，最后因为前者出现了极大的质量问题，全部召回。由于技术优势，市场给了大疆完全空白的竞争期。在这段时期，大疆又持续地研发低成本的无人机，将 Mavic 系列的体积和价格越做越低。大疆甚至还成立了一家子公司做了一个 799 的 Tello 无人机。</p>
<p>在我看来，大疆的无人机在技术上的壁垒已经领先同行 2 年左右，同时无人机的研发投入并不低，加上这并不是一个巨大的消费者市场（相对手机、手环、音箱、汽车来说），别的硬件厂商未必愿意投入那么长的时间和钱来追赶，于是大疆就成功了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>硬件产品相对于软件产品，在研发周期、迭代周期、管理难度、资金投入、体验难度都要难一些。</li>
<li>智能硬件大多是伪需求。智能音箱当前成为家庭接入的桥梁，但生态还未完善。</li>
<li>像大疆这样，硬件产品如果能够积累足够的技术壁垒，那么可以成功。</li>
<li>像手环、音箱这样，硬件产品和同行没有足够的差异性，那么就是资源竞争，看谁的资金和补贴能力强，背后是集团产品的战略协同目标。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/06/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%8E%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84Git%E4%BB%93%E5%BA%93%E4%B8%AD%E6%89%BE%E5%9B%9E%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%8E%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84Git%E4%BB%93%E5%BA%93%E4%B8%AD%E6%89%BE%E5%9B%9E%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/" itemprop="url">记一次从已损坏的 Git 仓库中找回代码的经历</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-23T17:08:17+08:00">
                2020-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>突然发觉，古人其实特别有趣，譬如有古语云：『常在河边走，哪有不湿鞋』，实在是富有生活气息的一句俗语，可古人又有言语：『光脚的不怕穿鞋的』，更是朴实无华的一句话。上周下班适逢天降大雨，我撑伞送一位同事到地铁站，结果走到半路人家来一句，“你快点走吧，我穿着凉鞋”，一时竟无语凝噎。常在河边走，固然会有湿鞋的顾虑，可真正的气度绝不是光着脚满地跑，如何做到湿了鞋子而不慌呢？答案是脚上无凉鞋而心中有凉鞋。今天，我将为大家我在使用<code>Git</code>过程中如何“湿鞋”、如何不怕“湿鞋”的一个故事(逃</p>
<h1 id="蓝屏重启后-Git-居然坏了"><a href="#蓝屏重启后-Git-居然坏了" class="headerlink" title="蓝屏重启后 Git 居然坏了"></a>蓝屏重启后 Git 居然坏了</h1><p>中国传统小说喜欢从神话讲起，端的是汪洋恣肆、纵横捭阖。而国外小说则喜欢从一片常青藤叶这种不显眼的事物写起，足可见二者见天地众生视角之不同。而我这个故事，是再普通不过的一次蓝屏。重启后 Visual Studio 提示恢复了未保存的代码，此时，我并未注意到 Git 仓库损坏的情况，就这样，我在一个“游离态”的版本上编写代码，直到我打开 SourceTree 的时候(作者注：<strong>我就是那个命令行和 GUI 混合使用的奇葩</strong>)，发现左侧本地分支全部消失，在命令行里<code>git status</code>，发现根本没有这个分支，而<code>.git/refs/</code>对应分支指向了一个错误的 Hash，我意识到我的 Git 仓库文件可能损坏了，这意味着我写的新 feature 可能丢失了，此时，Git 中提示的类似的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ error: refs/remotes/origin/HEAD: invalid sha1 pointer 0000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>
<p>在此之前，其实博主已经经历过类似的事情，在没有未提交的代码的情况下，其实可以暴力删除<code>. git</code>目录，然后在<code>git init</code>即可，这相当于重新初始化仓库啦，在这种情况下，本地的分支会被删掉，你需要重新建新分支。可是这次不一样啊，在做的是一个即将发版的新 feature，不允许我出这样的选择啊！博主双掌合一，像夏洛克一样冷静思考，缓缓地在命令行下敲出<code>git reflog</code>，这条命令相当于你在 Git 中的监控日志，你对 Git 所做的一切都会成为呈堂证供。此时，你会得到下面的信息——沉默是今晚的康桥……</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fatal: You are on a branch yet to be born</span><br></pre></td></tr></table></figure>
<p>这是什么意思呢？意思就是这个分支还是一个“新生儿“的状态，新生儿怎么可能又活动记录呢？所以，使用 Git 的准则之一，只要仓库没有坏，通过<code>git reflog</code>找到对应的 Hash ，<code>git checkout</code>就可以找回代码，哪怕你刚刚手滑删除了一个未提交的分支，这种情况下都可以找回来。But 现在这种状况下，这条路显然是走不通啦。继续双掌合一，像夏洛克一样冷静思考，每个分支里其实是记录着一个 hash ，对应着最后的一次提交，现在是这个 hash 不对，那就要找到正确的 hash 啊。命令行已经非常明确地告诉你，是因为某些 object 丢失或者损坏了，那不妨先用<code>git fsck</code>试试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck</span><br><span class="line">notice: HEAD points to an unborn branch (master)</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (589/589), <span class="keyword">done</span>.</span><br><span class="line">error: refs/remotes/origin/HEAD: invalid sha1 pointer 0000000000000000000000000000000000000000</span><br><span class="line">notice: No default references</span><br><span class="line">dangling tag 92d0fe18f9a55177d955edf58048b49db7987d5b</span><br><span class="line">dangling commit aa7856977e80d11833e97b4151f400a516316179</span><br><span class="line">dangling commit 16e449da82ec8bb51aed56c0c4c05473442db90a</span><br><span class="line">dangling commit 864c345397fcb3bdb902402e17148e19b3f263a8</span><br><span class="line">dangling tag be9471e1263a78fd765d4c72925c0425c90d3d64</span><br></pre></td></tr></table></figure>
<p>此时，我们就会得到这样的信息。我天，这简直太良心了好吧，连哪一个 object 丢了都明明白白地告诉你。既然是提示解包(unpack)的时候失败，不妨先手动解包看看呗，好吧，果然程序是不会欺骗人的。这个时候，我注意到这些里面有一些提交(commit)，我在想这些有没有可能是残留的有效分支，于是使用下面的命令创建临时分支，一番折腾发现这些分支都离我的分支比较远，所以，基本可以排除了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//尝试手动解包</span><br><span class="line">$ <span class="built_in">mv</span> .git/objects/pack/pack-0672bd01813664b80248dbe8330bf52da9c02b9f.pack .</span><br><span class="line">$ git unpack-objects -r &lt; pack-0672bd01813664b80248dbe8330bf52da9c02b9f.pack</span><br><span class="line">//从某个commit新建临时分支</span><br><span class="line">$ git update-ref refs/heads/recovery-1 aa7856977e80d11833e97b4151f400a516316179</span><br></pre></td></tr></table></figure>
<p>我又不甘心地看了看<code>git fsck</code>命令，发现它居然有一个<code>--lost-found</code>的参数可以用，这样子，我居然就得到一个名为<code>lost-found</code>的文件夹，它里面有一些以 hash 命名的文件，我挑选了一个离我蓝屏时间最近的文件，直接<code>git checkout</code>过去，发现这正是我需要的内容，赶紧<code>git checkout –b</code>存档，这实在是太珍贵了！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/67/781ba4991aee01c0bc0d640ae9ee8b674b2f47</span><br><span class="line">error: 67781ba4991aee01c0bc0d640ae9ee8b674b2f47: object corrupt or missing: .git/objects/67/781ba4991aee01c0bc0d640ae9ee8b674b2f47</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/6f/34f2bbde304619622f77f9ca159ed97b6ddafd</span><br><span class="line">error: 6f34f2bbde304619622f77f9ca159ed97b6ddafd: object corrupt or missing: .git/objects/6f/34f2bbde304619622f77f9ca159ed97b6ddafd</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/89/6e969a25c2238ebbb41e895753e82da1cdc7af</span><br><span class="line">error: 896e969a25c2238ebbb41e895753e82da1cdc7af: object corrupt or missing: .git/objects/89/6e969a25c2238ebbb41e895753e82da1cdc7af</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/d8/a180969f6cf8047def4b50c7c920dcd2b6f5cd</span><br><span class="line">error: d8a180969f6cf8047def4b50c7c920dcd2b6f5cd: object corrupt or missing: .git/objects/d8/a180969f6cf8047def4b50c7c920dcd2b6f5cd</span><br></pre></td></tr></table></figure>
<p>其实，接触 Git 的这些年里，使用命令行并没有让我觉得 Git 难以接近，相反它让我对 GUI 理解更深一点，就像好多人分不清<code>pull</code>和<code>fetch</code>，因为你不看命令行的输出啊；有好多人每次 SourceTree 一报错就不知道该怎么办 ，其实 Git 给的提示真的相当清晰了；我之前一直不知道什么叫<code>cherry-pick</code>，后来发现这玩意儿就是我们所说的“补丁”。平时这种问题可能就放过去了，可这次“扶大厦于将顷”，让代码失而复得的经历，的确令人难忘，所以，我更想把它写下来，当你都能真正驾驭它了，是用命令行还是用 GUI 就真的不在重要啦！这次的一个例外是索引没有坏，如果索引坏了，可以试试下面的命令：<code>git reset --mixed</code>。我还是坚持一个观点，<strong>Git 仓库坏了，能修复尽量去修复，不到万不得已，千万不要去删<code>. git</code>目录</strong>。</p>
<h1 id="各种场景下的-Git-恢复-撤销"><a href="#各种场景下的-Git-恢复-撤销" class="headerlink" title="各种场景下的 Git 恢复&#x2F;撤销"></a>各种场景下的 Git 恢复&#x2F;撤销</h1><p>在这篇文章刚开始的时候，我问大家，如何做到湿了鞋子而不慌呢？答案是脚上无凉鞋而心中有凉鞋。虽然 Git 本身是一款非常复杂的软件，可我们依然有很多的策略去应对各种“失误”，正如这篇文章 <a target="_blank" rel="noopener" href="https://git.seveas.net/undoing-all-kinds-of-mistakes.html#undoing-all-kinds-of-mistakes">Undoing all kinds of mistakes</a> 所言，Git 深知人类都是不完美的，面对平时使用 Git 过程中的各种失误，我们可以尝试使用下面的思路来解决。</p>
<h2 id="更改未提交到暂存区"><a href="#更改未提交到暂存区" class="headerlink" title="更改未提交到暂存区"></a>更改未提交到暂存区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//放弃所有文件的更改</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard</span></span><br><span class="line">//放弃指定文件的更新</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- &lt;path/to/file&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="更改已提交到暂存区"><a href="#更改已提交到暂存区" class="headerlink" title="更改已提交到暂存区"></a>更改已提交到暂存区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//回到最近的一次提交(改变指针)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br><span class="line">//回到某一次提交(改变指针)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard &lt;commitId&gt;</span></span><br><span class="line">//全部放弃=回到最近的一次提交(改变指针)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard 全部放弃</span></span><br><span class="line">//放弃提交指定文件</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD &lt;path/to/file&gt;</span></span><br><span class="line">//修改提交信息</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>

<h2 id="更改已推送到远程服务器"><a href="#更改已推送到远程服务器" class="headerlink" title="更改已推送到远程服务器"></a>更改已推送到远程服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//撤销前一次提交(产生新的提交)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert HEAD</span> </span><br><span class="line">//撤销前前一次提交(产生新的提交) </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert HEAD^</span></span><br><span class="line">//撤销某一个提交(产生新的提交)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert commit</span>  </span><br></pre></td></tr></table></figure>

<h2 id="万能公式"><a href="#万能公式" class="headerlink" title="万能公式"></a>万能公式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//万能公式</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout &lt;commitId&gt;</span></span><br><span class="line">//退而求其次</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fsck --lost-found</span></span><br></pre></td></tr></table></figure>

<p>除了 SourceTree，我想安利第二个 Git GUI 工具：<a target="_blank" rel="noopener" href="https://git-fork.com/">Fork</a>，大家感兴趣的话可以安装试用。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://git.seveas.net/repairing-and-recovering-broken-git-repositories.html">Repairing and recovering broken git repositories</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72091550?utm_source=cn.wiz.note&utm_medium=social&utm_oi=53182268964864">Git 撤销&amp;回滚操作</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.psjay.com/posts/git-revert-merge-commit/">Git 撤销合并</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9059335/get-parents-of-a-merge-commit-in-git">How to get the parents of a merge commit in git?</a></li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/06/20/NET-Core%E5%8E%9F%E7%94%9FDI%E6%89%A9%E5%B1%95%E4%B9%8B%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/NET-Core%E5%8E%9F%E7%94%9FDI%E6%89%A9%E5%B1%95%E4%B9%8B%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/" itemprop="url">.NET Core 原生 DI 扩展之属性注入实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-20T13:10:31+08:00">
                2020-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>在上一篇博客里，我们为<code>.NET Core</code>原生 DI 扩展了基于名称的注入功能。而今天，我们要来聊一聊属性注入。关于属性注入，历来争议不断，支持派认为，构造函数注入会让构造函数变得冗余，其立意点主要在代码的可读性。而反对派则认为，属性注入会让组件间的依赖关系变得模糊，其立意点主要在代码是否利于测试。我认识的一位前辈更是留下一句话：<strong>只要构造函数中超过 5 个以上的参数，我就觉得无法忍受</strong>。我个人是支持派，因为我写这篇博客的动机，正是一位朋友向我吐槽公司项目，说一个控制器里单单是构造函数里的参数就有十来个。在这其中最大的痛点是，有些在构造函数中注入的类型其实是重复的，譬如<code>ILogger&lt;&gt;</code>、<code>IMapper</code>、<code>IRepository&lt;&gt;</code>以及用户上下文信息等，虽然继承可以让痛苦减轻一点，可随之而来的就是冗长的 base 调用链。博主参与的项目里不乏有大量使用静态类、静态方法的，譬如 LogEx、UserContext 等等，可这种实践显然与依赖注入的思想背道而驰，为吾所不取也，这就是这篇博客产生的背景啦！</p>
<p>好了，当视角正式切入属性注入的时候，我们不妨先来考虑这样一件事情，即：当我们从容器里 Resolve 一个特定的类型的时候，这个实例到底是怎么被创建出来的呢？这个问题如果给到三年前的我，我会不假思索的说出两个字——反射。的确，这是最简单的一种实现方式，换句话说，首先，容器收集构造函数中的类型信息，并根据这些类型信息 Resolve 对应的实例；其次，这些实例最终会被放到一个<code>object[]</code>里，并作为参数传递给<code>Activator.CreateInstance()</code>方法。这是一个一般意义上的 Ioc 容器的工作机制。那么，相对应地，关于属性注入，我们可以认为容器 Reslove 一个特定类型的时候，这个类型提供了一个空的构造函数(<strong>这一点非常重要</strong>)，再创建完实例以后，再去 Reslove 这个类型中的字段或者是属性。所以，为了在微软自带的 DI 上实现属性注入，我们就必须实现自己的 ServiceProvider——AutowiredServiceProvider，这个 ServiceProvider 相比默认的 ServiceProvider 多了一部分功能，即反射属性或者字段的过程。一旦想通这一点，我们可以考虑装饰器模式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutowiredServiceProvider</span> : <span class="title">IServiceProvider</span>, <span class="title">ISupportRequiredService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _serviceProvider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutowiredServiceProvider</span> (<span class="params">IServiceProvider serviceProvider</span>)</span> &#123;</span><br><span class="line">        _serviceProvider = serviceProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetRequiredService</span> (<span class="params">Type serviceType</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GetService (serviceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetService</span> (<span class="params">Type serviceType</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> instance = _serviceProvider.GetService (serviceType);</span><br><span class="line">        Autowried (instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Autowried</span> (<span class="params"><span class="built_in">object</span> instance</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_serviceProvider == <span class="literal">null</span> || instance == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> flags = BindingFlags.Public | BindingFlags.NonPublic;</span><br><span class="line">        <span class="keyword">var</span> type = instance <span class="keyword">as</span> Type ?? instance.GetType ();</span><br><span class="line">        <span class="keyword">if</span> (instance <span class="keyword">is</span> Type) &#123;</span><br><span class="line">            instance = <span class="literal">null</span>;</span><br><span class="line">            flags |= BindingFlags.Static;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flags |= BindingFlags.Instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Feild</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> field <span class="keyword">in</span> type.GetFields (flags)) &#123;</span><br><span class="line">        <span class="keyword">var</span> autowriedAttr = field.GetCustomAttribute&lt;AutowiredAttribute&gt; ();</span><br><span class="line">            <span class="keyword">if</span> (autowriedAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> dependency = GetService (field.FieldType);</span><br><span class="line">                <span class="keyword">if</span> (dependency != <span class="literal">null</span>)</span><br><span class="line">                    field.SetValue (instance, dependency);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Property</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> property <span class="keyword">in</span> type.GetProperties (flags)) &#123;</span><br><span class="line">            <span class="keyword">var</span> autowriedAttr = property.GetCustomAttribute&lt;AutowiredAttribute&gt; ();</span><br><span class="line">            <span class="keyword">if</span> (autowriedAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> dependency = GetService (property.PropertyType);</span><br><span class="line">                <span class="keyword">if</span> (dependency != <span class="literal">null</span>)</span><br><span class="line">                    property.SetValue (instance, dependency);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰器模式，又被称之为“静态代理”，是面向切面编程(<strong>AOP</strong>)的实现方式之一，我们在这里为默认的 ServiceProvider 增加了<code>Autowired()</code>方法，它会扫描所有含<code>[Autowired]</code>标签的字段或属性，并尝试从容器中获取对应类型的实例。所以，这又说到了反对属性注入第二个理由，即：使用反射带来的性能问题，尤其是当依赖项间的引用关系异常复杂的时候。当然，所谓“兵来将挡，水来土掩”，反射产生性能损失，可以考虑用 Emit 或者表达书树作来替代反射，不过，微软貌似在.NET Core 中阉割了一部分 Emit 的 API，这些都是 Todo 啦你懂就好，我们继续往下说。接下来，为了替换掉微软默认的 ServiceProvider，我们还必须实现自己的 ServiceProviderFactory，像 Autofac、Unity、Castle 等容器，都是采用类似的做法来支持.NET Core。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutowiredServiceProviderFactory</span> : <span class="title">IServiceProviderFactory</span>&lt;<span class="title">IServiceCollection</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IServiceProvider <span class="title">CreateServiceProvider</span> (<span class="params">IServiceCollection containerBuilder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceProvider = containerBuilder.BuildServiceProvider ();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutowiredServiceProvider (serviceProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IServiceCollection IServiceProviderFactory&lt;IServiceCollection&gt;.CreateBuilder (IServiceCollection services) &#123;</span><br><span class="line">        <span class="keyword">if</span> (services == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ServiceCollection ();</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们是以微软内置的 DI 为基础来进行扩展的，所以，在实现<code>AutowiredServiceProviderFactory</code>的时候，提供的泛型参数依然是<code>IServiceCollection</code>。它需要实现两个方法：<code>CreateBuilder</code>和<code>CreateServiceProvider</code>，在这里我们需要返回我们“装饰”过的 ServiceProvider。接下来，万事俱备，只欠东风，我们需要在项目入口(<strong>Program.cs</strong>)调用<code>UseServiceProviderFactory()</code>方法，如果你在.NET Core 使用 Autofac，应该会对此感到亲切：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">  Host.CreateDefaultBuilder(args)</span><br><span class="line">    .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">    &#125;)</span><br><span class="line">    .UseServiceProviderFactory(<span class="keyword">new</span> AutowiredServiceProviderFactory());</span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了对微软默认的 ServiceProvider 的替换。假设我们有两个接口：<code>IFooService</code>和<code>IBarService</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IFooService &amp;&amp; FooService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFooService</span> &#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">Foo</span> ()</span>;</span><br><span class="line">  IBarService Bar &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooService</span> : <span class="title">IFooService</span> &#123;</span><br><span class="line">  [<span class="meta">Autowired</span>]</span><br><span class="line">  <span class="keyword">public</span> IBarService Bar &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Foo</span> ()</span> =&gt; <span class="string">&quot;I am Foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IBarService &amp;&amp; BarService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBarService</span> &#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">Bar</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BarService</span> : <span class="title">IBarService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Bar</span> ()</span> =&gt; <span class="string">&quot;I am Bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>FooService</code>依赖<code>IBarService</code>，而我们只需要给<code>Bar</code>加上<code>[Autowired]</code>标签即可，风格上借鉴了<code>Spring</code>的<code>@Autowired</code>。只要这两个接口被注入到 Ioc 容器中，这个属性就可以自动获得相应的服务实例。一起来看下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;IFooService,FooService&gt;();</span><br><span class="line">services.AddTransient&lt;IBarService, BarService&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceProvider = <span class="keyword">new</span> AutowiredServiceProvider(services.BuildServiceProvider());</span><br><span class="line"><span class="keyword">var</span> fooService = serviceProvier.GetRequiredService&lt;IFooService&gt;();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;fooService.Foo()&#125;</span> , <span class="subst">&#123;fooService.Bar.Bar()&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>回到我们一开始遇到的那个问题，如果我们让<code>IFooService</code>变成 Controller 中的一个属性，是否就能解决构造函数参数冗余的问题了呢？下面是一段简单的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">Autowired</span>]</span><br><span class="line">  <span class="keyword">public</span> IFooService Foo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Autowired</span>]</span><br><span class="line">  <span class="keyword">public</span> ILogger&lt;WeatherForecastController&gt; Logger &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">HttpGet</span>]</span><br><span class="line">  [<span class="meta">Route(<span class="string">&quot;Autowired&quot;</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetAutowriedService</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> Content(<span class="string">$&quot;<span class="subst">&#123;Foo.Foo()&#125;</span> , <span class="subst">&#123;Foo.Bar.Bar()&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们会发现<code>Foo</code>属性提示空引用错误，这是为什么呢？这是因为 Controller 并不是通过 IoC 容器来负责创建和销毁的，为了实现属性注入的目的，我们就必须让 IoC 容器来全面接管 Controller 的创建和销毁，此时，我们需要做两件事情，其一，注册 Controller 到 IoC 容器中；其二，实现自定义的<code>IControllerActivator</code>，并替换默认的 ControllerActivator:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services.AddControllers();</span><br><span class="line">services.AddControllersWithViews().AddControllersAsServices();</span><br><span class="line">services.Replace(ServiceDescriptor.Transient&lt;IControllerActivator, AutowiredControllerActivator&gt;());</span><br></pre></td></tr></table></figure>
<p>其中，<code>AutowiredControllerActivator</code>实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutowiredControllerActivator</span> : <span class="title">IControllerActivator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">ControllerContext context</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(ControllerContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> controllerType = context.ActionDescriptor.ControllerTypeInfo.AsType();</span><br><span class="line">    <span class="keyword">var</span> serviceProvider = context.HttpContext.RequestServices;</span><br><span class="line">    <span class="keyword">if</span>(!(serviceProvider <span class="keyword">is</span> AutowiredServiceProvider))</span><br><span class="line">      serviceProvider = <span class="keyword">new</span> AutowiredServiceProvider(context.HttpContext.RequestServices);</span><br><span class="line">    <span class="keyword">var</span> controller = serviceProvider.GetRequiredService(controllerType);</span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">ControllerContext context, <span class="built_in">object</span> controller</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)</span><br><span class="line">      <span class="function">hrow <span class="keyword">new</span> <span class="title">ArgumentNullException</span>(<span class="params"><span class="keyword">nameof</span>(ControllerContext</span>))</span>;</span><br><span class="line">    <span class="keyword">if</span> (controller == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(controller));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> disposeable = controller <span class="keyword">as</span> IDisposable;</span><br><span class="line">    <span class="keyword">if</span> (disposeable != <span class="literal">null</span>)</span><br><span class="line">      disposeable.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，一切都会像我们期待的那样美好，返回正确的结果。目前，这个方案最大的问题是，在非 Controller 层使用的时候，还是需要构造<code>AutowirdServiceProvider</code>实例。其实，在<code>AutowiredControllerActivator</code>里同样有这个问题，就是你即使实现<code>IServiceProviderFactory</code>接口，依然没有办法替换掉默认的 ServiceProvider 实现，只能说它能解决一部分问题，同时又引入了新的问题，最直观的例子是，你看到一个接口的时候，你并不能找全所有加了<code>[Autowired]</code>标签的依赖项，所以，直接造成了依赖关系模糊、不透明、难以测试等等的一系列问题，我认为，在一个可控的、小范围内使用还是可以的。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/06/10/NET-Core%E5%8E%9F%E7%94%9FDI%E6%89%A9%E5%B1%95%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/10/NET-Core%E5%8E%9F%E7%94%9FDI%E6%89%A9%E5%B1%95%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/" itemprop="url">.NET Core 原生 DI 扩展之基于名称的注入实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-10T13:08:03+08:00">
                2020-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
        
          
            <p>接触 <code>.NET Core</code> 有一段时间了，最大的感受无外乎无所不在的依赖注入，以及抽象化程度更高的全新框架设计。想起三年前 Peter 大神手写 IoC 容器时的惊艳，此时此刻，也许会有不一样的体会。的确，那个基于字典实现的 IoC 容器相当“简陋”，就像 <code>.NET Core</code> 里的依赖注入，默认(原生)都是采用构造函数注入的方式，可其实从整个依赖注入的理论上而言，属性注入和方法注入的方式，同样是依赖注入的实现方式啊。最近一位朋友找我讨论，<code>.NET Core</code> 里该如何实现 <code>Autowried</code>，这位朋友本身是 Java 出身，一番攀谈了解到原来是指属性注入啊。所以，我打算用两篇博客来聊聊 <code>.NET Core</code> 中的原生 DI 的扩展，而今天这篇，则单讲基于名称的注入的实现。</p>
<p><a target="_blank" rel="noopener" href="https://autofac.org/">Autofac</a>是一个非常不错的 IoC 容器，通常我们会使用它来替换微软内置的 IoC 容器。为什么要这样做呢？其实，微软在其官方<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">文档</a>中早已给出了说明，即微软内置的 IoC 容器实际上是不支持以下特性的： <strong>属性注入、基于名称的注入、子容器、自定义生存期管理、对迟缓初始化的 Func<T> 支持、基于约定的注册</strong>。这是我们为什么要替换微软内置的 IoC  容器的原因，除了 Autofac 以外，我们还可以考虑 <code>Unity</code> 、<code>Castle</code> 等容器，对我个人而言，其实最需要的一个功能是“扫描”，即它可以针对程序集中的组件或者服务进行自动注册。这个功能可以让人写起代码更省心一点，果然，人类的本质就是让自己变得更加懒惰呢。好了，话题拉回到本文主题，我们为什么需要基于名称的注入呢？它其实针对的是“<strong>同一个接口对应多种不同的实现</strong>”这种场景。</p>
<p>OK ，假设我们现在有一个接口 ISayHello，它对外提供一个方法 SayHello：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> receiver</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应地，我们有两个实现类，ChineseSayHello 和 EnglishSayHello：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChineseSayHello</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChineseSayHello</span> : <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> receiver</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">$&quot;你好，<span class="subst">&#123;receiver&#125;</span>&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EnglishSayHello</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnglishSayHello</span> : <span class="title">ISayHello</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> receiver</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">$&quot;Hello，<span class="subst">&#123;receiver&#125;</span>&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，一顿操作猛如虎：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddTransient&lt;ISayHello, ChineseSayHello&gt;();</span><br><span class="line">services.AddTransient&lt;ISayHello, EnglishSayHello&gt;();</span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> sayHello = serviceProvider.GetRequiredService&lt;ISayHello&gt;();</span><br></pre></td></tr></table></figure>
<p>没想到，尴尬的事情就发生了，大家来猜猜看，这个时候我们获取到的<code>ISayHello</code>到底是哪一个呢？事实上，它会获取到<code>EnglishSayHello</code>这个实现类，为什么呢？因为它后注册的呀！当然，微软的工程师们不可能想不到这个问题，所以，官方推荐的做法是使用<code>IEnumerable&lt;ISayHello&gt;</code>，这样我们就能拿到所有注册的<code>ISayHello</code>，然后自己决定到底要使用一种实现，类似下面这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHellos = _serviceProvider.GetRequiredService&lt;IEnumerable&lt;ISayHello&gt;&gt;();</span><br><span class="line"><span class="keyword">var</span> chineseSayHello = sayHellos.FirstOrDefault(x =&gt; x.GetType() == (<span class="keyword">typeof</span>(ChineseSayHello)));</span><br><span class="line"><span class="keyword">var</span> englishSayHello = sayHellos.FirstOrDefault(x =&gt; x.GetType() == (<span class="keyword">typeof</span>(EnglishSayHello)));</span><br></pre></td></tr></table></figure>
<p>可这样还是有一点不方便啊，继续改造：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">services.AddTransient&lt;ChineseSayHello&gt;();</span><br><span class="line">services.AddTransient&lt;EnglishSayHello&gt;();</span><br><span class="line">services.AddTransient(implementationFactory =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  Func&lt;<span class="built_in">string</span>, ISayHello&gt; sayHelloFactory = lang =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lang)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;Chinese&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> implementationFactory.GetService&lt;ChineseSayHello&gt;();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;English&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> implementationFactory.GetService&lt;EnglishSayHello&gt;();</span><br><span class="line">      <span class="literal">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sayHelloFactory;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样子，这个工厂类看起来就消失了对吧，其实并没有(逃</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHelloFactory = _serviceProvider.GetRequiredService&lt;Func&lt;<span class="built_in">string</span>, ISayHello&gt;&gt;();</span><br><span class="line"><span class="keyword">var</span> chineseSayHello = sayHelloFactory(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> englishSayHello = sayHelloFactory(<span class="string">&quot;English&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这距离我们的目标有一点接近了哈，唯一的遗憾是这个工厂类对调用方是透明的，可谓是隐藏细节上的失败。有没有更好的方案呢？好了，我不卖关子啦，一起来看下面的实现。</p>
<p>首先，我们定义一个接口<code>INamedServiceProvider</code>, 顾名思义，就不需要再解释什么了:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">INamedServiceProvider</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">TService <span class="title">GetService</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，编写实现类<code>NamedServiceProvider</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NamedServiceProvider</span> : <span class="title">INamedServiceProvider</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _serviceProvider;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IDictionary&lt;<span class="built_in">string</span>, Type&gt; _registrations;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedServiceProvider</span>(<span class="params">IServiceProvider serviceProvider, IDictionary&lt;<span class="built_in">string</span>, Type&gt; registrations</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _serviceProvider = serviceProvider;</span><br><span class="line">    _registrations = registrations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TService <span class="title">GetService</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!_registrations.TryGetValue(serviceName, <span class="keyword">out</span> <span class="keyword">var</span> implementationType))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Service \&quot;<span class="subst">&#123;serviceName&#125;</span>\&quot; is not registered in container&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (TService)_serviceProvider.GetService(implementationType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，我们这里用一个字典来维护名称和类型间的关系，一切仿佛又回到三年前 Peter 大神手写 IoC 的那个下午。接下来，我们定义一个<code>INamedServiceProviderBuilder</code>, 它可以让我们使用链式语法注册服务：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">INamedServiceProviderBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">INamedServiceProviderBuilder <span class="title">AddNamedService</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName, ServiceLifetime lifetime</span>) <span class="keyword">where</span> TService : <span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">INamedServiceProviderBuilder <span class="title">TryAddNamedService</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName, ServiceLifetime lifetime</span>) <span class="keyword">where</span> TService : <span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，Add 和 TryAdd 的区别就是后者会对已有的键进行检查，如果键存在则不会继续注册，和微软自带的 DI 中的 Add&#x2F;TryAdd 对应，我们一起来看它的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NamedServiceProviderBuilder</span> : <span class="title">INamedServiceProviderBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceCollection _services;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IDictionary&lt;<span class="built_in">string</span>, Type&gt; _registrations = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Type&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedServiceProviderBuilder</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _services = services;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Build</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    _services.AddTransient&lt;INamedServiceProvider&gt;(sp =&gt; <span class="keyword">new</span> NamedServiceProvider(sp, _registrations));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> INamedServiceProviderBuilder <span class="title">AddNamedService</span>&lt;<span class="title">TImplementation</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName, ServiceLifetime lifetime</span>) <span class="keyword">where</span> TImplementation : <span class="keyword">class</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lifetime)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Transient:</span><br><span class="line">        _services.AddTransient&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Scoped:</span><br><span class="line">        _services.AddScoped&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Singleton:</span><br><span class="line">        _services.AddSingleton&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _registrations.Add(serviceName, <span class="keyword">typeof</span>(TImplementation));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> INamedServiceProviderBuilder <span class="title">TryAddNamedService</span>&lt;<span class="title">TImplementation</span>&gt;(<span class="params"><span class="built_in">string</span> serviceName, ServiceLifetime lifetime</span>) <span class="keyword">where</span> TImplementation : <span class="keyword">class</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lifetime)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Transient:</span><br><span class="line">        _services.TryAddTransient&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Scoped:</span><br><span class="line">        _services.TryAddScoped&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ServiceLifetime.Singleton:</span><br><span class="line">        _services.TryAddSingleton&lt;TImplementation&gt;();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _registrations.TryAdd(serviceName, <span class="keyword">typeof</span>(TImplementation));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信到这里，大家都明白博主的意图了吧，核心其实是在<code>Build()</code>方法中，因为我们最终需要的是其实是<code>NamedServiceProvider</code>，而在此之前的种种，都属于收集依赖、构建 ServiceProvider 的过程，所以，它被定义为<code>NamedServiceProviderBuilder</code>，我们在这里维护的这个字典，最终会被传入到<code>NamedServiceProvider</code>的构造函数中，这样我们就知道根据名称应该返回哪一个服务了。</p>
<p>接下来，为了让它和微软自带的 DI 无缝粘合，我们需要编写一点扩展方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ServiceCollectionExstension</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TService <span class="title">GetNamedService</span>&lt;<span class="title">TService</span>&gt;(<span class="params"><span class="keyword">this</span> IServiceProvider serviceProvider, <span class="built_in">string</span> serviceName</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> namedServiceProvider = serviceProvider.GetRequiredService&lt;INamedServiceProvider&gt;();</span><br><span class="line">    <span class="keyword">if</span> (namedServiceProvider == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Service \&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(INamedServiceProvider)&#125;</span>\&quot; is not registered in container&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> namedServiceProvider.GetService&lt;TService&gt;(serviceName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> INamedServiceProviderBuilder <span class="title">AsNamedServiceProvider</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> builder = <span class="keyword">new</span> NamedServiceProviderBuilder(services);</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，回到我们一开始的问题，它是如何被解决的呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services</span><br><span class="line">  .AsNamedServiceProvider()</span><br><span class="line">  .AddNamedService&lt;ChineseSayHello&gt;(<span class="string">&quot;Chinese&quot;</span>, ServiceLifetime.Transient)</span><br><span class="line">  .AddNamedService&lt;EnglishSayHello&gt;(<span class="string">&quot;English&quot;</span>, ServiceLifetime.Transient)</span><br><span class="line">  .Build();</span><br><span class="line"><span class="keyword">var</span> serviceProvider = services.BuildServiceProvier();</span><br><span class="line"><span class="keyword">var</span> chineseSayHello = serviceProvider.GetNamedService&lt;ISayHello&gt;(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> englishSayHello = serviceProvider.GetNamedService&lt;ISayHello&gt;(<span class="string">&quot;English&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个时候，对调用方而已，依然是熟悉的 ServiceProvider，它只需要传入一个名称来获取服务即可，由此，我们就实现了基于名称的依赖注入。回顾一下它的实现过程，其实是一个逐步推进的过程，我们使用依赖注入，本来是希望依赖抽象，即针对同一个接口，可以无痛地从一种实现切换到另外一种实现。可我们发现，当这些实现同时被注册到容器里的时候，容器一样会迷惑于到底用哪一种实现，这就让我们开始思考，这种基于字典的 IoC 容器设计方案是否存在缺陷。所以，在.NET Core 里的 DI 设计中还引入了工厂的概念，因为并不是所以的 Resolve<T>都可以通过<code>Activator.Create</code>来实现，更不必说 Autofac 和 Castle 中还有子容器的概念，只能说人生不同的阶段总会有不同的理解吧！好了，这篇博客就先写到这里，欢迎大家给我留言，晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/79/">79</a><a class="extend next" rel="next" href="/page/22/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1579</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
