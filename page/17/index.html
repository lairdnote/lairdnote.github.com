<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/17/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/17/"/>





  <title>逐流小站</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-MW47YH6RH0', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/20/2021-03-20-the-food-of-mlxg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/20/2021-03-20-the-food-of-mlxg/" itemprop="url">码农装逼菜谱 (二) - 麻辣香锅</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-20T21:31:58+08:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天的装逼菜谱是：麻辣香锅。以下是成品效果图：</p>
<img src="/images/cook-mlxg.jpg" class="">

<h2 id="用料"><a href="#用料" class="headerlink" title="用料"></a>用料</h2><p>麻辣香锅的原料就完全随意了，我个人喜欢的搭配是：</p>
<ul>
<li>荤菜：五花肉、鸡翅、牛肉丸、肥牛、午餐肉、脆皮肠、鹌鹑蛋。</li>
<li>素菜：藕片、土豆、西芹、豆皮、香菇、洋葱、青蒜、西兰花、金针菇、魔芋丝。</li>
<li>麻辣香锅底料（或者火锅底料）：每一个人的量按 30 克算，如果是 4 个人就是 120 克。</li>
</ul>
<p>相信你看出来了，这个菜适合人多，因为每个菜都可以加一点。如果 2 人份的话，建议只用选 6~8 种原料即可。</p>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p>麻辣香锅的的制作办法核心就是先把各种菜弄熟，然后把麻辣香锅底料（或者火锅底料）炒香，最后把菜和底料混合即可。</p>
<h3 id="步骤-1-处理荤菜"><a href="#步骤-1-处理荤菜" class="headerlink" title="步骤 1 - 处理荤菜"></a>步骤 1 - 处理荤菜</h3><table>
<thead>
<tr>
<th>原料</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>牛肉丸</td>
<td>直接和素菜一起煮熟即可</td>
</tr>
<tr>
<td>肥牛</td>
<td>焯水，没有血色后就熟了</td>
</tr>
<tr>
<td>午餐肉</td>
<td>切片后，直接最后放入香锅里即可</td>
</tr>
<tr>
<td>脆皮肠</td>
<td>在肠的一端切个十字花刀，然后把脆皮肠煎成开花</td>
</tr>
<tr>
<td>鹌鹑蛋</td>
<td>煮熟剥好，最后放入香锅里即可</td>
</tr>
<tr>
<td>五花肉</td>
<td>把五花肉切片之后，用小火煎，最后两边煎成金黄色即可</td>
</tr>
<tr>
<td>鸡翅</td>
<td>先把鸡翅划几个缝，然后用料酒、姜片、生抽腌制 20 分钟。<br /> 之后像五花肉那样双面煎成金黄，然后加水烧 2 分钟，水烧得快干后取出。</td>
</tr>
</tbody></table>
<p>以上最好做的就是牛肉丸、肥牛、午餐肉、脆皮肠。如果想做起来简单，买这几样就行。</p>
<h3 id="步骤-2-处理素菜"><a href="#步骤-2-处理素菜" class="headerlink" title="步骤 2 - 处理素菜"></a>步骤 2 - 处理素菜</h3><table>
<thead>
<tr>
<th>原料</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>土豆</td>
<td>去皮，切片</td>
</tr>
<tr>
<td>藕片</td>
<td>去皮，切片</td>
</tr>
<tr>
<td>西芹</td>
<td>切段</td>
</tr>
<tr>
<td>豆皮</td>
<td>切成 1 厘米宽的丝</td>
</tr>
<tr>
<td>香菇</td>
<td>洗净，切成两半</td>
</tr>
<tr>
<td>洋葱</td>
<td>切成丝</td>
</tr>
<tr>
<td>青蒜</td>
<td>切成段</td>
</tr>
</tbody></table>
<p>以上这些菜切好之后，除了土豆，直接放到锅中加开水煮，煮个大概 3 分钟就行。</p>
<p>不用煮太久，因为藕片、豆皮、洋葱都可以生吃。</p>
<p>土豆单独用油煎一下会更好吃，为了省事，也可以和别的菜一起煮。</p>
<p>以上最好做的是藕片、豆皮、香菇、洋葱、金针菇、魔芋丝，基本上不需要什么额外处理。</p>
<h3 id="步骤-3-收尾"><a href="#步骤-3-收尾" class="headerlink" title="步骤 3 - 收尾"></a>步骤 3 - 收尾</h3><p>上面的荤菜、素菜预处理好了之后，就开始处理底料了。</p>
<p>把葱姜蒜切成末，油烧热之后，下葱姜蒜，炒一下之后把火关最小，然后把麻辣香锅底料加进去，火锅底料容易糊，用铲子慢慢把底料炒融化。</p>
<p>底料完全化掉之后，先加入荤菜。等调料都裹上之后，再加入素菜。</p>
<p>最后放一点点糖调味，然后就可以起锅啦~</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>个人感觉麻辣香锅的灵魂是方便面，吃起来特别香。只需要把方便面单独泡好后加进香锅即可。</li>
<li>如果希望点缀一下，可以放一点炸花生米、白芝麻、以及香菜。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/20/2021-03-20-the-food-of-tcpg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/20/2021-03-20-the-food-of-tcpg/" itemprop="url">码农装逼菜谱 (一) - 糖醋排骨</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-20T20:16:56+08:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近迷上了做饭，花几个小时给家人做一顿饭，然后美美的吃上一顿还是挺爽的。其实很多菜做起来一点都不难，只是中餐习惯用 “中火”，“少许”，“断生” 这些只可意会不可言传的词。所以我打算写一个「码农装逼菜谱」系列，让大家都可以轻松完成各种高级菜的制作。</p>
<p>我的菜谱原则是：</p>
<ul>
<li>尽量简化。能不加的调料就不加，能用调好的酱就不自己调。</li>
<li>尽量量化。所有调料都用量勺或者克重表示。</li>
</ul>
<p>为了量化食材配料，你需要备好两个便宜的小工具：一个是量勺（Table Spoon），拼多多上大概 10 来块钱包邮（如下图）。</p>
<img src="/images/cook-tool-2.jpg" class="">

<p>另一个是电子厨房秤，大概 20 多块钱（如下图）。</p>
<img src="/images/cook-tool-1.jpg" class="">

<p>今天第一个装逼菜谱是：糖醋排骨。以下是成品效果图：</p>
<img src="/images/cook-tcpg.jpg" class="">

<h2 id="用料"><a href="#用料" class="headerlink" title="用料"></a>用料</h2><p>以下提到的 1 勺表示 15 ML（Table Spoon），即上面量勺图中最大的那个 1 勺。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用量</th>
</tr>
</thead>
<tbody><tr>
<td>糖醋排骨</td>
<td>500 克</td>
</tr>
<tr>
<td>红糖（或白糖）</td>
<td>4 勺</td>
</tr>
<tr>
<td>镇江醋（或香醋）</td>
<td>3 勺</td>
</tr>
<tr>
<td>生抽（或酱油）</td>
<td>2 勺</td>
</tr>
<tr>
<td>黄酒（或料酒）</td>
<td>1 勺</td>
</tr>
</tbody></table>
<p>这里有个好记的口诀，上面的配料比例刚好是 54321（500g 排骨，4321 比例的糖、醋、酱油、黄酒）。</p>
<p>记不清楚哪个是 4 勺，哪个是 3 勺怎么办？我的记法是：糖醋排骨，名字中糖醋糖醋，糖在前，醋在后，所以 4 勺的是糖，3 勺的是醋。剩下的两个就很好记了，因为料酒在稍后介绍的很多菜中都是 1 勺，所以最少的就是料酒。</p>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>从超市采购猪肋排，让超市服务员帮你切成小段，尽量短一点。一般一次采购都不止 1 斤，可以分两次做。</p>
<p>拿个小碗，按排骨的重量，按比例把其他调料配好。比如如果是 2 斤排骨（1000g），调料就应该是双份的。</p>
<p>排骨拿热水器放出来的 40 度左右温水泡 2 分钟，去掉血水后沥干待用。</p>
<p>同时用电水壶烧 400 毫升开水，后面要用。</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>不沾锅烧热，放 1 勺油，油热之后下排骨煸炒。大概翻炒的速度就是 15 秒翻一下，看看排骨贴锅的那一面变色的速度，如果没有变很快可以翻慢一点。最后效果就是排骨表面的肉炒出一点金黄色。</p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>加开水 400 毫升，水量能够把排骨快要淹没即可。如果加多了也没关系，无非就是烧久一点而已。</p>
<p>放入之前配好的调料，盖上盖子小火炖煮。一共需要炖 40 分钟，中间需要检查 2 次。每家的炉子火力不一样，如果水干得快，可以中途稍微加点水。</p>
<p>我习惯在手环上设置一个 20 分钟的倒计时，这样可以安心玩手机或者做别的。</p>
<img src="/images/cook-timer.gif" class="">

<p>20 分钟后翻一下排骨，再设置一个 15 分钟的倒计时。如果火比较大水快没了，可以加一点水。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>15 分钟到了后，排骨基本就烧好了。</p>
<p>这个时候打开盖子，火力稍微大一点，让余下的水蒸发得快一点。同时时不时翻一下，避免水少糊锅。到最后基本收汁了，就可以起锅了。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>不需要葱姜，不需要焯水。放心，做出来一点都不会腥。</li>
<li>如果你希望排骨吃起来硬一点，可以在排骨泡完温水后，用吸油纸把水份都吸掉。</li>
<li>撒上白芝麻点缀，没有也没关系，这东西就是图好看而已。</li>
<li>起锅前也可以加几块话梅，没有也没关系。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/19/2021-03-19-i-am-the-mayor-of-shenzhen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/19/2021-03-19-i-am-the-mayor-of-shenzhen/" itemprop="url">像经营企业一样经营城市 - 读《我在深圳当市长》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-19T21:46:11+08:00">
                2021-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/images/mayor-of-shenzhen.jpg" class="">

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近看完了<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35231636/">《我在深圳当市长》</a>，作者是前深圳市市长李子彬。</p>
<p>李子彬在 94~00 年间在深圳市当市长，是深圳发展成为国内一线城市的主政者。在他的书中，我能看到一个城市经营发展面临的各种问题和挑战，很多情况下都比企业的经营复杂。</p>
<p>书中也涉及了很多社会发展的黑暗面。当我向一个深圳的朋友推荐此书的时候，他第一句话就是：</p>
<blockquote>
<p>「这书写的是不是 20 年前的事情？」</p>
</blockquote>
<p>我一算，00 年到现在，刚好过了 20 年。于是我问他：</p>
<blockquote>
<p>你怎么知道的？</p>
</blockquote>
<p>这个朋友说：</p>
<blockquote>
<p>因为刑法规定违法事情的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%BD%E8%AF%89%E6%97%B6%E6%95%88">追诉期</a>是 20 年。20 年过了，很多事情公开讲了也没有人追究。所以，这本书讲了任何可能违法的事情，也过了追诉期。</p>
</blockquote>
<p>有意思的是，虽然经营一个城市和经营一家企业很不一样，但是很多基本的原则和方法却惊人地一致。我从他的书中还是得到了很多启发，以下是一些小结。</p>
<h2 id="为城市发展定位"><a href="#为城市发展定位" class="headerlink" title="为城市发展定位"></a>为城市发展定位</h2><p>我们做企业做产品讲定位，而城市的发展也是需要讲策略和方法。深圳在当初改革开放的时候，首先确立了发展高新科技产业的城市定位。在全书中，我们都能看到市政府为了这个定位在做相关的工作。例如：</p>
<ul>
<li><p>高新技术产业需要人才，而深圳本地缺少著名院校。于是政府与高校通过建新型研究院的形式，将清华、北大这些院校的研究人才吸引过来，同时配套推进创新的技术落地。</p>
</li>
<li><p>让管经济的副市长同时管教育，这样教育就可以很方便地经济发展协同发展。</p>
</li>
<li><p>取消传统的荔枝节，改办高交会。</p>
</li>
</ul>
<p>深圳的每一次调整，都在朝着这个定位在走，几十年下来，深圳成为了全球供应链和配套最完整的硬件研发城市。</p>
<h2 id="树立好的经营环境"><a href="#树立好的经营环境" class="headerlink" title="树立好的经营环境"></a>树立好的经营环境</h2><p>政府要发展经济，主要是靠市场的手段，而不是靠行政命令。深圳市的领导班子很清楚这一点，于是他们把工作重点放到了树立好的经营环境上。他们做了以下这些事情：</p>
<ul>
<li>改善学校的学习环境，把歌舞厅等娱乐场所赶出学校。</li>
<li>改善治安环境。整治军牌乱象，成立独立的巡警，同时整治公安队伍。</li>
<li>整理乱收费，配合合理拨款。砍掉了将近一半的收费项目，另外设立收费登记薄，明确收费内容和收费额度，通过银行统一收款，从而规范收入。</li>
<li>整合部门，建立一站式投资服务大厅。将 27 个相关单位聚在一起办公，大幅缩短了办理相关手续的时间。</li>
<li>减少审批项。</li>
</ul>
<p>这些事情看起来简单，其实每一件事情都不容易。因为这些改革都会触及很多人的利益。比如减少审批项，就会影响很多部门的收入，人员的配备，同时如果未来因为没有审批出了一些问题，也是容易被追责的，所以改革者都需要承担很多风险。在政府里面能够将这些事情一一推进，比在企业中要难得多，但是他们全部都做到了，实属不易。</p>
<p>其实这些工作对于经营公司也是同样的：</p>
<ul>
<li><p>例如：对于一家公司来说，对内提供一个尽量舒服的工作环境，减少各种不必要的会议，减少审批的流程，减少工作汇报，让员工尽量将精力花在工作本身上，也是非常重要的。</p>
</li>
<li><p>又例如：企业的组织架构，其实也是需要是类似于一站式投资服务大厅这样的项目制形态。相关的业务同事应该聚在一起办公，才能让项目的进展尽量高效。否则就会出现特别多的流程，特别多的职能部门共同参与，但是事情却做得很慢，也做不好的情况。</p>
</li>
</ul>
<h2 id="国企改革"><a href="#国企改革" class="headerlink" title="国企改革"></a>国企改革</h2><p>深圳在国企改革的操作也让我觉得非常像互联网公司，其中的核心就是：放权。</p>
<p>深圳通过成立国有资产经营公司来管理股份制改革后的企业。而资产经营公司强调不干预企业的经营，只是做好特别少的几件事情。在人上面，只是参与董事会的提名，同时委派财务总监，这样可以保证财务帐目清晰，同时重大讨论的时候可以参与投票即可。另外做好服务，帮助企业融资或者克服一些困难。</p>
<p>这个其实特别像现在互联网公司的风险投资。风险投资一家公司，一般也就是进驻董事会，参与一些重大决策，同时审计相关的财务报表，保证公司的经营状态是清晰的。最后做一些投后服务，帮助企业融资或者发展。</p>
<p>你看一对比，是不是特别像？</p>
<h2 id="做对的事情"><a href="#做对的事情" class="headerlink" title="做对的事情"></a>做对的事情</h2><p>在政府经营的时候，应该做对的事情，还是应该做程序正义的事情？大部分人为了自己的私利，在冲突的时候，会选择做程序正义的事情，而放弃做对的事情。因为如果违背程序正义，会给自己带了潜在的很多麻烦。</p>
<p>而在子彬的书中，我看到了很多为了做正确的事情，而违背程序正义的行为。</p>
<p>书中给我印象最深的案例是水利工程的例子：深圳市因为慢慢发展起来人口变多，水不够用了，于是需要引水。市政府费了很大力气找到了引水的方案，省委也同意了，但是一直拿不到国家发展计划委员会的批复。</p>
<p>是把一切工作暂停下来等批复，还是尽快解决人民群众的饮水问题？子彬选择了后者，对水务局长说：</p>
<blockquote>
<p>「上头要追责，也是处分我，你们就开工干吧！」</p>
</blockquote>
<p>结果开工 9 个月后，才拿到批复。</p>
<p>水利工程分为两期，第二期工程得 10 年后才做，那个时候子彬已经不是市长了。第一期如果为第二期在施工上做铺垫，就可以为未来节省上百倍的钱。但是这些铺垫工作也是需要额外花钱的。</p>
<p>是为了任期内的经济效果，还是考虑未来 20 年的城市规模，现在多花一点钱，但是为后来的市长做好铺垫？子彬选择了后者。提前为二期工程把征地、管线预留这些都做好了提前的准备，结果 10 年后的二期工程只花了一期工程 1&#x2F;6 的钱。</p>
<h2 id="要任用能人"><a href="#要任用能人" class="headerlink" title="要任用能人"></a>要任用能人</h2><p>有人说国企稳定，好混日子。但是我在子彬的这本书里面看到，政府的高层任命，还是挑选的是特别能干的人。大家要找的是能成事的人，不是资历多老，背景多深的人。比如子彬在找管经济的副市长的时候，就点名要找一个懂经济的人，费劲心思去请能人过来当副市长，一点都不是高高在上等着大家竞选，或者随便挑一个听话的。</p>
<p>最近我一个朋友，从互联网公司跳到一家传统的企业，因为一个项目做得好，一下子连升两级，直接向总经理汇报工作，把他吓坏了。我就告诉他，说明这家传统企业也有着努力经营的心态，在任何组织，只是是希望努力经营好，就会任用厉害的人，在人才提拔上面与互联网公司没有什么区别。</p>
<h2 id="要亲临一线和了解数据"><a href="#要亲临一线和了解数据" class="headerlink" title="要亲临一线和了解数据"></a>要亲临一线和了解数据</h2><p>子彬在书中介绍了大量自己亲自参与调研的情况，每次接受上级视察的时候，对深圳的各种指标倒背如流。</p>
<p>这也是互联网的公司重视的企业文化，管理者不应该高高在上，应该亲自参与核心的工作，对核心数据要了如指掌。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>历史是一面镜子，从李子彬的这本书中，我感受到了深圳过去 20 多年发展当中面临的各种重大挑战以及主政者的决心与魄力。深圳是中国经济发展的代表城市，中国在经济上的迅速发展，在国际地位上的崛起，不是自然而然发生的，每一步都倾注着政府各部门管理者们的心血，为中国政府点赞！</p>
<p>同时我也发现，管理的原则是相通的，很多企业经营管理方法与城市的管理方法类似，这让我对政府运作的陌生感减少了很多，或许有一天，互联网的人才和政府的人才是可以相互流通的，因为方法是相通的。</p>
<p>还是很有意思的一本书，推荐给大家。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/16/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E8%B7%A8%E5%9F%9F%E4%B8%AD%E9%97%B4%E4%BB%B6%20CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/16/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E8%B7%A8%E5%9F%9F%E4%B8%AD%E9%97%B4%E4%BB%B6%20CORS/" itemprop="url">源代码探案系列之 .NET Core 跨域中间件 CORS</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-16T21:25:47+08:00">
                2021-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是 #<strong>源代码探案系列</strong># 第三篇，今天这篇博客，我们来一起解读下 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件，熟悉这个中间件的的小伙伴们，想必都已经猜出本文的主题：跨域。这确实是一个老生常谈的话题，可我并不认为，大家愿意去深入探究这个问题，因为博主曾经发现，每当工作中遇到跨域问题的时候，更多的是直接重写跨域相关的 HTTP 头。博主曾经写过一篇关于跨域的博客：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3846545990/">《聊聊前端跨域的爱恨情仇》</a>，当时是完全以前端的视角来看待跨域。所以，在今天这篇博客里，博主想带领大家从一种新的视角来看待跨域，也许，可以从中发现不一样的东西。</p>
<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>关于 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a>，大家都知道的是，可以通过<code>UseCors()</code>方法在整个 HTTP 请求管道中启用跨域中间件，或者是通过<code>AddCors()</code>方法来定义跨域策略，亦或者通过<code>[EnableCors]</code>来显式地指定跨域策略，更多的细节大家可以参考微软的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0">官方文档</a>，而在这里，我想聊一点大家可能不知道的东西，譬如：服务器端如何处理来自浏览器端的跨域请求？而这一切在 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中又如何实现？带着这些问题来解读 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件的源代码，我们能更快的找到我们想得到的答案。一图胜千言，请允许博主使用这张流程图来“开宗明义”，我们这就开始今天的“<strong>探案</strong>”：</p>
<p><img src="https://i.loli.net/2021/03/16/m1geMX8PfJwN3Bb.png" alt="一张图览尽 CORS 中间件"></p>
<h1 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h1><p>对于整个 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件而言，核心部件主要有：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsPolicy.cs">CorsPolicy</a>、<a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsService.cs">CorsService</a> 以及 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs">CorsMiddleware</a>。</p>
<h2 id="CorsPolicy"><a href="#CorsPolicy" class="headerlink" title="CorsPolicy"></a>CorsPolicy</h2><p>整个 <strong>CORS</strong> 中间件中，首当其冲的是<code>ICorsPolicy</code>。这个接口的作用是定义跨域的策略，我们知道<code>CORS</code>中引入了<code>Access-Control</code>系列的 HTTP 头，所以，<code>CorsPolicy</code> 本质上是在定义允许哪些 HTTP 头、HTTP 方法、源(<strong>Origin</strong>) 可以访问受限的资源，以及当跨域请求是一个复杂请求的时候，预检请求的超时时间、是否支持凭据等等：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyHeader &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyMethod &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyOrigin &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; IsOriginAllowed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; ExposedHeaders &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Headers &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Methods &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Origins &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> TimeSpan? PreflightMaxAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SupportsCredentials &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在整个中间件的设计中，与<code>CorsPolicy</code>接口产生直接联系的，是<code>CorsPolicyBuilder</code>和<code>ICorsPolicyProvider</code>。相信大家从命名上就可以了解到，前者是一个基于建造者模式的、针对 <code>CorsPolicy</code>进行“<strong>加工</strong>”的工具类，可以快速地对 跨域策略中允许的 HTTP 方法、HTTP 头、源(<strong>Origin</strong>)等信息进行修改。关于这一点，我们可以从<code>CorsPolicyBuilder</code>提供的方法签名中得到印证，而最终<code>CorsPolicyBuilder</code>通过<code>Build()</code>方法来返回一个“<strong>加工</strong>”好的<code>CorsPolicy</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicyBuilder</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithOrigins</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] origins</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] headers</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithExposedHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] exposedHeaders</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithMethods</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] methods</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowCredentials</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">DisallowCredentials</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyOrigin</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyMethod</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyHeader</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetPreflightMaxAge</span>(<span class="params">TimeSpan preflightMaxAge</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowed</span>(<span class="params">Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; isOriginAllowed</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowedToAllowWildcardSubdomains</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicy <span class="title">Build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了通过<code>CorsPolicyBuilder</code>来生成跨域策略，我们还可以通过<code>ICorsPolicyProvider</code>来生成跨域策略。如果你经常使用<code>ASP.NET Core</code>中的<strong>配置系统</strong>和<strong>依赖注入</strong>，对于这种“<strong>套路</strong>”应该不会感到陌生。这里，微软提供了一个默认实现：<code>DefaultCorsPolicyProvider</code>。<code>DefaultCorsPolicyProvider</code>本身依赖<code>CorsOptions</code>，允许使用者传入一个<code>CorsPolicy</code>的实例 或者是一个委托，来自定义跨域策略的“<strong>加工</strong>”细节，并在其内部维护一个字典，来实现<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0#np">具名的跨域策略</a>。如果使用者不为当前跨域策略指定名称，则会使用默认的跨域策略名称。在大多数场景下，我们并不会直接使用<code>CorsPolicyBuilder</code>，而是在<code>Startup</code>类中通过委托来定义跨域策略，两者可以说是不同层次上的跨域策略的“<strong>提供者</strong>”。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCorsPolicyProvider的GetPolicyAsync()</span></span><br><span class="line"><span class="keyword">public</span> Task&lt;CorsPolicy?&gt; GetPolicyAsync(HttpContext context, <span class="built_in">string</span>? policyName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyName ??= _options.DefaultPolicyName;</span><br><span class="line">    <span class="keyword">if</span> (_options.PolicyMap.TryGetValue(policyName, <span class="keyword">out</span> <span class="keyword">var</span> result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.policyTask!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NullResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CorsOptions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="built_in">string</span> name, CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="built_in">string</span> name, Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> CorsPolicy? GetPolicy(<span class="built_in">string</span> name);</span><br></pre></td></tr></table></figure>
<h2 id="CorsService"><a href="#CorsService" class="headerlink" title="CorsService"></a>CorsService</h2><p>OK，说完了跨域策略的“<strong>定义</strong>”，现在我们来看看跨域策略是如何被中间件“执行”的，这部分代码被定义在<code>CoreService</code>类的<code>EvaluatePolicy()</code>方法中。可以注意到，如果受限资源允许任意源(<strong>Origin</strong>)访问，则服务器端会认为这是一个不安全的跨域策略。</p>
<p>接下来，从<code>HttpContext</code>中提取客户端的源(<strong>Origin</strong>)，请求方法(<strong>HttpMethod</strong>)。此时，服务器端可以根据请求方法和 HTTP 头 判断当前请求是都为预检请求。按照<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>规范，当请求方法为<code>OPTION</code>且请求头中含有<code>Access-Control-Request-Method</code>时，即表示这是一个预检请求。</p>
<p>至此，我们有了两种选择，预检请求会交给<code>EvaluatePreflightRequest()</code>方法去处理，非预检请求会交给<code>EvaluateRequest()</code>方法去处理。除了<code>HttpContext</code>和<code>CorsPolicy</code>这两个参数以外，它们都会接受第三个参数<code>CorsResult</code>，它里面封装了我们一开始判断出来的关于源和预检请求的信息。继续细看，我们会发现这两个方法，都调用了<code>PopulateResult()</code>方法，继续顺着这条线索下去，我们就会发现，这个方法的主要作用是，结合跨域策略设定的各种参数，进一步对上一步生成的<code>CorsResult</code>进行“<strong>加工</strong>”。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsResult <span class="title">EvaluatePolicy</span>(<span class="params">HttpContext context, CorsPolicy policy</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin &amp;&amp; policy.SupportsCredentials) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(Resources.InsecureConfiguration, <span class="keyword">nameof</span>(policy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestHeaders = context.Request.Headers;</span><br><span class="line">    <span class="keyword">var</span> origin = requestHeaders[CorsConstants.Origin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">    <span class="keyword">var</span> isPreflightRequest = isOptionsRequest </span><br><span class="line">        &amp;&amp; requestHeaders.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> corsResult = <span class="keyword">new</span> CorsResult &#123;</span><br><span class="line">        IsPreflightRequest = isPreflightRequest,</span><br><span class="line">        IsOriginAllowed = IsOriginAllowed(policy, origin),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreflightRequest) &#123;</span><br><span class="line">        <span class="comment">//预检请求</span></span><br><span class="line">        EvaluatePreflightRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非预检请求</span></span><br><span class="line">        EvaluateRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> corsResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PopulateResult</span>(<span class="params">HttpContext context, </span></span></span><br><span class="line"><span class="params"><span class="function">    CorsPolicy policy, </span></span></span><br><span class="line"><span class="params"><span class="function">    CorsResult result</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = context.Request.Headers;</span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin) &#123;</span><br><span class="line">        result.AllowedOrigin = CorsConstants.AnyOrigin;</span><br><span class="line">        result.VaryByOrigin = policy.SupportsCredentials;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> origin = headers[CorsConstants.Origin];</span><br><span class="line">        result.AllowedOrigin = origin;</span><br><span class="line">        result.VaryByOrigin = policy.Origins.Count &gt; <span class="number">1</span> </span><br><span class="line">            || !policy.IsDefaultIsOriginAllowed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持凭据</span></span><br><span class="line">    result.SupportsCredentials = policy.SupportsCredentials;</span><br><span class="line">    <span class="comment">// 预检请求超时时间</span></span><br><span class="line">    result.PreflightMaxAge = policy.PreflightMaxAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://fetch.spec.whatwg.org/#http-new-header-syntax</span></span><br><span class="line">    AddHeaderValues(result.AllowedExposedHeaders, policy.ExposedHeaders);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">    <span class="keyword">var</span> allowedMethods = policy.AllowAnyMethod ?</span><br><span class="line">        <span class="keyword">new</span>[] &#123; result.IsPreflightRequest ? </span><br><span class="line">                (<span class="built_in">string</span>)headers[CorsConstants.AccessControlRequestMethod] : </span><br><span class="line">                context.Request.Method &#125; :</span><br><span class="line">        policy.Methods;</span><br><span class="line">    AddHeaderValues(result.AllowedMethods, allowedMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP头</span></span><br><span class="line">    <span class="keyword">var</span> allowedHeaders = policy.AllowAnyHeader ?</span><br><span class="line">        headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders) :</span><br><span class="line">        policy.Headers;</span><br><span class="line">    AddHeaderValues(result.AllowedHeaders, allowedHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这些参数最终的走向是哪里呢？我们注意到<code>CorsService</code>里有一个叫做<code>ApplyResult()</code>的方法，观察方法签名可以发现，它负责把跨域检测的结果应用到 HTTP 响应上，相信大家都能想到，这里会设置各种<code>Access-Control</code>系列的头，比如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<br><code>Access-Control-Max-Age</code>…等等。事实上，在<code>CorsMiddleware</code>中间件中，原本就是先调用<code>EvaluateResult()</code>方法，再调用<code>ApplyResult()</code>方法。当然，实际的代码中，还需要考虑<code>[DisableCors]</code>和<code>[EnableCors]</code>两个特性的影响，会多出一点判断的代码。关于跨域的代码层面的东西，我们就先讲到这里，在下一部分，我们会专门讲<code>CORS</code>里的简单请求和复杂请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context, ICorsPolicyProvider corsPolicyProvider</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(CorsConstants.Origin)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [DisableCors]</span></span><br><span class="line">    <span class="keyword">var</span> corsMetadata = endpoint?.Metadata.GetMetadata&lt;ICorsMetadata&gt;();</span><br><span class="line">    <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IDisableCorsAttribute) &#123;</span><br><span class="line">        <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">        <span class="keyword">var</span> isCorsPreflightRequest = isOptionsRequest </span><br><span class="line">            &amp;&amp; context.Request.Headers.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line">        <span class="keyword">if</span> (isCorsPreflightRequest) &#123;</span><br><span class="line">            <span class="comment">// If this is a preflight request, and we disallow CORS, complete the request</span></span><br><span class="line">            context.Response.StatusCode = StatusCodes.Status204NoContent;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// [EnableCors]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IEnableCorsAttribute enableCorsAttribute &amp;&amp;</span><br><span class="line">        enableCorsAttribute.PolicyName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Evaluate &amp;&amp; Apply</span></span><br><span class="line">        <span class="keyword">return</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        <span class="function"><span class="keyword">async</span> Task <span class="title">InvokeCoreAwaited</span>(<span class="params">HttpContext context, Task&lt;CorsPolicy?&gt; policyTask</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> corsPolicy = <span class="keyword">await</span> policyTask;</span><br><span class="line">            <span class="keyword">await</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="再论CORS"><a href="#再论CORS" class="headerlink" title="再论CORS"></a>再论CORS</h1><p>好了，行文至此。既然这篇博客的主题是“<strong>跨域</strong>”，那么，我们不妨多说一点。我们知道，“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了“<strong>跨域</strong>”这一限制。而为了顺应“<strong>前后端分离</strong>”、“<strong>微服务</strong>”等等的开发思想，“<strong>跨域</strong>”这个问题开始频繁地出现在人们的视野中，从最初的<strong>JSONP</strong>，到如今成为事实标准的<strong>CORS</strong>，甚至从<strong>Vue</strong>里的代理服务器、<strong>Nginx</strong>里的反向代理，我们总是能窥出一点“<strong>跨域</strong>”的影子，“<strong>跨域</strong>”可谓是无处不在。</p>
<p>那么，什么是 CORS 呢？ CORS ，即跨域资源共享，是一种利用 HTTP 头部来指示服务器端对除自身以外的源(域、协议、端口)是否可以访问指定的资源。你可能会联想到<strong>OAuth2</strong>、<strong>JWT</strong>等等关于认证授权的词汇，请注意，“跨域”始终发生在浏览器端，相对于浏览器，一般意义上的客户端都被视为可信任的。除此之外，CORS提供了一种被称之为“预检”的机制，它可以用来检测服务器端支持的 HTTP 请求头、HTTP 动词，在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p>
<p><img src="https://media.prod.mdn.mozit.cloud/attachments/2016/10/28/14295/a21a85eaccd405d608395b4ca8d82538/CORS_principle.png" alt="为什么会发生跨域？"></p>
<p>如上图所示，浏览器端，特别是<code>XMLHttpRequest</code> 、<code>Fetch API</code> 、<code>Web</code>字体 和 <code>Canvas</code>等始终遵循同源策略，<code>domain-a.com</code>和<code>domain-b.com</code>被视为两个不同域，因此，当<code>domain-a.com</code>试图访问<code>domain-b.com</code>下的资源时，就会被浏览器所限制，这就是我们所说的“<strong>跨域</strong>”。可能，这并不是一个特别好的例子，因为 HTML 中某些元素天生就被设计为允许跨域，例如：<code>image</code>、<code>iframe</code>、<code>link</code>、<code>script</code>等等。而如果我们通过“<strong>协商</strong>”来告诉<code>domain-b</code>，<code>domain-a</code>希望访问它下面的资源，这其实就是我们所说的 CORS 啦！这个“<strong>协商</strong>”过程呢，主要有两种，即 <strong>简单请求</strong> 和 <strong>复杂请求</strong>。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>我们将不触发 CORS 预检 的请求称为简单请求，通常情况下，简单请求满足下列条件：</p>
<ul>
<li>使用下列方法之一：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET">GET</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">HEAD</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">POST</a></li>
<li>除了被用户代理自动设置的首部字段(例如：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection">Connection</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent">User-Agent</a>) 和 在 Fetch 规范中定义为 <a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/#forbidden-header-name">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">对 CORS 安全的首部字段集合</a>。该集合为：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language">Accept-Language</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language">Content-Language</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type">Content-Type</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#dpr">DPR</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#downlink">Downlink</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#save-data">Save-Data</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#viewport-width">Viewport-Width</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#width">Width</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type">Content-Type</a> 的值仅限于下列三者之一：text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded</li>
<li>请求中的任意 <a href="">XMLHttpRequestUpload</a> 对象均没有注册任何事件监听器；<a href="">XMLHttpRequestUpload</a> 对象可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload">XMLHttpRequest.upload</a> 属性访问。</li>
<li>请求中没有使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream">ReadableStream</a> 对象。</li>
</ul>
<p>对于 <strong>简单请求</strong> ，由于它的 HTTP 动词是确定的，故其跨域主要体现在服务器端返回的 HTTP 响应中，可能出现的响应头有：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Headers</code>等。所以，如果客户端请求的<code>Origin</code>被包含在服务器端返回的<code>Access-Control-Allow-Origin</code>中，则表示跨域被允许，反之则不被允许。所以，现在大家应该能想明白，为啥那些年里大家稀里糊涂地，把<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Headers</code>设置为<code>*</code>就万事大吉了吧，而对照着中间件的代码，理解这层含义会更容易一点！</p>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>与简单请求不同，<strong>复杂请求</strong> 要求必须首先使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS">OPTIONS</a> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”<strong>预检请求</strong>“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<p><img src="https://media.prod.mdn.mozit.cloud/attachments/2019/06/19/16753/b32f78ac26d18e3e155205e4f0057b73/preflight_correct.png" alt="预检请求"></p>
<p>当浏览器检测到，从<code>JavaScript</code>中发起的请求需要被预检。此时，可以注意到，预检请求中同时携带了下面两个首部字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers：X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>

<p>服务器在接受预检请求后，会返回以下响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>首部字段<code>Access-Control-Allow-Methods</code>表明服务器允许客户端使用 POST、GET 和 OPTIONS 方法发起请求。</li>
<li>首部字段<code>Access-Control-Allow-Headers</code>表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。</li>
<li>首部字段<code>Access-Control-Max-Age</code>表明该响应的有效时间为 86400 秒，即 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</li>
</ul>
<p>下面整理了 CORS 中常见的 <strong>Access-Control</strong> 系列头部字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Expose-Headers</span><br><span class="line">Access-Control-Max-Age</span><br><span class="line">Access-Control-Allow-Credentials</span><br><span class="line">Access-Control-Allow-Methods</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line">Origin</span><br><span class="line">Access-Control-Request-Method</span><br><span class="line">Access-Control-Request-Headers</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分别从 <strong>源代码</strong> 和 <strong>规范</strong> 两个角度探讨了 “<strong>跨域</strong>” 这个话题，两者可以说是相辅相成的存在，CORS 中间件实现了 CORS 规范，而通过 CORS 规范帮助我们理解了中间件。“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了 “<strong>跨域</strong>” 这一限制。最初我们通过 <strong>JSONP</strong> 这种方案来解决跨域问题，而后来我们有了<strong>CORS</strong> 这种事实上的标准，其原理上利用 <strong>Origin</strong> 及 <strong>Access-Control</strong>系列的头来标识服务器端可以允许哪些源、以什么样的 HTTP 动词 &#x2F; 头来访问资源，按照 CORS 规范，浏览器端发起的请求被分为： <strong>简单请求</strong> 和 <strong>复杂请求</strong> 两种，两者最大的区别是，<strong>复杂请求</strong> 必须首先通过 <strong>OPTIONS</strong> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。好了，以上就是这篇博客的全部内容啦，欢迎大家在博客评论中参与讨论，再次谢谢大家，晚安！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/14/2021-03-14-forevermissed-dengzr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/14/2021-03-14-forevermissed-dengzr/" itemprop="url">缅怀子睿</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-14T19:48:11+08:00">
                2021-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/images/dengzr-4.png" width="400px" />

<p>就在几天前，我的大学同学、ACM 竞赛队友邓子睿因为癌症离开了。他今年才 35 岁，一直在硅谷的微软工作，刚刚成家立业，正是大展宏图的年纪。此时离开，让我和班上同学都感慨上天不公，造物弄人。</p>
<p>回想起来，因为共同参加学校 ACM&#x2F;ICPC 程序设计竞赛并且为同队队友，邓子睿可以算是和我相处时间最久的大学同学了。</p>
<p>邓子睿高中在全国有名的湖南雅礼中学，以 NOIP 信息学竞赛省一等奖的成绩保送北京师范大学信息学院。</p>
<p>邓子睿高中因为全力备战竞赛，所以放弃了很多正常的高中生的课程学习，这让他的 NOIP 竞赛更像是背水一战，特别是他当年是参加了两届竞赛，在高三那届竞赛才拿到了保送资格，这让他一直耿耿于怀。</p>
<p>所以在进入大学之后，邓子睿在参加 ACM 竞赛的时候，没有落下任何的学业，一直在班上成绩保持前十名。他说他受不了高中时候那种感受，他一定要竞赛好的同时把成绩也搞好。</p>
<p>他真的做到了。ACM&#x2F;ICPC 竞赛 3 人一队，我和他同为一组，2005 年，我们一起为北京师范大学拿下了历史上的首个银奖，也是学校 ACM 队首次获得奖牌（当时获奖率只有前 20%）。同时，他在大四的时候，因为成绩优异，拿到了保送到北京大学人工智能学院的机会。</p>
<img src="/images/dengzr-1.jpeg" class="">

<p>因为 4 年的队友关系，我们一直保持着联系。研究生阶段虽然在不同的学校，但是我们时不时会回师大聚聚，看望一下我们竞赛的老师冯速老师。研究生毕业后，他选择了微软中国，而我选择了网易。</p>
<p>我们工作后的头几年也时常聚会。他在微软的头几年并不算特别顺利，他本来希望尽快 transfer 到美国，但是因为各种原因总是耽搁。终于有一天他请大家吃饭，宣布自己拿到了 transfer 的机会，我们都很高兴。</p>
<p>到美国之后，每一次有机会回国内，我们就会约上吃一顿。邓子睿还是一样的精力旺盛，滑雪、拉丁舞、摄影，各种广泛的爱好把自己的生活过得有滋有味。最后一次合影，是 18 年 11 月，那次他因为工作短暂停留北京，当时微软的市值第一次超过了苹果，我们畅谈之后都祝愿大家事业越来越好。</p>
<p>没想到，这竟然是最后一次聚会了。</p>
<img src="/images/dengzr-2.jpeg" class="">

<p>就在一个月前，邓子睿主动联系了我，介绍了他的病情，希望我没事多和他聊聊天。当我知道他已经是肺癌晚期，已经开始做化疗的时候，我当时难过得说不出话来。反倒是他安慰我说，这边有最好的治疗条件，妈妈也来美国照顾他了，而且还有老婆，身边很多朋友都很关心，医保能够支付大部分的费用。</p>
<p>这一个月，我们会时不时地发一些好玩的东西，因为时差和治疗，我们之间回复的间隔比较长。我默默地祝福着他，希望他能扛过这一切。直到几天前，早上起来突然收到胡博的微信，说子睿已经离开了。</p>
<p>他的老婆<a target="_blank" rel="noopener" href="https://www.forevermissed.com/zirui-deng/about">为他建立了一个网站</a>，上面有他从小到大的各种照片，我也翻到了我们当时的合影。那真是一个无忧无虑的年纪：</p>
<img src="/images/dengzr-3.jpg" class="">

<p>邓子睿这一生，活得精彩，只是走得太快，带着太多亲人与朋友的思念。</p>
<p>愿天堂没有病痛，也愿活着的人都珍惜现在。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/10/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/10/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/" itemprop="url">源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-10T21:52:47+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇文章中，博主带领大家一起深入了解 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件，正当我得意洋洋地向 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/">Catcher Wong</a> 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过<code>SeamphoreSlim</code>控制线程数量而已，一旦放到分布式环境中，这个并发控制就被大大地削弱。所以，在今天这篇文章中，博主会带领大家一起“<strong>探案</strong>” <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的限流中间件 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimite</a>，希望大家可以从中感悟到不一样的东西。对我而言，这可能是人到中年的焦虑感所催生出来的一种源动力，同时亦是为了不让那些订阅专栏的同学失望。</p>
<p>关于“<strong>限流</strong>”这个话题，我个人以为，它可以引申出非常多的东西，譬如“熔断”和“限流”，其实可以看作是同一类问题的“一体两面”。最早接触熔断，是源于 <strong>Spring Cloud</strong> 中的 <strong>Hystrix</strong>，它其实是指当服务不可用的时候，客户端应该采取什么样的措施去应对，实际使用中我们可能会考虑重试、超时、降级等策略。相应地，当服务端在面对来自客户端的异常流量时，就产生了“限流”这个概念，“限流”可以是线程隔离**(<strong>线程数 + 队列大小限制</strong>)，可以是信号量隔离(<strong>设置最大并发请求数目</strong>)，可以是限制QPS。这里，我们讨论的主要是第三种，而实现限流的常见算法主要有<strong>计数器算法</strong>、<strong>漏桶算法</strong>和<strong>令牌桶算法</strong>。这里，<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 这个中间件，则主要使用了<strong>计数器算法</strong>，并配合 <code>IMemoryCache</code> 和 <code>IDistributedCache</code> 分别实现了基于内存和基于分布式缓存的持久化逻辑。</p>
<h1 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h1><p>首先，使用者通过配置定义了一个或者多个规则，这些规则决定了每个客户端在访问特定终结点时，一段时间内可以访问的最大次数。 <a href="">RateLimitMiddleware</a> 通过注入的<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs">IRateLimitProcessor</a> 来匹配规则，然后依次判断每个规则是否达到了限流条件。一旦达到限流条件，中间件会改变 HTTP 响应的状态码、响应头、返回值，告知使用者已达到最大调用次数。而针对每一种 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Core/IRateLimitProcessor.cs">IRateLimitProcessor</a> ，主要通过<code>ProcessRequestAsync()</code> 方法来实现计数，如果上一次的请求对应的时间戳 + 规则中时间间隔 &gt;&#x3D; 当前时间，则说明请求没有过期，此时，就需要给这个计数增加1。好了，现在我们来针对 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 中的核心部件逐个进行解读。</p>
<h2 id="RateLimitProcessor"><a href="#RateLimitProcessor" class="headerlink" title="RateLimitProcessor"></a>RateLimitProcessor</h2><p><code>RateLimitProcessor</code>，是一个抽象类，实现了<code>IRateLimitProcessor</code>接口，公开的方法有 3 个：<code>ProcessRequestAsync()</code>、<code>IsWhitelisted()</code> 和 <code>GetRateLimitHeaders()</code>。在此基础上，派生出<code>ClientRateLimitProcessor</code>和<code>IpRateLimitProcessor</code>两个子类。两者最大的不同在于，其所依赖的<code>Store</code>不同，前者为<code>IClientPolicyStore</code>，后者<code>IIpPolicyStore</code>，它们都实现了同一个接口<code>IRateLimitStore</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRateLimitStore</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">ExistsAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">GetAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">SetAsync</span>(<span class="params"><span class="built_in">string</span> id, T entry, TimeSpan? expirationTime = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，这些都是典型的基于键-值的存储，所以，不管是基于内存的IMemeryCache，还是基于分布式缓存的IDistributedCache，都可以做到无缝切换。不同的Processor，本质上是它们生成缓存键的方式不同，例如，<code>IpRateLimitProcessor</code>是用一个前缀来表示一组IP，而<code>ClientRateLimitProcessor</code>则是用通过客户端前缀和客户端Id来作为区分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/IpRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policies = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.IpPolicyPrefix&#125;</span>&quot;</span>,</span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">new</span> List&lt;RateLimitRule&gt;();</span><br><span class="line">    <span class="keyword">if</span> (policies?.IpRules?.Any() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for rules with IP intervals containing client IP</span></span><br><span class="line">        <span class="keyword">var</span> matchPolicies = policies.IpRules</span><br><span class="line">            .Where(r =&gt; IpParser.ContainsIp(r.Ip, identity.ClientIp));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> matchPolicies)</span><br><span class="line">        &#123;</span><br><span class="line">            rules.AddRange(item.Rules);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/ClientRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policy = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.ClientPolicyPrefix&#125;</span>_<span class="subst">&#123;identity.ClientId&#125;</span>&quot;</span>, </span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, policy?.Rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>RateLimitProcessor</code>而言，其实现思路是，通过<code>CounterKeyBuilder</code>及其子类来生成计数器标识(<strong>CounterId</strong>)，然后再通过<code>AsyncKeyLock</code>来实现计数，最终通过<code>IRateLimitCounterStore</code>来实现存储：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">async</span> Task&lt;RateLimitCounter&gt; <span class="title">ProcessRequestAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    ClientRequestIdentity requestIdentity, </span></span></span><br><span class="line"><span class="params"><span class="function">    RateLimitRule rule, </span></span></span><br><span class="line"><span class="params"><span class="function">    CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">    &#123;</span><br><span class="line">        Timestamp = DateTime.UtcNow,</span><br><span class="line">        Count = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成CounterId</span></span><br><span class="line">    <span class="keyword">var</span> counterId = BuildCounterKey(requestIdentity, rule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于AsyncLock的计数器</span></span><br><span class="line">    <span class="comment">// serial reads and writes on same key</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">await</span> AsyncLock.WriterLockAsync(counterId).ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = <span class="keyword">await</span> _counterStore.GetAsync(counterId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// entry has not expired</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value.Timestamp + rule.PeriodTimespan.Value &gt;= DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increment request count</span></span><br><span class="line">                <span class="keyword">var</span> totalCount = entry.Value.Count + _config.RateIncrementer?.Invoke() ?? <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep copy</span></span><br><span class="line">                counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">                &#123;</span><br><span class="line">                    Timestamp = entry.Value.Timestamp,</span><br><span class="line">                    Count = totalCount</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计数器存储</span></span><br><span class="line">        <span class="comment">// stores: id (string) - timestamp (datetime) - total_requests (long)</span></span><br><span class="line">        <span class="keyword">await</span> _counterStore.SetAsync(</span><br><span class="line">            counterId, </span><br><span class="line">            counter, </span><br><span class="line">            rule.PeriodTimespan.Value, </span><br><span class="line">            cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AsyncKeyLock"><a href="#AsyncKeyLock" class="headerlink" title="AsyncKeyLock"></a>AsyncKeyLock</h2><p>在分析<code>RateLimitProcessor</code>类的时候，我们提到了<code>AsyncKeyLock</code>。对于<code>AsyncKeyLock</code>的实现，我个人认为这是整个中间件的精华，因为这里出现了，和<code>SeamphoreSlim</code>一样经典的东西，这里用到了自旋锁<code>SpinLock</code>。我个人理解，<code>SpinLock</code> 约等于 <code>Interlocked</code> + 内核级别的while。这部分代码本身并不复杂，难就难在这样一个精妙的想法上面。其中，<a href="">AsyncKeyLockDoorman</a> 这个类的实现，应该是参考了微软的一篇博客—— <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/">Building Async Coordination Primitives, Part 7: AsyncReaderWriterLock</a>，因为<code>ReaderLockAsync()</code>、<code>WriterLockAsync()</code>、<code>ReaderRelease()</code> 和 <code>WriterRelease()</code> 这 4 个关键方法完全一样。结合限流这个场景来看，它是典型的“<strong>多写</strong>”场景，因为如果是相同的请求，那么就会产生相同的计数器标识(<strong>CounterId</strong>)，所以，这个<code>AsyncLockDoorman</code>这个类所定义的上下文边界，其实是“<strong>一读多写</strong>”的问题，所以，我们可以注意到，它里面定义了一个“写”操作的队列<code>_waitingWriters</code>，一个“读操作”的<code>_waitingReader</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncKeyLockDoorman</span>(<span class="params">Action&lt;AsyncKeyLockDoorman&gt; reset</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 多个写入者</span></span><br><span class="line">    _waitingWriters = <span class="keyword">new</span> Queue&lt;TaskCompletionSource&lt;Releaser&gt;&gt;();</span><br><span class="line">    <span class="comment">// 单个读取者</span></span><br><span class="line">    _waitingReader = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">    _status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _readerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">false</span>));</span><br><span class="line">    _writerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">true</span>));</span><br><span class="line">    _reset = reset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“写”操作而言，当一个新的写入者希望进来的时候，如果此时锁没有被别人占用，那么这个新的写入者会获得这个锁，状态值<code>m_status</code>会被修改为-1。反之，如果此时这个锁已经被别人占用了，那么这个新的写入者将会进入等待队列。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">WriterLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _status = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> _writerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">            _waitingWriters.Enqueue(waiter);</span><br><span class="line">            <span class="keyword">return</span> waiter.Task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“读”操作而言，我们来思考这样一个问题，什么时候“读”操作会被允许呢？答案是这一时刻没有写入者正在“写”或者“等”，因为如果不这样的话，就会发生我们平常所说的“<strong>脏读</strong>”，所以，这种情况下，就必须强迫“读取者”去等待写入者“空闲”下来。此时，不难理解<code>ReadLockAsync()</code>的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">ReaderLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status &gt;= <span class="number">0</span> &amp;&amp; _waitingWriters.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_status;</span><br><span class="line">            <span class="keyword">return</span> _readerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++_readersWaiting;</span><br><span class="line">            <span class="keyword">return</span> _waitingReader.Task.ContinueWith(t =&gt; t.Result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们把视线拉回到<code>AsyncKeyLock</code>，它负责维护一组<code>AsyncKeyLockDoorman</code>，其内部部通过一个字典来维护<code>CounterId</code>和<code>AsyncKeyLockDoorman</code>间的关系。与此同时，为了减少创建·AsyncKeyLockDoorman·带来的性能损耗，它使用一个栈来存储<code>AsyncKeyLockDoorman</code>。每次获取<code>AsyncKeyLockDoorman</code>的过程，本质上就是为指定的<code>Key</code>分配<code>AsyncKeyLockDoorman</code>的过程，同时会更新其引用数<code>RefCount</code>。相应地，释放<code>AsyncKeyLockDoorman</code>的过程，本质上就是减少其引用数<code>RefCount</code>，从字典中移除指定<code>Key</code>，“<strong>归还</strong>”对象池的过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AsyncKeyLockDoorman <span class="title">GetDoorman</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncKeyLockDoorman doorman;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (!Keys.TryGetValue(key, <span class="keyword">out</span> doorman))</span><br><span class="line">        &#123;</span><br><span class="line">            doorman = (Pool.Count &gt; <span class="number">0</span>) ? Pool.Pop() : </span><br><span class="line">                <span class="keyword">new</span> AsyncKeyLockDoorman(ReleaseDoorman);</span><br><span class="line">            doorman.Key = key;</span><br><span class="line">            Keys.Add(key, doorman);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doorman.RefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doorman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseDoorman</span>(<span class="params">AsyncKeyLockDoorman doorman</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (--doorman.RefCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Keys.Remove(doorman.Key);</span><br><span class="line">            <span class="keyword">if</span> (Pool.Count &lt; MaxPoolSize)</span><br><span class="line">            &#123;</span><br><span class="line">                doorman.Key = <span class="literal">null</span>;</span><br><span class="line">                Pool.Push(doorman);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RateLimitMiddleware"><a href="#RateLimitMiddleware" class="headerlink" title="RateLimitMiddleware"></a>RateLimitMiddleware</h2><p>OK，到这里，我们再回过头去看<strong>源代码解读</strong>这里的内容，大概就可以串起来整合中间件的调用链路，<code>Middleware</code>-&gt;<code>RateLimteProcessor</code>-&gt;<code>AsyncKeyLock</code>-&gt;<code>AsyncKeyLockDoorman</code>，坦白来讲，我一直没能想明白为什么要用<code>SpinLock</code>？难道仅仅是为了减少等待时间、提高性能吗？经过精简，我们发现，整个中间件的<code>Invoke()</code>方法，大致要经历下面几个阶段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查限流是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (_options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户身份</span></span><br><span class="line">    <span class="keyword">var</span> identity = <span class="keyword">await</span> ResolveIdentityAsync(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查白名单</span></span><br><span class="line">    <span class="keyword">if</span> (_processor.IsWhitelisted(identity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取限流规则</span></span><br><span class="line">    <span class="keyword">var</span> rulesDict = <span class="keyword">new</span> Dictionary&lt;RateLimitRule, RateLimitCounter&gt;();</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">await</span> _processor.GetMatchingRulesAsync(</span><br><span class="line">        identity, </span><br><span class="line">        context.RequestAborted</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> rule <span class="keyword">in</span> rules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取计数器数目</span></span><br><span class="line">        <span class="keyword">var</span> rateLimitCounter = <span class="keyword">await</span> _processor.ProcessRequestAsync(</span><br><span class="line">            identity, </span><br><span class="line">            rule, </span><br><span class="line">            context.RequestAborted</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (rule.Limit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求未过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value &lt; DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Count &gt; rule.Limit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 各种记日志，告诉调用者多长时间后再重试</span></span><br><span class="line">                <span class="keyword">var</span> retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中止请求</span></span><br><span class="line">                <span class="keyword">await</span> ReturnQuotaExceededResponse(context, rule, retryAfter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Limit &lt;= 0, 相当于直接不允许放行，中止请求</span></span><br><span class="line">            <span class="keyword">await</span> ReturnQuotaExceededResponse(</span><br><span class="line">                context, </span><br><span class="line">                rule, </span><br><span class="line">                <span class="built_in">int</span>.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture)</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置X-Rate-Limit头</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>作为 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/18417412/">并发限制</a> 这一篇的“姊妹篇”，这一篇的难度相对上一篇堪称“高山仰止”，主要的难点是 <strong>SpinLock</strong> 、“一读多写”的异步读写锁 <strong>AsyncKeyLock</strong> 以及 <strong>AsyncKeyLockDoorman</strong> 。如果大家感兴趣的话，可以去搜索一下 <strong>AsyncKeyLock</strong> 这个关键字，大家就会发现在好多<a target="_blank" rel="noopener" href="https://github.com/SixLabors/ImageSharp.Web/">开源项目</a> 中都能找到类似的代码片段，莫非这是某种神奇的算法吗？阅读源代码，其实是一个无法“立竿见影”的学习方法，有时候我们要通过叙述或者表达来输出我们对待一件事物的看法。这是因为，我们自以为是的“学会”和真正的“学会”，这两者间可能千差万别，就像我最近在用 <a target="_blank" rel="noopener" href="https://abp.io/">ABP vNext</a> 搭建一个小项目，阅读文档的时候，眼睛觉得它“学会”了，而实际需要需要扩展或者替换 ABP 的实体&#x2F;服务的时候。我的手会告诉我，它真的“不会”。做一个知难行易的“调包”侠也许会非常容易，可正因为如此，你要凸显自我就会非常困难。世上的事情，“<strong>夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</strong>”，哪怕就是增长一下见识呢，你说对吧……</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/05/2021/spatial-audio-for-local-videos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/05/2021/spatial-audio-for-local-videos/" itemprop="url">尝试为本地视频开启 AirPods Pro 空间音频</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-05T20:04:00+08:00">
                2021-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index">
                    <span itemprop="name">日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>继 <a target="_blank" rel="noopener" href="https://prinsss.github.io/airpods-2-are-great/">AirPods 2</a> 之后，前段时间我又没忍住，入手了传说中的<del>豌豆射手</del> AirPods Pro。</p>
<p>第一次体验到的「主动降噪」功能确实惊艳，虽然感觉对人声的处理还是差了点意思，但开和不开真的是两种完全不同的感受。尤其是乘坐公共交通的时候，感觉是终于夺回了一点耳朵的主导权，不用再一味地被各种噪声强奸了。</p>
<p>用了几个月，总的来说挺满意的，就是这人声降噪实在是普通，近处的人说话大声点就挡不住了（比如室友），只能开音乐盖过去。有人说是后续固件削弱了，不过我感觉买来就这吊样。可惜市面上还是没有能达到聋子模拟器效果的降噪耳机，遗憾。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/03/05/2021/spatial-audio-for-local-videos/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/04/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/04/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/" itemprop="url">源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-04T20:13:47+08:00">
                2021-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>打算开一个新的专栏——<strong>源代码探案系列</strong>，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“<strong>生手</strong>”到“<strong>熟练工</strong>”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个“<strong>手艺人</strong>”，可我更想说一句古人的话——<strong>君子不器</strong>。什么是器呢？“<strong>形而上者谓之道，形而下者谓之器</strong>”，用一句更直白的话来说，就是“<strong>不能知其然而不知其所以然</strong>”，这是我一个非CS科班出身的程序员，想去写这样一个专栏的初衷，因为在我看来，“<strong>器</strong>”是永远学不完的，而“<strong>道</strong>”虽然听起来虚无缥缈，实则“<strong>朝闻道，夕死可矣</strong>”。</p>
<p>作为这个专栏的第一篇博客，我打算从 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件开始。并发是一个爱恨交织的话题，我们喜欢高并发，因为这是程序员跻身高手行列的好机会；我们厌恶并发，因为它引入了多线程、锁、信号量这些复杂的东西。相信大家都曾被并发困扰过，古人云：<strong>他山之石，可以攻玉</strong>，还有什么比阅读源代码更朴实无华的“学习”呢？你找大牛，大牛可能忙着开会、做PPT；你找同事，同事里可能十个有八个都不知道啊。这个中间件的核心是 <code>IQueuePolicy</code> ，其位于以下<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter/src/QueuePolicies">位置</a>，它定义了两个核心的方法：<code>TryEnterAsync()</code> 和 <code>OnExit()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueuePolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其默认实现<code>QueuePolicy</code>中，<code>TryEnterAsync()</code>方法，决定着一个请求是会被拒绝还是接受。具体是怎么做呢？它定义了一个最大的并发请求数目，如果实际数超过了最大的并发请求数目，那么请求将会被拒绝。反之，请求将被接受。再仔细看，我们就会发现，它内部使用了<code>SeamphoreSlim</code>和<code>Interlocked</code>，所以，聪明的小伙伴们应该立马会联想到，这两种锁各自的作用是什么。</p>
<p>其中，<code>Seamphore</code> 是一个 Windows 内核中的一个同步信号量，适用于在多个有限的线程资源中共享内存资源，它就像一个栅栏，本身具有一定的容量，当线程数量达到这个容量后，新的线程就无法再通过，直到某个线程执行完成。<code>SeamphoreSlim</code>是<code>Seamphore</code>优化后的版本，在性能上表现更好一点，更推荐大家使用<code>SeamphoreSlim</code>。</p>
<p>而 <code>Interlocked</code> 的则是我们熟悉的原子操作，它可以在多个线程中，对共享的内存资源进行原子加或者原子减操作。在这里，<code>Interlocked</code>主要用来控制并发请求数的加和减。如果当前的并发请求数小于最大的并发请求数，表示还可以允许新的请求进来，此时，<code>TryEnterAsync()</code>方法会返回true。如果此时的并发请求数大于最大的并发请求数，则需要对当前请求数进行减操作，此时，<code>TryEnterAsync()</code>方法会返回false。</p>
<p>一旦搞清楚这一点，结合中间件的代码，我们可以非常容易地想明白,这个并发控制的实现思路。下面是<code>QueuePolicy</code>中<code>TryEnterAsync()</code>和<code>OnExit()</code>两个方法的实现，分别代表了“<strong>加锁</strong>”和“<strong>解锁</strong>”两个不同的阶段。某种程度上，<code>Seamphore</code>更像一个水闸，每次可以通过的“<strong>流量</strong>”是固定的，超出的部分会被直接“<strong>拒绝</strong>”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“加锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a return value of &#x27;false&#x27; indicates that the request is rejected</span></span><br><span class="line">    <span class="comment">// a return value of &#x27;true&#x27; indicates that the request may proceed</span></span><br><span class="line">    <span class="comment">// _serverSemaphore.Release is *not* called in this method, </span></span><br><span class="line">    <span class="comment">// it is called externally when requests leave the server</span></span><br><span class="line">    <span class="built_in">int</span> totalRequests = Interlocked.Increment(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前请求次数 &gt; 最大请求次数，返回false表示拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests &gt; _maxTotalRequest) &#123;</span><br><span class="line">        Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task task = _serverSemaphore.WaitAsync();</span><br><span class="line">    <span class="keyword">if</span> (task.IsCompletedSuccessfully) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SemaphoreAwaited(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“解锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _serverSemaphore.Release();</span><br><span class="line">    Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="揭秘-StackPolicy"><a href="#揭秘-StackPolicy" class="headerlink" title="揭秘 StackPolicy"></a>揭秘 StackPolicy</h1><p>除了<code>QueuePolicy</code>这种实现以外，官方还提供了<code>StackPolicy</code>的实现。从名称上，我们就能大致区分出它们的不同，因为我相信大家都能拎得清“队列”和“栈”。在实现<code>StackPolicy</code>的过程中，首先会判断是否还有访问请求次数<code>_freeServerSpots</code>，直接返回true，确保中间件可以继续执行。如果<code>_queueLength</code>和我们设置的队列最大容量相同，此时，表示队列已满，需要先取消之前的请求，并保留后来的请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValueTask</span>&lt;<span class="title">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_freeServerSpots &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，则取消之前的请求，即_head</span></span><br><span class="line">        <span class="keyword">if</span> (_queueLength == _maxQueueCapacity) &#123;</span><br><span class="line">            _hasReachedCapacity = <span class="literal">true</span>;</span><br><span class="line">            _buffer[_head].Complete(<span class="literal">false</span>);</span><br><span class="line">            _queueLength--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tcs = _cachedResettableTCS ?? </span><br><span class="line">            = <span class="keyword">new</span> ResettableBooleanCompletionSource(<span class="keyword">this</span>);</span><br><span class="line">        _cachedResettableTCS = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_hasReachedCapacity || _queueLength &lt; _buffer.Count) &#123;</span><br><span class="line">            _buffer[_head] = tcs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _buffer.Add(tcs);</span><br><span class="line">        &#125;</span><br><span class="line">        _queueLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment _head for next time</span></span><br><span class="line">        <span class="comment">// 如果_head = 最大队列容量，则_head需要移动至首位</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="keyword">if</span> (_head == _maxQueueCapacity) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.GetValueTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queueLength == <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots++;</span><br><span class="line"></span><br><span class="line">            f (_freeServerSpots &gt; _maxConcurrentRequests) &#123;</span><br><span class="line">                _freeServerSpots--;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;OnExit must only be called once per successful call to TryEnterAsync&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step backwards and launch a new task</span></span><br><span class="line">    <span class="keyword">if</span> (_head == <span class="number">0</span>) &#123;</span><br><span class="line">        _head = _maxQueueCapacity - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _head--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _buffer[_head].Complete(<span class="literal">true</span>);</span><br><span class="line">    _queueLength--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，现在，你可以感受到这两种策略的差异了，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。此时，如果我们再回过头来看 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 这个中间件的实现，就会有种恍然大悟的感觉。</p>
<h1 id="揭秘-Middleware"><a href="#揭秘-Middleware" class="headerlink" title="揭秘 Middleware"></a>揭秘 Middleware</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure we only ever call GetResult once on the TryEnterAsync ValueTask b/c it resets.</span></span><br><span class="line">    <span class="comment">// 以下代码片段，其实都是调用IQueuePolicy.TryEnterAsync()</span></span><br><span class="line">    <span class="keyword">var</span> waitInQueueTask = _queuePolicy.TryEnterAsync();</span><br><span class="line">    <span class="built_in">bool</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitInQueueTask.IsCompleted) &#123;</span><br><span class="line">        ConcurrencyLimiterEventSource.Log.QueueSkipped();</span><br><span class="line">        result = waitInQueueTask.Result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> (ConcurrencyLimiterEventSource.Log.QueueTimer())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">await</span> waitInQueueTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当result为true，表示请求被接收，此时，让中间件继续执行</span></span><br><span class="line">    <span class="comment">// 切记：调用_queuePolicy.OnExit()来释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _queuePolicy.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是请求被拒绝的情况，修改状态码以及输出错误信息</span></span><br><span class="line">        ConcurrencyLimiterEventSource.Log.RequestRejected();</span><br><span class="line">        ConcurrencyLimiterLog.RequestRejectedQueueFull(_logger);</span><br><span class="line">        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;</span><br><span class="line">        <span class="keyword">await</span> _onRejected(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就理清了整个中间件的运作机制，<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 中注入了<code>IQueuePolicy</code>这个接口，当一个新的请求进来，中间件会调用<code>IQueuePolicy</code>接口的<code>TryEnterAsync()</code>方法，该方法决定了一个请求是会被接受还是拒绝。当请求被接受的时候，中间件会调用<code>_next(context)</code>让请求继续往下走；当请求被拒绝的时候，中间件会修改 HTTP 状态码(503) 和 返回值，保证调用者可以收到错误信息。这就是这个中间件全部的秘密。而如果要在项目中使用这个中间件，同样是非常简单的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 中间件基本法，先注册后使用</span></span><br><span class="line"><span class="comment">// ConfigureServices()</span></span><br><span class="line"><span class="comment">// 或者 services.AddQueuePolicy()</span></span><br><span class="line">services.AddStackPolicy(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">    options.RequestQueueLimit = <span class="number">25</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure()</span></span><br><span class="line">app.UseConcurrencyLimiter();</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，主要揭秘了 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 中间件，这个中间件的主要功能是控制 ASP.NET Core 中的请求并发。作为这个中间件的核心，微软为 <code>IQueuePolicy</code> 接口提供了 <code>QueuePolicy</code> 和 <code>StackPolicy</code> 两种不同的策略实现。其中，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。对于我们而言，这个中间件最值得学习的地方，其实是<code>SeamphoreSlim</code>和<code>Interlocked</code>，我们经常提到“<strong>锁</strong>”，其实，“<strong>锁</strong>”不单单是指 .NET 中<code>Monitor</code>的语法糖，即<code>lock</code>关键字，在同步信号量以及线程同步的相关话题中，我们还会接触到譬如 <strong>Mutex(互斥锁)<strong>、ReaderWriterLockSlim、</strong>Interlocked(原子操作)<strong>、</strong>SpinLock(自旋锁)</strong> 以及 SeamphoreSlim 等等不同的“<strong>锁</strong>”。除此之外，还有譬如AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 等等的同步信号量。如果有读者朋友对此感兴趣，可以到 MSDN 上去搜索相关的关键字，能让博主本人和大家从中有所收获，这是我坚持写下去的理由。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、讨论。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/03/2021-03-04-2020-feb-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/03/2021-03-04-2020-feb-summary/" itemprop="url">二月总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-03T19:16:16+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">从思辨中学历史</a></li>
</ul>
<h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>因为上家公司经营不佳，所以被通知年后不用复工了，于是我开始了找工作的日子。说实话我挺喜欢小城市的生活节奏的，不太愿意回到广州这种一线城市。一线城市的人总是匆匆忙忙的，小城市虽然人少，但更有人情味，而在一线城市，哪怕挤地铁时别人就贴在自己身边，但其实出了地铁后，你可能就会忘记这个人，并无多少交集，甚至连他长什么样都不知道，所以我更喜欢小城市。但可惜我所在的小城市这类公司太少，薪资待遇也跟不上，无奈也只能回广州了。</p>
<p>经过了一个星期的面试，总算收到一个心仪的 offer，前天刚入职，就目前情况来看还是很不错的。有了之前的教训，这次我在公司附近的地方租房，免去上班挤地铁的痛苦，这极大提高了幸福感。</p>
<p>由于搬家东西较多，只能让父亲开车送我下来，心里有点不好受，短短几个月，行李搬来搬去的，还要他老人家陪自己奔波，暗暗下定决心，以后绝对不要频繁跳槽了，就先稳定下来吧。</p>
<h2 id="博客迁移到-Jekyll"><a href="#博客迁移到-Jekyll" class="headerlink" title="博客迁移到 Jekyll"></a>博客迁移到 Jekyll</h2><p>我之前的博客使用 hexo 搭建的，基于 <a target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题做了一些改造，至今也三年多了，我一直都挺喜欢这个主题，直到我看到这个  <a target="_blank" rel="noopener" href="https://github.com/cotes2020/jekyll-theme-chirpy">Chirpy</a>，我觉得是时候要换换花样了。但由于这个主题是 jekyll 平台的，我要用只能有两个选择：</p>
<ol>
<li>将主题适配到 hexo</li>
<li>将博客迁移到 jekyll</li>
</ol>
<p>显然方案一要更有趣，还能多一个 repo，但想到用了这么久 hexo，也想尝试一下 jekyll，所以暂时选择方案二，于是花了个把小时迁移过来。后续如果有换回 hexo 的想法，再实施方案一。</p>
<p>其实从 hexo 迁移到 jekyll 也是有损失的，比如会导致以前的文章：链接失效、评论丢失。</p>
<p>虽然上面两个问题都有办法解决，但是一来想到我的博客只是我的自留地，没什么人看，评论就更少了，并且数据也不是真的丢失了，有心的同学通过搜索引擎还是能够找到的，所以索性不管了。</p>
<p>另外一个就是不破不立嘛，今年更想多写一些技术以外的东西，虽然大部分只不过是我的牢骚罢了。</p>
<p>最后放一下博客前后主题的对比，也是跟陪伴我三年的 <a target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题讲拜拜。</p>
<p>之前：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220338.png" alt="之前"><br>现在：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220711.png" alt="之后"></p>
<h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IIilfJrCCUmOLxd70Vv1Lw">不为人知的韩国新浪潮电影，为什么那么重要？</a></li>
<li><a target="_blank" rel="noopener" href="http://einverne.github.io/post/2015/09/korean-film.html">不得不看的韩国电影</a></li>
<li><a target="_blank" rel="noopener" href="https://m.k.sohu.com/d/515933722">如今的春晚，诸神散去</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zuola.com/weblog/2005/09/298.htm">李敖北大演讲全文</a></li>
<li><a target="_blank" rel="noopener" href="http://mjlsh.usc.cuhk.edu.hk/Book.aspx?cid=4&tid=5812">不写三年大饥荒，就对不起历史和老百姓</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bmpi.dev/self/my-financial-planning/">我的家庭理财规划</a></li>
</ul>
<h3 id="文章-技术类"><a href="#文章-技术类" class="headerlink" title="文章(技术类)"></a>文章(技术类)</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2021/02/devtools">What’s New In DevTools (Chrome 90)</a></p>
<ol>
<li>New CSS flexbox debugging tools</li>
<li>New Core Web Vitals overlay</li>
<li>Issues tab updates</li>
<li>Format strings as (valid) JavaScript string literals in the Console</li>
<li>New Trust Tokens pane in the Application panel</li>
<li>Emulate the CSS color-gamut media feature</li>
<li>Improved Progressive Web Apps tooling</li>
<li>New Remote Address Space column in the Network panel</li>
<li>Performance improvements</li>
<li>Display allowed&#x2F;disallowed features in the Frame details view</li>
<li>New SameParty column in the Cookies pane</li>
<li>Deprecated non-standard fn.displayName support</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://linux.cn/article-13125-1.html?utm_source=rss&utm_medium=rss">用 Podman Compose 管理容器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/12642710.html">写给程序员的机器学习入门 (一) - 从基础说起</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh-style-guide.readthedocs.io/zh_CN/latest/">中文技术文档写作风格指南</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tidb-incubator/zh.md">自动检测工具</a></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeburst.io/5-vue-performance-tips-98e184338439">5 Advanced Tips for Vue Performance</a></p>
<ol>
<li>深度 watch 对象变更以便做一些特定操作时，建议将它转为 <code>JSON</code> 后再监听，可以减少大量内存耗费</li>
<li>不需要改变的数据使用 <code>Object.freeze</code> 冻结对象，让它不再被监听变更</li>
<li>不要用 Vuex 的 getters 来实现类似于 <code>getItemById</code> 的方法，因为它不会被缓存，可以返回一个 <code>Map</code>，通过索引的方式获取某个 Item</li>
<li>如果在 getters 或者 computed 返回一个通过拷贝的方式获取每个 Item 的列表时，修改某个 Item 会导致整个列表产生变更，从而导致整个列表组件重新渲染，应该将只需要变更的部分单独提取一个变量</li>
<li>使用 <code>IntersectionObserver</code> API 优化大量 DOM 的情况，只处理当前可见的 DOM 数据</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://web.eecs.utk.edu/~azh/blog/yestercode.html">Why is it so hard to see code from 5 minutes ago?</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API">Visual Viewport API</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://jakearchibald.com/2021/function-callback-risks/">Don’t use functions as callbacks unless they’re designed for it</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-color/#funcdef-rgb">CSS Color Module Level 4</a></p>
<ul>
<li>rgb 和 hsl 不需要用逗号分开，取而代之的是空格和 &#x2F;：<a target="_blank" rel="noopener" href="https://twitter.com/argyleink/status/1218305696862588928">点这里看看</a></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2021/02/useful-chrome-firefox-devtools-tips-shortcuts/">Useful DevTools Tips And Shortcuts (Chrome, Firefox, Edge)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jesuisundev.com/en/20-essential-web-tools-for-developers/">20 essential web tools for developers</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes">&lt;a&gt;: The Anchor element</a></p>
<ul>
<li>ping 属性了解一下</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bram.us/2021/02/23/the-future-of-css-scroll-linked-animations-part-1/">The Future of CSS: Scroll-Linked Animations with @scroll-timeline (Part 1)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.industrialempathy.com/posts/image-optimizations/">Maximally optimizing image loading for the web in 2021</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.blog/2021-02-12-avoiding-npm-substitution-attacks/">Avoiding npm substitution attacks</a></p>
</li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li><a target="_blank" rel="noopener" href="https://impatient-js.apachecn.org/#/">写给不耐烦程序员的 JavaScript（其实就是下一本 2019 年的译版）</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/deep-js/">Deep JavaScript: Theory and techniques</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/tackling-ts/">Tackling TypeScript: Upgrading from JavaScript</a></li>
<li><a target="_blank" rel="noopener" href="https://debuggingcss.com/">Debugging CSS</a></li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a target="_blank" rel="noopener" href="https://serverless.css-tricks.com/resources/">Resources - The Power of Serverless</a>：大量 serverless 相关的资源，来涨涨见识也好呀</li>
<li><a target="_blank" rel="noopener" href="https://linuxcommandlibrary.com/basic/oneliners.html?ref=tiny-helpers">Linux Command Library</a>：大量一行的 shell 命令示例</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/">CSS Working Group Editor Drafts</a>：CSS 提案列表</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/barhatsor/coco">coco</a>：使用纯 CSS3 建立 3d 组件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/chriswalz/bit">Bit</a>：现代化 Git CLI，在终端上交互式地使用 Git 命令</li>
<li><a target="_blank" rel="noopener" href="https://atool.vip/appicon/">批量生成多尺寸 APP Icon</a></li>
</ul>
<h3 id="技术（语言、类库等）"><a href="#技术（语言、类库等）" class="headerlink" title="技术（语言、类库等）"></a>技术（语言、类库等）</h3><ul>
<li><a target="_blank" rel="noopener" href="https://troisjs.github.io/">TroisJS</a>：ThreeJS + VueJS 3 + ViteJS</li>
<li><a target="_blank" rel="noopener" href="https://github.com/pmndrs/jotai">Jōtai</a>：一个 React 原始，灵活的状态管理器</li>
<li><a target="_blank" rel="noopener" href="https://motion.vueuse.org/">@vueuse&#x2F;motion</a>：一个 Vue 的可组合 API 动画库</li>
<li><a target="_blank" rel="noopener" href="https://github.com/didi/mpx">Mpx</a>：一款具有优秀开发体验和深度性能优化的增强型小程序开发框架</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/cong-si-bina-xue-xi-li-shi.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/cong-si-bina-xue-xi-li-shi.html" itemprop="url">从思辨中学历史</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-02T19:16:15+08:00">
                2021-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先介绍一下吕世浩这个人：他是国立台湾大学历史博士、北京大学考古学及博物馆学博士，曾于台湾大学历史学系任教。我前段时间学习了他的公开课：《中国古代历史与人物 —— 秦始皇》以及《史记二》，感兴趣的同学可以在互联网上免费进行观看。</p>
<p>他讲得非常好，「思辨」二字，就是他开这个课程的主要目的，学历史就是要锻炼你的思辨能力。何谓思辨？思辨是指思考辨别，哲学上指运用逻辑推导进行理论上的思考。既然是思辨，自然少不了问问题，没错，吕世浩老师在上课时会问我们很多问题，要回答这些问题就要思考。</p>
<p>我并不想无意义地重复吕世浩老师在课程中讲过的内容，但是吕世浩老师问了一些非常好的问题，也提出一些我个人非常赞同的观点，所以我会把他的观点贴在我的文章里，除此之外还有一些我个人的想法。但正如吕世浩老师所说，他的观点不一定是对的，我的更是如此，所以大家做个参考就好了。</p>
<h2 id="一、学生的目的是什么？"><a href="#一、学生的目的是什么？" class="headerlink" title="一、学生的目的是什么？"></a>一、学生的目的是什么？</h2><p>我们从小学到大学，花了十几年时间来上学，有没有问过自己这样一个问题：我们来当学生，我们的目的是什么？</p>
<p>我从小就有思考这个问题，而且在不同的年龄段，我给出的答案是不一样的，比如：</p>
<ul>
<li>在我小学三年级之前，我认为学生之所以要上学，是因为父母要工作没空管孩子，只能把孩子送到学校帮忙看管，这时候学生的目的就是乖乖呆在学校不要给父母添乱。</li>
<li>后来稍微懂事了，认为学生的目的是学识字、会算数，这样在日常生活中才能不被人欺骗。</li>
<li>上了初中，我开始厌倦当学生，觉得学校不自由，进入社会就没人可以管我，那时候我觉得当学生跟坐牢没区别，这时候我的目的就是不要当学生。</li>
<li>后来辍学出了社会，知道没有文化就只能拿最少的钱干最脏最累的活，那时候我觉得学生的目的就是要摆脱这种现状，不要走我们父母的老路。</li>
<li>现在的我比较认同的一种观点：不同层级的学生有着不同的目的，如果是一个技工院校的学生，那他的目的就是学会一门养家糊口的技能，如果是清华北大的学生，那他的目的就不能仅限于养家糊口，更应该要想着怎样为社会做出自己的贡献，能力越大责任也就越大。</li>
</ul>
<p>其实以上观点都没有错，思想是不分对错的，只有好跟坏、粗跟细的区别。</p>
<p>下面我们来看看吕世浩老师怎么说：</p>
<p>如果有同学这么多年从来没有思考过这个问题，那你就太不应该了，我们花了十几年去做一件事，怎么能不想想我们为什么要做这件事呢？</p>
<p>如果你看一本书，看完这本书后，你还是你，书还是书，那就等于没有看过这本书；如果你上一门课，上完这门课后，你却得不到任何好处，那你干嘛还要上这门课呢？这不是浪费自己的生命吗？天下没有比浪费自己生命、浪费别人的生命更大的罪。</p>
<p>所以，吕世浩老师开宗明义就是要告诉你，学生的目的就是：学——生。</p>
<p>那这个学——生又是什么意思呢？首先它肯定不是学——死的意思。</p>
<p>所以，如果一名学生完全不知道自己的目的是什么，那就是浪费自己的生命，那就不是学生，而是学死。</p>
<p>如果一名学生因为一些感情原因跑去跳楼，那他也不是在学——生。</p>
<p>西方学问重方法，中国学问重层次，其实这个学——生也是有层次的：</p>
<ul>
<li>第一个层次：如何活下去</li>
<li>第二个层次：如何活得好</li>
<li>第三个层次：如何活出衷心所愿的人生，在自己活得好的基础上，如何让身边的人活得好，再让更多的人活得好</li>
</ul>
<h2 id="二、我们活在一个什么样的时代？"><a href="#二、我们活在一个什么样的时代？" class="headerlink" title="二、我们活在一个什么样的时代？"></a>二、我们活在一个什么样的时代？</h2><p>我们究竟活在一个什么样的时代之中，吕世浩老师提出我们现在活在中国历史上的第三次巨变之中。</p>
<p>历史的本质就是变，但是变分为「小变」和「巨变」。巨变是指：整个历史的文化、制度、阶段相对来说几乎是推倒重来的。</p>
<p>他提出目前为止，中国历史上有三次巨变（关于这三次巨变都改变了什么东西可以看课程，这里就不复述了）：</p>
<ul>
<li>第一次：从仰韶到龙山</li>
<li>第二次：从战国到秦汉</li>
<li>第三次：从清末到今天</li>
</ul>
<p>我们何其幸运、又何其不幸地活在第三次巨变之中，活在巨变之中有什么特征呢？特征就是我们活在一个格局未定的时代，也就是我们活在价值观混乱与迷茫之中，我们不知道什么是正确的、什么是不正确的。</p>
<p>有同学可能会说：”我的价值观一点也不迷茫呀，我活得相当坚定呀！“。这些同学来试着回答一下吕世浩老师问的这个问题：人应不应该节俭？</p>
<p>节俭是我们中国传统习俗，每个人都应该节俭，但这样真的就是对的吗？试想如果整个社会中所有人都节俭，那么市场需求就会变小，就业需求就会降低，就有可能会导致经济危机，所以国家会想尽办法让我们消费，比如派发消费券、每年弄几个小长假来促进旅游业发展。而资本主义的本质恰恰就是刺激消费，不但让你把这个月的收入花光，还会通过各种办法来让你把下个月、下下个月的收入也提前透支掉，但是恰恰是这种主义的国家都是经济繁荣、国家百业昌盛。</p>
<p>吕世浩老师的观点讲完了，下面我想再举一个例子，来证明不同时代的人的价值观是不一样的，苏轼相信大家都知道，唐宋八大家之一，但是他当年在参加殿试时，提出了一个在我们今天看来相当惊世骇俗的观点，甚至有颠覆国家主权的嫌疑，以下内容摘抄自苏轼的<a target="_blank" rel="noopener" href="https://zh.m.wikisource.org/zh-hans/%E5%BE%A1%E8%A9%A6%E5%88%B6%E7%A7%91%E7%AD%96%EF%BC%88%E5%B9%B6%E5%95%8F%EF%BC%89">《御试制科策》</a>：</p>
<blockquote>
<p>“边境已安，而兵不得撤”者，有安之名，而无安之实也。臣欲小言之，则自以为愧；大言之，则世俗以为笑。臣请略言之。古之制北狄者，未始不通西域。今之所以不能通者，是夏人为人障也。朝廷置灵武于度外，几百年矣。议者以为绝域异方，曾不敢近，而况于取之乎！然臣以为事势有不可不取者。不取灵武，则无以通西域。西域不通，则契丹之强，未有艾也。然灵武之所以不可取者，非以数郡之能抗吾中国，吾中国自困而不能举也。其所以自困而不能举者，以不生不息之财，养不耕不战之兵，块然如巨人之病膇，非不枵然大矣，而手足不能以自举。欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。有战国之全利，而无战国之患，则夏人举矣。其便莫如稍徙缘边之民不能战守者于空闲之地，而以其地益募民为屯田。屯田之兵稍益，则向之戍卒可以稍减，使数岁之后，缘边之民，尽为耕战之夫，然后数出兵以苦之，要以使之厌战而不能支，则折而归吾矣。如此，而北狄始有可制之渐，中国始有息肩之所。不然，将济师之不暇，而又何撤乎？</p>
</blockquote>
<p>先交代一下背景，殿试是皇帝亲自出题，题目范围很广，涵盖了当时所有的施政方针，而苏轼的《御试制科策》正是他参加殿试的答卷，上文就是苏轼针对边境问题的一个回答，具体内容大家自己看，这里我想重点说的是这句话：「欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。」我理解这句话的大概意思就是：如果要解决这个困境，就是将秦地（今天甘肃一带）这个地方舍弃掉，让它独立出去跟隔壁的匈奴打，我们也不需要帮忙。</p>
<p>苏轼这观点要放在今天，还不被各大网友口诛笔伐，甚至给个颠覆国家主权罪都是有可能的。但前面说了，出题的人是皇帝，改试卷的自然也是他，提出这么大逆不道观点的苏轼，不但没有招来杀身之祸，还入三等（第一、第二等都是形同虚设的，所以第三等相当于第一了）。</p>
<p>活在巨变时代之中的不幸我们前面已经说了，那就是价值观混乱与迷茫。那么幸运的是什么呢？幸运的是由于我们活在一个格局未定的时代，所以一切皆有可能，你有没有发现，纵观整个中国历史，能够影响深远的历史人物基本都是出生在巨变时代之中的，比如活在第二次巨变的人物：孔子、秦始皇、汉武帝、王莽。</p>
<p>而活在第三次巨变之中的我们，说不定就能够找到这个新时代的出路，这也是吕世浩老师开这门课的原因。</p>
<p>你可能会说，我只不过是一个平凡人物，我怎么有可能跟前面所说的人物相比呢，我何德何能能够改变这个时代呢？</p>
<p>如果你学了历史，你就知道历史上非常多比你更加不幸的人，但是他们靠着自己的努力，去改变了这个时代。</p>
<h2 id="三、学历史有什么用？"><a href="#三、学历史有什么用？" class="headerlink" title="三、学历史有什么用？"></a>三、学历史有什么用？</h2><p>我们从初一就开始学历史，那学历史到底有什么用呢？</p>
<p>说实话，我初一时非常不喜欢历史课，这门课我可以从上课睡到下课，书本到学期期末还是新的。</p>
<p>那时候我一直搞不懂知道了公元不知多少年前在哪个地方出现了什么猿人跟我们有什么关系，恐怕只是单纯为了应试罢了。</p>
<p>直到初二讲到近代史，讲鸦片战争、八国联军之类的，才让我稍微有点兴趣，但是只讲一些比较重大的事件，且事件的起因、过程、产出的影响基本都是书上写好的，我们只管背就行了，根本用不着我们来思考。这种教育方式谈不上好坏，但我个人并不喜欢。</p>
<p>但是出来工作以后，因为机缘巧合的原因，我竟然喜欢上了读历史，当然，并不限于教科书上的那种历史。</p>
<p>起因我是读了一本叫做《明朝那些事儿》的小说，相信这本书很多人都听说过，但我第一次读到这本书的时候，我惊讶地发现，原来历史还能这么有趣？原来历史并不是只有枯燥乏味、背诵各种历史事件的时间、人物、地点，原来历史中的每个人都是有血有肉的，他们也会面临人生中很重要的抉择，而他们的抉择其实对我们有很大启发。</p>
<p>至此之后，我一发不可收拾，开始尝试阅读其它历史书，我读的第二本历史书叫做《中国大历史》，作者是黄仁宇，这本书是从宏观角度讲解中国历史各朝代的演变过程，不讲人物史料，侧重于讲各朝代的执政方针，如果你想搞清楚中国历史从宏观角度来看是如何发展的，那么推荐看这本书。</p>
<p>我在去年的<a target="_blank" rel="noopener" href="https://4ark.me/posts/2020-summary.html">《2020 年终总结》</a>也说过，闲人读历史，目的大概有三种，一种是证明了自己博学，一种是追溯上古的八卦，一种是想弄明白为什么是现在这个样子。其实这句话是豆瓣上《中国大历史》的一个书评，我认为概括的非常好。</p>
<p>这之后我还读了一些诸如《中国近代史》以及一些不太知名的人物史料的书，给我的帮助只是多了解了一些近现代的史料，对我个人的帮助并不大。所以既然要读历史，那怎么能不读《史记》呢？</p>
<p>但是由于个人文化根基不深，一上来让我直接看古文，还是有点难的，但是白话文又苦于不知道哪一家译得更好，就在这个时候，吕世浩老师的课程让我明白了应该如何读《史记》，当然也包括其它历史书啦。</p>
<p>然后我来讲讲吕世浩老师对于这个命题的见解，感兴趣的同学可以先看看这个 TED 演讲：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ap0w3PgSK7g">《学历史的大用》</a>，下面的内容基本出自这里。</p>
<p>回答这个问题之前，先说说古今对待此历史的区别。</p>
<p>现代，大部分人对于历史的看法就如我上面所说的一样，就是背诵各种历史事件的时间、人物、地点，除了应试之外别无所用。</p>
<p>而古代，帝王将相与社会精英无一不学历史，史学教育是他们人生培养中的重要组成部分，他们认为历史重要！重要！再重要！</p>
<p>为什么古今会有如此大的差别？</p>
<p>并不是因为历史对现代社会没有用，而是因为古代人学习历史的方法和现代人的方法根本不一样。</p>
<p>古人学历史的方法是“最关键处，合上书。”</p>
<p>当古人读史读到一个人在关键时刻要做抉择时，会把书合上，去想如果自己在那样的环境中会如何抉择。想好之后，他再打开书对照史实，看看自己的决定和当事人的是否一样，然后思考当事人为什么做那样的决定，是否成功。用这样的方法学史，其实是在用古人的智慧来磨练自己。</p>
<p>因此，古代要培养帝王精英，所以用思辨学历史；而现代要培养各行工匠，所以用背诵学历史。目的不同，方法因之而异。</p>
<p>学历史是古代培养政治精英、帝王将相的重要途径，他们重思辨，用心学习历史，通过史书文献中的用词，体会古人的心境，以达到知微见著。</p>
<p>讲完了如何学习历史，下面讲讲学历史的作用：</p>
<ol>
<li>启发智慧：古人的智慧就像是一个磨刀石，而我们的智慧就是一把刀，所以学习历史的作用就是用古人的人生作为磨刀石来磨砺我们的智慧。</li>
<li>审时度势：时是指”你所处的环境“，势是指”环境变动的方向“，如果你只是将古人的做法原封不动地搬到今天，那就是跟刻舟求剑一样，只不过是自欺欺人罢了。还有一个就是：变，历史的本质就是变，能够从历史中看出变，那是非常了不起的，但是更高的智慧是从变之中看出不变的东西，什么东西是历经一百个时代，而它始终是不变的呢？那就是人性和良知。</li>
<li>感动人心：而感动人心就是要唤回人的良知，怎么样才能让人感动呢？那就是真实，不真实的内容是不能感动人心的，比如，我看完《活着》这本书的时候，我非常有感触，为什么呢？因为我知道它是真实发生过的。再比如，《报任少卿书》为何这么打动人心呢？因为司马迁在这封信里将自己心里最深的隐衷道出来了，其能让人不为之动容呢？</li>
</ol>
<p>在这里我想来个鸡汤：当你自怨自哀，觉得你没有好父母，人生没有依靠时，想一想有一个人他三岁死了父亲，十几岁死了母亲，家贫如洗，没有接受任何正规教育，完全靠自学成才，成为中国最大的圣人，影响中国文化两千多年，他就是孔子。</p>
<p>只要你用对方法，历史是无穷智慧的宝库，无穷力量的来源。教育的目的是让人做知识的主人，而不是做知识的奴仆。要做知识的主人，就要启发自己的智慧，愿大家都能从历史中启发智慧，做自己生命的主人，开创理想的人生。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后非常感谢吕世浩老师开这一门公开课，能让我这种连大学都没有上过的人，真真正正感受到应该怎样去学历史，这是何等的幸运。吕世浩老师在课程讲的远远不止上面这些，感兴趣的同学强烈推荐观看学习，相信你的收获不会比我少。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/27/2021-2-27-subtitle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/27/2021-2-27-subtitle/" itemprop="url">如何为视频加字幕？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-27T00:00:00+08:00">
                2021-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="title：如何为视频加字幕？"><a href="#title：如何为视频加字幕？" class="headerlink" title="title：如何为视频加字幕？"></a>title：如何为视频加字幕？</h1><p>Hello 大家好，我是安哥。 </p>
<p>今天这篇文章，想给大家介绍一下，在电脑上为视频加字幕的各种方法，希望对想做视频的朋友有帮助。 </p>
<h2 id="剪映电脑版"><a href="#剪映电脑版" class="headerlink" title="剪映电脑版"></a>剪映电脑版</h2><p>为视频添加字幕，必须推荐在我心目中第一的神器——剪映，剪映在去年推出了 Mac 版，而在今年推出了更多人使用的 Windows 版本，可以在剪映官网下载。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143434141477.jpg" alt="-w3602">之所以排名第一，是因为它的「识别字幕」和「识别歌词」功能真的太好用了。  </p>
<p>导入视频，切换到「文本」选项卡，普通视频的话选择「识别字幕」，如果是 Live 或演唱会上拍摄的视频，就选择「识别歌词」，等待软件完成识别，它就会在视频上方生成字幕。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143425230293.jpg" alt="-w1954">由于是机器自动识别生成的字幕，难免会出现识别错误的情况，在这基础上人工<strong>校对</strong>一下就可以了。</p>
<p>这里要说一下剪映电脑版做得不好的地方——双击生成的字幕，无法在视频预览窗口直接修改文本，反而需要点击右侧的文本编辑窗口才能修改，每次修改都要移动视线，看着真别扭，用久了的话不知道会不会变成斗鸡眼呢。。。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143429938252.jpg" alt="-w1954"><br>剪映电脑版下载地址：<br><em><a target="_blank" rel="noopener" href="https://lv.ulikecam.com/">https://lv.ulikecam.com/</a></em></p>
<h2 id="Handbrake"><a href="#Handbrake" class="headerlink" title="Handbrake"></a>Handbrake</h2><p>Handbrake，是一款开源免费的视频处理工具，支持 macOS、Windows 和 Linux 系统，可用来压缩视频体积、转换视频格式，还能<strong>压制输出带有字幕的视频</strong>。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143438443965.jpg" alt="-w1685">这里说的压制输出带有字幕的视频，指的是在有字幕文件 srt 的情况下，将字幕文件和没有字幕的视频文件封装（合成）到一起。   </p>
<p>这个软件的界面为英文，但理解起来并不困难，请不要被吓到。</p>
<p>点击左上角的「Open Source」，打开需要添加字幕的视频文件。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143437635214.jpg" alt="-w921">接着点击下方的「<strong>Video</strong>」选项卡，这里有两个参数需要注意：</p>
<p>一个是视频编码器 Video Encoder，保持默认的 H.264 就可以了，这是一种非常通用的编码格式，在不同平台上都不会出现兼容性的问题。</p>
<p>另一个是视频的码率 Framerate，这个参数要根据导入的原始视频的帧率进行选择，如果不清楚视频的帧率，可右击视频文件，查看「属性」，一般就可以看到视频文件的帧率。    </p>
<p><img src="http://cdn.penghh.fun/mweb/16143440741073.jpg" alt="-w921">接着切换到「<strong>Subtitles</strong>」选项卡，这里就是用来为视频添加字幕的。</p>
<p>点击「Track」的下拉按钮，选择「<strong>Add External Subtitles Track</strong>」，即添加一条额外的字幕轨道。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143444676430.jpg" alt="-w921">在弹出的窗口中，选择已经准备好的 srt 字幕文件，导入 Handbrake 中。</p>
<p><img src="http://cdn.penghh.fun/mweb/16143445774462.jpg" alt="-w1529">勾选「Burned In」，即将视频文件和字幕文件合并到一个文件中，接着点击右下方的「Browse」，设置文件输出后保存的位置。  </p>
<p>最后点上方的绿色按钮「<strong>Start</strong>」，等待视频完成渲染，就可以得到带有字幕的视频了。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143447904874.jpg" alt="-w921"><br>Handbrake 下载地址：<br><em><a target="_blank" rel="noopener" href="https://handbrake.fr/">https://handbrake.fr/</a></em></p>
<h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>Final Cut Pro X，简称 FCP，是苹果推出的视频剪辑软件，只支持 macOS 系统。  </p>
<p>它支持从零开始，给视频加字幕，但这种方法不符合我们的高效理念。要用 FCP 给视频加字幕，肯定要找一个可以偷懒、省时省力的方法。  </p>
<p>我用 FCP 加字幕的流程是这样的：</p>
<ul>
<li>使用网易见外工作台将音频转换为 srt 字幕文件</li>
<li>借助在线工具「crossub」，将得到的 srt 字幕文件转换为 fcpxml 文件</li>
<li>将 fcpxml 导入 FCP，修改识别错误的字幕，最终导出带有字幕的视频</li>
</ul>
<p>FCP 支持导入 srt 字幕文件，在视频预览窗口字幕也能正常显示，但不知道为什么最终导出的视频字幕总是缺失，有知道原因的朋友麻烦在留言区告诉我。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143495563214.jpg" alt="-w2084">虽然找不到原因，但这里可以借助在线工具 crossub，将 srt 字幕转换为 fcpxml 文件，接着再导入 FCP 中，就能顺利导出了。 </p>
<p>在使用 crossub 时，需要根据视频工程的<strong>帧率</strong>来确定下图的<strong>帧速率</strong>，不然转换得到的 fcpxml 文件与原来的时间轴会发生错位。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143498891861.jpg" alt="-w1660">转换为 fcpxml 后下载文件，需要对文件进行<strong>重命名</strong>，删除后缀多余的文本「.删除此后缀」，删除后才能导入 FCP。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143501796977.jpg" alt="-w1560">回到 FCP 中，选择「文件 &gt;&gt; 导入」，选择 XML，导入刚刚重命名的 fcpxml 文件。</p>
<p><img src="http://cdn.penghh.fun/mweb/16143503728308.jpg" alt="-w757">导入 fcpxml 文件后，它会在 FCP 中创建一个新的事件「crossub」，切换到新事件，再点击右侧的剪辑工程。  </p>
<p>在剪辑工程下方的<strong>时间轴</strong>上，就能看到所有的字幕文本，Cmd + A 全选所有字幕文本，再按下 Cmd + C 复制。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143506613307.jpg" alt="-w1252">点击时间轴中部的向左的箭头，切换到原来的剪辑工程中。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143508723977.jpg" alt="-w1414">将时间线对准到视频开头的位置，再按下 Cmd + V 粘贴，操作无误的话，字幕与视频此时应该是刚好能对上的。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143510373742.jpg" alt="-w1502">接着在 FCP 中对字幕进行简单的校对，费这么大劲使用 FCP 为视频加字幕，最方便的地方来了：你可以在视频预览窗口双击字幕，直接进入字幕编辑状态，修改识别错误的文字，而不是像剪映「一会看这，一会看那」。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143511419721.jpg" alt="-w2084">  </p>
<p>在线工具 crossub 网址：<br><em><a target="_blank" rel="noopener" href="https://crossub.xiaowude.com/srt/226">https://crossub.xiaowude.com/srt/226</a></em></p>
<p>这个工具是 B 站一位叫 @偷工拣料 的 Up 主制作的，如果你看不懂我的文字教程，可以去看他录制的视频教程，手把手 👋 教学，包你能看懂：  </p>
<p><img src="http://cdn.penghh.fun/mweb/IMG_8414.jpg" alt="IMG_8414"><br>除了本文介绍的内容，关于视频制作的话题，我还写过另外一篇文章，感兴趣的朋友戳下方链接 👇：</p>
<p>如果本文对你有帮助的话，别忘了关注我的公众号「效率工具指南」，第一时间获取干货更新：  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/24/2021-02-24-talk-about-btc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/24/2021-02-24-talk-about-btc/" itemprop="url">我对比特币的理解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-24T00:08:16+08:00">
                2021-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/images/bitcoin.jpg" class="">

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>比特币今年涨势很好，但最近刚刚有一个大的回落，跌到 5 万美元&#x2F;个以下。对于比特币，市场有两个极端对立的观点：一波观点（代表者是巴菲特）认为是废纸，另一波观点认为比特币是黄金。</p>
<p>我说一些我的理解吧，不一定对，算作抛砖引玉，欢迎大家留言评论交流共同进步。</p>
<h2 id="二、局部的共识-全局的共识"><a href="#二、局部的共识-全局的共识" class="headerlink" title="二、局部的共识 &#x3D; 全局的共识"></a>二、局部的共识 &#x3D; 全局的共识</h2><p>让我讲一个故事来解释这个观点：「局部的共识 &#x3D; 全局的共识」。</p>
<blockquote>
<p>假设在地球上有一种东西，产量有限，但是所有人都不把这个东西当作值钱的宝贝。为了故事好玩，我们拿熊猫的便便当这个东西吧。</p>
<p>突然有一天，有一个神秘的宗教组织对熊猫的便便产生了兴趣，因为他们的「圣经」里面，熊猫的便便是极其尊贵的东西。这个宗教组织发展得还挺大，他们大量向市场买入熊猫的便便，并且在组织内部交易。那些原本要扔掉的熊猫的便便，因为有人花钱买，于是就被饲养熊猫的人收集起来卖钱。</p>
<p>慢慢地，所有人都知道这个东西可以换钱，熊猫的便便值钱成为一种共识。</p>
</blockquote>
<p>你看，这个故事中，只要购买量足够大，交易足够多，同时这个东西产量有限。一个原来在宗教组织内部的「局部的共识」就会变成「全局的共识」。</p>
<p>比特币也是一样的，其实它不需要所有人认同它的价值，它只需要相对多的少数人认同它的价值，然后交易足够频繁到价格趋于相对稳定，买卖的流通速度比较快，那么这个局部的共识就会发展成全局的共识。</p>
<p>你不相信它的价值可以不买它，但是因为有共识，如果有一个人送巴菲特一个比特币，巴菲特会把它卖掉而不是扔掉，因为他意识到它是值钱的。</p>
<p>所以，比特币的局部共识早已经形成了，在这个情况下，它肯定就不是废纸了，在我看来，它就是类似故事中的「熊猫的便便」，是一种有价值的资产。</p>
<h2 id="三、需求决定价格"><a href="#三、需求决定价格" class="headerlink" title="三、需求决定价格"></a>三、需求决定价格</h2><p>比特币确定是有价值的资产了，那么它到底应该值多少钱一个，如何给它定价呢？</p>
<p>我们再讲一个故事，每一个国家都会印钞票，钞票印多了会贬值，印少了会影响经济发展，那么到底印多少合适呢？有一个说法是货币提供量的增长应该与 GDP（国民生产总值）的增长率相同，这样货币不会贬值或升值。</p>
<p>比特币作为一种数字资产，它是有着一定的货币属性的。所以它的价格其实取决于：</p>
<ol>
<li>有多少人拿这个当作交易的货币，每年的交易额是多少。</li>
<li>有多少人拿这个当作投资的资产，每年的买入量是多少。</li>
</ol>
<p>假如比特币每年有固定一群人拿它当作交易的货币，每年的交易额是 100 亿。同时有 一群人愿意拿它当投资的资产，每年愿意买入的金额是 200 亿。那么比特币的市值应该就是这两者正相关的一个函数。</p>
<p>因为比特币的总量固定，不会增发，所以当交易额和买入量上涨的时候，比特币的市值就会上涨。</p>
<p>所以，比特币值多少钱，核心是判断有上一节我们提到的这个「局部的共识」人群规模，因为核心的交易还是在「局部的共识」人群内部产生。如果这个规模一直在上涨，或者这个规模不变，但是人均愿意买入得更多，比特币的价格都会上涨。</p>
<h2 id="四、比特币的需求在哪里"><a href="#四、比特币的需求在哪里" class="headerlink" title="四、比特币的需求在哪里"></a>四、比特币的需求在哪里</h2><p>比特币的非主流需求来自于黑市的匿名交易，这块是它不太光彩的一面。这方面它是类似于货币的。</p>
<p>比特币还有一个主流的需求，就是应对全球的通货膨胀。这一点就类似于黄金的效果。</p>
<p>大家知道因为疫情，各国都印了不少钱，国内因为防疫做得好印得少，使得人民币对美元都涨到 6.5 了。于是，在现在这个时间点，如果你持有现金，那么如果国家印钱，你的现金是贬值的，为了应对这个，你应该把钱换成保值的资产。这种资产应该随着国家印钱而增值，这样就抵抗通账了。</p>
<p>于是人们发现，买固定资产、买龙头股票都是好的抵抗通账的方式，这也是为什么去年美股以及 A 股的白马股涨得很好的原因。除了买股票，买比特币也是一种抗通账方式，这和买黄金的效果类似。</p>
<p>比特币相对于黄金来说，因为产量是固定的，所以稀缺性会更强。另外它的波动比较大，交易所又提供了很多杆杠交易，吸引了喜欢逐利的散户们。杠杆交易更像是一种赌博，人性都是好赌的，比特币交易所迎合了这类人的需求，同时又不受正常的股票交易所的监管限制。</p>
<p>于是，比特币在坚强的基本抗通账需求的基础上，变成了散户们的一场狂欢。</p>
<h2 id="五、未来比特币的走势"><a href="#五、未来比特币的走势" class="headerlink" title="五、未来比特币的走势"></a>五、未来比特币的走势</h2><p>比特币的价格还是由供需决定，未来比特币作为一种发行总量固定的资产，会越来越被更多人认同。只要认同它的人在增加，长期来看它都是应该上涨的。</p>
<p>但是暴涨暴跌其实对一种资产来说是不好的，我认为主流交易量上一个台阶之后，加上散户们慢慢交一些学费之后，比特币的投机和赌博需求不会长期存在。</p>
<p>赌博本质上是一个零和游戏，没有人能够一直从别人手里赌赢钱，这个时候比特币的价格应该会趋于逐步稳定。长期来看，也没有哪种资产长时间地被当作投机和赌博的标的，巨大波动都是相对短时间的。</p>
<p>对于参与比特币投机的朋友，我帮大家算一个账：</p>
<blockquote>
<p>如果一个人参与比特币的短期杠杆交易（看涨或看跌），连续进行了 4 次交易，其中有 3 次挣了 90%，另外有一次 -90%，请问这个人最终的收益率是多少？</p>
<p>这个数学题其实挺好算的，<code>1.9*1.9*1.9*0.1=0.6859</code>，最终这个人本金会亏将近一半。</p>
</blockquote>
<p>你看，这个天天在朋友圈炫耀炒币挣钱，很少亏的人，只要亏一次，整体收益都可能是负的。想明白这一点，大部分都不应该做高风险的杠杠交易。</p>
<p>如果比特币投机属性慢慢减少，它的价格会变得稳定，然后由于需求慢慢上升和社会的通胀，它的价格会逐步上涨。</p>
<h2 id="六、可能的风险（黑天鹅事件）"><a href="#六、可能的风险（黑天鹅事件）" class="headerlink" title="六、可能的风险（黑天鹅事件）"></a>六、可能的风险（黑天鹅事件）</h2><p>比特币的巨大风险有两个，一个是监管风险，另一个是数字加密的安全风险。</p>
<p>监管风险来自于部分国家可能认为它对法币带来了实质性的冲击，影响了国家对于货币的发行权。这种禁令可能不会在全世界发生，但只要有部分国家禁止它，就会影响它的需求量。</p>
<p>另一个风险就是它只是基于一个密码，所以被盗取后追回的难度极大。交易所由于安全漏洞被偷币的案例比比皆是。2019 年交易所币安就<a target="_blank" rel="noopener" href="https://www.blocktempo.com/hacked-binance-lost-7000-btc-hackers-transfer-process/">被盗</a>了 7000 个比特币。所以你只要不是把钱放在冷钱包里面，就有可能因为交易所的安全原因被盗取掉比特币。</p>
<p>比特币冷钱包相对安全，但是未来量子计算会不会将现有世面上的加密算法攻克还不好说，到时候比特币应该需要全网的一次安全升级，才能保证密钥的足够安全。虽然现在看不到这方面的危险，但是技术的进步总是飞速的，奇点到来的那一天是否遥远并不好说。毕竟<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>诞生才 50 年就把全世界改变了。</p>
<h2 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h2><p>小结一下：</p>
<ul>
<li>比特币是数字资产，不是废纸，因为它已经有了「局部的共识」。</li>
<li>比特币的需求决定价格，长期来看它有类似于黄金一样的抗通胀的效果。</li>
<li>长期来看，比特币不再成为赌博和投机的标的后，价格未来会越来越稳定。</li>
<li>监管和安全是比特币最大的风险。</li>
</ul>
<p>欢迎留言一起探讨。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/23/%E9%80%9A%E8%BF%87%20EmbededFileProvider%20%E5%AE%9E%E7%8E%B0%20Blazor%20%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/%E9%80%9A%E8%BF%87%20EmbededFileProvider%20%E5%AE%9E%E7%8E%B0%20Blazor%20%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE/" itemprop="url">通过 EmbededFileProvider 实现 Blazor 的静态文件访问</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-23T05:37:47+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>重构我的 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/">独立博客</a> ，是博主今年的计划之一，这个基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 的静态博客，最早搭建于2014年，可以说是比女朋友更亲密的存在，陪伴着博主走过了毕业、求职以及此刻的而立之年。其间虽然尝试过像 <a target="_blank" rel="noopener" href="https://jekyllrb.com/">Jekyll</a> 和 <a target="_blank" rel="noopener" href="https://www.gohugo.org/">Hugo</a> 这样的静态博客生成器，可是考虑到模板、插件等周边生态，这个想法一直被搁置下来。直到最近，突然涌现出通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 重写博客的想法，尤其是它对于 <a target="_blank" rel="noopener" href="https://webassembly.org/">WebAssembly</a> 的支持，而类似 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue</a> 和 <a target="_blank" rel="noopener" href="https://reactjs.org/">React</a>的组件化开发模式，在开发体验上有着同样不错的表现。所以，今天这篇博客就来聊聊在重写博客过程中的一点收获，即如何让 Blazor 访问本地的静态文件。</p>
<h1 id="从内嵌资源说起"><a href="#从内嵌资源说起" class="headerlink" title="从内嵌资源说起"></a>从内嵌资源说起</h1><p>首先，我们要引入一个概念，即：内嵌资源。我们平时接触的更多的是本地文件系统，或者是 FTP 、对象存储这类运行在远程服务器上的文件系统，这些都是非内嵌资源，所以，内嵌资源主要是指那些没有目录层级的文件资源，因为它会在编译的时候“<strong>嵌入</strong>”到动态链接库(DLL)中。一个典型的例子是<code>Swagger</code>，它在<code>.NET Core</code>平台下的实现是<a target="_blank" rel="noopener" href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">Swashbuckle.AspNetCore</a>，它允许使用自定义的HTML页面。这里可以注意到，它使用到了<code>GetManifestResourceStream()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// requires file to be added as an embedded resource</span></span><br><span class="line">    c.IndexStream = () =&gt; GetType().Assembly</span><br><span class="line">        .GetManifestResourceStream(<span class="string">&quot;CustomUIIndex.Swagger.index.html&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实，这里使用的就是一个内嵌资源。关于内嵌资源，我们有两种方式来定义它：</p>
<ul>
<li>在 Visual Studio 中选中指定文件，在其属性窗口中选择生成操作为嵌入的资源：</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/Zftpl5UFnmcLK49.png" alt="如何定义一个文件资源为内嵌资源"></p>
<ul>
<li>在项目文件(<strong>.csproj</strong>)中修改对应<code>ItemGroup</code>节点，参考示例如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk.Web&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">&quot;_config.yml&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CopyToOutputDirectory</span>&gt;</span>Always<span class="tag">&lt;/<span class="name">CopyToOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EmbeddedResource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了内嵌资源的定义。而定义内嵌资源，本质上还是为了在运行时期间去读取和使用，那么，自然而然地，我们不禁要问，该怎么读取这些内嵌资源呢？在<code>Assembly</code>类中，微软为我们提供了下列接口来处理内嵌资源：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ManifestResourceInfo <span class="title">GetManifestResourceInfo</span>(<span class="params"><span class="built_in">string</span> resourceName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span>[] <span class="title">GetManifestResourceNames</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params">Type type, <span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>GetManifestResourceNames()</code>方法用来返回所有内嵌资源的名称，<code>GetManifestResourceInfo()</code>方法用来返回指定内嵌资源的描述信息，<code>GetManifestResourceStream()</code>方法用来返回指定内嵌资源的文件流。为了方便大家理解，这里我们准备了一个简单的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> resources = assembly.GetManifestResourceNames();</span><br><span class="line">resources.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line"><span class="comment">//ConsoleApp.A.B.示例文档.txt</span></span><br><span class="line"><span class="comment">//ConsoleApp.A._config.yml</span></span><br><span class="line"><span class="keyword">var</span> fileInfo = assembly.GetManifestResourceInfo(resources[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = assembly.GetManifestResourceStream(resources[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>此时，我们会发现，内嵌资源都是使用类似<code>A.B.C.D</code>这样的形式来表示资源路径的，因为内嵌资源本身是没有目录层级的。现在，如果我们再回过头去看<code>Swagger</code>的示例，就不难理解为什么会有<code>CustomUIIndex.Swagger.index.html</code>这样一个奇怪的值，因为它对应着实际的物理文件路径，如下图所示，示例代码中输出的资源路径和实际的物理路径存在着对应关系：</p>
<p><img src="https://i.loli.net/2021/02/23/jgqxFTPt2OnHMyh.png" alt="项目中的物理路径与内嵌资源路径对照"></p>
<h1 id="EmbededFileProvider"><a href="#EmbededFileProvider" class="headerlink" title="EmbededFileProvider"></a>EmbededFileProvider</h1><p>OK，那么在了解了内嵌资源以后，接下来，我们需要关注的是<code>EmbededFileProvider</code>。需要说明的是，在<code>ASP.NET Core</code>中，微软是通过<code>IFileProvider</code>这个接口来解决文件读取问题的，典型的使用场景有静态文件中间件、Rozar模板引擎以及WWWRoot目录定位等等，通常情况下，我们使用<code>PhysicalFileProvider</code>更多一点，它和<code>EmbededFileProvider</code>一样，都实现了<code>IFileProvider</code>接口，所以，<code>ASP.NET Core</code>可以从不同的来源访问文件信息。</p>
<p>显然，<code>EmbededFileProvider</code>正是为了内嵌资源而生，它在内部使用到了<code>Assembly</code>类中和内嵌资源相关的接口.所以，除了上面的方式，我们还可以通过下面的方式来访问内嵌资源，需要注意的是，使用<code>EmbededFileProvider</code>需要引用<code>Microsoft.Extensions.FileProviders.Embedded</code>，大家可以比较一下这两种方式地差异：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> EmbeddedFileProvider(assembly);</span><br><span class="line"><span class="comment">//注意，这里写&quot;.&quot;或者&quot;&quot;都可以</span></span><br><span class="line"><span class="keyword">var</span> resouces = provider.GetDirectoryContents(<span class="string">&quot;.&quot;</span>).ToList();</span><br><span class="line"><span class="keyword">var</span> fileInfo = provider.GetFileInfo(resouces[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = fileInfo.CreateReadStream();</span><br></pre></td></tr></table></figure>

<p>除此以外，<code>IFileProvider</code>还有一个最重要的功能，即<code>Watch()</code>方法，它可以监听文件的变化，并返回一个<code>IChangeToken</code>。有没有一种似曾相识燕归来的感觉？没错，博主曾经在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/835719605/">基于选项模式实现.NET Core的配置热更新</a> 这篇文章中介绍过它，它是实现配置热更新的关键。事实上，<code>FileConfigurationSource</code>这个类中有一个<code>Provider</code>属性，而它对应的类型恰好是<code>IFileProvider</code>，这难道是巧合吗？不，仔细顺着这条线，我们大概就能明白微软的良苦用心，我们的配置文件自然是来自文件系统，而考虑到内嵌资源的存在，我们面对的文件系统其实是一个广义的文件系统，它可以是物理文件、内嵌文件、Glob、对象存储(<strong>OSS</strong>)等等</p>
<h1 id="Blazor的奇妙缘分"><a href="#Blazor的奇妙缘分" class="headerlink" title="Blazor的奇妙缘分"></a>Blazor的奇妙缘分</h1><p>好了，千呼万唤始出来，现在终于要讨论 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 这个话题啦！众所周知，静态博客生成器里主要存在着两种配置，即站点配置和主题配置，<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 里甚至还支持从特定文件夹里加载自定义的数据。所以，对于静态博客而言，它需要有从外部加载数据这个特性。我们知道，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 分为服务器和客户端两个版本，两者的区别主要在于 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-5.0">Rozar</a> 模板由谁来渲染，前者相当于服务端渲染(<strong>SSR</strong>) + <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/javascript-client?view=aspnetcore-5.0">SignalR</a>，而后者则是基于 <a target="_blank" rel="noopener" href="https://webassembly.org/">WebAssembly</a>，它可以直接在浏览器中加载。显然，后者更接近我们静态博客生成器的想法。由于 Hexo 使用 Yaml 作为配置语言，所以，为了读取原来 Hexo 博客的配置，参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nianming/p/7097338.html">实现自己的.NET Core配置Provider之Yaml</a> 这篇博客实现了一个YamlConfigurationProvider。</p>
<p>在使用的过程中，遇到的问题是，它无法识别配置文件的路径。原因很简单，经过编译的 Blazor 会被打包为 WebAssembly ，而 WebAssembly 在前端加载以后，原来的目录层级早已荡然无存。此时，基于物理文件的 <code>PhysicalFileProvider</code> 将无法工作。解决方案其实大家都能想到，换一种<code>IFileProvider</code>的实现就好了啊！至此，奇妙的缘分产生了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">YamlConfigurationProvider</span> : <span class="title">FileConfigurationProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> FileConfigurationSource _source;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YamlConfigurationProvider</span>(<span class="params">FileConfigurationSource source</span>) : <span class="title">base</span>(<span class="params">source</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> path = _source.Path;</span><br><span class="line">        <span class="keyword">var</span> provider = _source.FileProvider;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = provider.GetFileInfo(path).CreateReadStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//核心问题就是这个Stream的来源发生了变化</span></span><br><span class="line">            <span class="keyword">var</span> parser = <span class="keyword">new</span> YamlConfigurationFileParser();</span><br><span class="line">            Data = parser.Parse(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-3.1">官方文档</a>中提到过，Blazor 的配置文件默认从 WWWRoot 下的<code>appsettings.json</code>加载，所以，对于像JSON这类静态文件，可以注入HttpClient，以API的方式进行访问。例如，官方文档中推荐的加载配置文件的方式为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient()</span><br><span class="line">&#123;</span><br><span class="line">    BaseAddress = <span class="keyword">new</span> Uri(builder.HostEnvironment.BaseAddress)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped(sp =&gt; httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前方有语法糖，高甜:)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> http.GetAsync(<span class="string">&quot;cars.json&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"></span><br><span class="line">builder.Configuration.AddJsonStream(stream);</span><br></pre></td></tr></table></figure>

<p>而经过我们这样改造以后，我们还可以这样加载配置：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.Configuration.AddYamlFile(</span><br><span class="line">    provider:<span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetExecutingAssembly()),</span><br><span class="line">    path: <span class="string">&quot;_config.yml&quot;</span>,</span><br><span class="line">    optional:<span class="literal">false</span>,</span><br><span class="line">    reloadOnChange:<span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>一旦这些配置注入到 IoC 容器里，我们就可以纵享无所不在的依赖注入，这里以某个组件为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.Extensions.Configuration</span><br><span class="line">@inject IConfiguration Configuration</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-row DreamCat-content-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-container fade-scale in&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>@Configuration[&quot;title&quot;]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;subtitle&quot;</span>&gt;</span>@Configuration[&quot;subtitle&quot;]<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样地，对于组件内的数据，在大多数场景下，我们可以这样来处理，还是因为有无所不在的依赖注入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@page &quot;/&quot;</span><br><span class="line">@layout MainLayout</span><br><span class="line"></span><br><span class="line">@inject HttpClient httpClient</span><br><span class="line">@using BlazorBlog.Core.Domain.Blog;</span><br><span class="line">@using BlazorBlog.Web.Shared.Partials;</span><br><span class="line">@if (posts != null &amp;&amp; posts.Any())</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var post in posts)</span><br><span class="line">    &#123;</span><br><span class="line">        //这是一个自定义组件</span><br><span class="line">        <span class="tag">&lt;<span class="name">PostItem</span> <span class="attr">Model</span>=<span class="string">post</span>&gt;</span><span class="tag">&lt;/<span class="name">PostItem</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@code</span><br><span class="line">&#123;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Post</span>&gt;</span> posts &#123; get; set; &#125;</span><br><span class="line">    protected override async Task OnInitializedAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        posts = await httpClient.GetFromJsonAsync&lt;List<span class="tag">&lt;<span class="name">Post</span>&gt;</span>&gt;(&quot;content.json&quot;);</span><br><span class="line">        await base.OnInitializedAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以给大家展示下尚在开发中的静态博客：</p>
<p><img src="https://i.loli.net/2021/02/23/wMED8k6SbqITpma.png" alt="基于 Balzor 的静态博客"></p>
<p>理论上任何文件都可以这样做，主要是考虑到配置这种信息，用依赖注入会更好一点，这样每一个组件都可以使用这些配置，而如果是以 API 的形式集成，以目前 Blazor 打包以后加载的效果来看，页面会有比较大的“<strong>空白期</strong>”。我更加疑惑的是，如果 Blazor 打包后的体积过大，那么浏览器自带的存储空间是否够用呢？一句话总结的话， Blazor 是一个写起来非常舒服的框架，可未来是否会像当年的 Sliverlight 一样，这还要看大家对 WebAssembly 的接受程度，可谓是“<strong>路漫漫其修远兮</strong>”啊……</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，是博主由一个个“<strong>闪念</strong>”而串联起来的脑洞，作为一个实验性质的尝试，希望通过 Blazor 的客户端模式(<strong>WebAssembly</strong>) 实现一个静态博客，而在这个过程中，需要解决 Balzor 读取本地文件的问题，由此，我们引入了这篇博客的主题之一，即：<code>EmbededFileProvider</code>。顺着这条线索，我们梳理了内嵌的文件资源、<code>IFileProvider</code>接口、<code>FileConfigurationProvider</code>、<code>FileConfigurationSource</code>等等一系列看起来毫无关联的概念。事实上，“<strong>冥冥之中自有天意</strong>”，这一切怎么会毫无关联呢？我们最终从文件系统看到了配置系统，聊到了 Blazor 中的配置问题，这里我们熟悉的依赖注入、配置系统都得以延续下来。其实，单单就解决这个问题而言，完全不值得专门写一篇博客，<strong>可从一个点辐射到整个面的这种感悟，在人生的成长中更显得弥足珍贵，希望我们每一个人都能多多跳脱出自己的视角，去努力的看一看这个丰富多彩的世界，在多样性与多元化中去寻找整体上的统一，这是作为技术人员的我，一生都想去探索的哲学</strong>。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论中留下你的想法或者建议，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/21/2021-02-21-huawei-vs-apple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/21/2021-02-21-huawei-vs-apple/" itemprop="url">华为手机 vs 苹果手机，我的一年评测对比报告</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-21T20:40:38+08:00">
                2021-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/images/Huawei-vs-Apple.png" class="">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为工作的原因，我早年一直从事 iOS 开发，所以一直用着苹果手机。iPhone 的体验一直挺好的。</p>
<p>但是我一直比较好奇顶级的 Android 手机怎么样，体验和苹果会差多少，于是我去年就换了华为的 P30 Pro。</p>
<p>对比使用了一年，给大家分享一下我的感受。预告一下，前面夸华为比较多，后面夸苹果比较多。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>对比之下，我发现华为的硬件某些地方比 iPhone 还要厉害一些。比如：</p>
<h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>华为的这款摄像头可能是因为和莱卡合作，所以调校得还算不错。和苹果的摄像头比较起来，自然光照下可以说各有特点。苹果的拍照更加真实自然，而华为会用 AI 给你默认 PS 图，这样蓝天更蓝，美食饱和度更高。</p>
<p>在夜景情况下，华为拍照应该算是完胜，可以在人眼基本都看不清的情况下，通过延长曝光时间和自动的 HDR 拍出比较清晰的图片。</p>
<p>自拍模式下，华为会自动开启美颜：光滑皮肤，瘦脸，美白。把我整得像个小白脸一样。但不得不说，这确实符合大部分中国人的自拍习惯。</p>
<img src="/images/huawei-1.png" class="">

<p>华为还搞了一个 50 倍变焦，可以拍月亮。这确实是一个比较好的营销的点，但是说实话除了给朋友装 B 之外没有什么卵用，因为 50 倍之后影像已经极度模糊了。</p>
<p>拍月亮这个场景华为做了专门的优化，因为月亮面向地球的一面是固定不变的。为此我还专门查了一下这个叫做「<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20030267">地球引力潮汐锁定</a>」。反正因为我们看到的月亮环形山的位置和形状都是固定不变的，所以华为的 AI 算法帮我们把环形山给 PS 上去了。不得不说，这是一个好点子，但这和摄像头的能力没什么关系。</p>
<p>iPhone 12 Pro 的摄像头也有胜出的地方，iPhone 12 Pro 引入了更强的防抖功能，这样录制移动的 vlog 的时候效果会更出色，这一点华为是很差的。</p>
<h3 id="电池"><a href="#电池" class="headerlink" title="电池"></a>电池</h3><p>电池和充电速度华为 P30 Pro 都比 iPhone 要体验好。一般 iPhone 的电池新手机能用一天，老手机能用大半天。而华为新手机能用一天半，老手机也能用一天。</p>
<p>华为在省电这件事情上做了一件很暴力，但是很有效的办法。华为把所有的应用，都默认禁止了后台操作，仅保留了中国人最常使用的微信等应用允许常驻后台。</p>
<p>安卓市场的应用本来很流氓，结果华为这招更流氓，直接相当于开启了白名单模式。我刚换华为的时候，发现百度云盘不能自动备份照片了，一看才发现百度也被强制默认禁止了后台唤醒操作。这些操作都是默认的，所以普通用户都不会看到应用对权限申请的提示。</p>
<p>相对来说，苹果的应用市场要正常一些，只要你的应用逻辑上需要常驻后台，审核的时候就不会卡你。</p>
<p>但不管怎么样，华为做到了更长的待机时间。</p>
<h3 id="充电速度"><a href="#充电速度" class="headerlink" title="充电速度"></a>充电速度</h3><p>充电速度最新款的 iPhone 支持最高 22w 的充电，华为 P30 Pro 支持 40w 的快充。充电速度华为更厉害。</p>
<p>另外，iPhone 不送充电器，这一点有点让人不爽。华为是送 40w 的快充充电头和充电线。</p>
<img src="/images/apple-no-charge.png" class="">

<p>​华为对充电做了一个优化我觉得也很好，就是对有夜间插上充电线的用户，智能学习充电行为，避免长时间晚上电池过充，因为锂电池的过充和过放都不太好。</p>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><p>华为采用了类似 Face ID + 屏下指纹的双认证方式，苹果是采用 Face ID。</p>
<p>我个人还是更习惯屏下指纹，我一直觉得指纹比 Face ID 体验更优，特别是夜间在被窝里面玩手机的时候。</p>
<p>当然，现在疫情戴口罩了，Face ID 显得更加不人性化。</p>
<p>苹果应该引入类似的屏下指纹技术。</p>
<h3 id="NFC-和红外遥控器"><a href="#NFC-和红外遥控器" class="headerlink" title="NFC 和红外遥控器"></a>NFC 和红外遥控器</h3><p>安卓手机都可以开放对 NFC 硬件的控制，所以我使用华为的钱包功能，把各种工卡和门禁都复制到了手机中，这还是挺爽的，可以少带很多卡。</p>
<img src="/images/huawei-2.jpg" class="">

<p>苹果为了安全的原因，虽然有这个能力，但是只开放了公交卡和 Apple Pay，从实用角度，还是差了一些。</p>
<p>红外遥控器的能力类似，华为可以通过这个遥控几乎所有的电器，虽然用得不多，但是找不到遥控器的时候应急还是挺方便的。</p>
<h3 id="激光雷达扫描仪"><a href="#激光雷达扫描仪" class="headerlink" title="激光雷达扫描仪"></a>激光雷达扫描仪</h3><p>只有 iPhone 才有的硬件能力，可以扫描整个场景进行 3D 建模。配合可以做一些设计或者 AR 的游戏。</p>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><p>硬件的生态上，苹果就比华为厉害多了。比如苹果的跨设备剪切板，对于同时使用苹果手机和电脑的用户来说就非常爽。</p>
<p>苹果的手机与 AirPods 的连接，也是非常舒服的。</p>
<p>华为手机如果要做到同样的事情，得买华为的耳机，我为此就专门另外买了一个华为的 FreeBuds。但是华为的这款耳机明显比 AirPods Pro 差太多，比如降噪功能就是个摆设，完全不可用。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="垃圾短信拦截"><a href="#垃圾短信拦截" class="headerlink" title="垃圾短信拦截"></a>垃圾短信拦截</h3><p>软件方面华为有一些功能刚好解决了中国人的烦恼，比如：截长图和垃圾短信拦截。特别是垃圾短信的拦截功能，比苹果好用太多太多。我看了一下统计，它平均每天帮我拦截 5 条垃圾短信和 2 个骚扰电话（直接挂断）​：</p>
<img src="/images/huawei-3.png" class="">

<p>苹果的 iMessage 垃圾短信在中国就没有断过，老是会收到陌名其妙的非法赌博短信。</p>
<h3 id="应用市场"><a href="#应用市场" class="headerlink" title="应用市场"></a>应用市场</h3><p>华为预装了特别多的软件，这种特别有一种被绑架的感受。</p>
<p>华为的应用市场也有一个特别坑的地方，就是如果你在华为应用市场下载的游戏，是不能和微信的好友相互之间游戏的，现在很多游戏其实都有一些社交属性，如果看不到微信好友，那么就变成一个孤岛了。所以建议大家，下载游戏不要去华为应用市场下，一定要去应用宝或者游戏官网下载。</p>
<h3 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h3><p>华为如果要下载国外的应用，会麻烦很多。不像苹果，只需要切换成国外的帐号即可。特别是现在美国对华为的制裁，会使得很多国外应用比较难下载到华为手机中。</p>
<p>前阵子 clubhouse 火的时候，我为了下载它就费了挺多精力的。但是如果是苹果手机，就会很方便。</p>
<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>苹果手机有很多收费的高质量的上网 App，这方面安卓生态也要差很多。</p>
<h3 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h3><p>华为的日历不行，基本无法使用。全世界做好了日历这个应用的也就只有谷歌和苹果。</p>
<p>弄得我只好在华为手机上装了一个谷歌的日历，但是因为科学上网不方便，日历同步还是有影响。</p>
<p>这个对于我的日程管理多少有一些负面影响。好在公司统一用企业微信的日程，倒没有影响工作。</p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>华为 P30 Pro 256G 我买成 6000 左右，苹果 <a target="_blank" rel="noopener" href="https://www.apple.com.cn/iphone-12-pro/specs/#footnote-12">iPhone 12 Pro Max</a> 256G 得 1 万左右，价格还是差了不少。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>华为手机占优的地方：</p>
<ul>
<li>莱卡摄像头的夜景，自动美颜，50倍变焦</li>
<li>电池待机时间更长</li>
<li>屏下指纹</li>
<li>可以复制各种门禁到手机中</li>
<li>截长图，垃圾短信拦截</li>
<li>价格相对便宜</li>
</ul>
<p>苹果手机占优的地方：</p>
<ul>
<li>摄像头的防抖功能</li>
<li>激光雷达扫描仪</li>
<li>软件更安全</li>
<li>硬件生态更好，配套的耳机更好用</li>
<li>下载国外的应用更方便</li>
<li>科学上网 App 更成熟</li>
</ul>
<p>华为手机特别不好的地方：</p>
<ul>
<li>应用市场的游戏与微信好友信息不能互通</li>
<li>日程管理</li>
</ul>
<p>苹果手机特别不好的地方：</p>
<ul>
<li>iMessage 垃圾短信</li>
<li>Face ID，戴口罩没法解锁啊！</li>
</ul>
<p>说了这么多，最后要换新手机，到底换华为还是苹果呢？</p>
<p>我觉得吧，用习惯苹果的可以继续用苹果，毕竟很多花钱购买的 App 都买过了，而且苹果的生态确实更好，配合苹果电脑切换起来也更方便。虽然苹果手机稍微贵一点，但是给别人的品牌感受也更好一点，这就是全世界最值钱的公司生产的大众量产的最贵手机了。</p>
<p>习惯华为手机的人，可以继续使用华为。毕竟华为针对中国人做了很多定制的优化，美颜、门禁复制、截长图、垃圾拦截这些功能虽小，但是用起来还是挺爽的。大部分时候你也不需要下载国外的应用，也不需要复杂的日程管理。虽然你的手机没有人家的 iPhone 贵，但是你可以说你爱国，支持国货啊！</p>
<p>那我呢？我两个都买，没办法，谁让我做互联网工作呢，工作需要！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/17/2021/apple-music/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/17/2021/apple-music/" itemprop="url">日区 Apple Music 优缺点与实际体验</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-17T16:11:00+08:00">
                2021-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>想在一个平台上听到所有喜欢的歌，太难了。</p>
<p>虽说在大版权时代，资源还是存到自己的硬盘里最踏实，但下载党也不是那么好当的。而且习惯了流媒体的便利以后，我是越来越不愿意花那个心思了。然而国内音乐平台版权之争使得听歌体验愈发水深火热，我也不得不面对现实……</p>
<p>在网易云音乐的歌单灰掉一大片后，我终于决定跑路。</p>
<p>这篇文章算是我个人使用了半年多日区 Apple Music 的感受，如果你恰巧也在纠结如何选择，希望对你有所帮助。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/02/17/2021/apple-music/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/17/2021/build-x86-docker-images-on-an-m1-macs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/17/2021/build-x86-docker-images-on-an-m1-macs/" itemprop="url">在 M1 Mac 上构建 x86 Docker 镜像</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-17T05:38:00+08:00">
                2021-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>今天闲来无事，数了一下服务器上在跑的东西，打算把它们都扔到 Docker 里面去。第一个开刀的就是之前写的 <a target="_blank" rel="noopener" href="https://prinsss.github.io/google-analytics-api-page-views-counter/">Google Analytics 博客阅读量统计</a>，很简单的一个 Node.js + Express 程序。</p>
<p>写完 <a target="_blank" rel="noopener" href="https://github.com/prinsss/google-analytics-hit-counter">Dockerfile</a> 测试好，正准备 push 上去时，我才突然想起来：</p>
<p>我现在用的是 M1 MacBook，<strong>丫的默认 build 出来的镜像是 <code>arm64</code> 架构的呀！</strong></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/02/17/2021/build-x86-docker-images-on-an-m1-macs/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/15/%E4%BD%8E%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%83%B3%E8%AF%B4%E7%88%B1%E4%BD%A0%E4%B8%8D%E5%AE%B9%E6%98%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/15/%E4%BD%8E%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%83%B3%E8%AF%B4%E7%88%B1%E4%BD%A0%E4%B8%8D%E5%AE%B9%E6%98%93/" itemprop="url">低代码，想说爱你不容易</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-15T12:37:47+08:00">
                2021-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想写篇文章，聊一聊“<strong>低代码</strong>”这个话题。一方面，“<strong>低代码</strong>”这个概念确实非常火，其热度丝毫不亚于曾经的“<strong>中台</strong>”。有人说，2021 年是属于“<strong>云原生</strong>”的时代，看起来我们每一年都在被技术的“<strong>娱乐圈</strong>”抛弃，明明连 <code>Kubernetes</code> 都还没有入门呢？人们已然在欢呼雀跃般地声称要抛弃 <code>Docker</code> 。这个世界有时就是如此地魔幻，明明我们生活在一个拥有大量基础设施的时代，我们不必再像前辈们“刀耕火种”一般地去开发软件，可我们的生存空间为什么就越来越狭窄了呢？拼多多事件过去没有多久，腾讯的阳光普照奖再次让“<strong>打工魂</strong>”觉醒，也许果真像大鱼海棠里设定的一样，人的记忆只有 7 秒。而另一方面，我想结合我最近开发“<strong>工作流</strong>”的感受，来吐槽下这个看起来美好的“<strong>低代码</strong>”。也许，对企业而言，引入“<strong>低代码</strong>”的确能减少研发成本，可博主并不认为，它会降低业务本身的复杂性，如果所有声称“<strong>低代码</strong>”或者“<strong>无代码</strong>”的项目，最终依然需要研发人员来作为收场。对此，我想说，对不起，这不是我想要的“<strong>低代码</strong>”。</p>
<h1 id="低代码发展现状"><a href="#低代码发展现状" class="headerlink" title="低代码发展现状"></a>低代码发展现状</h1><p>或许，一个人成熟的标志就是，在面对一个未知的事物的时候，决不会不由分说地一通吐槽，就像一个人在职场上，你不能永远都只是学会抱怨，相对于抱怨，人们更希望听到的是解决方案。所以，一个人的成长，本质上就是不断学会为自己、为别人找解决方案的过程，前者是为了认识自我，而后者是为了交换资源。所以，在听我吐槽“<strong>低代码</strong>”前，不妨先一起来看看低代码的发展现状。</p>
<p><img src="https://i.loli.net/2021/02/15/j6dAcDPEopHSLCa.png" alt="低代码产品发展现状"></p>
<h2 id="国外趋势"><a href="#国外趋势" class="headerlink" title="国外趋势"></a>国外趋势</h2><p>有人认为，“<strong>低代码</strong>”的兴起源于钉钉的低代码应用 <a target="_blank" rel="noopener" href="https://www.aliwork.com/">易搭</a> 的落地。诚然，巨头企业的每一个动向都引领着整个行业的风潮，可低代码这个概念最早要追溯到 1980 年。彼时，<strong>IBM</strong> 的快速应用程序开发工具(<strong>RAD</strong>)被冠以新的名字——低代码，这是低代码这个概念首次面向大众，此后的 40 年里，国外诞生了诸如 <a target="_blank" rel="noopener" href="https://www.outsystems.com/">Outsystem</a> 、<a target="_blank" rel="noopener" href="https://www.mendix.com/">Mendix</a> 、 <a target="_blank" rel="noopener" href="https://www.zoho.com/creator/developers/">Zoho Creator</a> 等等的产品，整体发展相对缓慢。直到 2015 年以后，AWS、Google、Microsoft 和 Oracle 等巨头开始入局低代码领域。2018 年，西门子更是宣布以 6 亿欧元收购低代码应用开发领域的领导者 <a target="_blank" rel="noopener" href="https://www.mendix.com/">Mendix</a> 、快速应用开发的低代码平台 <a target="_blank" rel="noopener" href="https://www.outsystems.com/">Outsystem</a> 获得 3.6 亿美金的投资，低代码平台市场开始火爆起来，我们所熟悉的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/power-platform/">Power Platform</a>，其实就是微软的低代码开发平台，低代码领域通常都需要大量的积累和研发，需要有 10 到 20 年左右的技术沉淀。</p>
<h2 id="国内风云"><a href="#国内风云" class="headerlink" title="国内风云"></a>国内风云</h2><p>国内的低代码领域，相比国外发展起步较晚，可依然涌现出像<a target="_blank" rel="noopener" href="https://www.newdao.net/">牛刀</a>、<a target="_blank" rel="noopener" href="https://www.apicloud.com/">APICloud</a>、<a target="_blank" rel="noopener" href="https://www.ivx.cn/">iVX</a>、<a target="_blank" rel="noopener" href="https://www.dadayun.cn/index">搭搭云</a>、氚云、简道云、云表、<a target="_blank" rel="noopener" href="https://www.aliwork.com/">宜搭云</a>等等产品。从整体上而言，这类这类产品基本上都提供了可视化搭建环境，都声称无需编码即可完成业务系统的搭建。其实，从一名程序员的初心出发，我们所做的一切努力都是为了以后不写代码。经常有人问，怎么样可以做到零缺陷、零 Bug ，其实不写代码就好啦！我们并不担心低代码让我们失业，相反地，如果低代码可以消化掉 30% 的垃圾项目，那么，我们将会有更多的时间去做些有意义的事情，而不是在一个“<strong>劣币驱逐良币</strong>”的市场里，靠着 <code>996</code> 来争个你死我活。而从低代码的商业价值角度来看，<a target="_blank" rel="noopener" href="https://www.salesforce.com/">Salesforce</a>、<a target="_blank" rel="noopener" href="https://www.appian.co.uk/">Appian</a>、<a target="_blank" rel="noopener" href="https://www.joget.org/">Joget</a> 这三家公司均已上市，<a target="_blank" rel="noopener" href="https://www.mendix.com/">Mendix</a> 和 <a target="_blank" rel="noopener" href="https://www.outsystems.com/">Outsystem</a> 更是估值 10 亿美元以上的独角兽公司，这正是巨头们入局低代码的原因所在。</p>
<p>低代码领域，目前关注的重点主要集中在：<strong>表单生成和处理</strong>、<strong>工作流生成和管理</strong>、<strong>办公协作</strong>、<strong>人力资源</strong>、<strong>客户关系</strong>、<strong>ERP</strong> 等企业应用上，就如同 <strong>SAP</strong> 、<strong>金蝶</strong>、 <strong>SCM</strong> 等企业软件一样，每一个软件都曾声称能帮助企业解决某一类问题，低代码领域同样遵循“<strong>二八原则</strong>”，即 80% 的场景，通过定义的方法论、方式、工具集能够实现；而剩下的 20% 的场景或许实现不了，需要使用者通过扩展的方式来自行解决。譬如，针对大多数企业都存在的 CRUD 的需求，通过在线的 Excel 表格来实现基于表的业务驱动。例如 <a target="_blank" rel="noopener" href="https://www.seatable.cn/">SeaTable</a> 就是这类主打协同工作的产品；针对大多数企业都存在的审批类的需求，则可以通过可视化的工作流设计系统来完成。例如 <a target="_blank" rel="noopener" href="https://www.grapecity.com.cn/aboutus">葡萄城</a> 的 <a target="_blank" rel="noopener" href="https://www.grapecity.com.cn/developer/spreadjs">SpreadJS</a> 和 <a target="_blank" rel="noopener" href="https://www.grapecity.com.cn/solutions/huozige">活字格</a> ，同样可以视为低代码平台，甚至早期的 .NET 开发者被人“黑”只会拖控件，这难道不是广义上的低代码吗？</p>
<h1 id="低代码产品形态"><a href="#低代码产品形态" class="headerlink" title="低代码产品形态"></a>低代码产品形态</h1><p>搞清楚整个低代码的发展现状以后，那么，整个低代码领域主要的产品形态有哪些呢？了解其主要的产品形态，对于我们形成低代码的直观印象非常有帮助。在我看来，主要分为四类：</p>
<ul>
<li>表单生成类：以 <a target="_blank" rel="noopener" href="https://www.aliwork.com/">宜搭云</a> 和 <a target="_blank" rel="noopener" href="https://www.jnpfsoft.com/">JNPF</a> 为代表，主张通过可视化的设计器来完成页面布局、编排、设计，即所谓的“所见即所得”，类似的还有 <a target="_blank" rel="noopener" href="https://www.ivx.cn/">iVX</a>。</li>
<li>工作流生成类：以 Mendix 和 Outsystems 为代表，提供组件式的服务，通过编排工作流来实现特定的业务，即通过流程图的方式来实现业务逻辑部分，不同的节点代表不同的功能，不同的线条代表不同的分支。</li>
<li>协同工作类：以 <a target="_blank" rel="noopener" href="https://www.seatable.cn/">SeaTable</a> 为代表，基于表的业务驱动开发平台，可以以不同的维度管理数据、对数据可视化、共享协作等等，同时具备自动化规则、脚本运行等能力。</li>
<li>服务聚合类：以 <a target="_blank" rel="noopener" href="https://www.apicloud.com/">APICloud</a> 为代表，基于 API 聚合的组件市场工具，通过流程管理工具，可以管理整个应用的开发周期，从产品、设计开始，到研发测试和运营。</li>
</ul>
<p>所以，整体而言，低代码产品的核心是<strong>表单引擎</strong> 和 <strong>流程引擎(BPM)<strong>，外围支撑是</strong>BI 引擎</strong>、<em><strong>协同工作</strong>、</em>*服务聚合**等等，目前，市面上主流的低代码产品，表单引擎和流程引擎(BPM)基本是标配，所以，严格地说起来，上面的分类并不严谨，因为基本上都是混合式的产品形态。下面是部分低代码产品的截图：</p>
<p><img src="https://i.loli.net/2021/02/15/sY4r1ZHevJlKIE6.png" alt="某“低代码”二维码应用"></p>
<p><img src="https://i.loli.net/2021/02/15/u6AIRJGCeV4hPSg.png" alt="某“低代码”人力资源管理系统"></p>
<p><img src="https://i.loli.net/2021/02/15/4DyZAzi53wVEn6p.png" alt="某“低代码”可视化搭建系统"></p>
<h1 id="低代码研发痛点"><a href="#低代码研发痛点" class="headerlink" title="低代码研发痛点"></a>低代码研发痛点</h1><p>相信大家都知道了，接下来的内容是本文真正的重点。为什么要这样说呢？这主要和博主自身的工作有关系，简单来说，公司需要一个想象中的可视化设计器，业务人员只需要通过拖拽就可以完成业务逻辑的编排，而开发人员则需要负责对外输出组件供业务人员使用。这听起来特别像我们刚刚讨论的第二种产品形态对不对？听起来非常美好对不对？我承认这个想法真的符合潮流、非常的“低代码”。所以，我们前期采用了微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/framework/windows-workflow-foundation/">Windows Workflow Foundation</a> 框架，使用以后的效果大概是下面这个样子：</p>
<p><img src="https://i.loli.net/2021/02/15/hYpq4nCk5BsFdHi.jpg" alt="Windows Workflow Foundation 设计器"></p>
<h2 id="多人协作不便"><a href="#多人协作不便" class="headerlink" title="多人协作不便"></a>多人协作不便</h2><p>那么，我们在这个过程中到底遇到了哪些问题呢？首先，这种可视化编辑的场景，遇到的第一个问题就是<strong>多人协作</strong>，如果你使用过腾讯文档、钉钉文档这类在线文档类产品，你应该能领悟到我说的这个点。微软的这个框架是采用<code>XMAL</code>这种格式来储存数据的，虽然理论上可以通过 <code>Git</code> 实现多人协作，实际维护起来表示非常地麻烦，所以，我们最终由单人去维护这些工作流。那么，更广义上的低代码又该如何解决这个问题呢？流程图这种东西，就是一种看起来非常清晰，改起来非常麻烦的东西，就像一条锁链一样，你要不停地断开和接上。</p>
<h2 id="孱弱的表达能力"><a href="#孱弱的表达能力" class="headerlink" title="孱弱的表达能力"></a>孱弱的表达能力</h2><p>其次，是流程图这种表现方式的“表达”问题，就像你如果需要在<code>SQL</code>里表示循环要用到游标一样，这类工作流都无法表达程序三个结构中的循环，更不用说<strong>表达力孱弱</strong>的表达式啦，所以，这就造成一个非常尴尬的问题，你在流程图里写不了太复杂的表达式，一旦业务人员写不出来，就需要开发人员去写辅助性质的代码，类似<strong>正则</strong>、<strong>字符串插值</strong>、<strong>字符串处理</strong>、格式化等等的函数或者 API 非常缺乏。当然，我最无法忍受的，就是组件与组件间传值的方式，你除了返回 JSON 和写表再没有其它方式，更何况这个 JSON 返回给某个组件了，人家还未必能直接解析直接使用呢？因为编辑器无法绑定这种复杂的数据结构。</p>
<h2 id="混乱的变量和参数"><a href="#混乱的变量和参数" class="headerlink" title="混乱的变量和参数"></a>混乱的变量和参数</h2><p>接下来，我最想吐槽的是，关于<strong>全局变量</strong>和<strong>参数</strong>的问题，在流程图中你经常需要各个分支的标志位(Flag)或者是临时变量，然后你就看到了那种“变量满天飞”的混乱局面，简直像极了你刚开始写的代码，你需要顺着每个线条，逐个点开每个组件的属性面板，查看它都使用了哪些参数或者变量，至此，你终于明白了它的数据是如何流动的。从前，乡愁是成千上万行的代码；现在，乡愁是剪不断理还乱的“<strong>蜘蛛网</strong>”。多年前，我对虚幻引擎(<strong>Unreal</strong>)的蓝图功能有多么憧憬；多年后，我对这种基于流程引擎的低代码就有多排斥。尤其是，当我需要复用某一段逻辑的时候，我只能小心翼翼地选中节点和线条，然后再拷贝过去。</p>
<h2 id="动态计算-事件顺序-黑盒子"><a href="#动态计算-事件顺序-黑盒子" class="headerlink" title="动态计算&#x2F;事件顺序&#x2F;黑盒子"></a>动态计算&#x2F;事件顺序&#x2F;黑盒子</h2><p>最后，我参考了一位被 <a target="_blank" rel="noopener" href="https://powerapps.microsoft.com/zh-cn/">Power Apps</a> 所折磨的朋友的意见，除了上面提到的这些问题， <strong>属性</strong>面板或者<strong>公式</strong>无法使用动态计算的值，类似<code>Vue</code> 里面的计算属性，从实际使用的体验来看，这类以流程引擎和表单引擎为主要卖点的低代码工具，其实都会存在这样的问题，而面对这种问题，一般只能通过<code>trick</code>的手段来解决。同样地，<a target="_blank" rel="noopener" href="https://powerapps.microsoft.com/zh-cn/">Power Apps</a> <strong>事件顺序的不确定</strong>问题，因为低代码实际上是框架提供了某种机制，可以帮你完成某个事情，所以，低代码内部对于使用者来说，完全就是一个<strong>黑盒子</strong>，譬如 <a target="_blank" rel="noopener" href="https://powerapps.microsoft.com/zh-cn/">Power Apps</a> 在无网络的环境下使用会卡顿，调试起来非常不便等等。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>坦白来讲，这篇博客实在没什么“技术含量”，无非是按照一个月前的计划在整理内容。我对“低代码”持一种中立的态度，作为程序员，我是希望有这样的技术来简化流程，可以让研发人员从枯燥的“增删改查”中解放出来，留出时间去做更多有意义、有价值的事情。当我了解了低代码和零代码的差异以后，我突然明白，我需要的其实是零代码，因为我希望那帮业务人员能自己搞定，这样就不用再来烦我，可经历这段时间的“低代码”，我清醒地认识到，这个想法根本不现实。<strong>一来业务人员并不像他们想象的那样，除了不会写代码以外无所不能；二来业务的复杂性满足守恒定律，它永远不会消失，只会从一种形式变成另一种形式</strong>。<strong>也许，低代码真的能帮企业省不少钱；也许，企业最喜欢做的事情，就是花点小钱招人外包做这种事情。但我依然想告诫开发者们，不要去追逐这些看起来美好的东西，对企业来说，它今天使用 A 技术，明天使用 B 技术，完全无关紧要。可对于个人而言，这个选择显得非常重要。看一看曾经的 SAP 咨询顾问就知道了，如果有一天 SAP 都倒闭了，你掌握着这些只有在 SAP 上能发挥作用的技术有什么用呢？对技术人员来说，学习通用型的知识和技能，永远比把鸡蛋放在一个篮子里要更保险</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/10/2021/react-login-sign-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/10/2021/react-login-sign-up/" itemprop="url">React 入门：实现基本登录注册功能</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-10T13:27:06+08:00">
                2021-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>前端老年人复健篇，堂堂连载！</p>
<p>两年多没碰前端，感觉自己已经完全与时代脱节了。作为一个从 jQuery 一把梭时代过来的选手，对于现在那些「大前端」的玩意儿基本都是只懂个皮毛的状态（指看过 Hello world）。四年前我引用过这么一篇文章，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22782487">《在 2016 年学 JavaScript 是一种什么样的体验？》</a>，放到现在要是出个 2021 版本，估计会更唬人吧。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/02/10/2021/react-login-sign-up/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/c0e3674b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/c0e3674b.html" itemprop="url">一月总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-10T12:02:07+08:00">
                2021-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>呼~ 最近实在忙，都没时间写上个月的总结，现在都 2 月 10 号了，还有两天就过年啦，得赶紧把一月份的总结写了。</p>
<p>总的来说上个月还是过得比较充实的，前半月工作上比较闲，比较多私人时间来做自己的事，下半月赶了个项目，整整两个星期都在日夜赶进度，完全没有私人时间，好在现在已经调整回来。</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><h3 id="把你的英语用起来"><a href="#把你的英语用起来" class="headerlink" title="把你的英语用起来"></a>把你的英语用起来</h3><blockquote>
<p>透析法读原著，原地复活你放下多年的英语！ 本书彻底解救一直想学英语，但从来没有坚持下来的人！</p>
</blockquote>
<p>我就是那些一直想学英语，但是从来没有坚持下来的人，我尝试过各种背单词软件、也尝试过直接看英文原著，但是效果都不怎么显著，上个月别人给我推荐了这本《把你的英语用起来》，我看了一下此书的简介，可能这本书确实可以解决我学习英语的困境，于是我读了起来。</p>
<p>本书根据不同级别的人提供了相应的学习方法，经过书中的自测方法，我目前属于初级，于是按照书中里面所提到的办法，先把基础练好。</p>
<p>书中建议先按照《赖世雄美语从头学》这套课程学习一段时间，然后再回来跟着本书练习。</p>
<h3 id="赖世雄美语从头学"><a href="#赖世雄美语从头学" class="headerlink" title="赖世雄美语从头学"></a>赖世雄美语从头学</h3><p>其实，一年前我就买了赖世雄老师的全套书籍，然而一直放在床底吃灰，主要原因是我不太习惯使用纸质书籍学习，虽然附送了光盘，但是使用起来不方便，这次我在 B 站上找了一套别人搬运上去的视频。</p>
<p>以每天学习三节的速度，学完这套课程大概需要三四个月，但是仅在这短短半个月，我就能够感觉到我的英语能力得到了很大的提升，特别是语感方面，这比单纯背单词的效率来得更高。</p>
<p>起初我的学习方法是：把对话句子抄下来，没事的时候拿出来读一读，后来我发现这并不是该课程的正确打开方式，因为课程中每一节都会花大量的时间来讲解语法，所以不仅要能读出来里面的例子，更重要的是理解这些句子背后的语法结构，这样才能更好地在现实中应用。</p>
<p>我把学习笔记放在了语雀：<a target="_blank" rel="noopener" href="https://www.yuque.com/4ark/eryhwc/bzbvqk">赖世雄美语从头学</a></p>
<h2 id="读完的书籍"><a href="#读完的书籍" class="headerlink" title="读完的书籍"></a>读完的书籍</h2><h3 id="清醒思考的艺术"><a href="#清醒思考的艺术" class="headerlink" title="清醒思考的艺术"></a>清醒思考的艺术</h3><p>本书的全名是：清醒思考的艺术 —— 你最好让别人去犯的 52 种思维错误。</p>
<p>简而言之，书中讲了 52 个思维错误，其中有一些是日常生活中比较常见的，但也有一些是比较不易察觉的，虽然我认为大部分思维错误其实都是很难避免的，但是能够意识到它的存在还是很有用的。</p>
<p>不过本书只是做一个 check list 的作用，并没有讲得太深入，我之前也读过一遍，此次重读有两个目的：1）我应该要能意识到更多的思维错误；2）为了尝试在 notion 中作读书笔记，而本书的结构是最好不过了。</p>
<p>读书笔记：<a target="_blank" rel="noopener" href="https://www.notion.so/4ark/0e0b80deb60e4854bcdf0f8a4bd5e3a2">《清醒思考的艺术》读书笔记</a></p>
<h3 id="微思考-——-少有人走的路"><a href="#微思考-——-少有人走的路" class="headerlink" title="微思考 —— 少有人走的路"></a>微思考 —— 少有人走的路</h3><p>本书一口气读完，可能是阅历不够，感觉并没有太大的收获，让我印象比较深刻的是：</p>
<ul>
<li>分析自己的性格，思考自己努力从事的职业本身是否真的适合自己的天性。</li>
<li>千万不要做你不擅长的事情，否则，你会发现自己就像深陷于泥潭之中一般，只能徒劳地挣扎、抱怨。</li>
</ul>
<p>我在读到这个观点的时候，是挺认同作者这句话的，如果一个人去从事自己性格不擅长的事，那他必然是痛苦的，至少不比从事自己擅长的职业要来得轻松。所以，分析自己的性格，找到自己最擅长的事，并以此为职业，可能是最好的选择。</p>
<p>但是后来我又想，现实中不乏有人为了生活去做根本不适合自己性格的事，但经过磨练后，依然能够做得很好。</p>
<p>至于是顺势而为还是逆势而行，每个人都会有不同的选择，其实都没有错，虽然我是前者，但我更佩服后者。</p>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>上个月看了几部电影，大部分是韩国的，其中让我印象最深刻的是：</p>
<ol>
<li>熔炉</li>
<li>辩护人</li>
<li>出租车司机</li>
<li>寄生虫</li>
<li>海云台</li>
</ol>
<p>曾经我和大部分国人一样，对韩国充满厌恶，因为他们对中国历史文化的侵占，以及体育精神上的不道德。但是，这几部电影让我改变了对这个国家的看法，至少我认为在这电影方面，我们远远不如他们。</p>
<p>引用豆瓣上的两句短评：</p>
<ol>
<li>他们有改变国家的电影，我们有改变电影的国家</li>
<li>我们只有灾难，没有灾难片</li>
</ol>
<p>虽然电影并不需要背负起改变国家的责任，但是电影也不应作为政治的宣传物。即便拍不出跟他们并肩的电影，也请不要拍一些无脑剧来拉低我们的智商。</p>
<p>话说回来，我们国家不是没有人才能够拍出这些电影，我们八十年代也有过类似的电影：《光荣的愤怒》、《见习律师》、《村戏》等，只是后来都被禁了而已。</p>
<p>再引用一句微博上某不知名人士的话：提倡文化自信，更重要的是文化，而不是自信。</p>
<h2 id="史记-——-报任少卿书"><a href="#史记-——-报任少卿书" class="headerlink" title="史记 —— 报任少卿书"></a>史记 —— 报任少卿书</h2><p><a target="_blank" rel="noopener" href="https://4ark/posts/bao-ren-shao-qing-shu/">报任少卿书</a></p>
<h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><p>从这个月开始，除了记录一下我的所做的事情之外，再增加一点内容，那就是分享一下我发现的一些好东西，包括但不限于：文章、网站、工具、书籍等。</p>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul>
<li><a target="_blank" rel="noopener" href="http://einverne.github.io/post/2015/09/korean-film-brotherhood.html">残忍的战争</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zuola.com/weblog/2004/05/8.htm">什么才是真正的执行</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pongba/article/details/3549560">如何清晰地思考</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.techbridge.cc/2021/01/23/dom-clobbering/">淺談 DOM Clobbering 的原理及應用</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CYIqWZSrK_OcZ3vL5W5FGA">黄子华的蝴蝶飞不过沧海</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/technical-blog-experience/">写了十年技术博客，我收获了什么</a></li>
<li><a target="_blank" rel="noopener" href="http://tinylab.org/shell-redirect-stderr-stdout/">Shell 中的 2&gt;&amp;1 命令是什么，这次彻底搞清楚了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rainjay/blog/issues/7">谈谈时间管理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rainjay/blog/issues/6">金字塔原则</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6923936548027105293">像玩 jQuery 一样玩 AST</a></li>
<li><a target="_blank" rel="noopener" href="https://jub0bs.com/posts/2021-01-29-great-samesite-confusion/">The great SameSite confusion</a></li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a target="_blank" rel="noopener" href="https://shanyue.tech/">山月的琐碎博客记录</a></li>
<li><a target="_blank" rel="noopener" href="https://ctext.org/zhs">中国哲学书电子化计划</a></li>
<li><a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">OpenResty 最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="https://folkstory.github.io/lingqiu-folk-story/#/?id=%E5%BA%8F">灵丘民间故事歌谣谚语</a></li>
<li><a target="_blank" rel="noopener" href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a></li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://real-world-plantuml.com/?type=activity">Real World PlantUML</a> ：大量 UML 文本绘图模板，可直接复制代码</li>
<li><a target="_blank" rel="noopener" href="https://you-tldr.com/">you-tldr</a> ：根据 youtube 视频字幕快速生成文本</li>
<li><a target="_blank" rel="noopener" href="https://demo.greenroots.info/categories/web-apis/">web-apis</a>：一些 web api 的 demo</li>
<li><a target="_blank" rel="noopener" href="https://multiavatar.com/">Multiavatar</a>：根据你的昵称生成专属头像（但是好丑</li>
<li><a target="_blank" rel="noopener" href="https://moiva.io/">MOIVA</a>：快速调研某个 npm 包</li>
<li><a target="_blank" rel="noopener" href="https://tiny-helpers.dev/">Tiny helpers</a>：开发者在线工具集合</li>
<li><a target="_blank" rel="noopener" href="https://github.com/conwnet/github1s">github1s</a>：只要在 GitHub 仓库域名后面加上<code>1s</code>，即可在 Web 版的 VS Code 浏览代码，终于不需要再 clone 到本地啦（其实 youtube 也有 +1s 的操作</li>
<li><a target="_blank" rel="noopener" href="https://github.com/JonnyBurger/remotion">remotion</a>：使用 React 编程的方式创建视频</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84Thought%20Works%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84Thought%20Works%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/" itemprop="url">记一次失败的 ThoughtWorks 面试经历</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-09T20:37:47+08:00">
                2021-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>年前朋友问我，要不要试试 ThoughtWorks 澳洲线的岗位。对于这家号称“<strong>世界上面试最难</strong>”的公司，多少还是有一点畏惧，直到朋友安慰我说，它们这次有中级的岗位，还是可以试一试的，梦想还是要有的，万一实现了呢？自此，我凑齐了西安. NET圈子里的四大“天花板”公司的面试：<strong>葡萄城</strong>、<strong>活跃网络</strong>、<strong>奥博杰天</strong>、<strong>ThoughtWorks</strong> ，而对于我来说，亦有幸见识到世界上最难的面试，虽然后来事实证明，这个世界上没有太多的逆袭，可我还是想分享一下我的这次面试经历，因为它让我知道，在过去的两年里，我在哪些方面取得进步，在哪些方面存在不足。当我写下这篇博客的时候，我即将在今年夏天迎来我的29岁，果然我还是希望自己能再努力一点，因为不想让平行世界里的某个人失望。</p>
<h1 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h1><p>关于ThoughtWorks 的社招流程，大体上由<strong>HomeWork</strong>、<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong>  3个部分组成，其中，HomeWork，即家庭作业，原则上给3天时间来完成，不过据说可以向 HR 申请更多的时间来完成。<strong>Pair Programming</strong> 和 <strong>Face-to-face Interviews</strong> 通常是安排到同一天来进行的，前者时间为1.5小时，即传说中的结对编程，面试时会有一左一右两名面试官看着你现场写代码。后者时间为1小时，即传说中的技术文化面试，考察技术的深度、广度以及对 Thought Works 敏捷文化的认同感。</p>
<h2 id="HomeWork"><a href="#HomeWork" class="headerlink" title="HomeWork"></a>HomeWork</h2><p>2月18日，下班以后接到HR小姐姐的电话，在明确了我投简历的意向以后，我收到了HR小姐姐的邮件，基本上就是一个家庭作业，三选一提交，需要在三天内完成。我选择了Conference Track Management 这道题目，因为白天要上班，所以，我为此而连续肝了三个晚上。</p>
<p>坦白说，不同的阶段对这道题目的理解是不同的，在做家庭作业的阶段，你以为这道题考察的是职责分离和设计模式；而等到结对编程的阶段，你终于意识到，这其实是个背包问题。当然，这并不是说我会错了意，考虑到面试官有上帝视角，他们更容易看清楚问题的全貌。或许，面试官想最想看到的，恰恰就是你从冰山一角到目窥全牛这一瞬间的反应。</p>
<p>当我接到HR小姐姐的通知，这份作业Review通过时，我内心是非常激动的，因为这意味着我获得了去ThoughtWorks面试的“入场券”。可当我事后再以上帝视角去看待这个题目，我内心又变得非常难过，因为无论怎么看这份作业，都会觉得它设计得并不好，尤其是当它引入弹性时间这个因素以后，我一直深陷于如何从Part 1 到 Part 2，是不是按 Part 2 重新设计会更好一点？此时此刻，终于能理解面试官反馈的，关于扩展性方面的问题。</p>
<p><img src="https://i.loli.net/2021/02/09/7Ae6bSmujgvsB9G.jpg" alt="作业反馈01"></p>
<p><img src="https://i.loli.net/2021/02/09/NEQ9YmjMtHbI8eL.jpg" alt="作业反馈02"></p>
<p><img src="https://i.loli.net/2021/02/09/v6fluwU1bi4akBH.jpg" alt="作业反馈03"></p>
<p>关于这部分，我个人建议多多关注：</p>
<ul>
<li>编程风格：编码规范、项目结构、代码坏味道等。</li>
<li>语言特性：澳洲线岗位需要熟悉 .NET Core，所以，我使用 .NET Core 完成整个项目的编写。</li>
<li>设计模式：选择合适的设计模式，遵循 SOLID 原则。</li>
<li>TDD：一定要有单元测试代码，这一点TW最为看中。如果写的好，一定是加分项。建议遵循AAA原则来编写用例。</li>
<li>程序满足要求：程序一定满足题目要求，可执行，运行结果满足题意，这是最基本的要求。</li>
</ul>
<h2 id="Pair-Programming"><a href="#Pair-Programming" class="headerlink" title="Pair Programming"></a>Pair Programming</h2><p>提交作业后，等了一周多的时间，1月29日，HR 小姐姐终于联系我了，正如我上文所述，当时听到这个消息非常激动，因为终于有机会去 ThoughtWorks 这家世界上面试最难的公司去看看，ThoughtWorks 西安办公室位于环普产业园，这个地方相信大家都非常熟悉啦！当时算上周末，我给了自己 5 天时间去准备面试，因为我觉得面对 ThoughtWorks 的面试还是要重视一点，虽然后来好多问题都没有被问到。</p>
<p>结对编程是基本上就是，两个面试官一左一右地坐在你旁边，采用聊天和探讨的方式一起写代码，刚开始本来是用电视投屏“直播”的方式，后来因为 HDMI 接口接触不良的缘故，两位面试官干脆就直接看我电脑屏幕啦！在这个环节，个人感觉解释编码思路花时间太多，重构完有一个用例没有通过。最重要的是，家庭作业阶段的设计不利于现场新需求的开展，所以，这些因素综合起来，导致我结对变成这个部分表现得不好，希望大家引以为戒啊。</p>
<p>整个结对编程时长为一个半小时(1.5h)，在这段时间，你需要<strong>讲解编码思路</strong>、<strong>完成代码重构</strong>和<strong>完成现场作业</strong>，时间上还是非常紧凑的，回想起那天下午的两个半小时，有种像参加高考的感觉：你以为时间会很长，结果发现时间完全不够用。看起来轻松的氛围下，其实在不经意间考察你的沟通能力、工程能力和学习能力，ThoughtWorks 的面试，往往就是这样的朴实无华且“有趣”……</p>
<p>对于这部分，我个人建议多多关注：</p>
<ul>
<li>工程能力：语言特性、调试能力、设计能力等。像TW非常重视快捷键的使用，频繁使用鼠标会拉低印象分。</li>
<li>沟通能力：善于倾听和表达、以及理解需求的能力，需要你在面试官的引导下完成需求确认，这个阶段一样可以展示你技术的深&#x2F;广度，但建议最好长话短说。</li>
<li>学习能力：要求你对TDD、敏捷开发等有一定的好奇心，面试官教给你的新东西&#x2F;思路，能否举一反三、学以致用，我是在重构的过程中得到了面试官的指导，对此我表示感谢。</li>
<li>适应能力：能否以开放的态度接受面试官的重构意见，当意见不一致时，能否有理有据地、自信地表达你的观点，我遇到的问题是，面试官认为我混淆了职责分离和组件依赖。</li>
</ul>
<h2 id="Face-to-face-Interviews"><a href="#Face-to-face-Interviews" class="headerlink" title="Face-to-face Interviews"></a>Face-to-face Interviews</h2><p>结对编程环节结束以后，正当我还在关注那个失败用例的时候，两位新的面试官就走了进来，就这样，我迎来了那天下午的“<strong>技术文化面试</strong>”，考虑到天气的原因，我那天穿了一件鬼灭之刃的卫衣就去参加面试了，可那个小房间的闷热还是让人焦躁不安，一杯放凉的白开水，完全不足以缓解那种闷热的感觉。ThoughtWorks 的办公室和大多数外包公司的办公室没有什么区别，不同的是，它的办公室摆满了各种 <strong>O’Reilly</strong> 的动物书，至少在氛围上确实像它对外所展示的那样重视技术。</p>
<p>在这个环节，我遇到了很多的开放型问题，譬如<strong>你经历过的、印象最深刻的项目是什么</strong>，<strong>你在项目中遇到问题以后都是怎么样去解决的</strong>，<strong>你所在项目的人员配置、研发流程是什么样的……等</strong>等，虽然一开始还是经典的“自我介绍”，可我感觉我在回答这些开放型问题的时候，缺乏一种系统性思考或者某种方法论，它和回答技术问题不同，有时候我们需要层层展开、关注细节，可是在这样的问题上，它需要的是简洁而准确的答案。面试期间，面试官不止一次提示我听清楚她的问题，难道真的是我的沟通能力出了问题吗？</p>
<p>坦白来讲，这次我准备的很多面试题都没有被问到，我以为至少会问一下.NET Core、微服务 和 DDD 这些东西的。我同样不太明白的，是关于项目经历方面的，为什么面试官会认为，工作中主要负责的内容就是由我一个人单打独斗来的呢？我承认我这几年，性格上收敛了许多，没有了攻击性和对抗性，变成了一个非常随和的人，可我本质上并不是一个喜欢兜售或者推销的人，我并不觉得无法口若悬河是缺乏自信的表现。后来，面试官就考察了一下我的口语，本来就是口干舌燥，说到为什么选择 ThoughtWorks 的时候，大脑有一点卡壳，一边在组织中文，一边在想怎么翻译成英文，还有什么比结结巴巴地说完一段英语更让人难过的呢？</p>
<p>对于这个部分，我个人建议多多关注：</p>
<ul>
<li>系统思考：结合工作经验，不断去提炼类似架构方向、敏捷开发、项目管理方面的内容，不要永远局限在一个点上看待问题，不管是表达还是编程，都采用系统性、结构化的思路来梳理，要做到清晰、准确、完整。</li>
<li>自信：ThoughtWorks 是一家咨询服务公司，所以，很多研发都是顶着咨询师的头衔，个人觉得还是自信一点，会就是会，正常交流，不会的话，就虚心接受，表现出后期愿意去学习的状态。</li>
<li>协作能力：能否影响和带动团队中的人一起学习、成长，ThoughtWorks 盛行学习和分享的文化，你一定听说过它们的技术雷达、洞见。</li>
<li>沟通能力：这体现在你能否和客户正常地沟通、能否和团队成员达成有效的协作，虽然程序员都不大喜欢说话，但你至少应该能传达出正确的声音、能理解来自别人的观点。</li>
<li>动机：对 ThoughtWorks 的意愿性&#x2F;认同度，为什么会考虑 ThoughtWorks 等这些问题。</li>
</ul>
<h1 id="面试心得"><a href="#面试心得" class="headerlink" title="面试心得"></a>面试心得</h1><p>其实，当天面试一结束，我就知道这次面试大概率是凉了。回去的路上，我和老大哥说了我面试的过程，老大哥说，“<strong>让我冷静，要对自己有信心</strong>”。果然，第二天下午，收到HR小姐姐的回复，说面试没有通过，看了下面试官反馈的意见，<strong>主要是在结对编程过程中重构做得不好，对重构的意义不太明确；其次是面试官觉得我在沟通方面还不够大胆，希望我可以在发展他人方面做出改变</strong>。</p>
<p>听到这话，怎么突然就有种传销的感觉呢？说到影响别人，从12年开始写博客至今，我自认为我的博客还是帮助到了很多人，可能面试官一直觉得我在单打独斗吧，都2021年了，早就不是求伯君、雷军这些前辈们单打独斗写软件的时代啦，所以，果然还是我的表达出现了问题吗？我的朋友们经常批评说我沉迷于技术无法自拔，可我同样见过30多岁怕别人问原理的“中年”程序员，原本这个行业因为门槛低而越来越内卷，而这个圈子里的人又不以技术为重，有太多单纯为了钱而进入这个行业的人。可当整个行业都越来越“体力”劳动的时候，有很多浮躁的人跑来你面前说，技术并不重要类似的话，这个世界到底怎么了呢？</p>
<p>我想说什么呢？我认为技术因素和非技术因素都很重要，其实写作一直是我练习表达的一种方式。也许，在那些能言善辩的人眼中，我们这些“闷葫芦”都是些内向的、不太会沟通的人吧！这次面试结束以后，<strong>我打算找点系统性思考方面的书来看看，继续背单词增加词汇量，利用空闲时间来练习口语</strong>。<strong>我从来不认为，一个技术人员努力钻研技术有什么不对，因为这是一个技术人员的基本功。沟通能力能做到妙语生花是一种艺术，而我，追求的目标非常简单，即有条理的、清晰的、结构化的表达，我不追求所谓“高情商”的话术，人类时常因为这些模棱两可的字眼而相互误会，因为信息失真，因为信息冗余</strong>。当然，此刻我的首要目标是，完成那个家庭作业的重构，因为它写得实在是太糟糕啦！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/79/">79</a><a class="extend next" rel="next" href="/page/18/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1579</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
