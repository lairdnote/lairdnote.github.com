<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/17/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/17/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-31-2021-mar-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-31-2021-mar-summary/" itemprop="url">三月总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-30T15:49:42+00:00">
                2021-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="uni-app-踩坑小记"><a href="#uni-app-踩坑小记" class="headerlink" title="uni-app 踩坑小记"></a>uni-app 踩坑小记</h2><p>这是我去年在工作中使用 uni-app 和 uView 踩的一些坑，虽然大部分通过搜索引擎能够找到解决方法，但这些记录更为深入的探究了背后的原因，主要是途径就是看 uni-app 的源码或者分析编译后的代码，本着共享精神，也希望大家不要重复踩坑，相信能够对大家有所帮助。</p>
<p>另外由于在语雀上也能支持互联网索引，也就没必要再搬过来了，且在语雀上的阅读体验要更好。</p>
<p>这是链接：<a target="_blank" rel="noopener" href="https://www.yuque.com/4ark/cya7sq/tvs0tu">uni-app 踩坑小记 · 语雀 (yuque.com)</a></p>
<h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://dbanotes.net/review/the_students.html">现在的计算机专业学生怎么这个样？</a><ul>
<li>冯大辉在 2004 年发表的文章，讲了计算机专业的大学生有多浮躁，今天看来依然没变。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-05/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E5%91%98%E5%80%BC%E5%BE%97%E8%8A%B1%E6%97%B6%E9%97%B4%E5%9F%B9%E5%85%BB%E8%87%AA%E5%B7%B1%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4.html">为什么程序员值得花时间培养自己的商业思维？</a><ul>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E7%AE%97%E8%B4%A6.html">程序员的商业思维：学会算账</a>：要考虑成本，除了成本，我们还应放眼于所得收益，毕竟：每个收益都有其合理的成本要求。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E8%A1%A8%E8%BE%BE.html">程序员的商业思维：学会表达</a>：提升表达力的渠道有写文章、尝试演讲等，另外代码能力本质上也是表达能力的一种。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9B%E5%BA%94%E9%93%BE.html">程序员的商业思维：建立自己的供应链</a>：1）找到你在供应链的位置；2）让外界知道你的能力，打造你的品牌。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.htmlhttps://blog.dteam.top/posts/2019-08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.html">程序员的商业思维：解决问题</a>：1）你掌握的技能不值钱，真正值钱的是你运用技能的能力；2）问题本身的价值越大，那么解决能力的价值也就越大；3）自己解决问题的能力固然重要，但是借助外部资源解决问题的能力同样重要；4）不要打着解决问题的幌子制造问题。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%90%9B%E5%AD%90%E4%B9%9F%E8%A6%81%E8%A8%80%E5%88%A9.html">程序员的商业思维：君子也要言利</a>：谈钱效率高，钱本来就是一种最有效的量化手段。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2019-12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%BC%9A%E5%A4%96%E4%BA%A4.html">程序员的商业思维：学会外交</a>：1）外交不是拉关系，“关系”很重要，但仅仅认为这就是“拉关系”就是大错特错；2）当客户总强调你需要替他考虑而不替你考虑时，请果断放弃；策略：守住底线、双赢思维、有的放矢、明确定价。</li>
<li><a target="_blank" rel="noopener" href="https://blog.dteam.top/posts/2020-03/something-about-personal-leverage.html">程序员的商业思维：关注杠杆率</a>：1）从字面上看，杠杆率并不高深，无外乎代表你一份努力能撬动多大的结果；2）产品化思维有助于提高你的个人杠杆率；3）杠杆率是你的变现能力，了解自己的杠杆率，也是你跟老板谈判的筹码。</li>
</ul>
</li>
</ul>
<h3 id="文章（技术类）"><a href="#文章（技术类）" class="headerlink" title="文章（技术类）"></a>文章（技术类）</h3><ul>
<li><a target="_blank" rel="noopener" href="https://web.dev/content-visibility/">content-visibility: the new CSS property that boosts your rendering performance</a><ul>
<li>Chrome CSS 新属性，跳过屏幕外内容的渲染，从而提高初始加载时间。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://2ality.com/2021/01/import-assertions.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+2ality+(2ality+%E2%80%93+JavaScript+and+more)">ECMAScript proposal: Import assertions</a><ul>
<li>ECMAScript 提案：Import assertions，在 JS 中 import 文件时断言它的类型。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/wiki/coding_guidelines.html">TypeScript 代码风格</a>：可以参考一下。</li>
<li><a target="_blank" rel="noopener" href="https://web.dev/how-to-use-local-https/">How to use HTTPS for local development</a>：使用 <a target="_blank" rel="noopener" href="https://github.com/FiloSottile/mkcert">mkcert</a> 工具来让本地网站支持 HTTPS。</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936448887360077831">no-stream 似乎比 js 原生数组方法快</a>：没有黑魔法，仅仅是因为它只遍历一遍数组。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WakeLock">WakeLock</a>：一个实验性的 WEB API，用于使设备保持唤醒状态</li>
<li><a target="_blank" rel="noopener" href="https://adamschwartz.co/magic-of-css/">Magic of CSS</a>：一些 CSS 知识</li>
<li><a target="_blank" rel="noopener" href="https://blog.techbridge.cc/2021/03/28/how-source-map-works/">Source map 运行原理</a></li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/google/gts">google&#x2F;gts</a>：Google 的 TypeScript 代码风格，用于格式化和 lint。</li>
<li><a target="_blank" rel="noopener" href="https://www.tabnine.com/">tabnine</a>：使用 AI 更快的完成代码，支持各大 IDE 扩展（PS：在我电脑上内存占用有时候会飙升）。</li>
<li><a target="_blank" rel="noopener" href="https://estimator.dev/">EStimator</a>：通过提供现代 JavaScript 语法来计算网站的大小和性能改进。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GitSquared/edex-ui">eDEX-UI</a>：跨平台终端工具，炫酷就完了。</li>
<li><a target="_blank" rel="noopener" href="https://jspm.org/docs/cdn">JSPM</a>：原生 ES 模块 CDN。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/qeeqbox/social-analyzer">Social Analyzer</a>：一个通过 API&#x2F;CLI&#x2F;Web App 在 350+ 个网站分析、找寻特定用户资料的工具。它提供了不同的字符串分析和检测模块，可自由在“调查”过程中组合使用。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/swc-project/swc">swc</a>：一个用 rust 开发的 typescript 编译器</li>
<li><a target="_blank" rel="noopener" href="https://danger.systems/js/">danger-js</a>：一个审查危险代码的 CI 工具</li>
<li><a target="_blank" rel="noopener" href="https://clinicjs.org/">Clinic.js</a>：一个帮助诊断和检查 Node.js 性能问题的工具</li>
<li><a target="_blank" rel="noopener" href="https://qwerty-learner.vercel.app/">Qwerty Learner</a>：为键盘工作者设计的单词记忆与英语肌肉记忆锻炼软件</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-3-29-githubbeautify/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-3-29-githubbeautify/" itemprop="url">如何美化 GitHub 个人主页？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-29T14:00:00+00:00">
                2021-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/github-g1-chip-octocat-developer-tools-developer-g.png" alt="GitHub G1 Chip octocat developer tools developer github app icon app i"></p>
<p>Hello 大家好，我是安哥。   </p>
<p>之前在 GitHub 上找东西的时候，无意间看到一位网友的 GitHub 主页弄得很好看：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170226251048.jpg" alt="-w1399"></p>
<p>对比 GitHub 主页原来默认的样式，好了不止一点两点。附上 GitHub 主页默认的样式（不要误会，我并没有批评下图的作者的意思，这张图是我随便找的）：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170227763856.jpg" alt="-w1433"></p>
<p>我后来在网上搜了一下，发现实现这个效果也不难，依葫芦画瓢做了一下，效果如下。对比原版还是有点丑，但我已经挺满意了。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170222939614.jpg" alt="-w1475"></p>
<p>下面简单讲一下实现方法：   </p>
<p>在 GitHub 中创建一个与 GitHub ID 同名的仓库，例如我的 GitHub ID 为 phh95，因此创建的仓库名也为 phh95。   </p>
<p>由于我已创建了这个仓库，所以 GitHub 会在下方提示我已经创建过同名的仓库了。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170231333641.jpg" alt="-w1475"></p>
<p>创建时记得勾选从下方的「Add a README file」，在仓库中添加一个 README 的 Markdown 文件，等会我们就是要在这个文件中创建我们最终想要的个人主页样式。          </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170233210242.jpg" alt="-w1475"></p>
<p>创建仓库之后，点击右上角的个人头像，选择「Your profile」回到你的 GitHub 主页，你应该就可以看到 Hi there 👋 的文本内容。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170236462097.jpg" alt="-w1441"></p>
<p>点击右侧的编辑按钮，进入 REMDME 文件的编辑状态。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170237918890.jpg" alt="-w1475"></p>
<p>进入编辑状态，这个文档是使用 <strong>Markdown 语法</strong>来编辑的，如果你之前用过 Markdown 的话，编辑起来应该非常简单，如果你没接触过，想学的话十分钟也可以入门。  </p>
<p>只需要记住一点，上一行结束时，要在最末尾加多至少两个空格，才能实现换行，否则本来想分行的两行内容会连在一起。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170240040252.jpg" alt="-w1475"></p>
<p>编辑的过程中，点击上方的「<strong>Preview changes</strong>」选项卡，查看 Markdown 渲染后的效果。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170242625606.jpg" alt="-w1475"></p>
<p>这里着重说一下个人主页中一个看起来比较高级的「小牌子」的实现方法：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170244947247.jpg" alt="-w989"></p>
<p>上面这个小牌子其实是一个 <strong>svg 图片</strong>，生成这个 svg 图片需要用到一个在线工具「Shields.io」。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170249379436.jpg" alt="-w1461"></p>
<p>这是个外国的网站，我使用浏览器自带的翻译功能将其翻译成中文。  </p>
<p>前面我们说的小牌子，对应的英文为 <strong>BADGE</strong>，浏览器翻译为了「<strong>徽章</strong>」。   </p>
<p>以前面的小牌子「写作工具｜VS Code」为例，生成这个小牌子的方法如下：   </p>
<p><img src="https://img.shields.io/badge/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7-VS%20Code-blue">     </p>
<p>在网页 Shields.io 从左到右的三条短横线上填写：写作工具、VS Code、以及从颜色库中挑选一个颜色（这个颜色决定了第二个文本 VS Code 的背景色），最后点击右侧的「制作徽章」。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170252694705.jpg" alt="-w1461"></p>
<p>页面会返回生成的 svg 图片，效果如下图所示，觉得满意的话，复制页面地址栏的网址。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170255242593.jpg" alt="-w1461"></p>
<p>回到刚刚在编辑的 MD 文件中，先输入如下的字符，接着将刚才复制到剪贴板的链接 🔗 粘贴到英文括号 () 中，即以图片的形式将生成的 svg 图片添加到我们的 MD 文档中。     </p>
<p><code>![]()</code></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170259342090.jpg" alt="-w1475"></p>
<p>将 README 文档切换到渲染视图，就可以看到我们想要的小牌子了。   </p>
<p>​这里只讲最简单的小牌子的制作方法，下图中的第四个 Git 小牌子制作起来会复杂一些些，其实就是在 svg 图片链接中加多了一个参数，感兴趣的朋友可以去下载别人的 GitHub 同名仓库进行拆解，这里不多讲。<br>​<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/16170261067119.jpg" alt="-w1475"></p>
<p>Shields.io 官网：<br><em><a target="_blank" rel="noopener" href="https://shields.io/">https://shields.io/</a></em>  </p>
<p>如果你觉得我还是没讲清小牌子的用法，可以参考来自少数派上的一位作者 @SpencerWoo 写的文章《用 Substats 和 Shields.io 为你的个人主页定制动态数据小牌子》：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/qrcodea--a1.png" alt="QRcode_A — a1"></p>
<p>以上，希望有帮助。 </p>
<p>本文首发于我的公众号「效率工具指南」，欢迎关注。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/29/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号尾部二维码 带logo"></p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-29-the-food-of-lbss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-29-the-food-of-lbss/" itemprop="url">码农装逼菜谱 (三) - 凉拌三丝</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-28T23:42:20+00:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天的装逼菜谱是：凉拌三丝。</p>
<p>做的时候忘了拍照，下次补图。</p>
<h2 id="用料"><a href="#用料" class="headerlink" title="用料"></a>用料</h2><p>食材：马铃薯粉丝，莴笋，胡萝卜</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用量</th>
</tr>
</thead>
<tbody><tr>
<td>马铃薯粉丝</td>
<td>40 克</td>
</tr>
<tr>
<td>莴笋</td>
<td>半个</td>
</tr>
<tr>
<td>胡萝卜</td>
<td>1 个</td>
</tr>
</tbody></table>
<p>调料：糖，醋，酱油，耗油，香油，麻油，盐。</p>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>莴笋和胡萝卜去皮，用刮刀刮成丝。</p>
<p>莴笋丝加入 5g 盐腌制 15 分钟，然后用手挤掉水份。</p>
<p>胡萝卜快速焯水一下，捞起备用。</p>
<p>马铃薯粉丝用开水煮半分钟，关火用开水泡 5 分钟备用。</p>
<p>如果想做升级版的，可以再加入：鸡蛋皮，金针菇，鸡胸肉。</p>
<ul>
<li>鸡蛋煎成蛋皮，切成丝备用。</li>
<li>金针菇煮 3 分钟捞起备用。</li>
<li>鸡胸肉用开水煮，加料酒，4 分钟之后捞起撕成丝备用。</li>
</ul>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>找一个大碗，将原料混合。加入糖 2 小勺，醋 1 小勺，蚝油 1 小勺，香油 2~3 小勺，麻油 1 小勺，盐少许。拌匀即可。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>糖醋需要配合一起放，起香味的是香油，麻油，蚝油。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%B5%85%E8%AE%AE%20EF%20Core%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%B5%85%E8%AE%AE%20EF%20Core%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="url">浅议 EF Core 分库分表及多租户架构的实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-27T09:47:47+00:00">
                2021-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>各位朋友，大家好，我是 Payne，欢迎大家关注我的博客，我的博客地址是：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/">https://blog.yuanpei.me</a>。最近这段时间，我一直在学习 <a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 框架，在整个学习过程中，我基本就是在“<strong>文档</strong>”和“<strong>源码</strong>”间来回横跳。我个人推荐大家，多去阅读一点优秀的代码，因为阅读 <a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 的源代码简直就是一种享受，它可以暂时让你摆脱如泥沼一般的业务代码。言归正传，<a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 是一个支持多租户架构的框架，在了解了其多租户的实现原理以后，从中收获一点微不足道的小技巧。正好前几天，刚刚同一位朋友讨论完分库、分表这类话题。因此，在今天这篇博客中，我想和大家一起探讨下 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli">EF Core</a> 关于分库、分表以及多租户架构的实现。此中曲折，可以说是初窥门径，或许我无法提供给你一个开箱即用的方案，至少它可以带给你一点启发。有读者朋友建议我，不要总是写这种“<strong>高深</strong>”、“<strong>复杂</strong>”的话题，适当地迎合读者写点不需要动脑子的东西。对此，我想说，我有我个人技术上的追求，希望大家理解！</p>
<h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><p>首先，我们一起来探讨分库这个话题。从字面含义上了解，分库就是指<strong>应用程序拥有多个数据库，而这些数据库则拥有相同的表结构</strong>。你可能会问，为什么我们需要分库、分表？答案自然是<strong>性能</strong>，<strong>性能</strong>，还是TM的<strong>性能</strong>。我相信，大家都曾经或多或少地听到过<strong>垂直拆分</strong>、<strong>水平拆分</strong>这样的术语，下图展示了如何在<strong>数据库</strong>这一层级上进行拆分：</p>
<p><img src="https://i.loli.net/2021/03/29/nX8NBbhP9ToQa2M.png" alt="数据库的垂直拆分与水平拆分"></p>
<p>其实，我们可以从<strong>索引存储</strong>、<strong>B+树高度</strong>、<strong>QPS</strong> 和 <strong>连接数</strong> 这四个不同的角度来审视这个话题。相关观点认为，当单表数据量达到一定量级(阿里巴巴Java开发手册中为500W)时，由于内存无法存储其索引，此时SQL查询会产生磁盘IO；行记录的大小决定了B+树的每个叶子节点能存储多少记录，所以，行记录的大小会影响B+树的高度；单个MySQL物理机实例写QPS峰值大概为1万，一旦业务量达到某个量级，这个瓶颈会逐步凸显出来；单个MySQL实例最大连接数有限，更多的访问量意味着需要更多的连接数。</p>
<p>在谈论分库、分表的时候，我们忍不住会去想譬如“<strong>自动分表</strong>”和“<strong>路由</strong>”这样的问题，这些子库、子表，到底是提前在数据库里分好呢，还是在运行时期间自动去拆分呢，以及我对库&#x2F;表进行拆分以后，我应该怎么样找到某条数据对应的库&#x2F;表。我承认，这些问题并不简单，但当我们对问题进行简化以后，分库本质上就是动态地切换数据库，对不对？无非是拆分后的数据库可能会是类似db_0、db_1等等这样的序列。</p>
<p><img src="https://i.loli.net/2021/03/29/pmhOTFkZYjAsLXq.png" alt="对 Chinook 进行水平拆分"></p>
<p>对于数据库的自动拆分，博主尝试过的一种方案是：首先，通过<code>Add-Migration</code>生成迁移。然后，通过循环修改连接字符串的方式，调用<code>Context.Database.Migrate()</code>方法为一个数据库迁移表结构和种子数据。当然，有些朋友不认同在生产环境使用迁移的做法，认为对数据库的操作权限还是应该交给 DBA 来管理，这当然无可厚非。我表达的一直都是一种思路，我不想一个工作六年的人，对技术的态度永远都停留在“能跑”、“能抄”这种水平。</p>
<p>一旦想清楚这一层，实现起来还是非常简单的。我们在配置中准备多个数据库来模拟分库的场景，实际应用中到底是用<strong>范围</strong>、<strong>Hash</strong> 还是 <strong>配置</strong>，大家结合自己的场景来决定就好。其实，这个思路还可以用来做读写分离，无非是这个库更特殊一点，它是个从库。好了，我们一起来看下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里随机连接到某一个数据库</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得数据库库名后缀</span></span><br><span class="line"><span class="keyword">var</span> shardings = _options.Value.MultiTenants;</span><br><span class="line"><span class="keyword">var</span> sharding = shardings[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, shardings.Count)];</span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = sharding.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------分库场景--------&quot;</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure>
<p>事实上，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分库</strong>” 功能：</p>
<p><img src="https://i.loli.net/2021/03/29/jLxlK3fro8qXSas.png" alt="分库场景"></p>
<h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>好了，聊完分库，我们再来聊聊分表。分表就是指同一个数据库里拥有多张结构(<strong>Schema</strong>)相同的表。一个典型的例子是，Excel里的多张Sheet，只要它们拥有相同的结构(<strong>Schema</strong>)，就可以视为同一类型的数据，虽然它们拥有不同的表名。和分库类似，分表的着眼点是避免产生“大表”，从而达到提高查询性能的目的。而对应到 EF(<strong>EntityFramework</strong>) 的场景中，<strong>分表本质上就是在解决 EF 动态适配表名的问题</strong>。同样的，下面两张图展示了如何在<strong>表</strong>这个层级进行拆分：</p>
<p><img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153851001-806440217.jpg" alt="表的垂直拆分"></p>
<p><img src="https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190929153912863-301123895.jpg" alt="表的水平拆分"></p>
<blockquote>
<p>图片援引自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qdhxhz/p/11608222.html">雨点的名字 - 分库分表(1) — 理论</a></p>
</blockquote>
<p>譬如，我们以年为单位，产生了<code>Album_2020</code>和<code>Album_2021</code>两张表。那么，在已经定义好了实体<code>Album</code>的情况下，有没有办法可以让实体<code>Album</code>动态地去适配这两张表呢？或许，熟悉 EF 的你，此刻正在心里暗笑道，这有何难，只要在对应实体的<code>OnModelCreating()</code>方法中，修改<code>ToTable()</code>方法的参数就好了啊。可如果你亲自试一试，就会知道这是你的一厢情愿啦！</p>
<p><img src="https://i.loli.net/2021/03/29/cIFp74gUAX2Q8xq.png" alt="针对 Album 和 Artist 按年份进行拆分"></p>
<p>事实上，EF 针对实体和表的映射关系做了缓存，这意味着，一旦在<code>OnModelCreating()</code>方法中确定映射关系，这组映射关系将被缓存下来。在 EF 中，这组映射关系的缓存行为，由<code>IModelCacheKeyFactory</code>接口来决定，它提供了一个<code>Create()</code>方法，如果该方法的返回值与上一次相同，则不会调用<code>OnModelCreating()</code>方法。所以，我们的思路就是，让这个<code>Create()</code>方法返回不同的对象。为此，我们考虑实现<code>IModelCacheKeyFactory</code>接口，并用这个自定义实现来替换微软的默认实现。我们一起来看下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicModelCacheKeyFactory</span> : <span class="title">IModelCacheKeyFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Create</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> context <span class="keyword">is</span> ShardingContext shardingContext</span><br><span class="line">            ? (context.GetType(), shardingContext.ShardingSuffix)</span><br><span class="line">            : (<span class="built_in">object</span>)context.GetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了配合<code>DynamicModelCacheKeyFactory</code>的使用，我们还需要定义用于分表的<code>ShardingContext</code>，它继承自<code>DbContext</code>，我们为其扩展了<code>ShardingSuffix</code>属性，并通过注入的<code>IShardingPolicyProvider</code>接口来获取一个分表后缀。比如，我们有<code>Order</code>表，经过拆分后获得<code>Order_01</code>、<code>Order_02</code>这样的子表，所以，这个分表后缀其实就是01、02。没错，我们还是要去修改<code>ToTable()</code>方法中的表名，不同的是，这里的表名是动态的。注意到，<code>Create()</code>方法返回的是一个元组，所以，不同的<code>ShardingSuffix</code>会产生不同的映射关系。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShardingContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IShardingPolicyProvider _shardingPolicyProvider;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShardingSuffix &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShardingContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      DbContextOptions&lt;ShardingContext&gt; options, </span></span></span><br><span class="line"><span class="params"><span class="function">      IShardingPolicyProvider shardingPolicyProvider</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _shardingPolicyProvider = shardingPolicyProvider;</span><br><span class="line">        ShardingSuffix = _shardingPolicyProvider.GetShardingSuffix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Album</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Album_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().ToTable(<span class="string">$&quot;Album_<span class="subst">&#123;ShardingSuffix&#125;</span>&quot;</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;().HasKey(x =&gt; x.AlbumId);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.AlbumId).HasColumnName(<span class="string">&quot;AlbumId&quot;</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.Title).HasColumnName(<span class="string">&quot;Title&quot;</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Album&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">&quot;ArtistId&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Artist</span></span><br><span class="line">        <span class="comment">// 动态映射表名，譬如：Artist_2021</span></span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().ToTable(<span class="string">$&quot;Artist_<span class="subst">&#123;ShardingSuffix&#125;</span>&quot;</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;().HasKey(x =&gt; x.ArtistId);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.ArtistId).HasColumnName(<span class="string">&quot;ArtistId&quot;</span>);</span><br><span class="line">        modelBuilder.Entity&lt;Artist&gt;()</span><br><span class="line">          .Property(x =&gt; x.Name).HasColumnName(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于分库、分表以后，怎么去匹配对应的库或者表，这类问题我们称之为路由问题。常见的策略主要有，<strong>范围</strong>、<strong>Hash</strong> 和 <strong>配置</strong>：</p>
<ul>
<li>范围最直观的就是按照时间来拆分，比如按年、按月、按天等等，主要的问题是分布不均匀；其次，可以按照Id的范围来划分，比如0到10万、10万到20万依次划分到不同的表里，主要的问题是热点数据带来的性能问题。</li>
<li>Hash主要指哈希取模。例如，可以针对用户Id做如下处理：<code>HASH(userId) % N</code>，其中，<code>N</code>表示当前拆分表的数目。可以预见的问题是，当<code>N</code>变化的时候，会产生数据迁移的需求，所以，这种方式并不利于扩容，</li>
<li>配置，顾名思义，就是用一张表来存储数据和子表间的映射关系，每次先按照数据的主键找到子表，然后再从子表中查询所需要的数据。好处是扩容灵活，而缺点同样明显，查询配置表，带来了额外的性能损耗。</li>
</ul>
<p>在这里，我们是使用年份来作为分表后缀的。为了方便演示，在实现<code>ShardingByYearPolicy</code>类时，我们直接使用了当前时间，这意味着我们会将<code>Album</code>实体映射到<code>Album_2021</code>这张表，以此类推。在实际使用中，更推荐大家使用 <a target="_blank" rel="noopener" href="https://halo.sherlocky.com/archives/xue-hua-suan-fa-snowflake/">雪花算法</a> 生成Id，因为这样，我们就可以通过Id反推出具体的时间范围，进而决定要映射到哪一个库、哪一张表。关于子表的生成，博主这里是通过迁移来实现的，考虑到EF自动创建数据库&#x2F;表，都需要先创建迁移，所以，这并不是一个开箱即用的方案。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ShardingByYearPolicy</span> : <span class="title">IShardingPolicyProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetShardingSuffix</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;yyyy&quot;</span>)&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们可以编写简单的代码，来验证我们的这些想法是都正确，即使是最简单的控制台程序，我还是喜欢用依赖注入：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入ShardingContext</span></span><br><span class="line">services.AddDbContext&lt;ShardingContext&gt;(options =&gt; &#123;</span><br><span class="line">    options.UseSqlite(config.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Database:Default&quot;</span>)); </span><br><span class="line">    <span class="comment">//替换默认实现</span></span><br><span class="line">    options.ReplaceService&lt;IModelCacheKeyFactory, DynamicModelCacheKeyFactory&gt;(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入IShardingPolicyProvider</span></span><br><span class="line">services.AddTransient&lt;IShardingPolicyProvider, ShardingByYearPolicy&gt;();</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以通过<code>ShardingContext</code>来匹配<code>Album_2021</code>表：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该连接到Album_2021表</span></span><br><span class="line"><span class="comment">// 实际应该按照某种方式获得表名后缀</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------分表场景--------&quot;</span>);</span><br><span class="line">Console.WriteLine(_shardingContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_shardingContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_shardingContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure>
<p>此时，我们会得到下面的结果：</p>
<p><img src="https://i.loli.net/2021/03/29/Evj8wXCIsV1Ddme.png" alt="EF Core 分表效果演示"></p>
<p>至此，如果选择性地忽略 “<strong>路由</strong>” 和 “<strong>自动分表</strong>” 这两个特性，我们已经在 EF 层面上局部的实现了 “<strong>分表</strong>” 功能。怎么样，是不是还行？</p>
<h1 id="多租户架构"><a href="#多租户架构" class="headerlink" title="多租户架构"></a>多租户架构</h1><p>最后，我们来聊聊多租户架构这个话题。可能有朋友觉得多租户架构和分库、分表没什么关系，不好意思啊，这是个非常合理的联想，因为还真就有关系，甚至我们还能继续发散到读写分离。你想想看，多租户架构中，如果一个租户一个数据库，这是不是就是分库的场景。而在分库的场景中，如果一个是主库，一个是从库，这是不是就是读写分离的场景。在学习数学的过程中，学会转化问题是一种重要的思维，即让一个不熟悉的问题变成一个熟悉的问题，在今天这篇博客中，从分库发散到多租户、读写分离，正是这一思路的体现，通常情况下，多租户架构有多数据库和单数据库两种实现方式。</p>
<h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p>多数据库，指每一个租户一个数据库。这种实现方式的好处是，租户间的数据天然隔离，数据库的访问压力天然隔离。可由于所有租户都共享一套应用程序，随着数据库越来越多，维护的成本亦越来越高。参考分库的实现，我们可以非常容易地实现租户数据库的切换。这里，我们的思路是，调用方在 HTTP 请求中加入自定义的首部字段<code>X-TenantId</code>，<code>DbContext</code>通过该字段来匹配对应的链接字符串，这样就可以实现多数据库的多租户架构：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TenantInfoProvider</span> : <span class="title">ITenantInfoProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> X_TENANT_ID = <span class="string">&quot;X-TenantId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TenantInfoProvider</span>(<span class="params">IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpContextAccessor = httpContextAccessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetTenantId</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> httpContext = _httpContextAccessor.HttpContext;</span><br><span class="line">        <span class="keyword">if</span> (httpContext != <span class="literal">null</span> &amp;&amp; httpContext.Request.Headers.ContainsKey(X_TENANT_ID))</span><br><span class="line">            <span class="keyword">return</span> httpContext.Request.Headers[X_TENANT_ID].FirstOrDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，假设我们<code>AppSettings.json</code>文件维护各个租户的连接字符串信息。通常，在实际场景中，我们会将这些信息存储在数据库中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Database&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=Chinook.db&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MultiTenants&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;tenantId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConnectionString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=Chinook01.db&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;tenantId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ConnectionString&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=Chinook02.db&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此时，我们可以通过下面的代码片段来实现租户切换：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line"><span class="keyword">var</span> database = _options.Value.MultiTenants.FirstOrDefault(x =&gt; x.TenantId == tenantId);</span><br><span class="line"><span class="keyword">if</span> (database == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Invalid tenantId \&quot;<span class="subst">&#123;tenantId&#125;</span>\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">_chinookContext.Database.GetDbConnection().ConnectionString = database.ConnectionString;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------多租户 + 多数据库--------&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;TenantId:<span class="subst">&#123;tenantId&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(_chinookContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_chinookContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_chinookContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure>

<p>可以注意到，一切如我们所预料的一样，程序自动切换到<code>01</code>这个租户：</p>
<p><img src="https://i.loli.net/2021/03/29/S5QeCjzdcgG9wpT.png" alt="多租户 + 多数据库"></p>
<h2 id="单数据库"><a href="#单数据库" class="headerlink" title="单数据库"></a>单数据库</h2><p>单数据库，指所有租户都在一个数据库里，使用相同的表结构(<strong>Schema</strong>)，并通过<code>TenantId</code>字段进行区分。<a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 中的多租户架构就是这种模式，而我之前的公司，则是单数据库 + 多数据库的混合模式。这种实现方式的好处是数据库非常精简，而缺点同样很明显，一旦某个租户出现问题，非常容易波及所有租户，因为所有租户都在一个数据库里，数据库的压力实际上是大家一起分担的，租户间相互影响的可能性非常大。</p>
<p>同样地，我们依然需要用到<code>X-TenantId</code>这个请求头，由于所有租户都在一个数据库上，我们不会再试图去修改链接字符串。EF Core 中针对实体提供了<code>HasQueryFilter()</code>扩展方法，该访问允许我们传入一个 Lambda 表达式。此时，我们所有的请求都会自动带上类似<code>Album.TenantId = &#39;xxxx&#39;</code>这样的条件，这样我们就实现了单数据库的多租户架构。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MulitiTenancyContext</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Artist&gt; Artist &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Album&gt; Album &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITenantInfoProvider _tenantInfoProvider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MulitiTenancyContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      DbContextOptions&lt;MulitiTenancyContext&gt; options, </span></span></span><br><span class="line"><span class="params"><span class="function">      ITenantInfoProvider tenantInfoProvider</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tenantInfoProvider = tenantInfoProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line"></span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> ArtistMap());</span><br><span class="line">        modelBuilder.ApplyConfiguration(<span class="keyword">new</span> AlbumMap());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用 HasQueryFilter 进行租户间数据隔离</span></span><br><span class="line">        <span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(tenantId))</span><br><span class="line">        &#123;</span><br><span class="line">            modelBuilder.Entity&lt;Album&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">            modelBuilder.Entity&lt;Artist&gt;().HasQueryFilter(x =&gt; x.TenantId == tenantId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在实体上应用这个过滤条件，参照 <a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 中的实现，我们定义了<code>IMulitiTenancy</code>接口，所有实体均需要实现<code>TenantId</code>字段。为了简化设计，我们直接使用字符串类型来定义租户Id，而在 <a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 中很多主键都被定义为 <code>Guid</code>，我们掌握核心原理即可，不用过分强求和 <a target="_blank" rel="noopener" href="https://github.com/abpframework/abp">ABP vNext</a> 的一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMulitiTenancy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Album</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Album</span> : <span class="title">IMulitiTenancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AlbumId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ArtistId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> TenantId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以编写简单的测试代码，来验证我们的想法是否正确。同样地，我还是使用了依赖注入：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该查询01租户内的Album</span></span><br><span class="line"><span class="keyword">var</span> tenantId = _tenantInfoProvider.GetTenantId();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------多租户 + 单数据库--------&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;TenantId:<span class="subst">&#123;tenantId&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Database.GetDbConnection().ConnectionString);</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Album.ToQueryString());</span><br><span class="line">Console.WriteLine(_mulitiTenancyContext.Artist.ToQueryString());</span><br></pre></td></tr></table></figure>

<p>可以注意到，打印出的 SQL 语句中自动带出了过滤条件：</p>
<p><img src="https://i.loli.net/2021/03/29/7na2eIo4suLhTGY.png" alt="多租户 + 多数据库"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客主要探讨了 EF 在分库、分表及多租户架构上实施的可能性。分库、分表的目的是为了提高数据库的查询性能，在这个过程中，我们可以考虑<strong>范围</strong>、<strong>Hash</strong>和<strong>配置</strong>三种路由策略，它们各自有自己的优缺点，需要使用者结合业务场景去衡量。虽然分库、分表在面对百万级别以上的数据时，不失为一种提高性能的方案，可世间万物都是双刃剑，它同样带来了一系列新的问题，譬如<strong>跨库写带来的分布式事务问题，跨库读带来的Join、Count()、排序、分页等问题，数据迁移问题</strong>等等，而如果希望通过Hash(Id)来进行拆分，还需要解决<strong>全局Id唯一的问题</strong>。所以说，这是一个没有标准答案的问题，需要使用者自己去进行取舍。多租户架构、读写分离均可以看作是特殊的分库场景，<code>EF Core</code> 中新增的<code>HasQueryFilter()</code>方法则帮助我们解决了单数据库的多租户架构问题。好了，以上就是这篇博客的全部内容啦，如果大家对文中的观点有建议或者意见，欢迎大家在评论区留言，谢谢！</p>
<p>附本文源代码：<a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding">https://github.com/Regularly-Archive/2021/tree/master/EF.Sharding</a></p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-3-24-gittips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-3-24-gittips/" itemprop="url">搭建博客可能会用到的 Git 命令</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-24T14:35:00+00:00">
                2021-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2019 年为了学习使用 GitHub Pages 搭建博客，我在一个 App 上买了一门和 GitHub 有关的课，但主要看了其中一讲：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/24/16165915158049.jpg" alt="-w1266">学完这一讲之后，我还写了一篇简短的搭建博客的文章： </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/es2mvKMy00lfasYJsjEJJg">不懂技术，如何搭建个人博客？</a>   </p>
<p>课程剩下的其他内容，就被我晾在一边了。上个月看到这个 App 提醒我好久没学习了，提醒的文案也很皮，「<strong>21 天了，似乎养成了不学习的习惯</strong>」，哈哈哈哈哈哈。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/24/img8559.jpeg" alt="IMG_8559"></p>
<p>买了课程没看，心里有点愧疚，就开始捡起来看一些，顺便做了一下笔记（别说了，主要是不知道今天发点啥，强行用学习笔记来凑数）。  </p>
<p>以下内容主要来自「极客时间」的课程《Git 三剑客》，这里的三剑客是指：  </p>
<ul>
<li>Git</li>
<li>GitHub</li>
<li>GitLab</li>
</ul>
<p>我整理了一些在课程中用到的 Git 命令，对程序员可能是小菜一碟，可能对想搭建博客的朋友有帮助：</p>
<p>运行这些命令，需要有一个<strong>环境</strong>，这个环境就是电脑的「<strong>终端</strong>」，Windows 上打开「运行」，输入「cmd」，同样可以打开终端。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/24/16165937767585.jpg" alt="-w1066"></p>
<p>Git 下载地址：<br><em><a target="_blank" rel="noopener" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></em></p>
<h2 id="安装-Git-之后，查看是否正确安装"><a href="#安装-Git-之后，查看是否正确安装" class="headerlink" title="安装 Git 之后，查看是否正确安装"></a>安装 Git 之后，查看是否正确安装</h2><p>git –version</p>
<p>这个命令也可以简写成 git –v</p>
<h2 id="创建一个新的仓库并初始化"><a href="#创建一个新的仓库并初始化" class="headerlink" title="创建一个新的仓库并初始化"></a>创建一个新的仓库并初始化</h2><p>git init hexo_blog    </p>
<h2 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h2><p>git add index.html   </p>
<p>注：add 后面加上做出变更的文件   </p>
<p>这里简单说一下 Git 的工作方式（或者说工作流程）：</p>
<ul>
<li>当前正在编辑的文件，处于工作目录（<strong>工作区</strong>）</li>
<li>编辑好但待提交的文件，可以暂时添加到<strong>暂存区</strong>，这相当于是一个<strong>中间态</strong>，既可以向前一步作提交（commit），也可以向后一步，回退或覆盖<strong>工作区</strong>，这个方式有点像是 PS 里的「历史记录」面板，可以比较灵活地进行变更。</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/24/16165942783235.jpg" alt="-w819"></p>
<h2 id="将编辑好的内容-push-到-GitHub"><a href="#将编辑好的内容-push-到-GitHub" class="headerlink" title="将编辑好的内容 push 到 GitHub"></a>将编辑好的内容 push 到 GitHub</h2><p>git add .<br>git commit -m”附带的信息，例如在某个时间点编辑了博客”<br>git push    </p>
<p>这三个命令，是搭建好博客之后，每次发布文章时，都需要用到的命令。看完这篇文章，其他的 Git 命令都可以忘记，除了这三条。      </p>
<h2 id="查看-Git-工作目录和暂存区的状态"><a href="#查看-Git-工作目录和暂存区的状态" class="headerlink" title="查看 Git 工作目录和暂存区的状态"></a>查看 Git 工作目录和暂存区的状态</h2><p>命令：git status   </p>
<p>遇到未被 Git 管理的文件或文件夹，可以使用 add 命令将其纳入到 Git 的管理之下。   </p>
<p>例如：git add index.html images    </p>
<p>注：add 后面可以加文件，也可以加文件夹 📁，上面的 index.html 是文件名，images 是文件夹。   </p>
<h2 id="查看-Git-变更的记录"><a href="#查看-Git-变更的记录" class="headerlink" title="查看 Git 变更的记录"></a>查看 Git 变更的记录</h2><p>这个有点像是 PS 里面的「<strong>历史记录面板</strong>」，记录了你做出的所有变更。     </p>
<p>命令：git log   </p>
<h2 id="清理一下终端当前显示的内容"><a href="#清理一下终端当前显示的内容" class="headerlink" title="清理一下终端当前显示的内容"></a>清理一下终端当前显示的内容</h2><p>命令：clear    </p>
<h2 id="新建文件夹的命令"><a href="#新建文件夹的命令" class="headerlink" title="新建文件夹的命令"></a>新建文件夹的命令</h2><p>命令：mkdir+空格+文件夹名称   </p>
<h2 id="创建一个新的文件"><a href="#创建一个新的文件" class="headerlink" title="创建一个新的文件"></a>创建一个新的文件</h2><p>echo “hello,world” &gt; readme</p>
<p>创建一个 readme 文件，里面的内容为 hello,world    </p>
<h2 id="查看-Git-最近-N-次的日志"><a href="#查看-Git-最近-N-次的日志" class="headerlink" title="查看 Git 最近 N 次的日志"></a>查看 Git 最近 N 次的日志</h2><p>git log -n   </p>
<p>如果之前提交过很多次，git log 不附带参数的话，会返回一长串日志，不便于观看     </p>
<h2 id="在终端中查看文件内容或编辑文件"><a href="#在终端中查看文件内容或编辑文件" class="headerlink" title="在终端中查看文件内容或编辑文件"></a>在终端中查看文件内容或编辑文件</h2><p>命令：vi+空格+文件名  </p>
<p>例如你想在终端中编辑一个名为 <code>style.css</code> 的文件，可以运行命令 </p>
<p>vi <code>style.css</code>     </p>
<p>在 Vim 编辑器中编辑好文件，该如何退出呢？   </p>
<p>按下 ESC 键，在终端底部输入不同的命令，命令对应的含义如下：</p>
<p>:w!     保存<br>:wq!    保存并退出编辑(w 代表写入，q 代表退出)          </p>
<h2 id="从某个子路径直接退回到根目录下"><a href="#从某个子路径直接退回到根目录下" class="headerlink" title="从某个子路径直接退回到根目录下"></a>从某个子路径直接退回到根目录下</h2><p>命令：cd ..&#x2F;    </p>
<h2 id="查看当前路径已有的文件和文件夹"><a href="#查看当前路径已有的文件和文件夹" class="headerlink" title="查看当前路径已有的文件和文件夹"></a>查看当前路径已有的文件和文件夹</h2><p>命令：ls -al</p>
<p>注：这个命令可以列出隐藏的文件。   </p>
<h2 id="在-Git-中给文件快速重命名的方法"><a href="#在-Git-中给文件快速重命名的方法" class="headerlink" title="在 Git 中给文件快速重命名的方法"></a>在 Git 中给文件快速重命名的方法</h2><p>命令：git mv</p>
<p>举个例子，如果你想把 readme 重命名为 <code>readme.md</code>，只需要执行命令：  </p>
<p>git mv readme <code>read.md</code> </p>
<h2 id="删除某个文件"><a href="#删除某个文件" class="headerlink" title="删除某个文件"></a>删除某个文件</h2><p>git rm filename</p>
<p>这个命令会直接将处于暂存区的文件删除，这样就不需要先在工作目录下删除文件，再到暂存区清理文件。 </p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>git checkout master    </p>
<p>注：从当前分支切换到 master 分支上，这个命令需要在工作路径下运行     </p>
<h2 id="新建分支并切换到新分支上"><a href="#新建分支并切换到新分支上" class="headerlink" title="新建分支并切换到新分支上"></a>新建分支并切换到新分支上</h2><p>git checkout -b 新分支的名称 旧分支名称      </p>
<p>注：基于旧分支的基础上，创建一个新的分支      </p>
<h2 id="查看当前工作在哪个分支下边（查看当前有哪些分支）"><a href="#查看当前工作在哪个分支下边（查看当前有哪些分支）" class="headerlink" title="查看当前工作在哪个分支下边（查看当前有哪些分支）"></a>查看当前工作在哪个分支下边（查看当前有哪些分支）</h2><p>git branch -av</p>
<p>注：运行返回的带有星号 * 的分支，就是当前的工作分支   </p>
<h2 id="查看本地的-git-配置"><a href="#查看本地的-git-配置" class="headerlink" title="查看本地的 git 配置"></a>查看本地的 git 配置</h2><p>git config –local –list：显示所有配置信息，包含 <code>user.name</code>、user.email 等。    </p>
<p>git config –local <code>user.name</code>：仅显示 <code>user.name</code> 信息。   </p>
<h2 id="更改-user-name-信息"><a href="#更改-user-name-信息" class="headerlink" title="更改 user.name 信息"></a>更改 <code>user.name</code> 信息</h2><p>git config –local <code>user.name</code> ‘angola’   </p>
<p>末尾的单引号内的名字 angola 就是更改之后的 <code>user.name</code>   </p>
<h2 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h2><p>命令含义：主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。      </p>
<p>cat+空格+文件名：将文件内容打印显示    </p>
<h2 id="查看-HEAD-指针目前指向哪个分支"><a href="#查看-HEAD-指针目前指向哪个分支" class="headerlink" title="查看 HEAD 指针目前指向哪个分支"></a>查看 HEAD 指针目前指向哪个分支</h2><p>cat .git&#x2F;HEAD   </p>
<p>假设运行返回的结果是 ref: refs&#x2F;heads&#x2F;fix_readme    </p>
<p>这意味着 HEAD 目前指向分支 fix_readme    </p>
<h2 id="查看路径下边类型是文件的个数"><a href="#查看路径下边类型是文件的个数" class="headerlink" title="查看路径下边类型是文件的个数"></a>查看路径下边类型是文件的个数</h2><p>find .git&#x2F;objects -type file   </p>
<p>注：.git&#x2F;objects 路径下类型是文件的数量     </p>
<h2 id="比较两次-commit-的区别"><a href="#比较两次-commit-的区别" class="headerlink" title="比较两次 commit 的区别"></a>比较两次 commit 的区别</h2><p>git diff 3d4731d80eb 415c5c8086e1    </p>
<p>注：diff 后面跟的是两次 commit 对应的哈希值     </p>
<p>比较 HEAD 与 HEAD 父级（即 HEAD 的前一个版本）的不同：      </p>
<p>git diff HEAD <code>HEAD^1</code>     </p>
<p>最末尾也可以不加数字，单纯使用：   </p>
<p>git diff HEAD <code>HEAD^</code>    </p>
<p>HEAD 与 HEAD 父级的父级（即 HEAD 的爷爷）的不同：  </p>
<p>git diff HEAD <code>HEAD^^</code><br>等同于 git diff HEAD <code>HEAD～2</code>   </p>
<h2 id="图形界面工具"><a href="#图形界面工具" class="headerlink" title="图形界面工具"></a>图形界面工具</h2><p>gitk<br>gitk –all    </p>
<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><p>git branch -d 待删除的分支名称    </p>
<h2 id="修改最新-commit-的-message"><a href="#修改最新-commit-的-message" class="headerlink" title="修改最新 commit 的 message"></a>修改最新 commit 的 message</h2><p>git commit –amend   </p>
<p>运行之后，会打开编辑窗口，顶部可编辑最近一次提交的 message 信息，编辑好之后按 ESC，输入 :wq! 退出编辑   </p>
<h2 id="消除最近的几次提交"><a href="#消除最近的几次提交" class="headerlink" title="消除最近的几次提交"></a>消除最近的几次提交</h2><p>git log –graph<br>git reset –hard 5df3fd1900</p>
<p>第一个命令是，在终端中以图形化的方式显示之前提交的记录，记录中会显示每一次 commit 对应的哈希值。</p>
<p>注：5df3fd1900 是恢复到的某一次 commit 对应的哈希值</p>
<h2 id="比较暂存区和-HEAD-所含文件的差异"><a href="#比较暂存区和-HEAD-所含文件的差异" class="headerlink" title="比较暂存区和 HEAD 所含文件的差异"></a>比较暂存区和 HEAD 所含文件的差异</h2><p>git diff –cached</p>
<p>cached 代表暂存区 </p>
<h2 id="比较工作区和暂存区所含文件的差异"><a href="#比较工作区和暂存区所含文件的差异" class="headerlink" title="比较工作区和暂存区所含文件的差异"></a>比较工作区和暂存区所含文件的差异</h2><p>git diff</p>
<p>diff 后面不加参数，默认比较的是工作区和暂存区的差别</p>
<p>如果 diff 添加了文件名，就是比较这个文件在工作区和暂存区的差别，例如    </p>
<p>git diff –readme.md   </p>
<p>添加两个文件名的话，就可以同时查看两个文件在工作区和暂存区的差别：   </p>
<p>git diff –readme.md styles&#x2F;style.css </p>
<h2 id="如何指定不需要-Git-管理的文件？"><a href="#如何指定不需要-Git-管理的文件？" class="headerlink" title="如何指定不需要 Git 管理的文件？"></a>如何指定不需要 Git 管理的文件？</h2><p>不需要 Git 管理的文件，可以在 <code>.gitignore</code> 文件中列出。  </p>
<p>先使用命令 vi <code>.gitignore</code></p>
<p>创建一个 <code>.gitignore</code> 文件，文件名必须为 <code>.gitignore</code>，在文件中列明不纳入 Git 管理的文件和文件夹。</p>
<p>在输入文件和文件名时需要注意：</p>
<ul>
<li>doc 代表 doc 文件不纳入 Git 管理</li>
<li>doc&#x2F; 末尾如果带有斜杠，代表文件夹 doc 下的所有文件都不纳入 Git 管理</li>
</ul>
<p>如果先将文件或文件夹添加到了暂存区，<code>.gitignore</code> 对其也不起作用。   </p>
<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><p>这本课我还没看完，其他有些单纯靠文字无法理解的内容，我在记笔记的时候还附上了一些截图，放在幕布中，感兴趣的朋友可以扫描下方的二维码查看：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/03/24/qrcodea3.png" alt="QRcode_A3"><br>本文也同步发布在我的个人博客上，你可以点击底部左下角的「<strong>阅读原文</strong>」，查看本文在博客上的表现。   </p>
<p>以上。      </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-3-22-aboutme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-3-22-aboutme/" itemprop="url">我是谁？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-22T14:00:00+00:00">
                2021-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>自我剖析，可能是每个人不经意间会做的一件事，这是一种向内探寻自己的方式。</p>
<p>我们会在内心给出一些关于「我是谁」的答案，但不一定会落笔写下来，更谈不上展示给别人看，害怕自己认为的和他人认为的存在落差，害怕自己的人设不够完美。</p>
<p>每个人都有人设，人设不是明星独有的东西，你给人留下的印象，就是你的人设，有些人在网络上和现实中可能会有两个截然不同的人设，这并不奇怪。</p>
<p>微信之父张小龙曾在微信公开课上谈过朋友圈与「人设」的关系：</p>
<blockquote>
<p>发朋友圈，其实就是把自己的人设带给所有朋友，放到所有朋友的脑袋里面的过程。</p>
</blockquote>
<p>受一名网友 boyzcl 的文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BAeszt31Qvdg-xYEqmPzJg">我是谁?</a>》的启发，我也想写一下我认为的自己。</p>
<p>我是谁？</p>
<p>我的本名叫彭宏豪，<br>网名叫安哥拉，<br>这两个昵称之间并没有什么联系。</p>
<p>在网上，<br>除非特殊的情况，<br>我更愿意用真名作为自己的 ID，<br>之所以用真名，<br>一方面是因为真名能更好地约束自己；<br>另一方面是受了李笑来老师的影响，<br>他曾说过：</p>
<blockquote>
<p>我一直认为使用实名是划算的……“个人品牌”的积累，从使用实名那一瞬间开始……</p>
</blockquote>
<p>我是一个 95 年出生的人，射手座，但我不太相信星座，我不希望我的人生被那几句优缺点定义，我不希望落入「自我实现的预言」的怪圈；<br>我是一个目前在广州打工的潮汕人，小时候来过广州，在广州度过一次春节，对广州有一种莫名的好感；<br>我是一个干过物流、后转行新媒体的新媒体人，自称新媒体小编，但不喜欢别人叫我小编或工具人（之所以顺利转行新媒体，说来话长，可能是运气，也可能是因为我在闲暇时间会断断续续写公众号，所以我有个不成熟的看法：我在空闲时间写东西，在别人在空闲时间备考公务员，这两者都是为人生未来的发展提供多一种选择，多一种可能性）；<br>我是一个长期自称爱好是跑步，但累计跑步公里数未超过 500 km 的人；<br>我是一个独自看过歌手李健两场演唱会的人；<br>我是一个喜欢余华、王小波、村上春树的人；<br>我是一个以前出门会带一包抽式纸巾、但拒绝被称作「暖男」的人；<br>我是一个轻度的泛社交软件用户，除了微信，我还会使用微博、知乎、知识星球、推特和即刻；<br>我是一个睡前喜欢听音频节目的人，因为我发现这东西能够助眠，不过后来听得少了，2018 年刚毕业那会，音频节目陪我度过了很多个夜晚；<br>我是一个有点细心、自认为记性比较好的人；<br>我是一个有点天真的人；</p>
<p>我是一个内向闷骚的人；<br>我是一个胆小、羞于宣传（包装）自己的人；<br>我是一个害怕挑战、畏惧变化、多数时候躲在舒适区的人；<br>我是一个心理素质&#x2F;韧性还不够强（不够皮实）的人；<br>我是一个私下喜欢对自己的好朋友说粗话的人；<br>我是一个对自己长相没有自信、不喜欢拍照的人；<br>我是一个曾认为友谊（关系）不重要、自己厉害最重要的人，但后来发现缺少友谊的人生会缺少一大乐趣，并让人生呈现虚无；<br>我是一个容易放弃的人，好多事情坚持没多久没放弃了，如大学时代背英语单词、毕业后的每天做一页 PPT、公众号日更、每天做 7 分钟运动；<br>我是一个没什么特长、学生时代惧怕写自我评价的人；<br>我是一个曾梦想成为 IT 男、产品经理或单纯靠写字赚钱的人，但至今都没实现；</p>
<p>我想成为一个更自信、对自我评价更高的人；<br>我想成为一个富有人格魅力的人；<br>我想成为一个能输出高质量内容或观点的人，因为我相信「Brain is the new sexy」；<br>我想成为一个能帮到他人的人；<br>我想成为一个值得交往的人；<br>我想做一个不变坏的人。</p>
<p>我对未来有这些不成熟的想法：  </p>
<ul>
<li>未来能做一个能带来收入的 App，有时会觉得独立开发者很酷，不用生活在一线城市，做出来的产品也可以服务到广阔的人群。</li>
<li>不能做 App 的话，退而求次，做一个付费社群，只为愿意为我付费的人服务，因为不让人掏钱买的服务或内容，别人都不懂得珍惜。</li>
<li>希望未来有一天，自己的被动收入能 Cover 生活必需的支出，到时想工作就工作，不想工作就出去走走。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本来今天想发一篇工具文章的，但下午部门开会的时候，看到一份问卷调查收集的数据，气死我了。  </p>
<p>写了接近两年的文章，居然还有好多人不知道看的文章是谁写的，看了说不来气是假的。  </p>
<p>气死我了，公众号还是不行，还是不够突出作者的位置，搞得我还是一个为他人做嫁衣的工具人，用完即扔。。。离开了平台，自己啥都不是。 </p>
<p>我又陷入了焦虑。   </p>
<h2 id="关注「效率工具指南」"><a href="#关注「效率工具指南」" class="headerlink" title="关注「效率工具指南」"></a>关注「效率工具指南」</h2><p>本文首发于我的公众号「效率工具指南」，原文链接 🔗：    </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fI1etNSdxpMWox3bABy-NA">我是谁</a>   </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-20-the-food-of-mlxg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-20-the-food-of-mlxg/" itemprop="url">码农装逼菜谱 (二) - 麻辣香锅</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-20T13:31:58+00:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>今天的装逼菜谱是：麻辣香锅。以下是成品效果图：</p>
<img src="/images/cook-mlxg.jpg" class="">

<h2 id="用料"><a href="#用料" class="headerlink" title="用料"></a>用料</h2><p>麻辣香锅的原料就完全随意了，我个人喜欢的搭配是：</p>
<ul>
<li>荤菜：五花肉、鸡翅、牛肉丸、肥牛、午餐肉、脆皮肠、鹌鹑蛋。</li>
<li>素菜：藕片、土豆、西芹、豆皮、香菇、洋葱、青蒜、西兰花、金针菇、魔芋丝。</li>
<li>麻辣香锅底料（或者火锅底料）：每一个人的量按 30 克算，如果是 4 个人就是 120 克。</li>
</ul>
<p>相信你看出来了，这个菜适合人多，因为每个菜都可以加一点。如果 2 人份的话，建议只用选 6~8 种原料即可。</p>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p>麻辣香锅的的制作办法核心就是先把各种菜弄熟，然后把麻辣香锅底料（或者火锅底料）炒香，最后把菜和底料混合即可。</p>
<h3 id="步骤-1-处理荤菜"><a href="#步骤-1-处理荤菜" class="headerlink" title="步骤 1 - 处理荤菜"></a>步骤 1 - 处理荤菜</h3><table>
<thead>
<tr>
<th>原料</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>牛肉丸</td>
<td>直接和素菜一起煮熟即可</td>
</tr>
<tr>
<td>肥牛</td>
<td>焯水，没有血色后就熟了</td>
</tr>
<tr>
<td>午餐肉</td>
<td>切片后，直接最后放入香锅里即可</td>
</tr>
<tr>
<td>脆皮肠</td>
<td>在肠的一端切个十字花刀，然后把脆皮肠煎成开花</td>
</tr>
<tr>
<td>鹌鹑蛋</td>
<td>煮熟剥好，最后放入香锅里即可</td>
</tr>
<tr>
<td>五花肉</td>
<td>把五花肉切片之后，用小火煎，最后两边煎成金黄色即可</td>
</tr>
<tr>
<td>鸡翅</td>
<td>先把鸡翅划几个缝，然后用料酒、姜片、生抽腌制 20 分钟。<br /> 之后像五花肉那样双面煎成金黄，然后加水烧 2 分钟，水烧得快干后取出。</td>
</tr>
</tbody></table>
<p>以上最好做的就是牛肉丸、肥牛、午餐肉、脆皮肠。如果想做起来简单，买这几样就行。</p>
<h3 id="步骤-2-处理素菜"><a href="#步骤-2-处理素菜" class="headerlink" title="步骤 2 - 处理素菜"></a>步骤 2 - 处理素菜</h3><table>
<thead>
<tr>
<th>原料</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td>土豆</td>
<td>去皮，切片</td>
</tr>
<tr>
<td>藕片</td>
<td>去皮，切片</td>
</tr>
<tr>
<td>西芹</td>
<td>切段</td>
</tr>
<tr>
<td>豆皮</td>
<td>切成 1 厘米宽的丝</td>
</tr>
<tr>
<td>香菇</td>
<td>洗净，切成两半</td>
</tr>
<tr>
<td>洋葱</td>
<td>切成丝</td>
</tr>
<tr>
<td>青蒜</td>
<td>切成段</td>
</tr>
</tbody></table>
<p>以上这些菜切好之后，除了土豆，直接放到锅中加开水煮，煮个大概 3 分钟就行。</p>
<p>不用煮太久，因为藕片、豆皮、洋葱都可以生吃。</p>
<p>土豆单独用油煎一下会更好吃，为了省事，也可以和别的菜一起煮。</p>
<p>以上最好做的是藕片、豆皮、香菇、洋葱、金针菇、魔芋丝，基本上不需要什么额外处理。</p>
<h3 id="步骤-3-收尾"><a href="#步骤-3-收尾" class="headerlink" title="步骤 3 - 收尾"></a>步骤 3 - 收尾</h3><p>上面的荤菜、素菜预处理好了之后，就开始处理底料了。</p>
<p>把葱姜蒜切成末，油烧热之后，下葱姜蒜，炒一下之后把火关最小，然后把麻辣香锅底料加进去，火锅底料容易糊，用铲子慢慢把底料炒融化。</p>
<p>底料完全化掉之后，先加入荤菜。等调料都裹上之后，再加入素菜。</p>
<p>最后放一点点糖调味，然后就可以起锅啦~</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>个人感觉麻辣香锅的灵魂是方便面，吃起来特别香。只需要把方便面单独泡好后加进香锅即可。</li>
<li>如果希望点缀一下，可以放一点炸花生米、白芝麻、以及香菜。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-20-the-food-of-tcpg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-20-the-food-of-tcpg/" itemprop="url">码农装逼菜谱 (一) - 糖醋排骨</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-20T12:16:56+00:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近迷上了做饭，花几个小时给家人做一顿饭，然后美美的吃上一顿还是挺爽的。其实很多菜做起来一点都不难，只是中餐习惯用 “中火”，“少许”，“断生” 这些只可意会不可言传的词。所以我打算写一个「码农装逼菜谱」系列，让大家都可以轻松完成各种高级菜的制作。</p>
<p>我的菜谱原则是：</p>
<ul>
<li>尽量简化。能不加的调料就不加，能用调好的酱就不自己调。</li>
<li>尽量量化。所有调料都用量勺或者克重表示。</li>
</ul>
<p>为了量化食材配料，你需要备好两个便宜的小工具：一个是量勺（Table Spoon），拼多多上大概 10 来块钱包邮（如下图）。</p>
<img src="/images/cook-tool-2.jpg" class="">

<p>另一个是电子厨房秤，大概 20 多块钱（如下图）。</p>
<img src="/images/cook-tool-1.jpg" class="">

<p>今天第一个装逼菜谱是：糖醋排骨。以下是成品效果图：</p>
<img src="/images/cook-tcpg.jpg" class="">

<h2 id="用料"><a href="#用料" class="headerlink" title="用料"></a>用料</h2><p>以下提到的 1 勺表示 15 ML（Table Spoon），即上面量勺图中最大的那个 1 勺。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用量</th>
</tr>
</thead>
<tbody><tr>
<td>糖醋排骨</td>
<td>500 克</td>
</tr>
<tr>
<td>红糖（或白糖）</td>
<td>4 勺</td>
</tr>
<tr>
<td>镇江醋（或香醋）</td>
<td>3 勺</td>
</tr>
<tr>
<td>生抽（或酱油）</td>
<td>2 勺</td>
</tr>
<tr>
<td>黄酒（或料酒）</td>
<td>1 勺</td>
</tr>
</tbody></table>
<p>这里有个好记的口诀，上面的配料比例刚好是 54321（500g 排骨，4321 比例的糖、醋、酱油、黄酒）。</p>
<p>记不清楚哪个是 4 勺，哪个是 3 勺怎么办？我的记法是：糖醋排骨，名字中糖醋糖醋，糖在前，醋在后，所以 4 勺的是糖，3 勺的是醋。剩下的两个就很好记了，因为料酒在稍后介绍的很多菜中都是 1 勺，所以最少的就是料酒。</p>
<h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>从超市采购猪肋排，让超市服务员帮你切成小段，尽量短一点。一般一次采购都不止 1 斤，可以分两次做。</p>
<p>拿个小碗，按排骨的重量，按比例把其他调料配好。比如如果是 2 斤排骨（1000g），调料就应该是双份的。</p>
<p>排骨拿热水器放出来的 40 度左右温水泡 2 分钟，去掉血水后沥干待用。</p>
<p>同时用电水壶烧 400 毫升开水，后面要用。</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>不沾锅烧热，放 1 勺油，油热之后下排骨煸炒。大概翻炒的速度就是 15 秒翻一下，看看排骨贴锅的那一面变色的速度，如果没有变很快可以翻慢一点。最后效果就是排骨表面的肉炒出一点金黄色。</p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>加开水 400 毫升，水量能够把排骨快要淹没即可。如果加多了也没关系，无非就是烧久一点而已。</p>
<p>放入之前配好的调料，盖上盖子小火炖煮。一共需要炖 40 分钟，中间需要检查 2 次。每家的炉子火力不一样，如果水干得快，可以中途稍微加点水。</p>
<p>我习惯在手环上设置一个 20 分钟的倒计时，这样可以安心玩手机或者做别的。</p>
<img src="/images/cook-timer.gif" class="">

<p>20 分钟后翻一下排骨，再设置一个 15 分钟的倒计时。如果火比较大水快没了，可以加一点水。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>15 分钟到了后，排骨基本就烧好了。</p>
<p>这个时候打开盖子，火力稍微大一点，让余下的水蒸发得快一点。同时时不时翻一下，避免水少糊锅。到最后基本收汁了，就可以起锅了。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>不需要葱姜，不需要焯水。放心，做出来一点都不会腥。</li>
<li>如果你希望排骨吃起来硬一点，可以在排骨泡完温水后，用吸油纸把水份都吸掉。</li>
<li>撒上白芝麻点缀，没有也没关系，这东西就是图好看而已。</li>
<li>起锅前也可以加几块话梅，没有也没关系。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-19-i-am-the-mayor-of-shenzhen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-19-i-am-the-mayor-of-shenzhen/" itemprop="url">像经营企业一样经营城市 - 读《我在深圳当市长》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-19T13:46:11+00:00">
                2021-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/mayor-of-shenzhen.jpg" class="">

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近看完了<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35231636/">《我在深圳当市长》</a>，作者是前深圳市市长李子彬。</p>
<p>李子彬在 94~00 年间在深圳市当市长，是深圳发展成为国内一线城市的主政者。在他的书中，我能看到一个城市经营发展面临的各种问题和挑战，很多情况下都比企业的经营复杂。</p>
<p>书中也涉及了很多社会发展的黑暗面。当我向一个深圳的朋友推荐此书的时候，他第一句话就是：</p>
<blockquote>
<p>「这书写的是不是 20 年前的事情？」</p>
</blockquote>
<p>我一算，00 年到现在，刚好过了 20 年。于是我问他：</p>
<blockquote>
<p>你怎么知道的？</p>
</blockquote>
<p>这个朋友说：</p>
<blockquote>
<p>因为刑法规定违法事情的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%BD%E8%AF%89%E6%97%B6%E6%95%88">追诉期</a>是 20 年。20 年过了，很多事情公开讲了也没有人追究。所以，这本书讲了任何可能违法的事情，也过了追诉期。</p>
</blockquote>
<p>有意思的是，虽然经营一个城市和经营一家企业很不一样，但是很多基本的原则和方法却惊人地一致。我从他的书中还是得到了很多启发，以下是一些小结。</p>
<h2 id="为城市发展定位"><a href="#为城市发展定位" class="headerlink" title="为城市发展定位"></a>为城市发展定位</h2><p>我们做企业做产品讲定位，而城市的发展也是需要讲策略和方法。深圳在当初改革开放的时候，首先确立了发展高新科技产业的城市定位。在全书中，我们都能看到市政府为了这个定位在做相关的工作。例如：</p>
<ul>
<li><p>高新技术产业需要人才，而深圳本地缺少著名院校。于是政府与高校通过建新型研究院的形式，将清华、北大这些院校的研究人才吸引过来，同时配套推进创新的技术落地。</p>
</li>
<li><p>让管经济的副市长同时管教育，这样教育就可以很方便地经济发展协同发展。</p>
</li>
<li><p>取消传统的荔枝节，改办高交会。</p>
</li>
</ul>
<p>深圳的每一次调整，都在朝着这个定位在走，几十年下来，深圳成为了全球供应链和配套最完整的硬件研发城市。</p>
<h2 id="树立好的经营环境"><a href="#树立好的经营环境" class="headerlink" title="树立好的经营环境"></a>树立好的经营环境</h2><p>政府要发展经济，主要是靠市场的手段，而不是靠行政命令。深圳市的领导班子很清楚这一点，于是他们把工作重点放到了树立好的经营环境上。他们做了以下这些事情：</p>
<ul>
<li>改善学校的学习环境，把歌舞厅等娱乐场所赶出学校。</li>
<li>改善治安环境。整治军牌乱象，成立独立的巡警，同时整治公安队伍。</li>
<li>整理乱收费，配合合理拨款。砍掉了将近一半的收费项目，另外设立收费登记薄，明确收费内容和收费额度，通过银行统一收款，从而规范收入。</li>
<li>整合部门，建立一站式投资服务大厅。将 27 个相关单位聚在一起办公，大幅缩短了办理相关手续的时间。</li>
<li>减少审批项。</li>
</ul>
<p>这些事情看起来简单，其实每一件事情都不容易。因为这些改革都会触及很多人的利益。比如减少审批项，就会影响很多部门的收入，人员的配备，同时如果未来因为没有审批出了一些问题，也是容易被追责的，所以改革者都需要承担很多风险。在政府里面能够将这些事情一一推进，比在企业中要难得多，但是他们全部都做到了，实属不易。</p>
<p>其实这些工作对于经营公司也是同样的：</p>
<ul>
<li><p>例如：对于一家公司来说，对内提供一个尽量舒服的工作环境，减少各种不必要的会议，减少审批的流程，减少工作汇报，让员工尽量将精力花在工作本身上，也是非常重要的。</p>
</li>
<li><p>又例如：企业的组织架构，其实也是需要是类似于一站式投资服务大厅这样的项目制形态。相关的业务同事应该聚在一起办公，才能让项目的进展尽量高效。否则就会出现特别多的流程，特别多的职能部门共同参与，但是事情却做得很慢，也做不好的情况。</p>
</li>
</ul>
<h2 id="国企改革"><a href="#国企改革" class="headerlink" title="国企改革"></a>国企改革</h2><p>深圳在国企改革的操作也让我觉得非常像互联网公司，其中的核心就是：放权。</p>
<p>深圳通过成立国有资产经营公司来管理股份制改革后的企业。而资产经营公司强调不干预企业的经营，只是做好特别少的几件事情。在人上面，只是参与董事会的提名，同时委派财务总监，这样可以保证财务帐目清晰，同时重大讨论的时候可以参与投票即可。另外做好服务，帮助企业融资或者克服一些困难。</p>
<p>这个其实特别像现在互联网公司的风险投资。风险投资一家公司，一般也就是进驻董事会，参与一些重大决策，同时审计相关的财务报表，保证公司的经营状态是清晰的。最后做一些投后服务，帮助企业融资或者发展。</p>
<p>你看一对比，是不是特别像？</p>
<h2 id="做对的事情"><a href="#做对的事情" class="headerlink" title="做对的事情"></a>做对的事情</h2><p>在政府经营的时候，应该做对的事情，还是应该做程序正义的事情？大部分人为了自己的私利，在冲突的时候，会选择做程序正义的事情，而放弃做对的事情。因为如果违背程序正义，会给自己带了潜在的很多麻烦。</p>
<p>而在子彬的书中，我看到了很多为了做正确的事情，而违背程序正义的行为。</p>
<p>书中给我印象最深的案例是水利工程的例子：深圳市因为慢慢发展起来人口变多，水不够用了，于是需要引水。市政府费了很大力气找到了引水的方案，省委也同意了，但是一直拿不到国家发展计划委员会的批复。</p>
<p>是把一切工作暂停下来等批复，还是尽快解决人民群众的饮水问题？子彬选择了后者，对水务局长说：</p>
<blockquote>
<p>「上头要追责，也是处分我，你们就开工干吧！」</p>
</blockquote>
<p>结果开工 9 个月后，才拿到批复。</p>
<p>水利工程分为两期，第二期工程得 10 年后才做，那个时候子彬已经不是市长了。第一期如果为第二期在施工上做铺垫，就可以为未来节省上百倍的钱。但是这些铺垫工作也是需要额外花钱的。</p>
<p>是为了任期内的经济效果，还是考虑未来 20 年的城市规模，现在多花一点钱，但是为后来的市长做好铺垫？子彬选择了后者。提前为二期工程把征地、管线预留这些都做好了提前的准备，结果 10 年后的二期工程只花了一期工程 1&#x2F;6 的钱。</p>
<h2 id="要任用能人"><a href="#要任用能人" class="headerlink" title="要任用能人"></a>要任用能人</h2><p>有人说国企稳定，好混日子。但是我在子彬的这本书里面看到，政府的高层任命，还是挑选的是特别能干的人。大家要找的是能成事的人，不是资历多老，背景多深的人。比如子彬在找管经济的副市长的时候，就点名要找一个懂经济的人，费劲心思去请能人过来当副市长，一点都不是高高在上等着大家竞选，或者随便挑一个听话的。</p>
<p>最近我一个朋友，从互联网公司跳到一家传统的企业，因为一个项目做得好，一下子连升两级，直接向总经理汇报工作，把他吓坏了。我就告诉他，说明这家传统企业也有着努力经营的心态，在任何组织，只是是希望努力经营好，就会任用厉害的人，在人才提拔上面与互联网公司没有什么区别。</p>
<h2 id="要亲临一线和了解数据"><a href="#要亲临一线和了解数据" class="headerlink" title="要亲临一线和了解数据"></a>要亲临一线和了解数据</h2><p>子彬在书中介绍了大量自己亲自参与调研的情况，每次接受上级视察的时候，对深圳的各种指标倒背如流。</p>
<p>这也是互联网的公司重视的企业文化，管理者不应该高高在上，应该亲自参与核心的工作，对核心数据要了如指掌。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>历史是一面镜子，从李子彬的这本书中，我感受到了深圳过去 20 多年发展当中面临的各种重大挑战以及主政者的决心与魄力。深圳是中国经济发展的代表城市，中国在经济上的迅速发展，在国际地位上的崛起，不是自然而然发生的，每一步都倾注着政府各部门管理者们的心血，为中国政府点赞！</p>
<p>同时我也发现，管理的原则是相通的，很多企业经营管理方法与城市的管理方法类似，这让我对政府运作的陌生感减少了很多，或许有一天，互联网的人才和政府的人才是可以相互流通的，因为方法是相通的。</p>
<p>还是很有意思的一本书，推荐给大家。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E8%B7%A8%E5%9F%9F%E4%B8%AD%E9%97%B4%E4%BB%B6%20CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E8%B7%A8%E5%9F%9F%E4%B8%AD%E9%97%B4%E4%BB%B6%20CORS/" itemprop="url">源代码探案系列之 .NET Core 跨域中间件 CORS</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-16T13:25:47+00:00">
                2021-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文是 #<strong>源代码探案系列</strong># 第三篇，今天这篇博客，我们来一起解读下 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件，熟悉这个中间件的的小伙伴们，想必都已经猜出本文的主题：跨域。这确实是一个老生常谈的话题，可我并不认为，大家愿意去深入探究这个问题，因为博主曾经发现，每当工作中遇到跨域问题的时候，更多的是直接重写跨域相关的 HTTP 头。博主曾经写过一篇关于跨域的博客：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3846545990/">《聊聊前端跨域的爱恨情仇》</a>，当时是完全以前端的视角来看待跨域。所以，在今天这篇博客里，博主想带领大家从一种新的视角来看待跨域，也许，可以从中发现不一样的东西。</p>
<h1 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h1><p>关于 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a>，大家都知道的是，可以通过<code>UseCors()</code>方法在整个 HTTP 请求管道中启用跨域中间件，或者是通过<code>AddCors()</code>方法来定义跨域策略，亦或者通过<code>[EnableCors]</code>来显式地指定跨域策略，更多的细节大家可以参考微软的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0">官方文档</a>，而在这里，我想聊一点大家可能不知道的东西，譬如：服务器端如何处理来自浏览器端的跨域请求？而这一切在 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中又如何实现？带着这些问题来解读 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件的源代码，我们能更快的找到我们想得到的答案。一图胜千言，请允许博主使用这张流程图来“开宗明义”，我们这就开始今天的“<strong>探案</strong>”：</p>
<p><img src="https://i.loli.net/2021/03/16/m1geMX8PfJwN3Bb.png" alt="一张图览尽 CORS 中间件"></p>
<h1 id="核心部件"><a href="#核心部件" class="headerlink" title="核心部件"></a>核心部件</h1><p>对于整个 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/tree/main/src/Middleware/CORS/src">CORS</a> 中间件而言，核心部件主要有：<a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsPolicy.cs">CorsPolicy</a>、<a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsService.cs">CorsService</a> 以及 <a target="_blank" rel="noopener" href="https://hub.fastgit.org/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs">CorsMiddleware</a>。</p>
<h2 id="CorsPolicy"><a href="#CorsPolicy" class="headerlink" title="CorsPolicy"></a>CorsPolicy</h2><p>整个 <strong>CORS</strong> 中间件中，首当其冲的是<code>ICorsPolicy</code>。这个接口的作用是定义跨域的策略，我们知道<code>CORS</code>中引入了<code>Access-Control</code>系列的 HTTP 头，所以，<code>CorsPolicy</code> 本质上是在定义允许哪些 HTTP 头、HTTP 方法、源(<strong>Origin</strong>) 可以访问受限的资源，以及当跨域请求是一个复杂请求的时候，预检请求的超时时间、是否支持凭据等等：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyHeader &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyMethod &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> AllowAnyOrigin &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; IsOriginAllowed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; ExposedHeaders &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Headers &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Methods &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;<span class="built_in">string</span>&gt; Origins &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> TimeSpan? PreflightMaxAge &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SupportsCredentials &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在整个中间件的设计中，与<code>CorsPolicy</code>接口产生直接联系的，是<code>CorsPolicyBuilder</code>和<code>ICorsPolicyProvider</code>。相信大家从命名上就可以了解到，前者是一个基于建造者模式的、针对 <code>CorsPolicy</code>进行“<strong>加工</strong>”的工具类，可以快速地对 跨域策略中允许的 HTTP 方法、HTTP 头、源(<strong>Origin</strong>)等信息进行修改。关于这一点，我们可以从<code>CorsPolicyBuilder</code>提供的方法签名中得到印证，而最终<code>CorsPolicyBuilder</code>通过<code>Build()</code>方法来返回一个“<strong>加工</strong>”好的<code>CorsPolicy</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CorsPolicyBuilder</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithOrigins</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] origins</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] headers</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithExposedHeaders</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] exposedHeaders</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">WithMethods</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] methods</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowCredentials</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">DisallowCredentials</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyOrigin</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyMethod</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">AllowAnyHeader</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetPreflightMaxAge</span>(<span class="params">TimeSpan preflightMaxAge</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowed</span>(<span class="params">Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; isOriginAllowed</span>)</span>;</span><br><span class="line">    <span class="function">CorsPolicyBuilder <span class="title">SetIsOriginAllowedToAllowWildcardSubdomains</span>()</span>;</span><br><span class="line">    <span class="function">CorsPolicy <span class="title">Build</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了通过<code>CorsPolicyBuilder</code>来生成跨域策略，我们还可以通过<code>ICorsPolicyProvider</code>来生成跨域策略。如果你经常使用<code>ASP.NET Core</code>中的<strong>配置系统</strong>和<strong>依赖注入</strong>，对于这种“<strong>套路</strong>”应该不会感到陌生。这里，微软提供了一个默认实现：<code>DefaultCorsPolicyProvider</code>。<code>DefaultCorsPolicyProvider</code>本身依赖<code>CorsOptions</code>，允许使用者传入一个<code>CorsPolicy</code>的实例 或者是一个委托，来自定义跨域策略的“<strong>加工</strong>”细节，并在其内部维护一个字典，来实现<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0#np">具名的跨域策略</a>。如果使用者不为当前跨域策略指定名称，则会使用默认的跨域策略名称。在大多数场景下，我们并不会直接使用<code>CorsPolicyBuilder</code>，而是在<code>Startup</code>类中通过委托来定义跨域策略，两者可以说是不同层次上的跨域策略的“<strong>提供者</strong>”。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCorsPolicyProvider的GetPolicyAsync()</span></span><br><span class="line"><span class="keyword">public</span> Task&lt;CorsPolicy?&gt; GetPolicyAsync(HttpContext context, <span class="built_in">string</span>? policyName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyName ??= _options.DefaultPolicyName;</span><br><span class="line">    <span class="keyword">if</span> (_options.PolicyMap.TryGetValue(policyName, <span class="keyword">out</span> <span class="keyword">var</span> result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.policyTask!;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NullResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CorsOptions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDefaultPolicy</span>(<span class="params">Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="built_in">string</span> name, CorsPolicy policy</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPolicy</span>(<span class="params"><span class="built_in">string</span> name, Action&lt;CorsPolicyBuilder&gt; configurePolicy</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> CorsPolicy? GetPolicy(<span class="built_in">string</span> name);</span><br></pre></td></tr></table></figure>
<h2 id="CorsService"><a href="#CorsService" class="headerlink" title="CorsService"></a>CorsService</h2><p>OK，说完了跨域策略的“<strong>定义</strong>”，现在我们来看看跨域策略是如何被中间件“执行”的，这部分代码被定义在<code>CoreService</code>类的<code>EvaluatePolicy()</code>方法中。可以注意到，如果受限资源允许任意源(<strong>Origin</strong>)访问，则服务器端会认为这是一个不安全的跨域策略。</p>
<p>接下来，从<code>HttpContext</code>中提取客户端的源(<strong>Origin</strong>)，请求方法(<strong>HttpMethod</strong>)。此时，服务器端可以根据请求方法和 HTTP 头 判断当前请求是都为预检请求。按照<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>规范，当请求方法为<code>OPTION</code>且请求头中含有<code>Access-Control-Request-Method</code>时，即表示这是一个预检请求。</p>
<p>至此，我们有了两种选择，预检请求会交给<code>EvaluatePreflightRequest()</code>方法去处理，非预检请求会交给<code>EvaluateRequest()</code>方法去处理。除了<code>HttpContext</code>和<code>CorsPolicy</code>这两个参数以外，它们都会接受第三个参数<code>CorsResult</code>，它里面封装了我们一开始判断出来的关于源和预检请求的信息。继续细看，我们会发现这两个方法，都调用了<code>PopulateResult()</code>方法，继续顺着这条线索下去，我们就会发现，这个方法的主要作用是，结合跨域策略设定的各种参数，进一步对上一步生成的<code>CorsResult</code>进行“<strong>加工</strong>”。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CorsResult <span class="title">EvaluatePolicy</span>(<span class="params">HttpContext context, CorsPolicy policy</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin &amp;&amp; policy.SupportsCredentials) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(Resources.InsecureConfiguration, <span class="keyword">nameof</span>(policy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestHeaders = context.Request.Headers;</span><br><span class="line">    <span class="keyword">var</span> origin = requestHeaders[CorsConstants.Origin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">    <span class="keyword">var</span> isPreflightRequest = isOptionsRequest </span><br><span class="line">        &amp;&amp; requestHeaders.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> corsResult = <span class="keyword">new</span> CorsResult &#123;</span><br><span class="line">        IsPreflightRequest = isPreflightRequest,</span><br><span class="line">        IsOriginAllowed = IsOriginAllowed(policy, origin),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPreflightRequest) &#123;</span><br><span class="line">        <span class="comment">//预检请求</span></span><br><span class="line">        EvaluatePreflightRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非预检请求</span></span><br><span class="line">        EvaluateRequest(context, policy, corsResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> corsResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PopulateResult</span>(<span class="params">HttpContext context, </span></span></span><br><span class="line"><span class="params"><span class="function">    CorsPolicy policy, </span></span></span><br><span class="line"><span class="params"><span class="function">    CorsResult result</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> headers = context.Request.Headers;</span><br><span class="line">    <span class="keyword">if</span> (policy.AllowAnyOrigin) &#123;</span><br><span class="line">        result.AllowedOrigin = CorsConstants.AnyOrigin;</span><br><span class="line">        result.VaryByOrigin = policy.SupportsCredentials;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> origin = headers[CorsConstants.Origin];</span><br><span class="line">        result.AllowedOrigin = origin;</span><br><span class="line">        result.VaryByOrigin = policy.Origins.Count &gt; <span class="number">1</span> </span><br><span class="line">            || !policy.IsDefaultIsOriginAllowed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持凭据</span></span><br><span class="line">    result.SupportsCredentials = policy.SupportsCredentials;</span><br><span class="line">    <span class="comment">// 预检请求超时时间</span></span><br><span class="line">    result.PreflightMaxAge = policy.PreflightMaxAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://fetch.spec.whatwg.org/#http-new-header-syntax</span></span><br><span class="line">    AddHeaderValues(result.AllowedExposedHeaders, policy.ExposedHeaders);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">    <span class="keyword">var</span> allowedMethods = policy.AllowAnyMethod ?</span><br><span class="line">        <span class="keyword">new</span>[] &#123; result.IsPreflightRequest ? </span><br><span class="line">                (<span class="built_in">string</span>)headers[CorsConstants.AccessControlRequestMethod] : </span><br><span class="line">                context.Request.Method &#125; :</span><br><span class="line">        policy.Methods;</span><br><span class="line">    AddHeaderValues(result.AllowedMethods, allowedMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许的HTTP头</span></span><br><span class="line">    <span class="keyword">var</span> allowedHeaders = policy.AllowAnyHeader ?</span><br><span class="line">        headers.GetCommaSeparatedValues(CorsConstants.AccessControlRequestHeaders) :</span><br><span class="line">        policy.Headers;</span><br><span class="line">    AddHeaderValues(result.AllowedHeaders, allowedHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这些参数最终的走向是哪里呢？我们注意到<code>CorsService</code>里有一个叫做<code>ApplyResult()</code>的方法，观察方法签名可以发现，它负责把跨域检测的结果应用到 HTTP 响应上，相信大家都能想到，这里会设置各种<code>Access-Control</code>系列的头，比如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<br><code>Access-Control-Max-Age</code>…等等。事实上，在<code>CorsMiddleware</code>中间件中，原本就是先调用<code>EvaluateResult()</code>方法，再调用<code>ApplyResult()</code>方法。当然，实际的代码中，还需要考虑<code>[DisableCors]</code>和<code>[EnableCors]</code>两个特性的影响，会多出一点判断的代码。关于跨域的代码层面的东西，我们就先讲到这里，在下一部分，我们会专门讲<code>CORS</code>里的简单请求和复杂请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context, ICorsPolicyProvider corsPolicyProvider</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(CorsConstants.Origin)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [DisableCors]</span></span><br><span class="line">    <span class="keyword">var</span> corsMetadata = endpoint?.Metadata.GetMetadata&lt;ICorsMetadata&gt;();</span><br><span class="line">    <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IDisableCorsAttribute) &#123;</span><br><span class="line">        <span class="keyword">var</span> isOptionsRequest = HttpMethods.IsOptions(context.Request.Method);</span><br><span class="line">        <span class="keyword">var</span> isCorsPreflightRequest = isOptionsRequest </span><br><span class="line">            &amp;&amp; context.Request.Headers.ContainsKey(CorsConstants.AccessControlRequestMethod);</span><br><span class="line">        <span class="keyword">if</span> (isCorsPreflightRequest) &#123;</span><br><span class="line">            <span class="comment">// If this is a preflight request, and we disallow CORS, complete the request</span></span><br><span class="line">            context.Response.StatusCode = StatusCodes.Status204NoContent;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// [EnableCors]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (corsMetadata <span class="keyword">is</span> IEnableCorsAttribute enableCorsAttribute &amp;&amp;</span><br><span class="line">        enableCorsAttribute.PolicyName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Evaluate &amp;&amp; Apply</span></span><br><span class="line">        <span class="keyword">return</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        <span class="function"><span class="keyword">async</span> Task <span class="title">InvokeCoreAwaited</span>(<span class="params">HttpContext context, Task&lt;CorsPolicy?&gt; policyTask</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> corsPolicy = <span class="keyword">await</span> policyTask;</span><br><span class="line">            <span class="keyword">await</span> EvaluateAndApplyPolicy(context, corsPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="再论CORS"><a href="#再论CORS" class="headerlink" title="再论CORS"></a>再论CORS</h1><p>好了，行文至此。既然这篇博客的主题是“<strong>跨域</strong>”，那么，我们不妨多说一点。我们知道，“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了“<strong>跨域</strong>”这一限制。而为了顺应“<strong>前后端分离</strong>”、“<strong>微服务</strong>”等等的开发思想，“<strong>跨域</strong>”这个问题开始频繁地出现在人们的视野中，从最初的<strong>JSONP</strong>，到如今成为事实标准的<strong>CORS</strong>，甚至从<strong>Vue</strong>里的代理服务器、<strong>Nginx</strong>里的反向代理，我们总是能窥出一点“<strong>跨域</strong>”的影子，“<strong>跨域</strong>”可谓是无处不在。</p>
<p>那么，什么是 CORS 呢？ CORS ，即跨域资源共享，是一种利用 HTTP 头部来指示服务器端对除自身以外的源(域、协议、端口)是否可以访问指定的资源。你可能会联想到<strong>OAuth2</strong>、<strong>JWT</strong>等等关于认证授权的词汇，请注意，“跨域”始终发生在浏览器端，相对于浏览器，一般意义上的客户端都被视为可信任的。除此之外，CORS提供了一种被称之为“预检”的机制，它可以用来检测服务器端支持的 HTTP 请求头、HTTP 动词，在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p>
<p><img src="https://media.prod.mdn.mozit.cloud/attachments/2016/10/28/14295/a21a85eaccd405d608395b4ca8d82538/CORS_principle.png" alt="为什么会发生跨域？"></p>
<p>如上图所示，浏览器端，特别是<code>XMLHttpRequest</code> 、<code>Fetch API</code> 、<code>Web</code>字体 和 <code>Canvas</code>等始终遵循同源策略，<code>domain-a.com</code>和<code>domain-b.com</code>被视为两个不同域，因此，当<code>domain-a.com</code>试图访问<code>domain-b.com</code>下的资源时，就会被浏览器所限制，这就是我们所说的“<strong>跨域</strong>”。可能，这并不是一个特别好的例子，因为 HTML 中某些元素天生就被设计为允许跨域，例如：<code>image</code>、<code>iframe</code>、<code>link</code>、<code>script</code>等等。而如果我们通过“<strong>协商</strong>”来告诉<code>domain-b</code>，<code>domain-a</code>希望访问它下面的资源，这其实就是我们所说的 CORS 啦！这个“<strong>协商</strong>”过程呢，主要有两种，即 <strong>简单请求</strong> 和 <strong>复杂请求</strong>。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>我们将不触发 CORS 预检 的请求称为简单请求，通常情况下，简单请求满足下列条件：</p>
<ul>
<li>使用下列方法之一：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET">GET</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD">HEAD</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">POST</a></li>
<li>除了被用户代理自动设置的首部字段(例如：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection">Connection</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent">User-Agent</a>) 和 在 Fetch 规范中定义为 <a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/#forbidden-header-name">禁用首部名称</a> 的其他首部，允许人为设置的字段为 Fetch 规范定义的 <a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">对 CORS 安全的首部字段集合</a>。该集合为：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language">Accept-Language</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language">Content-Language</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type">Content-Type</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#dpr">DPR</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#downlink">Downlink</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#save-data">Save-Data</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#viewport-width">Viewport-Width</a>、<a target="_blank" rel="noopener" href="http://httpwg.org/http-extensions/client-hints.html#width">Width</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type">Content-Type</a> 的值仅限于下列三者之一：text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded</li>
<li>请求中的任意 <a href="">XMLHttpRequestUpload</a> 对象均没有注册任何事件监听器；<a href="">XMLHttpRequestUpload</a> 对象可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload">XMLHttpRequest.upload</a> 属性访问。</li>
<li>请求中没有使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream">ReadableStream</a> 对象。</li>
</ul>
<p>对于 <strong>简单请求</strong> ，由于它的 HTTP 动词是确定的，故其跨域主要体现在服务器端返回的 HTTP 响应中，可能出现的响应头有：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Headers</code>等。所以，如果客户端请求的<code>Origin</code>被包含在服务器端返回的<code>Access-Control-Allow-Origin</code>中，则表示跨域被允许，反之则不被允许。所以，现在大家应该能想明白，为啥那些年里大家稀里糊涂地，把<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Headers</code>设置为<code>*</code>就万事大吉了吧，而对照着中间件的代码，理解这层含义会更容易一点！</p>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>与简单请求不同，<strong>复杂请求</strong> 要求必须首先使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS">OPTIONS</a> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”<strong>预检请求</strong>“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<p><img src="https://media.prod.mdn.mozit.cloud/attachments/2019/06/19/16753/b32f78ac26d18e3e155205e4f0057b73/preflight_correct.png" alt="预检请求"></p>
<p>当浏览器检测到，从<code>JavaScript</code>中发起的请求需要被预检。此时，可以注意到，预检请求中同时携带了下面两个首部字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers：X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>

<p>服务器在接受预检请求后，会返回以下响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>首部字段<code>Access-Control-Allow-Methods</code>表明服务器允许客户端使用 POST、GET 和 OPTIONS 方法发起请求。</li>
<li>首部字段<code>Access-Control-Allow-Headers</code>表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。</li>
<li>首部字段<code>Access-Control-Max-Age</code>表明该响应的有效时间为 86400 秒，即 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。</li>
</ul>
<p>下面整理了 CORS 中常见的 <strong>Access-Control</strong> 系列头部字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Expose-Headers</span><br><span class="line">Access-Control-Max-Age</span><br><span class="line">Access-Control-Allow-Credentials</span><br><span class="line">Access-Control-Allow-Methods</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line">Origin</span><br><span class="line">Access-Control-Request-Method</span><br><span class="line">Access-Control-Request-Headers</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文分别从 <strong>源代码</strong> 和 <strong>规范</strong> 两个角度探讨了 “<strong>跨域</strong>” 这个话题，两者可以说是相辅相成的存在，CORS 中间件实现了 CORS 规范，而通过 CORS 规范帮助我们理解了中间件。“<strong>跨域</strong>”产生的背景是，浏览器作为一个公共环境，它本身是不被信任的，所以，为了杜绝非当前域的资源，例如Cookie、API等等被“<strong>窃取</strong>”，浏览器便增加了 “<strong>跨域</strong>” 这一限制。最初我们通过 <strong>JSONP</strong> 这种方案来解决跨域问题，而后来我们有了<strong>CORS</strong> 这种事实上的标准，其原理上利用 <strong>Origin</strong> 及 <strong>Access-Control</strong>系列的头来标识服务器端可以允许哪些源、以什么样的 HTTP 动词 &#x2F; 头来访问资源，按照 CORS 规范，浏览器端发起的请求被分为： <strong>简单请求</strong> 和 <strong>复杂请求</strong> 两种，两者最大的区别是，<strong>复杂请求</strong> 必须首先通过 <strong>OPTIONS</strong> 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。好了，以上就是这篇博客的全部内容啦，欢迎大家在博客评论中参与讨论，再次谢谢大家，晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-14-forevermissed-dengzr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-14-forevermissed-dengzr/" itemprop="url">缅怀子睿</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-14T11:48:11+00:00">
                2021-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/dengzr-4.png" width="400px" />

<p>就在几天前，我的大学同学、ACM 竞赛队友邓子睿因为癌症离开了。他今年才 35 岁，一直在硅谷的微软工作，刚刚成家立业，正是大展宏图的年纪。此时离开，让我和班上同学都感慨上天不公，造物弄人。</p>
<p>回想起来，因为共同参加学校 ACM&#x2F;ICPC 程序设计竞赛并且为同队队友，邓子睿可以算是和我相处时间最久的大学同学了。</p>
<p>邓子睿高中在全国有名的湖南雅礼中学，以 NOIP 信息学竞赛省一等奖的成绩保送北京师范大学信息学院。</p>
<p>邓子睿高中因为全力备战竞赛，所以放弃了很多正常的高中生的课程学习，这让他的 NOIP 竞赛更像是背水一战，特别是他当年是参加了两届竞赛，在高三那届竞赛才拿到了保送资格，这让他一直耿耿于怀。</p>
<p>所以在进入大学之后，邓子睿在参加 ACM 竞赛的时候，没有落下任何的学业，一直在班上成绩保持前十名。他说他受不了高中时候那种感受，他一定要竞赛好的同时把成绩也搞好。</p>
<p>他真的做到了。ACM&#x2F;ICPC 竞赛 3 人一队，我和他同为一组，2005 年，我们一起为北京师范大学拿下了历史上的首个银奖，也是学校 ACM 队首次获得奖牌（当时获奖率只有前 20%）。同时，他在大四的时候，因为成绩优异，拿到了保送到北京大学人工智能学院的机会。</p>
<img src="/images/dengzr-1.jpeg" class="">

<p>因为 4 年的队友关系，我们一直保持着联系。研究生阶段虽然在不同的学校，但是我们时不时会回师大聚聚，看望一下我们竞赛的老师冯速老师。研究生毕业后，他选择了微软中国，而我选择了网易。</p>
<p>我们工作后的头几年也时常聚会。他在微软的头几年并不算特别顺利，他本来希望尽快 transfer 到美国，但是因为各种原因总是耽搁。终于有一天他请大家吃饭，宣布自己拿到了 transfer 的机会，我们都很高兴。</p>
<p>到美国之后，每一次有机会回国内，我们就会约上吃一顿。邓子睿还是一样的精力旺盛，滑雪、拉丁舞、摄影，各种广泛的爱好把自己的生活过得有滋有味。最后一次合影，是 18 年 11 月，那次他因为工作短暂停留北京，当时微软的市值第一次超过了苹果，我们畅谈之后都祝愿大家事业越来越好。</p>
<p>没想到，这竟然是最后一次聚会了。</p>
<img src="/images/dengzr-2.jpeg" class="">

<p>就在一个月前，邓子睿主动联系了我，介绍了他的病情，希望我没事多和他聊聊天。当我知道他已经是肺癌晚期，已经开始做化疗的时候，我当时难过得说不出话来。反倒是他安慰我说，这边有最好的治疗条件，妈妈也来美国照顾他了，而且还有老婆，身边很多朋友都很关心，医保能够支付大部分的费用。</p>
<p>这一个月，我们会时不时地发一些好玩的东西，因为时差和治疗，我们之间回复的间隔比较长。我默默地祝福着他，希望他能扛过这一切。直到几天前，早上起来突然收到胡博的微信，说子睿已经离开了。</p>
<p>他的老婆<a target="_blank" rel="noopener" href="https://www.forevermissed.com/zirui-deng/about">为他建立了一个网站</a>，上面有他从小到大的各种照片，我也翻到了我们当时的合影。那真是一个无忧无虑的年纪：</p>
<img src="/images/dengzr-3.jpg" class="">

<p>邓子睿这一生，活得精彩，只是走得太快，带着太多亲人与朋友的思念。</p>
<p>愿天堂没有病痛，也愿活着的人都珍惜现在。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/" itemprop="url">源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-10T13:52:47+00:00">
                2021-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在上一篇文章中，博主带领大家一起深入了解 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件，正当我得意洋洋地向 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/">Catcher Wong</a> 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过<code>SeamphoreSlim</code>控制线程数量而已，一旦放到分布式环境中，这个并发控制就被大大地削弱。所以，在今天这篇文章中，博主会带领大家一起“<strong>探案</strong>” <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的限流中间件 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimite</a>，希望大家可以从中感悟到不一样的东西。对我而言，这可能是人到中年的焦虑感所催生出来的一种源动力，同时亦是为了不让那些订阅专栏的同学失望。</p>
<p>关于“<strong>限流</strong>”这个话题，我个人以为，它可以引申出非常多的东西，譬如“熔断”和“限流”，其实可以看作是同一类问题的“一体两面”。最早接触熔断，是源于 <strong>Spring Cloud</strong> 中的 <strong>Hystrix</strong>，它其实是指当服务不可用的时候，客户端应该采取什么样的措施去应对，实际使用中我们可能会考虑重试、超时、降级等策略。相应地，当服务端在面对来自客户端的异常流量时，就产生了“限流”这个概念，“限流”可以是线程隔离**(<strong>线程数 + 队列大小限制</strong>)，可以是信号量隔离(<strong>设置最大并发请求数目</strong>)，可以是限制QPS。这里，我们讨论的主要是第三种，而实现限流的常见算法主要有<strong>计数器算法</strong>、<strong>漏桶算法</strong>和<strong>令牌桶算法</strong>。这里，<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 这个中间件，则主要使用了<strong>计数器算法</strong>，并配合 <code>IMemoryCache</code> 和 <code>IDistributedCache</code> 分别实现了基于内存和基于分布式缓存的持久化逻辑。</p>
<h1 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h1><p>首先，使用者通过配置定义了一个或者多个规则，这些规则决定了每个客户端在访问特定终结点时，一段时间内可以访问的最大次数。 <a href="">RateLimitMiddleware</a> 通过注入的<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs">IRateLimitProcessor</a> 来匹配规则，然后依次判断每个规则是否达到了限流条件。一旦达到限流条件，中间件会改变 HTTP 响应的状态码、响应头、返回值，告知使用者已达到最大调用次数。而针对每一种 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Core/IRateLimitProcessor.cs">IRateLimitProcessor</a> ，主要通过<code>ProcessRequestAsync()</code> 方法来实现计数，如果上一次的请求对应的时间戳 + 规则中时间间隔 &gt;&#x3D; 当前时间，则说明请求没有过期，此时，就需要给这个计数增加1。好了，现在我们来针对 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 中的核心部件逐个进行解读。</p>
<h2 id="RateLimitProcessor"><a href="#RateLimitProcessor" class="headerlink" title="RateLimitProcessor"></a>RateLimitProcessor</h2><p><code>RateLimitProcessor</code>，是一个抽象类，实现了<code>IRateLimitProcessor</code>接口，公开的方法有 3 个：<code>ProcessRequestAsync()</code>、<code>IsWhitelisted()</code> 和 <code>GetRateLimitHeaders()</code>。在此基础上，派生出<code>ClientRateLimitProcessor</code>和<code>IpRateLimitProcessor</code>两个子类。两者最大的不同在于，其所依赖的<code>Store</code>不同，前者为<code>IClientPolicyStore</code>，后者<code>IIpPolicyStore</code>，它们都实现了同一个接口<code>IRateLimitStore</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRateLimitStore</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">ExistsAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">GetAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">SetAsync</span>(<span class="params"><span class="built_in">string</span> id, T entry, TimeSpan? expirationTime = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，这些都是典型的基于键-值的存储，所以，不管是基于内存的IMemeryCache，还是基于分布式缓存的IDistributedCache，都可以做到无缝切换。不同的Processor，本质上是它们生成缓存键的方式不同，例如，<code>IpRateLimitProcessor</code>是用一个前缀来表示一组IP，而<code>ClientRateLimitProcessor</code>则是用通过客户端前缀和客户端Id来作为区分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/IpRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policies = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.IpPolicyPrefix&#125;</span>&quot;</span>,</span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">new</span> List&lt;RateLimitRule&gt;();</span><br><span class="line">    <span class="keyword">if</span> (policies?.IpRules?.Any() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for rules with IP intervals containing client IP</span></span><br><span class="line">        <span class="keyword">var</span> matchPolicies = policies.IpRules</span><br><span class="line">            .Where(r =&gt; IpParser.ContainsIp(r.Ip, identity.ClientIp));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> matchPolicies)</span><br><span class="line">        &#123;</span><br><span class="line">            rules.AddRange(item.Rules);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/ClientRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policy = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.ClientPolicyPrefix&#125;</span>_<span class="subst">&#123;identity.ClientId&#125;</span>&quot;</span>, </span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, policy?.Rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>RateLimitProcessor</code>而言，其实现思路是，通过<code>CounterKeyBuilder</code>及其子类来生成计数器标识(<strong>CounterId</strong>)，然后再通过<code>AsyncKeyLock</code>来实现计数，最终通过<code>IRateLimitCounterStore</code>来实现存储：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">async</span> Task&lt;RateLimitCounter&gt; <span class="title">ProcessRequestAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    ClientRequestIdentity requestIdentity, </span></span></span><br><span class="line"><span class="params"><span class="function">    RateLimitRule rule, </span></span></span><br><span class="line"><span class="params"><span class="function">    CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">    &#123;</span><br><span class="line">        Timestamp = DateTime.UtcNow,</span><br><span class="line">        Count = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成CounterId</span></span><br><span class="line">    <span class="keyword">var</span> counterId = BuildCounterKey(requestIdentity, rule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于AsyncLock的计数器</span></span><br><span class="line">    <span class="comment">// serial reads and writes on same key</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">await</span> AsyncLock.WriterLockAsync(counterId).ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = <span class="keyword">await</span> _counterStore.GetAsync(counterId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// entry has not expired</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value.Timestamp + rule.PeriodTimespan.Value &gt;= DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increment request count</span></span><br><span class="line">                <span class="keyword">var</span> totalCount = entry.Value.Count + _config.RateIncrementer?.Invoke() ?? <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep copy</span></span><br><span class="line">                counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">                &#123;</span><br><span class="line">                    Timestamp = entry.Value.Timestamp,</span><br><span class="line">                    Count = totalCount</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计数器存储</span></span><br><span class="line">        <span class="comment">// stores: id (string) - timestamp (datetime) - total_requests (long)</span></span><br><span class="line">        <span class="keyword">await</span> _counterStore.SetAsync(</span><br><span class="line">            counterId, </span><br><span class="line">            counter, </span><br><span class="line">            rule.PeriodTimespan.Value, </span><br><span class="line">            cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AsyncKeyLock"><a href="#AsyncKeyLock" class="headerlink" title="AsyncKeyLock"></a>AsyncKeyLock</h2><p>在分析<code>RateLimitProcessor</code>类的时候，我们提到了<code>AsyncKeyLock</code>。对于<code>AsyncKeyLock</code>的实现，我个人认为这是整个中间件的精华，因为这里出现了，和<code>SeamphoreSlim</code>一样经典的东西，这里用到了自旋锁<code>SpinLock</code>。我个人理解，<code>SpinLock</code> 约等于 <code>Interlocked</code> + 内核级别的while。这部分代码本身并不复杂，难就难在这样一个精妙的想法上面。其中，<a href="">AsyncKeyLockDoorman</a> 这个类的实现，应该是参考了微软的一篇博客—— <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/">Building Async Coordination Primitives, Part 7: AsyncReaderWriterLock</a>，因为<code>ReaderLockAsync()</code>、<code>WriterLockAsync()</code>、<code>ReaderRelease()</code> 和 <code>WriterRelease()</code> 这 4 个关键方法完全一样。结合限流这个场景来看，它是典型的“<strong>多写</strong>”场景，因为如果是相同的请求，那么就会产生相同的计数器标识(<strong>CounterId</strong>)，所以，这个<code>AsyncLockDoorman</code>这个类所定义的上下文边界，其实是“<strong>一读多写</strong>”的问题，所以，我们可以注意到，它里面定义了一个“写”操作的队列<code>_waitingWriters</code>，一个“读操作”的<code>_waitingReader</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncKeyLockDoorman</span>(<span class="params">Action&lt;AsyncKeyLockDoorman&gt; reset</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 多个写入者</span></span><br><span class="line">    _waitingWriters = <span class="keyword">new</span> Queue&lt;TaskCompletionSource&lt;Releaser&gt;&gt;();</span><br><span class="line">    <span class="comment">// 单个读取者</span></span><br><span class="line">    _waitingReader = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">    _status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _readerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">false</span>));</span><br><span class="line">    _writerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">true</span>));</span><br><span class="line">    _reset = reset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“写”操作而言，当一个新的写入者希望进来的时候，如果此时锁没有被别人占用，那么这个新的写入者会获得这个锁，状态值<code>m_status</code>会被修改为-1。反之，如果此时这个锁已经被别人占用了，那么这个新的写入者将会进入等待队列。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">WriterLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _status = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> _writerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">            _waitingWriters.Enqueue(waiter);</span><br><span class="line">            <span class="keyword">return</span> waiter.Task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“读”操作而言，我们来思考这样一个问题，什么时候“读”操作会被允许呢？答案是这一时刻没有写入者正在“写”或者“等”，因为如果不这样的话，就会发生我们平常所说的“<strong>脏读</strong>”，所以，这种情况下，就必须强迫“读取者”去等待写入者“空闲”下来。此时，不难理解<code>ReadLockAsync()</code>的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">ReaderLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status &gt;= <span class="number">0</span> &amp;&amp; _waitingWriters.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_status;</span><br><span class="line">            <span class="keyword">return</span> _readerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++_readersWaiting;</span><br><span class="line">            <span class="keyword">return</span> _waitingReader.Task.ContinueWith(t =&gt; t.Result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们把视线拉回到<code>AsyncKeyLock</code>，它负责维护一组<code>AsyncKeyLockDoorman</code>，其内部部通过一个字典来维护<code>CounterId</code>和<code>AsyncKeyLockDoorman</code>间的关系。与此同时，为了减少创建·AsyncKeyLockDoorman·带来的性能损耗，它使用一个栈来存储<code>AsyncKeyLockDoorman</code>。每次获取<code>AsyncKeyLockDoorman</code>的过程，本质上就是为指定的<code>Key</code>分配<code>AsyncKeyLockDoorman</code>的过程，同时会更新其引用数<code>RefCount</code>。相应地，释放<code>AsyncKeyLockDoorman</code>的过程，本质上就是减少其引用数<code>RefCount</code>，从字典中移除指定<code>Key</code>，“<strong>归还</strong>”对象池的过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AsyncKeyLockDoorman <span class="title">GetDoorman</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncKeyLockDoorman doorman;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (!Keys.TryGetValue(key, <span class="keyword">out</span> doorman))</span><br><span class="line">        &#123;</span><br><span class="line">            doorman = (Pool.Count &gt; <span class="number">0</span>) ? Pool.Pop() : </span><br><span class="line">                <span class="keyword">new</span> AsyncKeyLockDoorman(ReleaseDoorman);</span><br><span class="line">            doorman.Key = key;</span><br><span class="line">            Keys.Add(key, doorman);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doorman.RefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doorman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseDoorman</span>(<span class="params">AsyncKeyLockDoorman doorman</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (--doorman.RefCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Keys.Remove(doorman.Key);</span><br><span class="line">            <span class="keyword">if</span> (Pool.Count &lt; MaxPoolSize)</span><br><span class="line">            &#123;</span><br><span class="line">                doorman.Key = <span class="literal">null</span>;</span><br><span class="line">                Pool.Push(doorman);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RateLimitMiddleware"><a href="#RateLimitMiddleware" class="headerlink" title="RateLimitMiddleware"></a>RateLimitMiddleware</h2><p>OK，到这里，我们再回过头去看<strong>源代码解读</strong>这里的内容，大概就可以串起来整合中间件的调用链路，<code>Middleware</code>-&gt;<code>RateLimteProcessor</code>-&gt;<code>AsyncKeyLock</code>-&gt;<code>AsyncKeyLockDoorman</code>，坦白来讲，我一直没能想明白为什么要用<code>SpinLock</code>？难道仅仅是为了减少等待时间、提高性能吗？经过精简，我们发现，整个中间件的<code>Invoke()</code>方法，大致要经历下面几个阶段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查限流是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (_options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户身份</span></span><br><span class="line">    <span class="keyword">var</span> identity = <span class="keyword">await</span> ResolveIdentityAsync(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查白名单</span></span><br><span class="line">    <span class="keyword">if</span> (_processor.IsWhitelisted(identity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取限流规则</span></span><br><span class="line">    <span class="keyword">var</span> rulesDict = <span class="keyword">new</span> Dictionary&lt;RateLimitRule, RateLimitCounter&gt;();</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">await</span> _processor.GetMatchingRulesAsync(</span><br><span class="line">        identity, </span><br><span class="line">        context.RequestAborted</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> rule <span class="keyword">in</span> rules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取计数器数目</span></span><br><span class="line">        <span class="keyword">var</span> rateLimitCounter = <span class="keyword">await</span> _processor.ProcessRequestAsync(</span><br><span class="line">            identity, </span><br><span class="line">            rule, </span><br><span class="line">            context.RequestAborted</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (rule.Limit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求未过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value &lt; DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Count &gt; rule.Limit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 各种记日志，告诉调用者多长时间后再重试</span></span><br><span class="line">                <span class="keyword">var</span> retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中止请求</span></span><br><span class="line">                <span class="keyword">await</span> ReturnQuotaExceededResponse(context, rule, retryAfter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Limit &lt;= 0, 相当于直接不允许放行，中止请求</span></span><br><span class="line">            <span class="keyword">await</span> ReturnQuotaExceededResponse(</span><br><span class="line">                context, </span><br><span class="line">                rule, </span><br><span class="line">                <span class="built_in">int</span>.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture)</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置X-Rate-Limit头</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>作为 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/18417412/">并发限制</a> 这一篇的“姊妹篇”，这一篇的难度相对上一篇堪称“高山仰止”，主要的难点是 <strong>SpinLock</strong> 、“一读多写”的异步读写锁 <strong>AsyncKeyLock</strong> 以及 <strong>AsyncKeyLockDoorman</strong> 。如果大家感兴趣的话，可以去搜索一下 <strong>AsyncKeyLock</strong> 这个关键字，大家就会发现在好多<a target="_blank" rel="noopener" href="https://github.com/SixLabors/ImageSharp.Web/">开源项目</a> 中都能找到类似的代码片段，莫非这是某种神奇的算法吗？阅读源代码，其实是一个无法“立竿见影”的学习方法，有时候我们要通过叙述或者表达来输出我们对待一件事物的看法。这是因为，我们自以为是的“学会”和真正的“学会”，这两者间可能千差万别，就像我最近在用 <a target="_blank" rel="noopener" href="https://abp.io/">ABP vNext</a> 搭建一个小项目，阅读文档的时候，眼睛觉得它“学会”了，而实际需要需要扩展或者替换 ABP 的实体&#x2F;服务的时候。我的手会告诉我，它真的“不会”。做一个知难行易的“调包”侠也许会非常容易，可正因为如此，你要凸显自我就会非常困难。世上的事情，“<strong>夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</strong>”，哪怕就是增长一下见识呢，你说对吧……</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/spatial-audio-for-local-videos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/spatial-audio-for-local-videos/" itemprop="url">尝试为本地视频开启 AirPods Pro 空间音频</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-05T12:04:00+00:00">
                2021-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index">
                    <span itemprop="name">日常</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>继 <a target="_blank" rel="noopener" href="https://prinsss.github.io/airpods-2-are-great/">AirPods 2</a> 之后，前段时间我又没忍住，入手了传说中的<del>豌豆射手</del> AirPods Pro。</p>
<p>第一次体验到的「主动降噪」功能确实惊艳，虽然感觉对人声的处理还是差了点意思，但开和不开真的是两种完全不同的感受。尤其是乘坐公共交通的时候，感觉是终于夺回了一点耳朵的主导权，不用再一味地被各种噪声强奸了。</p>
<p>用了几个月，总的来说挺满意的，就是这人声降噪实在是普通，近处的人说话大声点就挡不住了（比如室友），只能开音乐盖过去。有人说是后续固件削弱了，不过我感觉买来就这吊样。可惜市面上还是没有能达到聋子模拟器效果的降噪耳机，遗憾。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/spatial-audio-for-local-videos/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/" itemprop="url">源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-04T12:13:47+00:00">
                2021-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>打算开一个新的专栏——<strong>源代码探案系列</strong>，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“<strong>生手</strong>”到“<strong>熟练工</strong>”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个“<strong>手艺人</strong>”，可我更想说一句古人的话——<strong>君子不器</strong>。什么是器呢？“<strong>形而上者谓之道，形而下者谓之器</strong>”，用一句更直白的话来说，就是“<strong>不能知其然而不知其所以然</strong>”，这是我一个非CS科班出身的程序员，想去写这样一个专栏的初衷，因为在我看来，“<strong>器</strong>”是永远学不完的，而“<strong>道</strong>”虽然听起来虚无缥缈，实则“<strong>朝闻道，夕死可矣</strong>”。</p>
<p>作为这个专栏的第一篇博客，我打算从 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件开始。并发是一个爱恨交织的话题，我们喜欢高并发，因为这是程序员跻身高手行列的好机会；我们厌恶并发，因为它引入了多线程、锁、信号量这些复杂的东西。相信大家都曾被并发困扰过，古人云：<strong>他山之石，可以攻玉</strong>，还有什么比阅读源代码更朴实无华的“学习”呢？你找大牛，大牛可能忙着开会、做PPT；你找同事，同事里可能十个有八个都不知道啊。这个中间件的核心是 <code>IQueuePolicy</code> ，其位于以下<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter/src/QueuePolicies">位置</a>，它定义了两个核心的方法：<code>TryEnterAsync()</code> 和 <code>OnExit()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueuePolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其默认实现<code>QueuePolicy</code>中，<code>TryEnterAsync()</code>方法，决定着一个请求是会被拒绝还是接受。具体是怎么做呢？它定义了一个最大的并发请求数目，如果实际数超过了最大的并发请求数目，那么请求将会被拒绝。反之，请求将被接受。再仔细看，我们就会发现，它内部使用了<code>SeamphoreSlim</code>和<code>Interlocked</code>，所以，聪明的小伙伴们应该立马会联想到，这两种锁各自的作用是什么。</p>
<p>其中，<code>Seamphore</code> 是一个 Windows 内核中的一个同步信号量，适用于在多个有限的线程资源中共享内存资源，它就像一个栅栏，本身具有一定的容量，当线程数量达到这个容量后，新的线程就无法再通过，直到某个线程执行完成。<code>SeamphoreSlim</code>是<code>Seamphore</code>优化后的版本，在性能上表现更好一点，更推荐大家使用<code>SeamphoreSlim</code>。</p>
<p>而 <code>Interlocked</code> 的则是我们熟悉的原子操作，它可以在多个线程中，对共享的内存资源进行原子加或者原子减操作。在这里，<code>Interlocked</code>主要用来控制并发请求数的加和减。如果当前的并发请求数小于最大的并发请求数，表示还可以允许新的请求进来，此时，<code>TryEnterAsync()</code>方法会返回true。如果此时的并发请求数大于最大的并发请求数，则需要对当前请求数进行减操作，此时，<code>TryEnterAsync()</code>方法会返回false。</p>
<p>一旦搞清楚这一点，结合中间件的代码，我们可以非常容易地想明白,这个并发控制的实现思路。下面是<code>QueuePolicy</code>中<code>TryEnterAsync()</code>和<code>OnExit()</code>两个方法的实现，分别代表了“<strong>加锁</strong>”和“<strong>解锁</strong>”两个不同的阶段。某种程度上，<code>Seamphore</code>更像一个水闸，每次可以通过的“<strong>流量</strong>”是固定的，超出的部分会被直接“<strong>拒绝</strong>”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“加锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a return value of &#x27;false&#x27; indicates that the request is rejected</span></span><br><span class="line">    <span class="comment">// a return value of &#x27;true&#x27; indicates that the request may proceed</span></span><br><span class="line">    <span class="comment">// _serverSemaphore.Release is *not* called in this method, </span></span><br><span class="line">    <span class="comment">// it is called externally when requests leave the server</span></span><br><span class="line">    <span class="built_in">int</span> totalRequests = Interlocked.Increment(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前请求次数 &gt; 最大请求次数，返回false表示拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests &gt; _maxTotalRequest) &#123;</span><br><span class="line">        Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task task = _serverSemaphore.WaitAsync();</span><br><span class="line">    <span class="keyword">if</span> (task.IsCompletedSuccessfully) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SemaphoreAwaited(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“解锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _serverSemaphore.Release();</span><br><span class="line">    Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="揭秘-StackPolicy"><a href="#揭秘-StackPolicy" class="headerlink" title="揭秘 StackPolicy"></a>揭秘 StackPolicy</h1><p>除了<code>QueuePolicy</code>这种实现以外，官方还提供了<code>StackPolicy</code>的实现。从名称上，我们就能大致区分出它们的不同，因为我相信大家都能拎得清“队列”和“栈”。在实现<code>StackPolicy</code>的过程中，首先会判断是否还有访问请求次数<code>_freeServerSpots</code>，直接返回true，确保中间件可以继续执行。如果<code>_queueLength</code>和我们设置的队列最大容量相同，此时，表示队列已满，需要先取消之前的请求，并保留后来的请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValueTask</span>&lt;<span class="title">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_freeServerSpots &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，则取消之前的请求，即_head</span></span><br><span class="line">        <span class="keyword">if</span> (_queueLength == _maxQueueCapacity) &#123;</span><br><span class="line">            _hasReachedCapacity = <span class="literal">true</span>;</span><br><span class="line">            _buffer[_head].Complete(<span class="literal">false</span>);</span><br><span class="line">            _queueLength--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tcs = _cachedResettableTCS ?? </span><br><span class="line">            = <span class="keyword">new</span> ResettableBooleanCompletionSource(<span class="keyword">this</span>);</span><br><span class="line">        _cachedResettableTCS = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_hasReachedCapacity || _queueLength &lt; _buffer.Count) &#123;</span><br><span class="line">            _buffer[_head] = tcs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _buffer.Add(tcs);</span><br><span class="line">        &#125;</span><br><span class="line">        _queueLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment _head for next time</span></span><br><span class="line">        <span class="comment">// 如果_head = 最大队列容量，则_head需要移动至首位</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="keyword">if</span> (_head == _maxQueueCapacity) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.GetValueTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queueLength == <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots++;</span><br><span class="line"></span><br><span class="line">            f (_freeServerSpots &gt; _maxConcurrentRequests) &#123;</span><br><span class="line">                _freeServerSpots--;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;OnExit must only be called once per successful call to TryEnterAsync&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step backwards and launch a new task</span></span><br><span class="line">    <span class="keyword">if</span> (_head == <span class="number">0</span>) &#123;</span><br><span class="line">        _head = _maxQueueCapacity - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _head--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _buffer[_head].Complete(<span class="literal">true</span>);</span><br><span class="line">    _queueLength--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，现在，你可以感受到这两种策略的差异了，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。此时，如果我们再回过头来看 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 这个中间件的实现，就会有种恍然大悟的感觉。</p>
<h1 id="揭秘-Middleware"><a href="#揭秘-Middleware" class="headerlink" title="揭秘 Middleware"></a>揭秘 Middleware</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure we only ever call GetResult once on the TryEnterAsync ValueTask b/c it resets.</span></span><br><span class="line">    <span class="comment">// 以下代码片段，其实都是调用IQueuePolicy.TryEnterAsync()</span></span><br><span class="line">    <span class="keyword">var</span> waitInQueueTask = _queuePolicy.TryEnterAsync();</span><br><span class="line">    <span class="built_in">bool</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitInQueueTask.IsCompleted) &#123;</span><br><span class="line">        ConcurrencyLimiterEventSource.Log.QueueSkipped();</span><br><span class="line">        result = waitInQueueTask.Result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> (ConcurrencyLimiterEventSource.Log.QueueTimer())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">await</span> waitInQueueTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当result为true，表示请求被接收，此时，让中间件继续执行</span></span><br><span class="line">    <span class="comment">// 切记：调用_queuePolicy.OnExit()来释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _queuePolicy.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是请求被拒绝的情况，修改状态码以及输出错误信息</span></span><br><span class="line">        ConcurrencyLimiterEventSource.Log.RequestRejected();</span><br><span class="line">        ConcurrencyLimiterLog.RequestRejectedQueueFull(_logger);</span><br><span class="line">        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;</span><br><span class="line">        <span class="keyword">await</span> _onRejected(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就理清了整个中间件的运作机制，<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 中注入了<code>IQueuePolicy</code>这个接口，当一个新的请求进来，中间件会调用<code>IQueuePolicy</code>接口的<code>TryEnterAsync()</code>方法，该方法决定了一个请求是会被接受还是拒绝。当请求被接受的时候，中间件会调用<code>_next(context)</code>让请求继续往下走；当请求被拒绝的时候，中间件会修改 HTTP 状态码(503) 和 返回值，保证调用者可以收到错误信息。这就是这个中间件全部的秘密。而如果要在项目中使用这个中间件，同样是非常简单的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 中间件基本法，先注册后使用</span></span><br><span class="line"><span class="comment">// ConfigureServices()</span></span><br><span class="line"><span class="comment">// 或者 services.AddQueuePolicy()</span></span><br><span class="line">services.AddStackPolicy(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">    options.RequestQueueLimit = <span class="number">25</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure()</span></span><br><span class="line">app.UseConcurrencyLimiter();</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，主要揭秘了 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 中间件，这个中间件的主要功能是控制 ASP.NET Core 中的请求并发。作为这个中间件的核心，微软为 <code>IQueuePolicy</code> 接口提供了 <code>QueuePolicy</code> 和 <code>StackPolicy</code> 两种不同的策略实现。其中，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。对于我们而言，这个中间件最值得学习的地方，其实是<code>SeamphoreSlim</code>和<code>Interlocked</code>，我们经常提到“<strong>锁</strong>”，其实，“<strong>锁</strong>”不单单是指 .NET 中<code>Monitor</code>的语法糖，即<code>lock</code>关键字，在同步信号量以及线程同步的相关话题中，我们还会接触到譬如 <strong>Mutex(互斥锁)<strong>、ReaderWriterLockSlim、</strong>Interlocked(原子操作)<strong>、</strong>SpinLock(自旋锁)</strong> 以及 SeamphoreSlim 等等不同的“<strong>锁</strong>”。除此之外，还有譬如AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 等等的同步信号量。如果有读者朋友对此感兴趣，可以到 MSDN 上去搜索相关的关键字，能让博主本人和大家从中有所收获，这是我坚持写下去的理由。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、讨论。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-03-04-2020-feb-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-03-04-2020-feb-summary/" itemprop="url">二月总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-03T11:16:16+00:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">从思辨中学历史</a></li>
</ul>
<h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>因为上家公司经营不佳，所以被通知年后不用复工了，于是我开始了找工作的日子。说实话我挺喜欢小城市的生活节奏的，不太愿意回到广州这种一线城市。一线城市的人总是匆匆忙忙的，小城市虽然人少，但更有人情味，而在一线城市，哪怕挤地铁时别人就贴在自己身边，但其实出了地铁后，你可能就会忘记这个人，并无多少交集，甚至连他长什么样都不知道，所以我更喜欢小城市。但可惜我所在的小城市这类公司太少，薪资待遇也跟不上，无奈也只能回广州了。</p>
<p>经过了一个星期的面试，总算收到一个心仪的 offer，前天刚入职，就目前情况来看还是很不错的。有了之前的教训，这次我在公司附近的地方租房，免去上班挤地铁的痛苦，这极大提高了幸福感。</p>
<p>由于搬家东西较多，只能让父亲开车送我下来，心里有点不好受，短短几个月，行李搬来搬去的，还要他老人家陪自己奔波，暗暗下定决心，以后绝对不要频繁跳槽了，就先稳定下来吧。</p>
<h2 id="博客迁移到-Jekyll"><a href="#博客迁移到-Jekyll" class="headerlink" title="博客迁移到 Jekyll"></a>博客迁移到 Jekyll</h2><p>我之前的博客使用 hexo 搭建的，基于 <a target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题做了一些改造，至今也三年多了，我一直都挺喜欢这个主题，直到我看到这个  <a target="_blank" rel="noopener" href="https://github.com/cotes2020/jekyll-theme-chirpy">Chirpy</a>，我觉得是时候要换换花样了。但由于这个主题是 jekyll 平台的，我要用只能有两个选择：</p>
<ol>
<li>将主题适配到 hexo</li>
<li>将博客迁移到 jekyll</li>
</ol>
<p>显然方案一要更有趣，还能多一个 repo，但想到用了这么久 hexo，也想尝试一下 jekyll，所以暂时选择方案二，于是花了个把小时迁移过来。后续如果有换回 hexo 的想法，再实施方案一。</p>
<p>其实从 hexo 迁移到 jekyll 也是有损失的，比如会导致以前的文章：链接失效、评论丢失。</p>
<p>虽然上面两个问题都有办法解决，但是一来想到我的博客只是我的自留地，没什么人看，评论就更少了，并且数据也不是真的丢失了，有心的同学通过搜索引擎还是能够找到的，所以索性不管了。</p>
<p>另外一个就是不破不立嘛，今年更想多写一些技术以外的东西，虽然大部分只不过是我的牢骚罢了。</p>
<p>最后放一下博客前后主题的对比，也是跟陪伴我三年的 <a target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polarbear</a>  主题讲拜拜。</p>
<p>之前：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220338.png" alt="之前"><br>现在：<br><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210304220711.png" alt="之后"></p>
<h2 id="分享发现"><a href="#分享发现" class="headerlink" title="分享发现"></a>分享发现</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IIilfJrCCUmOLxd70Vv1Lw">不为人知的韩国新浪潮电影，为什么那么重要？</a></li>
<li><a target="_blank" rel="noopener" href="http://einverne.github.io/post/2015/09/korean-film.html">不得不看的韩国电影</a></li>
<li><a target="_blank" rel="noopener" href="https://m.k.sohu.com/d/515933722">如今的春晚，诸神散去</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zuola.com/weblog/2005/09/298.htm">李敖北大演讲全文</a></li>
<li><a target="_blank" rel="noopener" href="http://mjlsh.usc.cuhk.edu.hk/Book.aspx?cid=4&tid=5812">不写三年大饥荒，就对不起历史和老百姓</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bmpi.dev/self/my-financial-planning/">我的家庭理财规划</a></li>
</ul>
<h3 id="文章-技术类"><a href="#文章-技术类" class="headerlink" title="文章(技术类)"></a>文章(技术类)</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2021/02/devtools">What’s New In DevTools (Chrome 90)</a></p>
<ol>
<li>New CSS flexbox debugging tools</li>
<li>New Core Web Vitals overlay</li>
<li>Issues tab updates</li>
<li>Format strings as (valid) JavaScript string literals in the Console</li>
<li>New Trust Tokens pane in the Application panel</li>
<li>Emulate the CSS color-gamut media feature</li>
<li>Improved Progressive Web Apps tooling</li>
<li>New Remote Address Space column in the Network panel</li>
<li>Performance improvements</li>
<li>Display allowed&#x2F;disallowed features in the Frame details view</li>
<li>New SameParty column in the Cookies pane</li>
<li>Deprecated non-standard fn.displayName support</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://linux.cn/article-13125-1.html?utm_source=rss&utm_medium=rss">用 Podman Compose 管理容器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/12642710.html">写给程序员的机器学习入门 (一) - 从基础说起</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh-style-guide.readthedocs.io/zh_CN/latest/">中文技术文档写作风格指南</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tidb-incubator/zh.md">自动检测工具</a></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeburst.io/5-vue-performance-tips-98e184338439">5 Advanced Tips for Vue Performance</a></p>
<ol>
<li>深度 watch 对象变更以便做一些特定操作时，建议将它转为 <code>JSON</code> 后再监听，可以减少大量内存耗费</li>
<li>不需要改变的数据使用 <code>Object.freeze</code> 冻结对象，让它不再被监听变更</li>
<li>不要用 Vuex 的 getters 来实现类似于 <code>getItemById</code> 的方法，因为它不会被缓存，可以返回一个 <code>Map</code>，通过索引的方式获取某个 Item</li>
<li>如果在 getters 或者 computed 返回一个通过拷贝的方式获取每个 Item 的列表时，修改某个 Item 会导致整个列表产生变更，从而导致整个列表组件重新渲染，应该将只需要变更的部分单独提取一个变量</li>
<li>使用 <code>IntersectionObserver</code> API 优化大量 DOM 的情况，只处理当前可见的 DOM 数据</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://web.eecs.utk.edu/~azh/blog/yestercode.html">Why is it so hard to see code from 5 minutes ago?</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API">Visual Viewport API</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://jakearchibald.com/2021/function-callback-risks/">Don’t use functions as callbacks unless they’re designed for it</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-color/#funcdef-rgb">CSS Color Module Level 4</a></p>
<ul>
<li>rgb 和 hsl 不需要用逗号分开，取而代之的是空格和 &#x2F;：<a target="_blank" rel="noopener" href="https://twitter.com/argyleink/status/1218305696862588928">点这里看看</a></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2021/02/useful-chrome-firefox-devtools-tips-shortcuts/">Useful DevTools Tips And Shortcuts (Chrome, Firefox, Edge)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jesuisundev.com/en/20-essential-web-tools-for-developers/">20 essential web tools for developers</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attributes">&lt;a&gt;: The Anchor element</a></p>
<ul>
<li>ping 属性了解一下</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bram.us/2021/02/23/the-future-of-css-scroll-linked-animations-part-1/">The Future of CSS: Scroll-Linked Animations with @scroll-timeline (Part 1)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.industrialempathy.com/posts/image-optimizations/">Maximally optimizing image loading for the web in 2021</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.blog/2021-02-12-avoiding-npm-substitution-attacks/">Avoiding npm substitution attacks</a></p>
</li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li><a target="_blank" rel="noopener" href="https://impatient-js.apachecn.org/#/">写给不耐烦程序员的 JavaScript（其实就是下一本 2019 年的译版）</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/deep-js/">Deep JavaScript: Theory and techniques</a></li>
<li><a target="_blank" rel="noopener" href="https://exploringjs.com/tackling-ts/">Tackling TypeScript: Upgrading from JavaScript</a></li>
<li><a target="_blank" rel="noopener" href="https://debuggingcss.com/">Debugging CSS</a></li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a target="_blank" rel="noopener" href="https://serverless.css-tricks.com/resources/">Resources - The Power of Serverless</a>：大量 serverless 相关的资源，来涨涨见识也好呀</li>
<li><a target="_blank" rel="noopener" href="https://linuxcommandlibrary.com/basic/oneliners.html?ref=tiny-helpers">Linux Command Library</a>：大量一行的 shell 命令示例</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/">CSS Working Group Editor Drafts</a>：CSS 提案列表</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/barhatsor/coco">coco</a>：使用纯 CSS3 建立 3d 组件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/chriswalz/bit">Bit</a>：现代化 Git CLI，在终端上交互式地使用 Git 命令</li>
<li><a target="_blank" rel="noopener" href="https://atool.vip/appicon/">批量生成多尺寸 APP Icon</a></li>
</ul>
<h3 id="技术（语言、类库等）"><a href="#技术（语言、类库等）" class="headerlink" title="技术（语言、类库等）"></a>技术（语言、类库等）</h3><ul>
<li><a target="_blank" rel="noopener" href="https://troisjs.github.io/">TroisJS</a>：ThreeJS + VueJS 3 + ViteJS</li>
<li><a target="_blank" rel="noopener" href="https://github.com/pmndrs/jotai">Jōtai</a>：一个 React 原始，灵活的状态管理器</li>
<li><a target="_blank" rel="noopener" href="https://motion.vueuse.org/">@vueuse&#x2F;motion</a>：一个 Vue 的可组合 API 动画库</li>
<li><a target="_blank" rel="noopener" href="https://github.com/didi/mpx">Mpx</a>：一款具有优秀开发体验和深度性能优化的增强型小程序开发框架</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/cong-si-bina-xue-xi-li-shi.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/cong-si-bina-xue-xi-li-shi.html" itemprop="url">从思辨中学历史</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-02T11:16:15+00:00">
                2021-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>首先介绍一下吕世浩这个人：他是国立台湾大学历史博士、北京大学考古学及博物馆学博士，曾于台湾大学历史学系任教。我前段时间学习了他的公开课：《中国古代历史与人物 —— 秦始皇》以及《史记二》，感兴趣的同学可以在互联网上免费进行观看。</p>
<p>他讲得非常好，「思辨」二字，就是他开这个课程的主要目的，学历史就是要锻炼你的思辨能力。何谓思辨？思辨是指思考辨别，哲学上指运用逻辑推导进行理论上的思考。既然是思辨，自然少不了问问题，没错，吕世浩老师在上课时会问我们很多问题，要回答这些问题就要思考。</p>
<p>我并不想无意义地重复吕世浩老师在课程中讲过的内容，但是吕世浩老师问了一些非常好的问题，也提出一些我个人非常赞同的观点，所以我会把他的观点贴在我的文章里，除此之外还有一些我个人的想法。但正如吕世浩老师所说，他的观点不一定是对的，我的更是如此，所以大家做个参考就好了。</p>
<h2 id="一、学生的目的是什么？"><a href="#一、学生的目的是什么？" class="headerlink" title="一、学生的目的是什么？"></a>一、学生的目的是什么？</h2><p>我们从小学到大学，花了十几年时间来上学，有没有问过自己这样一个问题：我们来当学生，我们的目的是什么？</p>
<p>我从小就有思考这个问题，而且在不同的年龄段，我给出的答案是不一样的，比如：</p>
<ul>
<li>在我小学三年级之前，我认为学生之所以要上学，是因为父母要工作没空管孩子，只能把孩子送到学校帮忙看管，这时候学生的目的就是乖乖呆在学校不要给父母添乱。</li>
<li>后来稍微懂事了，认为学生的目的是学识字、会算数，这样在日常生活中才能不被人欺骗。</li>
<li>上了初中，我开始厌倦当学生，觉得学校不自由，进入社会就没人可以管我，那时候我觉得当学生跟坐牢没区别，这时候我的目的就是不要当学生。</li>
<li>后来辍学出了社会，知道没有文化就只能拿最少的钱干最脏最累的活，那时候我觉得学生的目的就是要摆脱这种现状，不要走我们父母的老路。</li>
<li>现在的我比较认同的一种观点：不同层级的学生有着不同的目的，如果是一个技工院校的学生，那他的目的就是学会一门养家糊口的技能，如果是清华北大的学生，那他的目的就不能仅限于养家糊口，更应该要想着怎样为社会做出自己的贡献，能力越大责任也就越大。</li>
</ul>
<p>其实以上观点都没有错，思想是不分对错的，只有好跟坏、粗跟细的区别。</p>
<p>下面我们来看看吕世浩老师怎么说：</p>
<p>如果有同学这么多年从来没有思考过这个问题，那你就太不应该了，我们花了十几年去做一件事，怎么能不想想我们为什么要做这件事呢？</p>
<p>如果你看一本书，看完这本书后，你还是你，书还是书，那就等于没有看过这本书；如果你上一门课，上完这门课后，你却得不到任何好处，那你干嘛还要上这门课呢？这不是浪费自己的生命吗？天下没有比浪费自己生命、浪费别人的生命更大的罪。</p>
<p>所以，吕世浩老师开宗明义就是要告诉你，学生的目的就是：学——生。</p>
<p>那这个学——生又是什么意思呢？首先它肯定不是学——死的意思。</p>
<p>所以，如果一名学生完全不知道自己的目的是什么，那就是浪费自己的生命，那就不是学生，而是学死。</p>
<p>如果一名学生因为一些感情原因跑去跳楼，那他也不是在学——生。</p>
<p>西方学问重方法，中国学问重层次，其实这个学——生也是有层次的：</p>
<ul>
<li>第一个层次：如何活下去</li>
<li>第二个层次：如何活得好</li>
<li>第三个层次：如何活出衷心所愿的人生，在自己活得好的基础上，如何让身边的人活得好，再让更多的人活得好</li>
</ul>
<h2 id="二、我们活在一个什么样的时代？"><a href="#二、我们活在一个什么样的时代？" class="headerlink" title="二、我们活在一个什么样的时代？"></a>二、我们活在一个什么样的时代？</h2><p>我们究竟活在一个什么样的时代之中，吕世浩老师提出我们现在活在中国历史上的第三次巨变之中。</p>
<p>历史的本质就是变，但是变分为「小变」和「巨变」。巨变是指：整个历史的文化、制度、阶段相对来说几乎是推倒重来的。</p>
<p>他提出目前为止，中国历史上有三次巨变（关于这三次巨变都改变了什么东西可以看课程，这里就不复述了）：</p>
<ul>
<li>第一次：从仰韶到龙山</li>
<li>第二次：从战国到秦汉</li>
<li>第三次：从清末到今天</li>
</ul>
<p>我们何其幸运、又何其不幸地活在第三次巨变之中，活在巨变之中有什么特征呢？特征就是我们活在一个格局未定的时代，也就是我们活在价值观混乱与迷茫之中，我们不知道什么是正确的、什么是不正确的。</p>
<p>有同学可能会说：”我的价值观一点也不迷茫呀，我活得相当坚定呀！“。这些同学来试着回答一下吕世浩老师问的这个问题：人应不应该节俭？</p>
<p>节俭是我们中国传统习俗，每个人都应该节俭，但这样真的就是对的吗？试想如果整个社会中所有人都节俭，那么市场需求就会变小，就业需求就会降低，就有可能会导致经济危机，所以国家会想尽办法让我们消费，比如派发消费券、每年弄几个小长假来促进旅游业发展。而资本主义的本质恰恰就是刺激消费，不但让你把这个月的收入花光，还会通过各种办法来让你把下个月、下下个月的收入也提前透支掉，但是恰恰是这种主义的国家都是经济繁荣、国家百业昌盛。</p>
<p>吕世浩老师的观点讲完了，下面我想再举一个例子，来证明不同时代的人的价值观是不一样的，苏轼相信大家都知道，唐宋八大家之一，但是他当年在参加殿试时，提出了一个在我们今天看来相当惊世骇俗的观点，甚至有颠覆国家主权的嫌疑，以下内容摘抄自苏轼的<a target="_blank" rel="noopener" href="https://zh.m.wikisource.org/zh-hans/%E5%BE%A1%E8%A9%A6%E5%88%B6%E7%A7%91%E7%AD%96%EF%BC%88%E5%B9%B6%E5%95%8F%EF%BC%89">《御试制科策》</a>：</p>
<blockquote>
<p>“边境已安，而兵不得撤”者，有安之名，而无安之实也。臣欲小言之，则自以为愧；大言之，则世俗以为笑。臣请略言之。古之制北狄者，未始不通西域。今之所以不能通者，是夏人为人障也。朝廷置灵武于度外，几百年矣。议者以为绝域异方，曾不敢近，而况于取之乎！然臣以为事势有不可不取者。不取灵武，则无以通西域。西域不通，则契丹之强，未有艾也。然灵武之所以不可取者，非以数郡之能抗吾中国，吾中国自困而不能举也。其所以自困而不能举者，以不生不息之财，养不耕不战之兵，块然如巨人之病膇，非不枵然大矣，而手足不能以自举。欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。有战国之全利，而无战国之患，则夏人举矣。其便莫如稍徙缘边之民不能战守者于空闲之地，而以其地益募民为屯田。屯田之兵稍益，则向之戍卒可以稍减，使数岁之后，缘边之民，尽为耕战之夫，然后数出兵以苦之，要以使之厌战而不能支，则折而归吾矣。如此，而北狄始有可制之渐，中国始有息肩之所。不然，将济师之不暇，而又何撤乎？</p>
</blockquote>
<p>先交代一下背景，殿试是皇帝亲自出题，题目范围很广，涵盖了当时所有的施政方针，而苏轼的《御试制科策》正是他参加殿试的答卷，上文就是苏轼针对边境问题的一个回答，具体内容大家自己看，这里我想重点说的是这句话：「欲去是疾也，则莫若捐秦以委之，使秦人断然如战国之世，不待中国之援，而中国亦若未始有秦者。」我理解这句话的大概意思就是：如果要解决这个困境，就是将秦地（今天甘肃一带）这个地方舍弃掉，让它独立出去跟隔壁的匈奴打，我们也不需要帮忙。</p>
<p>苏轼这观点要放在今天，还不被各大网友口诛笔伐，甚至给个颠覆国家主权罪都是有可能的。但前面说了，出题的人是皇帝，改试卷的自然也是他，提出这么大逆不道观点的苏轼，不但没有招来杀身之祸，还入三等（第一、第二等都是形同虚设的，所以第三等相当于第一了）。</p>
<p>活在巨变时代之中的不幸我们前面已经说了，那就是价值观混乱与迷茫。那么幸运的是什么呢？幸运的是由于我们活在一个格局未定的时代，所以一切皆有可能，你有没有发现，纵观整个中国历史，能够影响深远的历史人物基本都是出生在巨变时代之中的，比如活在第二次巨变的人物：孔子、秦始皇、汉武帝、王莽。</p>
<p>而活在第三次巨变之中的我们，说不定就能够找到这个新时代的出路，这也是吕世浩老师开这门课的原因。</p>
<p>你可能会说，我只不过是一个平凡人物，我怎么有可能跟前面所说的人物相比呢，我何德何能能够改变这个时代呢？</p>
<p>如果你学了历史，你就知道历史上非常多比你更加不幸的人，但是他们靠着自己的努力，去改变了这个时代。</p>
<h2 id="三、学历史有什么用？"><a href="#三、学历史有什么用？" class="headerlink" title="三、学历史有什么用？"></a>三、学历史有什么用？</h2><p>我们从初一就开始学历史，那学历史到底有什么用呢？</p>
<p>说实话，我初一时非常不喜欢历史课，这门课我可以从上课睡到下课，书本到学期期末还是新的。</p>
<p>那时候我一直搞不懂知道了公元不知多少年前在哪个地方出现了什么猿人跟我们有什么关系，恐怕只是单纯为了应试罢了。</p>
<p>直到初二讲到近代史，讲鸦片战争、八国联军之类的，才让我稍微有点兴趣，但是只讲一些比较重大的事件，且事件的起因、过程、产出的影响基本都是书上写好的，我们只管背就行了，根本用不着我们来思考。这种教育方式谈不上好坏，但我个人并不喜欢。</p>
<p>但是出来工作以后，因为机缘巧合的原因，我竟然喜欢上了读历史，当然，并不限于教科书上的那种历史。</p>
<p>起因我是读了一本叫做《明朝那些事儿》的小说，相信这本书很多人都听说过，但我第一次读到这本书的时候，我惊讶地发现，原来历史还能这么有趣？原来历史并不是只有枯燥乏味、背诵各种历史事件的时间、人物、地点，原来历史中的每个人都是有血有肉的，他们也会面临人生中很重要的抉择，而他们的抉择其实对我们有很大启发。</p>
<p>至此之后，我一发不可收拾，开始尝试阅读其它历史书，我读的第二本历史书叫做《中国大历史》，作者是黄仁宇，这本书是从宏观角度讲解中国历史各朝代的演变过程，不讲人物史料，侧重于讲各朝代的执政方针，如果你想搞清楚中国历史从宏观角度来看是如何发展的，那么推荐看这本书。</p>
<p>我在去年的<a target="_blank" rel="noopener" href="https://4ark.me/posts/2020-summary.html">《2020 年终总结》</a>也说过，闲人读历史，目的大概有三种，一种是证明了自己博学，一种是追溯上古的八卦，一种是想弄明白为什么是现在这个样子。其实这句话是豆瓣上《中国大历史》的一个书评，我认为概括的非常好。</p>
<p>这之后我还读了一些诸如《中国近代史》以及一些不太知名的人物史料的书，给我的帮助只是多了解了一些近现代的史料，对我个人的帮助并不大。所以既然要读历史，那怎么能不读《史记》呢？</p>
<p>但是由于个人文化根基不深，一上来让我直接看古文，还是有点难的，但是白话文又苦于不知道哪一家译得更好，就在这个时候，吕世浩老师的课程让我明白了应该如何读《史记》，当然也包括其它历史书啦。</p>
<p>然后我来讲讲吕世浩老师对于这个命题的见解，感兴趣的同学可以先看看这个 TED 演讲：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ap0w3PgSK7g">《学历史的大用》</a>，下面的内容基本出自这里。</p>
<p>回答这个问题之前，先说说古今对待此历史的区别。</p>
<p>现代，大部分人对于历史的看法就如我上面所说的一样，就是背诵各种历史事件的时间、人物、地点，除了应试之外别无所用。</p>
<p>而古代，帝王将相与社会精英无一不学历史，史学教育是他们人生培养中的重要组成部分，他们认为历史重要！重要！再重要！</p>
<p>为什么古今会有如此大的差别？</p>
<p>并不是因为历史对现代社会没有用，而是因为古代人学习历史的方法和现代人的方法根本不一样。</p>
<p>古人学历史的方法是“最关键处，合上书。”</p>
<p>当古人读史读到一个人在关键时刻要做抉择时，会把书合上，去想如果自己在那样的环境中会如何抉择。想好之后，他再打开书对照史实，看看自己的决定和当事人的是否一样，然后思考当事人为什么做那样的决定，是否成功。用这样的方法学史，其实是在用古人的智慧来磨练自己。</p>
<p>因此，古代要培养帝王精英，所以用思辨学历史；而现代要培养各行工匠，所以用背诵学历史。目的不同，方法因之而异。</p>
<p>学历史是古代培养政治精英、帝王将相的重要途径，他们重思辨，用心学习历史，通过史书文献中的用词，体会古人的心境，以达到知微见著。</p>
<p>讲完了如何学习历史，下面讲讲学历史的作用：</p>
<ol>
<li>启发智慧：古人的智慧就像是一个磨刀石，而我们的智慧就是一把刀，所以学习历史的作用就是用古人的人生作为磨刀石来磨砺我们的智慧。</li>
<li>审时度势：时是指”你所处的环境“，势是指”环境变动的方向“，如果你只是将古人的做法原封不动地搬到今天，那就是跟刻舟求剑一样，只不过是自欺欺人罢了。还有一个就是：变，历史的本质就是变，能够从历史中看出变，那是非常了不起的，但是更高的智慧是从变之中看出不变的东西，什么东西是历经一百个时代，而它始终是不变的呢？那就是人性和良知。</li>
<li>感动人心：而感动人心就是要唤回人的良知，怎么样才能让人感动呢？那就是真实，不真实的内容是不能感动人心的，比如，我看完《活着》这本书的时候，我非常有感触，为什么呢？因为我知道它是真实发生过的。再比如，《报任少卿书》为何这么打动人心呢？因为司马迁在这封信里将自己心里最深的隐衷道出来了，其能让人不为之动容呢？</li>
</ol>
<p>在这里我想来个鸡汤：当你自怨自哀，觉得你没有好父母，人生没有依靠时，想一想有一个人他三岁死了父亲，十几岁死了母亲，家贫如洗，没有接受任何正规教育，完全靠自学成才，成为中国最大的圣人，影响中国文化两千多年，他就是孔子。</p>
<p>只要你用对方法，历史是无穷智慧的宝库，无穷力量的来源。教育的目的是让人做知识的主人，而不是做知识的奴仆。要做知识的主人，就要启发自己的智慧，愿大家都能从历史中启发智慧，做自己生命的主人，开创理想的人生。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后非常感谢吕世浩老师开这一门公开课，能让我这种连大学都没有上过的人，真真正正感受到应该怎样去学历史，这是何等的幸运。吕世浩老师在课程讲的远远不止上面这些，感兴趣的同学强烈推荐观看学习，相信你的收获不会比我少。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-2-27-subtitle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-2-27-subtitle/" itemprop="url">如何为视频加字幕？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-26T16:00:00+00:00">
                2021-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h1 id="title：如何为视频加字幕？"><a href="#title：如何为视频加字幕？" class="headerlink" title="title：如何为视频加字幕？"></a>title：如何为视频加字幕？</h1><p>Hello 大家好，我是安哥。 </p>
<p>今天这篇文章，想给大家介绍一下，在电脑上为视频加字幕的各种方法，希望对想做视频的朋友有帮助。 </p>
<h2 id="剪映电脑版"><a href="#剪映电脑版" class="headerlink" title="剪映电脑版"></a>剪映电脑版</h2><p>为视频添加字幕，必须推荐在我心目中第一的神器——剪映，剪映在去年推出了 Mac 版，而在今年推出了更多人使用的 Windows 版本，可以在剪映官网下载。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143434141477.jpg" alt="-w3602">之所以排名第一，是因为它的「识别字幕」和「识别歌词」功能真的太好用了。  </p>
<p>导入视频，切换到「文本」选项卡，普通视频的话选择「识别字幕」，如果是 Live 或演唱会上拍摄的视频，就选择「识别歌词」，等待软件完成识别，它就会在视频上方生成字幕。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143425230293.jpg" alt="-w1954">由于是机器自动识别生成的字幕，难免会出现识别错误的情况，在这基础上人工<strong>校对</strong>一下就可以了。</p>
<p>这里要说一下剪映电脑版做得不好的地方——双击生成的字幕，无法在视频预览窗口直接修改文本，反而需要点击右侧的文本编辑窗口才能修改，每次修改都要移动视线，看着真别扭，用久了的话不知道会不会变成斗鸡眼呢。。。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143429938252.jpg" alt="-w1954"><br>剪映电脑版下载地址：<br><em><a target="_blank" rel="noopener" href="https://lv.ulikecam.com/">https://lv.ulikecam.com/</a></em></p>
<h2 id="Handbrake"><a href="#Handbrake" class="headerlink" title="Handbrake"></a>Handbrake</h2><p>Handbrake，是一款开源免费的视频处理工具，支持 macOS、Windows 和 Linux 系统，可用来压缩视频体积、转换视频格式，还能<strong>压制输出带有字幕的视频</strong>。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143438443965.jpg" alt="-w1685">这里说的压制输出带有字幕的视频，指的是在有字幕文件 srt 的情况下，将字幕文件和没有字幕的视频文件封装（合成）到一起。   </p>
<p>这个软件的界面为英文，但理解起来并不困难，请不要被吓到。</p>
<p>点击左上角的「Open Source」，打开需要添加字幕的视频文件。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143437635214.jpg" alt="-w921">接着点击下方的「<strong>Video</strong>」选项卡，这里有两个参数需要注意：</p>
<p>一个是视频编码器 Video Encoder，保持默认的 H.264 就可以了，这是一种非常通用的编码格式，在不同平台上都不会出现兼容性的问题。</p>
<p>另一个是视频的码率 Framerate，这个参数要根据导入的原始视频的帧率进行选择，如果不清楚视频的帧率，可右击视频文件，查看「属性」，一般就可以看到视频文件的帧率。    </p>
<p><img src="http://cdn.penghh.fun/mweb/16143440741073.jpg" alt="-w921">接着切换到「<strong>Subtitles</strong>」选项卡，这里就是用来为视频添加字幕的。</p>
<p>点击「Track」的下拉按钮，选择「<strong>Add External Subtitles Track</strong>」，即添加一条额外的字幕轨道。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143444676430.jpg" alt="-w921">在弹出的窗口中，选择已经准备好的 srt 字幕文件，导入 Handbrake 中。</p>
<p><img src="http://cdn.penghh.fun/mweb/16143445774462.jpg" alt="-w1529">勾选「Burned In」，即将视频文件和字幕文件合并到一个文件中，接着点击右下方的「Browse」，设置文件输出后保存的位置。  </p>
<p>最后点上方的绿色按钮「<strong>Start</strong>」，等待视频完成渲染，就可以得到带有字幕的视频了。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143447904874.jpg" alt="-w921"><br>Handbrake 下载地址：<br><em><a target="_blank" rel="noopener" href="https://handbrake.fr/">https://handbrake.fr/</a></em></p>
<h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>Final Cut Pro X，简称 FCP，是苹果推出的视频剪辑软件，只支持 macOS 系统。  </p>
<p>它支持从零开始，给视频加字幕，但这种方法不符合我们的高效理念。要用 FCP 给视频加字幕，肯定要找一个可以偷懒、省时省力的方法。  </p>
<p>我用 FCP 加字幕的流程是这样的：</p>
<ul>
<li>使用网易见外工作台将音频转换为 srt 字幕文件</li>
<li>借助在线工具「crossub」，将得到的 srt 字幕文件转换为 fcpxml 文件</li>
<li>将 fcpxml 导入 FCP，修改识别错误的字幕，最终导出带有字幕的视频</li>
</ul>
<p>FCP 支持导入 srt 字幕文件，在视频预览窗口字幕也能正常显示，但不知道为什么最终导出的视频字幕总是缺失，有知道原因的朋友麻烦在留言区告诉我。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143495563214.jpg" alt="-w2084">虽然找不到原因，但这里可以借助在线工具 crossub，将 srt 字幕转换为 fcpxml 文件，接着再导入 FCP 中，就能顺利导出了。 </p>
<p>在使用 crossub 时，需要根据视频工程的<strong>帧率</strong>来确定下图的<strong>帧速率</strong>，不然转换得到的 fcpxml 文件与原来的时间轴会发生错位。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143498891861.jpg" alt="-w1660">转换为 fcpxml 后下载文件，需要对文件进行<strong>重命名</strong>，删除后缀多余的文本「.删除此后缀」，删除后才能导入 FCP。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143501796977.jpg" alt="-w1560">回到 FCP 中，选择「文件 &gt;&gt; 导入」，选择 XML，导入刚刚重命名的 fcpxml 文件。</p>
<p><img src="http://cdn.penghh.fun/mweb/16143503728308.jpg" alt="-w757">导入 fcpxml 文件后，它会在 FCP 中创建一个新的事件「crossub」，切换到新事件，再点击右侧的剪辑工程。  </p>
<p>在剪辑工程下方的<strong>时间轴</strong>上，就能看到所有的字幕文本，Cmd + A 全选所有字幕文本，再按下 Cmd + C 复制。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143506613307.jpg" alt="-w1252">点击时间轴中部的向左的箭头，切换到原来的剪辑工程中。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143508723977.jpg" alt="-w1414">将时间线对准到视频开头的位置，再按下 Cmd + V 粘贴，操作无误的话，字幕与视频此时应该是刚好能对上的。  </p>
<p><img src="http://cdn.penghh.fun/mweb/16143510373742.jpg" alt="-w1502">接着在 FCP 中对字幕进行简单的校对，费这么大劲使用 FCP 为视频加字幕，最方便的地方来了：你可以在视频预览窗口双击字幕，直接进入字幕编辑状态，修改识别错误的文字，而不是像剪映「一会看这，一会看那」。   </p>
<p><img src="http://cdn.penghh.fun/mweb/16143511419721.jpg" alt="-w2084">  </p>
<p>在线工具 crossub 网址：<br><em><a target="_blank" rel="noopener" href="https://crossub.xiaowude.com/srt/226">https://crossub.xiaowude.com/srt/226</a></em></p>
<p>这个工具是 B 站一位叫 @偷工拣料 的 Up 主制作的，如果你看不懂我的文字教程，可以去看他录制的视频教程，手把手 👋 教学，包你能看懂：  </p>
<p><img src="http://cdn.penghh.fun/mweb/IMG_8414.jpg" alt="IMG_8414"><br>除了本文介绍的内容，关于视频制作的话题，我还写过另外一篇文章，感兴趣的朋友戳下方链接 👇：</p>
<p>如果本文对你有帮助的话，别忘了关注我的公众号「效率工具指南」，第一时间获取干货更新：  </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-02-24-talk-about-btc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-02-24-talk-about-btc/" itemprop="url">我对比特币的理解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-23T16:08:16+00:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/bitcoin.jpg" class="">

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>比特币今年涨势很好，但最近刚刚有一个大的回落，跌到 5 万美元&#x2F;个以下。对于比特币，市场有两个极端对立的观点：一波观点（代表者是巴菲特）认为是废纸，另一波观点认为比特币是黄金。</p>
<p>我说一些我的理解吧，不一定对，算作抛砖引玉，欢迎大家留言评论交流共同进步。</p>
<h2 id="二、局部的共识-全局的共识"><a href="#二、局部的共识-全局的共识" class="headerlink" title="二、局部的共识 &#x3D; 全局的共识"></a>二、局部的共识 &#x3D; 全局的共识</h2><p>让我讲一个故事来解释这个观点：「局部的共识 &#x3D; 全局的共识」。</p>
<blockquote>
<p>假设在地球上有一种东西，产量有限，但是所有人都不把这个东西当作值钱的宝贝。为了故事好玩，我们拿熊猫的便便当这个东西吧。</p>
<p>突然有一天，有一个神秘的宗教组织对熊猫的便便产生了兴趣，因为他们的「圣经」里面，熊猫的便便是极其尊贵的东西。这个宗教组织发展得还挺大，他们大量向市场买入熊猫的便便，并且在组织内部交易。那些原本要扔掉的熊猫的便便，因为有人花钱买，于是就被饲养熊猫的人收集起来卖钱。</p>
<p>慢慢地，所有人都知道这个东西可以换钱，熊猫的便便值钱成为一种共识。</p>
</blockquote>
<p>你看，这个故事中，只要购买量足够大，交易足够多，同时这个东西产量有限。一个原来在宗教组织内部的「局部的共识」就会变成「全局的共识」。</p>
<p>比特币也是一样的，其实它不需要所有人认同它的价值，它只需要相对多的少数人认同它的价值，然后交易足够频繁到价格趋于相对稳定，买卖的流通速度比较快，那么这个局部的共识就会发展成全局的共识。</p>
<p>你不相信它的价值可以不买它，但是因为有共识，如果有一个人送巴菲特一个比特币，巴菲特会把它卖掉而不是扔掉，因为他意识到它是值钱的。</p>
<p>所以，比特币的局部共识早已经形成了，在这个情况下，它肯定就不是废纸了，在我看来，它就是类似故事中的「熊猫的便便」，是一种有价值的资产。</p>
<h2 id="三、需求决定价格"><a href="#三、需求决定价格" class="headerlink" title="三、需求决定价格"></a>三、需求决定价格</h2><p>比特币确定是有价值的资产了，那么它到底应该值多少钱一个，如何给它定价呢？</p>
<p>我们再讲一个故事，每一个国家都会印钞票，钞票印多了会贬值，印少了会影响经济发展，那么到底印多少合适呢？有一个说法是货币提供量的增长应该与 GDP（国民生产总值）的增长率相同，这样货币不会贬值或升值。</p>
<p>比特币作为一种数字资产，它是有着一定的货币属性的。所以它的价格其实取决于：</p>
<ol>
<li>有多少人拿这个当作交易的货币，每年的交易额是多少。</li>
<li>有多少人拿这个当作投资的资产，每年的买入量是多少。</li>
</ol>
<p>假如比特币每年有固定一群人拿它当作交易的货币，每年的交易额是 100 亿。同时有 一群人愿意拿它当投资的资产，每年愿意买入的金额是 200 亿。那么比特币的市值应该就是这两者正相关的一个函数。</p>
<p>因为比特币的总量固定，不会增发，所以当交易额和买入量上涨的时候，比特币的市值就会上涨。</p>
<p>所以，比特币值多少钱，核心是判断有上一节我们提到的这个「局部的共识」人群规模，因为核心的交易还是在「局部的共识」人群内部产生。如果这个规模一直在上涨，或者这个规模不变，但是人均愿意买入得更多，比特币的价格都会上涨。</p>
<h2 id="四、比特币的需求在哪里"><a href="#四、比特币的需求在哪里" class="headerlink" title="四、比特币的需求在哪里"></a>四、比特币的需求在哪里</h2><p>比特币的非主流需求来自于黑市的匿名交易，这块是它不太光彩的一面。这方面它是类似于货币的。</p>
<p>比特币还有一个主流的需求，就是应对全球的通货膨胀。这一点就类似于黄金的效果。</p>
<p>大家知道因为疫情，各国都印了不少钱，国内因为防疫做得好印得少，使得人民币对美元都涨到 6.5 了。于是，在现在这个时间点，如果你持有现金，那么如果国家印钱，你的现金是贬值的，为了应对这个，你应该把钱换成保值的资产。这种资产应该随着国家印钱而增值，这样就抵抗通账了。</p>
<p>于是人们发现，买固定资产、买龙头股票都是好的抵抗通账的方式，这也是为什么去年美股以及 A 股的白马股涨得很好的原因。除了买股票，买比特币也是一种抗通账方式，这和买黄金的效果类似。</p>
<p>比特币相对于黄金来说，因为产量是固定的，所以稀缺性会更强。另外它的波动比较大，交易所又提供了很多杆杠交易，吸引了喜欢逐利的散户们。杠杆交易更像是一种赌博，人性都是好赌的，比特币交易所迎合了这类人的需求，同时又不受正常的股票交易所的监管限制。</p>
<p>于是，比特币在坚强的基本抗通账需求的基础上，变成了散户们的一场狂欢。</p>
<h2 id="五、未来比特币的走势"><a href="#五、未来比特币的走势" class="headerlink" title="五、未来比特币的走势"></a>五、未来比特币的走势</h2><p>比特币的价格还是由供需决定，未来比特币作为一种发行总量固定的资产，会越来越被更多人认同。只要认同它的人在增加，长期来看它都是应该上涨的。</p>
<p>但是暴涨暴跌其实对一种资产来说是不好的，我认为主流交易量上一个台阶之后，加上散户们慢慢交一些学费之后，比特币的投机和赌博需求不会长期存在。</p>
<p>赌博本质上是一个零和游戏，没有人能够一直从别人手里赌赢钱，这个时候比特币的价格应该会趋于逐步稳定。长期来看，也没有哪种资产长时间地被当作投机和赌博的标的，巨大波动都是相对短时间的。</p>
<p>对于参与比特币投机的朋友，我帮大家算一个账：</p>
<blockquote>
<p>如果一个人参与比特币的短期杠杆交易（看涨或看跌），连续进行了 4 次交易，其中有 3 次挣了 90%，另外有一次 -90%，请问这个人最终的收益率是多少？</p>
<p>这个数学题其实挺好算的，<code>1.9*1.9*1.9*0.1=0.6859</code>，最终这个人本金会亏将近一半。</p>
</blockquote>
<p>你看，这个天天在朋友圈炫耀炒币挣钱，很少亏的人，只要亏一次，整体收益都可能是负的。想明白这一点，大部分都不应该做高风险的杠杠交易。</p>
<p>如果比特币投机属性慢慢减少，它的价格会变得稳定，然后由于需求慢慢上升和社会的通胀，它的价格会逐步上涨。</p>
<h2 id="六、可能的风险（黑天鹅事件）"><a href="#六、可能的风险（黑天鹅事件）" class="headerlink" title="六、可能的风险（黑天鹅事件）"></a>六、可能的风险（黑天鹅事件）</h2><p>比特币的巨大风险有两个，一个是监管风险，另一个是数字加密的安全风险。</p>
<p>监管风险来自于部分国家可能认为它对法币带来了实质性的冲击，影响了国家对于货币的发行权。这种禁令可能不会在全世界发生，但只要有部分国家禁止它，就会影响它的需求量。</p>
<p>另一个风险就是它只是基于一个密码，所以被盗取后追回的难度极大。交易所由于安全漏洞被偷币的案例比比皆是。2019 年交易所币安就<a target="_blank" rel="noopener" href="https://www.blocktempo.com/hacked-binance-lost-7000-btc-hackers-transfer-process/">被盗</a>了 7000 个比特币。所以你只要不是把钱放在冷钱包里面，就有可能因为交易所的安全原因被盗取掉比特币。</p>
<p>比特币冷钱包相对安全，但是未来量子计算会不会将现有世面上的加密算法攻克还不好说，到时候比特币应该需要全网的一次安全升级，才能保证密钥的足够安全。虽然现在看不到这方面的危险，但是技术的进步总是飞速的，奇点到来的那一天是否遥远并不好说。毕竟<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>诞生才 50 年就把全世界改变了。</p>
<h2 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h2><p>小结一下：</p>
<ul>
<li>比特币是数字资产，不是废纸，因为它已经有了「局部的共识」。</li>
<li>比特币的需求决定价格，长期来看它有类似于黄金一样的抗通胀的效果。</li>
<li>长期来看，比特币不再成为赌博和投机的标的后，价格未来会越来越稳定。</li>
<li>监管和安全是比特币最大的风险。</li>
</ul>
<p>欢迎留言一起探讨。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E9%80%9A%E8%BF%87%20EmbededFileProvider%20%E5%AE%9E%E7%8E%B0%20Blazor%20%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E9%80%9A%E8%BF%87%20EmbededFileProvider%20%E5%AE%9E%E7%8E%B0%20Blazor%20%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE/" itemprop="url">通过 EmbededFileProvider 实现 Blazor 的静态文件访问</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-22T21:37:47+00:00">
                2021-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>重构我的 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/">独立博客</a> ，是博主今年的计划之一，这个基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 的静态博客，最早搭建于2014年，可以说是比女朋友更亲密的存在，陪伴着博主走过了毕业、求职以及此刻的而立之年。其间虽然尝试过像 <a target="_blank" rel="noopener" href="https://jekyllrb.com/">Jekyll</a> 和 <a target="_blank" rel="noopener" href="https://www.gohugo.org/">Hugo</a> 这样的静态博客生成器，可是考虑到模板、插件等周边生态，这个想法一直被搁置下来。直到最近，突然涌现出通过 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 重写博客的想法，尤其是它对于 <a target="_blank" rel="noopener" href="https://webassembly.org/">WebAssembly</a> 的支持，而类似 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue</a> 和 <a target="_blank" rel="noopener" href="https://reactjs.org/">React</a>的组件化开发模式，在开发体验上有着同样不错的表现。所以，今天这篇博客就来聊聊在重写博客过程中的一点收获，即如何让 Blazor 访问本地的静态文件。</p>
<h1 id="从内嵌资源说起"><a href="#从内嵌资源说起" class="headerlink" title="从内嵌资源说起"></a>从内嵌资源说起</h1><p>首先，我们要引入一个概念，即：内嵌资源。我们平时接触的更多的是本地文件系统，或者是 FTP 、对象存储这类运行在远程服务器上的文件系统，这些都是非内嵌资源，所以，内嵌资源主要是指那些没有目录层级的文件资源，因为它会在编译的时候“<strong>嵌入</strong>”到动态链接库(DLL)中。一个典型的例子是<code>Swagger</code>，它在<code>.NET Core</code>平台下的实现是<a target="_blank" rel="noopener" href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">Swashbuckle.AspNetCore</a>，它允许使用自定义的HTML页面。这里可以注意到，它使用到了<code>GetManifestResourceStream()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// requires file to be added as an embedded resource</span></span><br><span class="line">    c.IndexStream = () =&gt; GetType().Assembly</span><br><span class="line">        .GetManifestResourceStream(<span class="string">&quot;CustomUIIndex.Swagger.index.html&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实，这里使用的就是一个内嵌资源。关于内嵌资源，我们有两种方式来定义它：</p>
<ul>
<li>在 Visual Studio 中选中指定文件，在其属性窗口中选择生成操作为嵌入的资源：</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/Zftpl5UFnmcLK49.png" alt="如何定义一个文件资源为内嵌资源"></p>
<ul>
<li>在项目文件(<strong>.csproj</strong>)中修改对应<code>ItemGroup</code>节点，参考示例如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk.Web&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmbeddedResource</span> <span class="attr">Include</span>=<span class="string">&quot;_config.yml&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CopyToOutputDirectory</span>&gt;</span>Always<span class="tag">&lt;/<span class="name">CopyToOutputDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EmbeddedResource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了内嵌资源的定义。而定义内嵌资源，本质上还是为了在运行时期间去读取和使用，那么，自然而然地，我们不禁要问，该怎么读取这些内嵌资源呢？在<code>Assembly</code>类中，微软为我们提供了下列接口来处理内嵌资源：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> ManifestResourceInfo <span class="title">GetManifestResourceInfo</span>(<span class="params"><span class="built_in">string</span> resourceName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span>[] <span class="title">GetManifestResourceNames</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params">Type type, <span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Stream <span class="title">GetManifestResourceStream</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>GetManifestResourceNames()</code>方法用来返回所有内嵌资源的名称，<code>GetManifestResourceInfo()</code>方法用来返回指定内嵌资源的描述信息，<code>GetManifestResourceStream()</code>方法用来返回指定内嵌资源的文件流。为了方便大家理解，这里我们准备了一个简单的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> resources = assembly.GetManifestResourceNames();</span><br><span class="line">resources.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line"><span class="comment">//ConsoleApp.A.B.示例文档.txt</span></span><br><span class="line"><span class="comment">//ConsoleApp.A._config.yml</span></span><br><span class="line"><span class="keyword">var</span> fileInfo = assembly.GetManifestResourceInfo(resources[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = assembly.GetManifestResourceStream(resources[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>此时，我们会发现，内嵌资源都是使用类似<code>A.B.C.D</code>这样的形式来表示资源路径的，因为内嵌资源本身是没有目录层级的。现在，如果我们再回过头去看<code>Swagger</code>的示例，就不难理解为什么会有<code>CustomUIIndex.Swagger.index.html</code>这样一个奇怪的值，因为它对应着实际的物理文件路径，如下图所示，示例代码中输出的资源路径和实际的物理路径存在着对应关系：</p>
<p><img src="https://i.loli.net/2021/02/23/jgqxFTPt2OnHMyh.png" alt="项目中的物理路径与内嵌资源路径对照"></p>
<h1 id="EmbededFileProvider"><a href="#EmbededFileProvider" class="headerlink" title="EmbededFileProvider"></a>EmbededFileProvider</h1><p>OK，那么在了解了内嵌资源以后，接下来，我们需要关注的是<code>EmbededFileProvider</code>。需要说明的是，在<code>ASP.NET Core</code>中，微软是通过<code>IFileProvider</code>这个接口来解决文件读取问题的，典型的使用场景有静态文件中间件、Rozar模板引擎以及WWWRoot目录定位等等，通常情况下，我们使用<code>PhysicalFileProvider</code>更多一点，它和<code>EmbededFileProvider</code>一样，都实现了<code>IFileProvider</code>接口，所以，<code>ASP.NET Core</code>可以从不同的来源访问文件信息。</p>
<p>显然，<code>EmbededFileProvider</code>正是为了内嵌资源而生，它在内部使用到了<code>Assembly</code>类中和内嵌资源相关的接口.所以，除了上面的方式，我们还可以通过下面的方式来访问内嵌资源，需要注意的是，使用<code>EmbededFileProvider</code>需要引用<code>Microsoft.Extensions.FileProviders.Embedded</code>，大家可以比较一下这两种方式地差异：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.GetExecutingAssembly();</span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> EmbeddedFileProvider(assembly);</span><br><span class="line"><span class="comment">//注意，这里写&quot;.&quot;或者&quot;&quot;都可以</span></span><br><span class="line"><span class="keyword">var</span> resouces = provider.GetDirectoryContents(<span class="string">&quot;.&quot;</span>).ToList();</span><br><span class="line"><span class="keyword">var</span> fileInfo = provider.GetFileInfo(resouces[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> fileStream = fileInfo.CreateReadStream();</span><br></pre></td></tr></table></figure>

<p>除此以外，<code>IFileProvider</code>还有一个最重要的功能，即<code>Watch()</code>方法，它可以监听文件的变化，并返回一个<code>IChangeToken</code>。有没有一种似曾相识燕归来的感觉？没错，博主曾经在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/835719605/">基于选项模式实现.NET Core的配置热更新</a> 这篇文章中介绍过它，它是实现配置热更新的关键。事实上，<code>FileConfigurationSource</code>这个类中有一个<code>Provider</code>属性，而它对应的类型恰好是<code>IFileProvider</code>，这难道是巧合吗？不，仔细顺着这条线，我们大概就能明白微软的良苦用心，我们的配置文件自然是来自文件系统，而考虑到内嵌资源的存在，我们面对的文件系统其实是一个广义的文件系统，它可以是物理文件、内嵌文件、Glob、对象存储(<strong>OSS</strong>)等等</p>
<h1 id="Blazor的奇妙缘分"><a href="#Blazor的奇妙缘分" class="headerlink" title="Blazor的奇妙缘分"></a>Blazor的奇妙缘分</h1><p>好了，千呼万唤始出来，现在终于要讨论 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 这个话题啦！众所周知，静态博客生成器里主要存在着两种配置，即站点配置和主题配置，<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 里甚至还支持从特定文件夹里加载自定义的数据。所以，对于静态博客而言，它需要有从外部加载数据这个特性。我们知道，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1">Blazor</a> 分为服务器和客户端两个版本，两者的区别主要在于 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-5.0">Rozar</a> 模板由谁来渲染，前者相当于服务端渲染(<strong>SSR</strong>) + <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/javascript-client?view=aspnetcore-5.0">SignalR</a>，而后者则是基于 <a target="_blank" rel="noopener" href="https://webassembly.org/">WebAssembly</a>，它可以直接在浏览器中加载。显然，后者更接近我们静态博客生成器的想法。由于 Hexo 使用 Yaml 作为配置语言，所以，为了读取原来 Hexo 博客的配置，参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nianming/p/7097338.html">实现自己的.NET Core配置Provider之Yaml</a> 这篇博客实现了一个YamlConfigurationProvider。</p>
<p>在使用的过程中，遇到的问题是，它无法识别配置文件的路径。原因很简单，经过编译的 Blazor 会被打包为 WebAssembly ，而 WebAssembly 在前端加载以后，原来的目录层级早已荡然无存。此时，基于物理文件的 <code>PhysicalFileProvider</code> 将无法工作。解决方案其实大家都能想到，换一种<code>IFileProvider</code>的实现就好了啊！至此，奇妙的缘分产生了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">YamlConfigurationProvider</span> : <span class="title">FileConfigurationProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> FileConfigurationSource _source;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YamlConfigurationProvider</span>(<span class="params">FileConfigurationSource source</span>) : <span class="title">base</span>(<span class="params">source</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> path = _source.Path;</span><br><span class="line">        <span class="keyword">var</span> provider = _source.FileProvider;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = provider.GetFileInfo(path).CreateReadStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//核心问题就是这个Stream的来源发生了变化</span></span><br><span class="line">            <span class="keyword">var</span> parser = <span class="keyword">new</span> YamlConfigurationFileParser();</span><br><span class="line">            Data = parser.Parse(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-3.1">官方文档</a>中提到过，Blazor 的配置文件默认从 WWWRoot 下的<code>appsettings.json</code>加载，所以，对于像JSON这类静态文件，可以注入HttpClient，以API的方式进行访问。例如，官方文档中推荐的加载配置文件的方式为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient()</span><br><span class="line">&#123;</span><br><span class="line">    BaseAddress = <span class="keyword">new</span> Uri(builder.HostEnvironment.BaseAddress)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped(sp =&gt; httpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前方有语法糖，高甜:)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> http.GetAsync(<span class="string">&quot;cars.json&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"></span><br><span class="line">builder.Configuration.AddJsonStream(stream);</span><br></pre></td></tr></table></figure>

<p>而经过我们这样改造以后，我们还可以这样加载配置：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.Configuration.AddYamlFile(</span><br><span class="line">    provider:<span class="keyword">new</span> EmbeddedFileProvider(Assembly.GetExecutingAssembly()),</span><br><span class="line">    path: <span class="string">&quot;_config.yml&quot;</span>,</span><br><span class="line">    optional:<span class="literal">false</span>,</span><br><span class="line">    reloadOnChange:<span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>一旦这些配置注入到 IoC 容器里，我们就可以纵享无所不在的依赖注入，这里以某个组件为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.Extensions.Configuration</span><br><span class="line">@inject IConfiguration Configuration</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-container-fluid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-row DreamCat-content-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mdui-container fade-scale in&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>@Configuration[&quot;title&quot;]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;subtitle&quot;</span>&gt;</span>@Configuration[&quot;subtitle&quot;]<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样地，对于组件内的数据，在大多数场景下，我们可以这样来处理，还是因为有无所不在的依赖注入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@page &quot;/&quot;</span><br><span class="line">@layout MainLayout</span><br><span class="line"></span><br><span class="line">@inject HttpClient httpClient</span><br><span class="line">@using BlazorBlog.Core.Domain.Blog;</span><br><span class="line">@using BlazorBlog.Web.Shared.Partials;</span><br><span class="line">@if (posts != null &amp;&amp; posts.Any())</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var post in posts)</span><br><span class="line">    &#123;</span><br><span class="line">        //这是一个自定义组件</span><br><span class="line">        <span class="tag">&lt;<span class="name">PostItem</span> <span class="attr">Model</span>=<span class="string">post</span>&gt;</span><span class="tag">&lt;/<span class="name">PostItem</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@code</span><br><span class="line">&#123;</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Post</span>&gt;</span> posts &#123; get; set; &#125;</span><br><span class="line">    protected override async Task OnInitializedAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        posts = await httpClient.GetFromJsonAsync&lt;List<span class="tag">&lt;<span class="name">Post</span>&gt;</span>&gt;(&quot;content.json&quot;);</span><br><span class="line">        await base.OnInitializedAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以给大家展示下尚在开发中的静态博客：</p>
<p><img src="https://i.loli.net/2021/02/23/wMED8k6SbqITpma.png" alt="基于 Balzor 的静态博客"></p>
<p>理论上任何文件都可以这样做，主要是考虑到配置这种信息，用依赖注入会更好一点，这样每一个组件都可以使用这些配置，而如果是以 API 的形式集成，以目前 Blazor 打包以后加载的效果来看，页面会有比较大的“<strong>空白期</strong>”。我更加疑惑的是，如果 Blazor 打包后的体积过大，那么浏览器自带的存储空间是否够用呢？一句话总结的话， Blazor 是一个写起来非常舒服的框架，可未来是否会像当年的 Sliverlight 一样，这还要看大家对 WebAssembly 的接受程度，可谓是“<strong>路漫漫其修远兮</strong>”啊……</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，是博主由一个个“<strong>闪念</strong>”而串联起来的脑洞，作为一个实验性质的尝试，希望通过 Blazor 的客户端模式(<strong>WebAssembly</strong>) 实现一个静态博客，而在这个过程中，需要解决 Balzor 读取本地文件的问题，由此，我们引入了这篇博客的主题之一，即：<code>EmbededFileProvider</code>。顺着这条线索，我们梳理了内嵌的文件资源、<code>IFileProvider</code>接口、<code>FileConfigurationProvider</code>、<code>FileConfigurationSource</code>等等一系列看起来毫无关联的概念。事实上，“<strong>冥冥之中自有天意</strong>”，这一切怎么会毫无关联呢？我们最终从文件系统看到了配置系统，聊到了 Blazor 中的配置问题，这里我们熟悉的依赖注入、配置系统都得以延续下来。其实，单单就解决这个问题而言，完全不值得专门写一篇博客，<strong>可从一个点辐射到整个面的这种感悟，在人生的成长中更显得弥足珍贵，希望我们每一个人都能多多跳脱出自己的视角，去努力的看一看这个丰富多彩的世界，在多样性与多元化中去寻找整体上的统一，这是作为技术人员的我，一生都想去探索的哲学</strong>。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论中留下你的想法或者建议，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-02-21-huawei-vs-apple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-02-21-huawei-vs-apple/" itemprop="url">华为手机 vs 苹果手机，我的一年评测对比报告</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-21T12:40:38+00:00">
                2021-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/Huawei-vs-Apple.png" class="">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为工作的原因，我早年一直从事 iOS 开发，所以一直用着苹果手机。iPhone 的体验一直挺好的。</p>
<p>但是我一直比较好奇顶级的 Android 手机怎么样，体验和苹果会差多少，于是我去年就换了华为的 P30 Pro。</p>
<p>对比使用了一年，给大家分享一下我的感受。预告一下，前面夸华为比较多，后面夸苹果比较多。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>对比之下，我发现华为的硬件某些地方比 iPhone 还要厉害一些。比如：</p>
<h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>华为的这款摄像头可能是因为和莱卡合作，所以调校得还算不错。和苹果的摄像头比较起来，自然光照下可以说各有特点。苹果的拍照更加真实自然，而华为会用 AI 给你默认 PS 图，这样蓝天更蓝，美食饱和度更高。</p>
<p>在夜景情况下，华为拍照应该算是完胜，可以在人眼基本都看不清的情况下，通过延长曝光时间和自动的 HDR 拍出比较清晰的图片。</p>
<p>自拍模式下，华为会自动开启美颜：光滑皮肤，瘦脸，美白。把我整得像个小白脸一样。但不得不说，这确实符合大部分中国人的自拍习惯。</p>
<img src="/images/huawei-1.png" class="">

<p>华为还搞了一个 50 倍变焦，可以拍月亮。这确实是一个比较好的营销的点，但是说实话除了给朋友装 B 之外没有什么卵用，因为 50 倍之后影像已经极度模糊了。</p>
<p>拍月亮这个场景华为做了专门的优化，因为月亮面向地球的一面是固定不变的。为此我还专门查了一下这个叫做「<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20030267">地球引力潮汐锁定</a>」。反正因为我们看到的月亮环形山的位置和形状都是固定不变的，所以华为的 AI 算法帮我们把环形山给 PS 上去了。不得不说，这是一个好点子，但这和摄像头的能力没什么关系。</p>
<p>iPhone 12 Pro 的摄像头也有胜出的地方，iPhone 12 Pro 引入了更强的防抖功能，这样录制移动的 vlog 的时候效果会更出色，这一点华为是很差的。</p>
<h3 id="电池"><a href="#电池" class="headerlink" title="电池"></a>电池</h3><p>电池和充电速度华为 P30 Pro 都比 iPhone 要体验好。一般 iPhone 的电池新手机能用一天，老手机能用大半天。而华为新手机能用一天半，老手机也能用一天。</p>
<p>华为在省电这件事情上做了一件很暴力，但是很有效的办法。华为把所有的应用，都默认禁止了后台操作，仅保留了中国人最常使用的微信等应用允许常驻后台。</p>
<p>安卓市场的应用本来很流氓，结果华为这招更流氓，直接相当于开启了白名单模式。我刚换华为的时候，发现百度云盘不能自动备份照片了，一看才发现百度也被强制默认禁止了后台唤醒操作。这些操作都是默认的，所以普通用户都不会看到应用对权限申请的提示。</p>
<p>相对来说，苹果的应用市场要正常一些，只要你的应用逻辑上需要常驻后台，审核的时候就不会卡你。</p>
<p>但不管怎么样，华为做到了更长的待机时间。</p>
<h3 id="充电速度"><a href="#充电速度" class="headerlink" title="充电速度"></a>充电速度</h3><p>充电速度最新款的 iPhone 支持最高 22w 的充电，华为 P30 Pro 支持 40w 的快充。充电速度华为更厉害。</p>
<p>另外，iPhone 不送充电器，这一点有点让人不爽。华为是送 40w 的快充充电头和充电线。</p>
<img src="/images/apple-no-charge.png" class="">

<p>​华为对充电做了一个优化我觉得也很好，就是对有夜间插上充电线的用户，智能学习充电行为，避免长时间晚上电池过充，因为锂电池的过充和过放都不太好。</p>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><p>华为采用了类似 Face ID + 屏下指纹的双认证方式，苹果是采用 Face ID。</p>
<p>我个人还是更习惯屏下指纹，我一直觉得指纹比 Face ID 体验更优，特别是夜间在被窝里面玩手机的时候。</p>
<p>当然，现在疫情戴口罩了，Face ID 显得更加不人性化。</p>
<p>苹果应该引入类似的屏下指纹技术。</p>
<h3 id="NFC-和红外遥控器"><a href="#NFC-和红外遥控器" class="headerlink" title="NFC 和红外遥控器"></a>NFC 和红外遥控器</h3><p>安卓手机都可以开放对 NFC 硬件的控制，所以我使用华为的钱包功能，把各种工卡和门禁都复制到了手机中，这还是挺爽的，可以少带很多卡。</p>
<img src="/images/huawei-2.jpg" class="">

<p>苹果为了安全的原因，虽然有这个能力，但是只开放了公交卡和 Apple Pay，从实用角度，还是差了一些。</p>
<p>红外遥控器的能力类似，华为可以通过这个遥控几乎所有的电器，虽然用得不多，但是找不到遥控器的时候应急还是挺方便的。</p>
<h3 id="激光雷达扫描仪"><a href="#激光雷达扫描仪" class="headerlink" title="激光雷达扫描仪"></a>激光雷达扫描仪</h3><p>只有 iPhone 才有的硬件能力，可以扫描整个场景进行 3D 建模。配合可以做一些设计或者 AR 的游戏。</p>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><p>硬件的生态上，苹果就比华为厉害多了。比如苹果的跨设备剪切板，对于同时使用苹果手机和电脑的用户来说就非常爽。</p>
<p>苹果的手机与 AirPods 的连接，也是非常舒服的。</p>
<p>华为手机如果要做到同样的事情，得买华为的耳机，我为此就专门另外买了一个华为的 FreeBuds。但是华为的这款耳机明显比 AirPods Pro 差太多，比如降噪功能就是个摆设，完全不可用。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h3 id="垃圾短信拦截"><a href="#垃圾短信拦截" class="headerlink" title="垃圾短信拦截"></a>垃圾短信拦截</h3><p>软件方面华为有一些功能刚好解决了中国人的烦恼，比如：截长图和垃圾短信拦截。特别是垃圾短信的拦截功能，比苹果好用太多太多。我看了一下统计，它平均每天帮我拦截 5 条垃圾短信和 2 个骚扰电话（直接挂断）​：</p>
<img src="/images/huawei-3.png" class="">

<p>苹果的 iMessage 垃圾短信在中国就没有断过，老是会收到陌名其妙的非法赌博短信。</p>
<h3 id="应用市场"><a href="#应用市场" class="headerlink" title="应用市场"></a>应用市场</h3><p>华为预装了特别多的软件，这种特别有一种被绑架的感受。</p>
<p>华为的应用市场也有一个特别坑的地方，就是如果你在华为应用市场下载的游戏，是不能和微信的好友相互之间游戏的，现在很多游戏其实都有一些社交属性，如果看不到微信好友，那么就变成一个孤岛了。所以建议大家，下载游戏不要去华为应用市场下，一定要去应用宝或者游戏官网下载。</p>
<h3 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h3><p>华为如果要下载国外的应用，会麻烦很多。不像苹果，只需要切换成国外的帐号即可。特别是现在美国对华为的制裁，会使得很多国外应用比较难下载到华为手机中。</p>
<p>前阵子 clubhouse 火的时候，我为了下载它就费了挺多精力的。但是如果是苹果手机，就会很方便。</p>
<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>苹果手机有很多收费的高质量的上网 App，这方面安卓生态也要差很多。</p>
<h3 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h3><p>华为的日历不行，基本无法使用。全世界做好了日历这个应用的也就只有谷歌和苹果。</p>
<p>弄得我只好在华为手机上装了一个谷歌的日历，但是因为科学上网不方便，日历同步还是有影响。</p>
<p>这个对于我的日程管理多少有一些负面影响。好在公司统一用企业微信的日程，倒没有影响工作。</p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>华为 P30 Pro 256G 我买成 6000 左右，苹果 <a target="_blank" rel="noopener" href="https://www.apple.com.cn/iphone-12-pro/specs/#footnote-12">iPhone 12 Pro Max</a> 256G 得 1 万左右，价格还是差了不少。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>华为手机占优的地方：</p>
<ul>
<li>莱卡摄像头的夜景，自动美颜，50倍变焦</li>
<li>电池待机时间更长</li>
<li>屏下指纹</li>
<li>可以复制各种门禁到手机中</li>
<li>截长图，垃圾短信拦截</li>
<li>价格相对便宜</li>
</ul>
<p>苹果手机占优的地方：</p>
<ul>
<li>摄像头的防抖功能</li>
<li>激光雷达扫描仪</li>
<li>软件更安全</li>
<li>硬件生态更好，配套的耳机更好用</li>
<li>下载国外的应用更方便</li>
<li>科学上网 App 更成熟</li>
</ul>
<p>华为手机特别不好的地方：</p>
<ul>
<li>应用市场的游戏与微信好友信息不能互通</li>
<li>日程管理</li>
</ul>
<p>苹果手机特别不好的地方：</p>
<ul>
<li>iMessage 垃圾短信</li>
<li>Face ID，戴口罩没法解锁啊！</li>
</ul>
<p>说了这么多，最后要换新手机，到底换华为还是苹果呢？</p>
<p>我觉得吧，用习惯苹果的可以继续用苹果，毕竟很多花钱购买的 App 都买过了，而且苹果的生态确实更好，配合苹果电脑切换起来也更方便。虽然苹果手机稍微贵一点，但是给别人的品牌感受也更好一点，这就是全世界最值钱的公司生产的大众量产的最贵手机了。</p>
<p>习惯华为手机的人，可以继续使用华为。毕竟华为针对中国人做了很多定制的优化，美颜、门禁复制、截长图、垃圾拦截这些功能虽小，但是用起来还是挺爽的。大部分时候你也不需要下载国外的应用，也不需要复杂的日程管理。虽然你的手机没有人家的 iPhone 贵，但是你可以说你爱国，支持国货啊！</p>
<p>那我呢？我两个都买，没办法，谁让我做互联网工作呢，工作需要！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><a class="extend next" rel="next" href="/page/18/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
