<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/11/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界. Linux Python Rust React Nextjs are my love.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/11/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/weekly-idea.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/weekly-idea.html" itemprop="url">我为什么要写周刊</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-13T16:00:00+00:00">
                2022-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="为什么想写周刊"><a href="#为什么想写周刊" class="headerlink" title="为什么想写周刊"></a>为什么想写周刊</h2><p>自从养成了阅读 RSS 的习惯以后，作为我获取信息的主要渠道，我每天都会花费 1 - 2 个小时去阅读大量的 RSS 订阅源，这其中的大部分基本都是只瞄一眼标题，或者快速阅读一下内容，而对于一些吸引我注意的标题，才会通过浏览器打开原文仔细阅读，当然这么多文章是无法一次性读完的，这时候会通过 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">OneTab</a> 扩展先保存起来，也就是充当稍后阅读的工具（题外话：我在 OneTab 上常年保存着 200+ 以上的标签页），如果读到觉得不错的文章，就会通过 <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm">Save to Notion</a> 这个扩展保存到我的 Notion 页面中，使用这个扩展可以很方便地对文章进行分类、原文剪藏，方便后续快速索引。</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121723977.png?imageMogr2/format/webp"></p>
<p>但是后面我发现，大部分文章读完就忘了，能记下来的往往只有少部分，这是因为我没有针对文章的内容做总结，也就是用自己的话去输出这些文章的核心内容、以及一些更深入的思考，以此加深自己的理解。</p>
<p>于是，我又开了一个 Notion 页面，利用 Relation 字段去关联文章，大概长这样：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121826436.png?imageMogr2/format/webp"></p>
<p>但就这样「单机」玩，很难坚持下去，所以就索性把这个 Weekly 挂在 Blog 上，虽然也是基本没人看：）</p>
<p>但这意义就不一样了呀！无论是对保持更新频率、提高博客逼格都能提到一些帮助（不是吗？）。</p>
<p>所以，你会发现在 Blog 的顶部菜单栏里面多一个 Weekly 的栏目，当然也提供了 RSS 订阅。</p>
<h2 id="只是记录阅读吗"><a href="#只是记录阅读吗" class="headerlink" title="只是记录阅读吗"></a>只是记录阅读吗</h2><p>以上的确是我想办这个周刊的初衷，但我并不会局限于此，如果只是分享我阅读过的文章就未免显得过于学术性（流水账），我还是希望我这个周刊既有专业性的内容、也有我个人的一些思考在里面，毕竟有一些琐碎的事情不想专门开一篇文章来长篇大论，就特别适合写在我的周刊里面。还是那句话，我这个周刊的主要读者是我自己，所以这里也充当我一个定时输出我不成熟观点的地方。</p>
<p>其实已经有不少人在做这件事，就国内而言，最著名的莫过于阮一峰老师的 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/weekly/">《科技爱好者周刊》</a>，截止本文编写之时，已经更新到 194 期了，几乎坚持每周一更（没有经过仔细核实）。虽然他是一个相对有争议的人，但我还是非常敬佩他，相信很多人和我一样，是通过他的文章来入门前端技术的，所以尊称他一声老师并不为过。</p>
<p>我不是他最早的一批读者，这当然是因为我比较年轻：），但是我曾经把他博客上所有的文章从头开始读了一遍，从 03 年最早一篇文章开始（可能还是更早），这么多年写作风格自然也有很大的转变，从以前一名愤青，写作文章主要都是关注一些社会、文学、经济等问题，到后来开始转行计算机，主要写一些技术入门、科技新闻的文章。但无论如何，就从他坚持做这件事二十年来看，这种态度非常值得我们学习。</p>
<p>也有人和我一样，刚刚开始做这件事，这不，前几天就看到了这个：<a target="_blank" rel="noopener" href="https://www.codedump.info/post/20220116-weekly-1/">周刊第 1 期：开刊，数字化生活数据</a>。</p>
<p>总之，我希望和他们一样，通过这种方式来分享自己看到的东西、观点，多给自己一个与外界沟通的渠道。</p>
<h2 id="开刊日"><a href="#开刊日" class="headerlink" title="开刊日"></a>开刊日</h2><p>由于之前的比较零散，就从 2022 年 2 月 14 号这一天作为这个周刊的开始吧。</p>
<p>因为这一天意义非凡，首先当然是情人节，另外也是计算机的生日，不过更重要的是这一天也是我生日：）</p>
<p>可惜我们老家那边普遍过农历生日，所以要每隔 19 年才会碰上同一天生日，这周刊开在三年前就更有意义了。</p>
<p>不过每次想起我诞生于本世纪第一个情人节，还跟计算机同一天生日，想必我是一个无论在计算机还是感情方面都应该会有很高造诣的人，然而事实证明是我在这两方面都非常菜。</p>
<p>感谢阅读。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-13-picsee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-13-picsee/" itemprop="url">图片管理+截图+图片编辑+图片格式转换，这个神器让我直呼内行｜Picsee</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-12T16:30:00+00:00">
                2022-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JeS3ergTmhGknZACv0b61w">效率工具指南</a>」<br>文&#x2F;彭宏豪</p>
<p>Hello 各位好，这里是效率工具指南。<br>我是小豪。  </p>
<p>很久之前介绍过一款电脑上的图片管理工具 Eagle（说起来我也很久没用过这个工具了），功能很强大，可以将本地图片、网络图片（截图）、字体、视频、音频集中到一处，通过文件夹、标签、创建筛选条件等进行分类管理。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446619958775.jpg"></p>
<p>唯一不足的地方在于，这款软件是付费应用——买断制 199 元，如果你日常对图片管理的需求不高，可能不一定下得了手👋。   </p>
<p>但是别急，有需求的产品就会有替代品。  </p>
<p>国内的开发者 @chitaner 开发了一款可称作 Eagle 替代品的软件——<strong>Picsee</strong>。</p>
<p>它并没有完全复刻 Eagle，而是在 Eagle 管理图片的基础上，增加了差异化的设计，例如：  </p>
<ul>
<li>增加了截图功能，可作为系统级别的截图工具，免去安装其他的截图工具   </li>
<li>简单的图片编辑 &amp; 标注功能  </li>
<li>增加了智能筛选的功能，可以自动找出电脑上重复的照片，节省宝贵的磁盘空间  </li>
<li>将图片上传到图床，方便在博客或其他平台引入图片</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446642617690.jpg"></p>
<p>Picsee 官网：<br><a target="_blank" rel="noopener" href="https://picsee.chitaner.com/">https://picsee.chitaner.com/</a></p>
<h2 id="管理的图片来源"><a href="#管理的图片来源" class="headerlink" title="管理的图片来源"></a>管理的图片来源</h2><p>Picsee 管理的图片主要有 3 种来源：  </p>
<ul>
<li>电脑本地的图片，在 Mac 上图片来自于照片 App</li>
<li>浏览器插件捕获的「整页截图」</li>
<li>Picsee 截图功能截取的图片</li>
</ul>
<p>和 Eagle 一样，Picsee 提供了可保存浏览器图片的剪藏插件，插件有两个选项：批量收藏和整页截图。  </p>
<p>整页截图类似于截图软件的「滚动截图」，可以将整个页面以长图的形式保存到 Picsee 中。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446660402452.jpg"></p>
<p>目前这个插件未上架到应用商店，可以从软件官网提供的链接下载。  </p>
<p>Picsee Extension 插件下载地址：<br><a target="_blank" rel="noopener" href="https://picsee.chitaner.com/webExtension/">https://picsee.chitaner.com/webExtension/</a></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446690459364.jpg"></p>
<p>对比 Eagle 剪藏插件，Picsee 插件少了「选择区域截图」和「可视区域截图」的选项。  </p>
<p>表面上看 Picsee 无法自由截取保存局部区域，但实际上它把这个功能<strong>单独做成了截图功能</strong>，可在多个场景下使用，并不局限于浏览器中。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446712647750.jpg"></p>
<p>点击状态栏的 Picsee 图标，或者使用快捷键 Shift + Command + X，可以触发 Picsee 的截图功能。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446717747414.jpg"></p>
<p>下图是 Picsee 截图界面，选取截取的区域后，右下角提供了简单的标注工具、滚动截图、贴图和复制到剪贴板等选项。  </p>
<p>这与 Mac 上的第三方截图软件，例如 iShot 或者 Xnip 大同小异，如果你还没安装这些截图工具，可以<strong>考虑使用 Picsee 作为截图工具</strong>，管理图片和截图两不误。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446719885771.jpg"></p>
<p>截取的图片复制到剪贴板，切换到 Picsee 客户端，使用 Cmd + V 粘贴图片，可以将剪贴板的图片保存到 Picsee 中，这样就能实现类似 Eagle 插件「选择区域截图」的效果啦。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446749265477.jpg"></p>
<h2 id="预览图片-视频"><a href="#预览图片-视频" class="headerlink" title="预览图片&#x2F;视频"></a>预览图片&#x2F;视频</h2><p>保存在 Picsee 中的视频，左上角会显示视频格式，例如下图中的多个 mp4 的小字。  </p>
<p><strong>将鼠标移动到视频上方，会自动播放视频</strong>，且会播放声音，如果是在办公室使用，且电脑带有扬声器，预览视频之前，请记得先关闭声音。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446598488239.jpg"></p>
<p>视频可以用鼠标快速预览，此外还有一种预览图片&#x2F;视频的方法：选中图片&#x2F;视频，按下<strong>空格键</strong>。  </p>
<p>下图是一张图片的预览页面，电脑上安装过第三方「图片浏览器」的朋友，会不会觉得似曾相识呢？  </p>
<p>点击预览界面底部的编辑按钮，可以对图片进行简单的编辑。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446762567731.jpg"></p>
<p>在 Picsee 中可以对图片进行简单的编辑，也是它区别于 Eagle 的一个优点，想得真周到，在此为开发者点个赞👍。  </p>
<h2 id="图片导出"><a href="#图片导出" class="headerlink" title="图片导出"></a>图片导出</h2><p>在图片预览状态下，点击下方的「导出」按钮，可以打开导出面板。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446607599471.jpg"></p>
<p>不同于一些软件的导出功能就是单纯的导出，Picsee 的导出面板提供了一些额外的选项：  </p>
<ul>
<li>导出时转换为其他图片格式，包含 bmp、jpeg、png 和 tiff </li>
<li>若导出格式为 JPG，可以调整图片质量（即压缩强度） </li>
<li>清除图片的 EXIF 信息，这可以去除图片包含的位置信息，保护个人隐私</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446605621218.jpg"></p>
<h2 id="智能筛选"><a href="#智能筛选" class="headerlink" title="智能筛选"></a>智能筛选</h2><p>除了图片编辑和格式转换，Picsee 中还有一个实用的功能：<strong>找出电脑上重复的照片</strong>，为磁盘腾出空间。  </p>
<p>点击左侧栏「智能任务」右侧的 + ，选择「创建智能任务」。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446770770282.jpg"></p>
<p>这里的「智能任务」，就是借助软件内置的程序，帮我们自动找出相似的照片。  </p>
<p>下图的「范围」是选定要查找可能存在重复照片的位置，勾选的位置越多，程序查找起来，花费的时间也会增加。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446809012846.jpg"></p>
<p>创建好智能任务后，等待程序运行完毕，就能看到相册中存在的重复照片。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446812247859.jpg"></p>
<p>由于苹果自带照片 App 的限制，无法直接在 Picsee 中删除重复的照片。  </p>
<p>这里提供一个删除重复照片的小技巧：选中两种重复的照片，右击鼠标，选择「<strong>在 Finder 中显示</strong>」，在 Finder 中就可以删除重复的照片啦。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446813310018.jpg"></p>
<h2 id="导入素材包"><a href="#导入素材包" class="headerlink" title="导入素材包"></a>导入素材包</h2><p>最后，还要给各位安利一下 Picsee 的作者 @chitaner 为用户整理的<strong>必应壁纸</strong>素材包，共计 7000 多张高清壁纸。   </p>
<blockquote>
<p>软件作者的话：偶尔上Bing搜索，经常被它的背景页，惊讶到，太美了！从网上搜索发现，有搜集这些图片，拿来做桌面壁纸的，也专门有人利用Bing作源做壁纸应用，壁纸网站的，微软也围绕这一点自己单独出了个壁纸应用。这次，从网络上搜集了Bing2009年到目前为止的，7000多张的壁纸，共6G左右大小，做成了Picsee素材包，方便分享下载研究学习使用，公开使用注意版权。  </p>
</blockquote>
<p>想要的朋友，可以从 Picsee 官网下载：<br><a target="_blank" rel="noopener" href="https://sourl.cn/5iZvEg">https://sourl.cn/5iZvEg</a>  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446818322269.jpg"></p>
<p>将素材包下载到本地后，点击顶部工具栏的按钮，选择「导入素材包」，导入后就可以看到所有的必应壁纸啦。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/13/16446822477006.jpg"></p>
<p>写完真累，还没有夜宵，有帮助的话，请多多点赞或分享～   </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-2-11-bilibili/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-2-11-bilibili/" itemprop="url">如何将b站上的视频下载到本地？5个下载B站视频的好用工具！</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-11T02:57:00+00:00">
                2022-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于微信公众号「效率工具指南」<br>文&#x2F;彭宏豪     </p>
<h2 id="贝贝BiliBili"><a href="#贝贝BiliBili" class="headerlink" title="贝贝BiliBili"></a>贝贝BiliBili</h2><p>这是一个在线下载 B 站视频的工具，只要有网就可以使用，不限制特定的平台。 </p>
<p>在网站顶部粘贴要下载的视频链接，输入验证码，点击右侧的「解析视频」。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445897825726.jpg"></p>
<p>解析得到视频后，将鼠标移动到视频上方右击，选择「视频存储为」，确定保存视频的位置，等待视频完成下载。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445898557084.jpg"></p>
<p>贝贝BiliBili 网址：<br><a target="_blank" rel="noopener" href="https://xbeibeix.com/api/bilibili/">https://xbeibeix.com/api/bilibili/</a></p>
<h2 id="MikuTools"><a href="#MikuTools" class="headerlink" title="MikuTools"></a>MikuTools</h2><p>除了贝贝BiliBili，还有另外一个好用的多功能在线网站——<strong>MikuTools</strong>，这个网站聚合了多种常用的小工具，包含我们这里要用到的 B 站视频下载工具。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445905220528.jpg"></p>
<p>MikuTools 网址：<br><a target="_blank" rel="noopener" href="https://tools.miku.ac/bilibili_video_downloader/">https://tools.miku.ac/bilibili_video_downloader/</a>  </p>
<p>这个工具有一个不太好的地方在于，<strong>下载的视频格式为 flv</strong>，在导入一些剪辑软件之前，可能要先转换为 mp4 格式。  </p>
<p>如果你需要转换视频格式，可以使用之前介绍过的另外一款工具 QuickCut：  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649919194&idx=1&sn=d51a53be3d5bdcb2f1c520800d55810e&chksm=83a88af7b4df03e137de5e218348c7f0cf34408d502605574b7ef859b28e4530b4c0dc8d37c4&token=855337760&lang=zh_CN#rd">多功能视频工具箱，免费良心还好用｜Quick Cut</a>       </p>
<h2 id="浏览器插件「B站下载助手」"><a href="#浏览器插件「B站下载助手」" class="headerlink" title="浏览器插件「B站下载助手」"></a>浏览器插件「B站下载助手」</h2><p>插件名称：B站下载助手</p>
<p>这是我一直以来使用的方法，到目前为止还未失效。</p>
<p>安装插件之后，在视频页面右下角会多出一个和小破站主色调相同的按钮。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445814939730.jpg"></p>
<p>点击按钮，会打开一个面板，下载的视频清晰度取决于播放时选择的清晰度。</p>
<p>其他的两个选项「下载模式」和「合并下载」保持默认即可，点击底部的「<strong>合并下载</strong>」，就可以下载视频啦。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445850605450.jpg"></p>
<p>目前这款浏览器插件已从应用商店下架，无法直接安装，有需要的朋友，可以扫描下方的二维码，在公众号「效率工具指南」后台回复「B站」，获取插件安装包。        </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>
<h2 id="Downie"><a href="#Downie" class="headerlink" title="Downie"></a>Downie</h2><p>Downie，可能是 Mac 上最强大的视频下载工具，可以下载多个视频网站的内容。  </p>
<p>它使用起来也非常简单：复制想要下载的视频链接，切换到 Downie，按下 Command + V 粘贴链接，就可以下载视频啦。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/02/11/16445865620008.jpg"></p>
<p>Downie 用起来非常方便，省时又省力，是一个非常值得购入的工具，软件为买断制，79 元，一次付费可长期使用。  </p>
<p>Downie 官网：<br><a target="_blank" rel="noopener" href="https://software.charliemonroe.net/downie/">https://software.charliemonroe.net/downie/</a></p>
<h2 id="其他的工具"><a href="#其他的工具" class="headerlink" title="其他的工具"></a>其他的工具</h2><p>除了本文介绍的工具，我之前在另外一篇文章中，还介绍其他的下载 B 站视频的方法，感兴趣的可以戳下方👇的链接：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649908756&idx=1&sn=3b0d554a0cb7e228adb3b21fdc2eab1d&chksm=83a86239b4dfeb2f2a9aa85501bd61ed373070a802baee26f51d92faa2e963b21a9189b114a5&token=855337760&lang=zh_CN#rd">以为是使用浏览器的高手，看了这些才知道我是个弟弟</a>    </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E7%83%9F%E6%B3%A2%E6%A2%A6%E5%BD%B1%EF%BC%8C%E4%BB%8E%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D%E5%88%B0%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E7%83%9F%E6%B3%A2%E6%A2%A6%E5%BD%B1%EF%BC%8C%E4%BB%8E%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D%E5%88%B0%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/" itemprop="url">烟波梦影，从天国王朝到刺客信条</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-03T10:30:45+00:00">
                2022-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" itemprop="url" rel="index">
                    <span itemprop="name">生活感悟</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>最近看了一部叫做<a target="_blank" rel="noopener" href="https://movie.douban.com/subject/1309071/">《天国王朝》</a>的电影，主要讲述了第三次十字军东征时期的一段故事：法兰克铁匠巴利安，因为受到失散多年的父亲的召唤，亦是为了替自杀而死的妻子寻求救赎，来到了三教圣城——耶路撒冷。其间，父亲亡故，巴利安承袭了爵位和封地，甚至得到了西贝拉公主的青睐，可这依然无法阻止他深陷十字军的政治漩涡。当时，身染麻风病的耶路撒冷王鲍德温四世与阿拉伯传奇英雄萨拉丁，维持着基督教与伊斯兰教之间脆弱的和平；而以居伊和雷纳德为首的好战势力，则通过袭击穆斯林的方式不断挑起争端。战争终于不可避免地爆发了，这正是历史上著名的哈丁之战。此后，狮心王理查一世独自面对东方世界的滚滚黄沙，东西方的军事、宗教和文化碰撞出火花，更是堪比双子星一般的存在。</p>
<p><img src="/P9832764530.jpg" alt="天国王朝中的巴利安男爵形象"></p>
<h1 id="圣城耶路撒冷"><a href="#圣城耶路撒冷" class="headerlink" title="圣城耶路撒冷"></a>圣城耶路撒冷</h1><p>熟悉刺客信条系列的朋友，此刻应该会想到，这个系列的第一部作品，正是取材于第三次十字军东征时期，主角阿泰尔则是活跃在该时期的一名叙利亚刺客。因为电影中出现了刺客的敌对势力——<a target="_blank" rel="noopener" href="https://baike.sogou.com/v74701.htm">圣殿骑士(团)</a>。所以，我觉得透过历史去打通电影和游戏会是一件非常有趣的事情。也许，中世纪时期发生的事情，到今天已然无法做到存伪去真，可正如我曾经迷恋过亚瑟王从石头中拔出(伊甸)圣剑的故事一样，圆桌骑士或者说骑士本身，在一个(中二)男人眼中是接近武侠小说里侠客的存在。所以，在一个武侠没落的时代，你就不难理解，我为什么会喜欢上刺客信条这样一款游戏。虽然，这些骑士相当迷信，动辄要通过决斗让上帝来裁决，可就像塞万提斯笔下的<a target="_blank" rel="noopener" href="https://book.douban.com/subject/24854061/">堂·吉诃德</a>一样，当他准备大战风车的那一刻，你又会觉得他是一个英雄。</p>
<p><img src="/Alta%C3%AFr.png" alt="刺客信条中阿泰尔施展信仰之跃"></p>
<p>故事要从哪里说起呢？我想，应该从鲍德温四世那场著名的战役——蒙吉萨之战说起。那一年，年仅16岁的鲍德温四世，率领3000人击败了20000人的萨拉丁军队。这段历史带给我的震撼，丝毫不亚于中国历史上的官渡之战和淝水之战。如果你对此毫无概念，不妨对比一下孙权的合肥之战，当时的孙权号称有100000人的兵力，而张辽只有800人，史称“孙十万与张八百”。这一场战役令鲍德温四世获得了极好的威望，而雷纳德则因为参与了这场战役而成为主战派的首领。可惜，这场堪称为传奇的胜利仅仅为耶路撒冷换来了两年的和平。1779年鲍德温四世兵败泉水谷，病情的恶化令他的身体每况愈下，到1785年他因麻风病去世的时候，他只有24岁，电影里始终以面具示人的就是鲍德温四世。后期的耶路撒冷王国，基本是由他的姐夫居伊以及雷蒙德三世把持，朝局的不稳定无疑加速了耶路撒冷王国的覆灭。</p>
<p><img src="/P2355584352.jpg" alt="天国王朝中的鲍德温四世形象"></p>
<p>相传，鲍德温四世出生时，是由其伯父鲍德温三世主持洗礼的。当时，国王鲍德温三世决定把自己的名字作为礼物赠送给这个新生儿，一旁的大臣开玩笑地说道，“作为一国之王，如果只是赠送一个名字，是否显得太过吝啬了呢？”。国王听完以后，大笑一声，指着圣(真)十字架说道，“那我就再送一份礼物给他——耶路撒冷之王”。后来，鲍德温三世突然得了重症，而他又没有子女。于是，他的侄子，即鲍德温四世继承了他的王位，成为了新一任的国王。对于历史而言，我们永远无法假设，我们无法想象这个16岁就击萨拉丁的少年，如果没有染上麻风病，又会在历史上留下怎么样的故事？本片的男主角巴利安，其原型在历史上被称为“伊贝林的巴利安男爵”，曾经参与过蒙吉萨之战，支持雷蒙德三世摄政，基本可以认为是主和派。电影中主张袭击穆斯林的，主要是居伊、雷纳德以及圣殿骑士团。</p>
<h1 id="十字军与圣殿骑士"><a href="#十字军与圣殿骑士" class="headerlink" title="十字军与圣殿骑士"></a>十字军与圣殿骑士</h1><p>好了，现在总算和刺客信条产生某种联系了。在刺客信条第一部中，圣殿骑士主要是以十字军的形象出现。事实上，十字军东征是由天主教教会发起的解放圣地耶路撒冷的一项运动，因为按照基督教、伊斯兰教、犹太教各自的说法，耶路撒冷都是它们心目中的圣地。可是，从十一世纪末开始，耶路撒冷及其周边的拜占庭地区，一直都被穆斯林占领。因此，罗马教廷以解放圣地的名义发动了多次东征，这些东征的军队服饰均以红十字作为标志，故而称为“十字军”。十字军占领耶路撒冷以后，很多欧洲人前往圣地朝圣，为了保护这些朝圣者的安全、攻击异教徒，1名法国贵族和8名骑士建立了军事性质的修会，因为其地点位于所罗门神殿的遗址上，故又称为圣殿骑士团。类似的组织，还有医院骑士团、条顿骑士团。其实，在初代刺客信条中，阿泰尔的刺杀对象里就有医院骑士团的成员。</p>
<p><img src="/P2355584519.jpg" alt="天国王朝中的十字军形象"></p>
<p>从今天的角度来看，所谓的“讨伐异教徒”的圣战，其本身并不见得有多么神圣，神殿骑士团侵略和掠夺的成分更多一点，反倒是育碧用自由和秩序的命题，让圣殿骑士多了一点人性的光辉，从三代开始，圣殿骑士和刺客都不再是那种非黑即白的设定，甚至到法国大革命前夕，双方都意识到合作的可能性，可惜，这一切终究毁在各自阵营里的狂热分子手上，就像耶路撒冷王国是毁在一个毫无军事素养的居伊一样。法国刺客<a target="_blank" rel="noopener" href="https://assassinscreed.huijiwiki.com/wiki/%E9%98%BF%E5%B0%94%E8%AF%BA%C2%B7%E5%A4%9A%E9%87%8C%E5%AE%89">亚诺·多利安</a>不无遗憾地说到，“<strong>现在我懂了，诸行并非都得到允许，而是教条本身即为一种警告</strong>”。我们继续说回电影，截止到1187年，通过著名的哈丁之战，萨拉丁终于夺回圣地耶路撒冷，甚至缴获了钉死过耶稣的真十字架，他凭借自己出色的军事才能，一举收复了包括阿卡在内的众多港口城市，彻底切断了十字军在海上的补给线。</p>
<p><img src="/P7297435160.jpg" alt="天国王朝中的萨拉丁形象"></p>
<p>当然，不甘心的十字军，决定以英格兰国王理查一世(狮心王)和 法兰西国王腓力二世为主力，开始积极筹备又一次的十字军东征，大战一触即发。这一年，阿泰尔22岁，此时的他尚未成为刺客大师，但已然成为组织中的骨干力量。直到1191年，26岁的阿泰尔，被导师阿尔莫林派去所罗门圣殿遗址取得金苹果时，年轻而高傲的阿泰尔准备高调刺杀圣殿骑士罗伯特，这一举动把兄弟会成员马利克等彻底暴露在危险之中。而后面的故事我们都知道了，阿泰尔被剥夺了等级和武器，去完成刺杀9个圣殿骑士的任务。历史上的罗伯特，正是在前一年跟随狮心王舰队参与第三次十字军东征，甚至在1192年受封圣殿骑士团大师，可惜当他遇到阿泰尔的时候，这条仕途注定要永远地停留在1193年9月23日那一天。而这，大概就是，袖剑之下，众生平等，万物为虚，万事皆允。</p>
<h1 id="世界的十字路口"><a href="#世界的十字路口" class="headerlink" title="世界的十字路口"></a>世界的十字路口</h1><p>转眼间，时间来到12世纪，狮心王和萨拉丁，西方和东方，基督教和伊斯兰教，都在这一刻走向了对立面。如果说，土耳其的伊斯坦布尔是亚洲和欧洲的十字路口。那么，毫无疑问，这将会两个当世雄主间的终极对决。1191年9月7日，狮心王理查在阿苏夫会战中击败萨拉丁，在十字军进军耶路撒冷的途中，萨拉丁不断派出穆斯林骑兵进行袭扰，直到1192年1月，十字军抵达贝特努巴城堡，此时，距离圣地耶路撒冷只剩下12英里，耶路撒冷唾手可得。历史更像是一种巧合，那一年萨拉丁的埃及援军从南部抵达战场，狮心王理查一世在英国的统治地位随时都有可能被颠覆，战争顿时陷入了焦灼状态。1192年8月，互相怀有敬意的双方，在雅法城签署停战协定，史称“雅法合约”，正是从那一刻起，声势浩大的第三次十字军东征悄然落下帷幕。</p>
<p><img src="/P2307353790.jpg" alt="狮心王理查一世影视形象"></p>
<p>萨拉丁是否归还了真十字架，后世的我们已无从得知。我只知道，从那一刻开始，这对惺惺相惜、势均力敌的对手，再没有等来交手的机会，一年后萨拉丁去世，而理查一世则在回国途中被奥地利公爵扣押。直到1194年，经过英、奥双方多次谈判，理查一世终于获释。可这个拥有狮子般雄心壮志的传奇将领，永远都选择冲锋陷阵、选择身先士卒，获释后不久，他就再次陷入了英法战争的泥潭，于1199年战死沙场。以我狭隘的历史观，后世能匹敌理查一世这次东征运动的将领，也许，只有先后在莫斯科损兵折将的拿破仑和希特勒。在育碧的世界观中，马西亚夫最终没能挡住成吉思汗西征的步伐，原因是成吉思汗手中或许掌握着某种伊甸碎片。1222年，成吉思汗攻下花拉子模汗国首都撒马尔罕，丘处机远赴西域“止杀”，那一年阿泰尔57岁，他已经离开马西亚夫，开始长达20多年的“自我流放”。</p>
<p><img src="/Alta%C3%AFr-1.png" alt="结束隐居生活的阿泰尔"></p>
<p>谁能想到，丘处机路过牛家村的那一年，他的父亲奥马尔正准备潜入萨拉丁的营地，结果在回来的时候不慎触发警报，不得不杀死一名贵族。那一年，萨拉丁大军围攻马西亚夫，在萨拉丁的逼迫之下，奥马尔以生命为代价，从萨拉丁手中换回俘虏艾哈迈德·索菲安以及萨拉丁的撤军。那一年，阿泰尔11岁，几乎在同一天，阿泰尔和阿巴斯同时失去了父亲。阿巴斯不愿意接受父亲叛变的事实，并把一切都归咎于阿泰尔的父亲，两个人内心的芥蒂自此种下。这份怨恨直到阿巴斯死去都没能放下，那一年，阿泰尔80岁，利用从金苹果中学到的知识，阿泰尔研制出了袖枪，而这段故事，我们曾在启示录中，以艾吉欧·奥迪托雷的身份亲眼见证过。对于整个第三次十字军东征而言，阿泰尔的故事更像是惊鸿一瞥，可正是这段难辨真伪的传奇故事，让刺客信条系列成为此后育碧旗下最广为人知的游戏IP，万物为虚，万事皆允，耕耘于黑暗，服侍光明，这就是刺客。</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>育碧说，<strong>History Is Our Playground</strong>，电影里的故事真真假假，游戏里的故事更不必说，甚至是我这些未曾考据过的文过饰非，可这恰恰是历史最为迷人的地方，一个人的形象，其实是由无数个人的记忆拼凑出来的，你可以去肆意地想象你心目中的鲍德温四世、萨拉丁，亦或者是狮心王理查一世、传奇刺客阿泰尔，只要这一切都能自圆其说。所以，育碧选择用阴谋论、用自由与秩序来填补那些虚构的情节，听起来像一款游戏对不对？可玫瑰岛这个社会实验告诉我们，这一切还真的就是一款游戏，毕竟，意大利唯一一场打赢的战争，对手是一座面积只有400平米的小岛，试想，如果西泽尔·波奇亚泉下有知，怕是连胡子都要气得歪掉？当然，请记住一句话，<strong>我说的都是错的！</strong></p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-1-29-flomo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-1-29-flomo/" itemprop="url">flomo 为何与众不同？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-29T02:47:00+00:00">
                2022-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>文&#x2F;彭宏豪   </p>
<p>flomo，是一个类似于私密版微博的轻量笔记工具，可以在多种设备、平台上使用。  </p>
<p>如果你对 flomo 还不了解，可以查看我之前写过的一些文章：  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649910143&idx=1&sn=41dd71db6a5892735694bbb2deef53ff&chksm=83a86f52b4dfe644df026cd7c7fdfcd1e00269e8a4b44af95c8776fd61ad22934d07bae49f63&scene=21#wechat_redirect">轻量好看的笔记工具，虽然小但操作真的骚｜flomo</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649917151&idx=1&sn=4f4625cf29530f35b0cb9a21c5db523c&chksm=83a882f2b4df0be42df6a4e0df12a1e5c277ef6a8a81fa20a75745688c4c4f01e0346e56603b&token=1635685711&lang=zh_CN#rd">flomo 好用玩法</a>    </p>
<p>使用一个产品，除了关注产品本身的功能、界面设计，对比它和其他同类产品的差异，有时候更细心的人，可能还会关注到产品背后的人。  </p>
<p>想起前两天在公众号「乱翻书」看到作者「潘乱」说的一句话：  </p>
<blockquote>
<p>产品是产品经理世界观的映射。  </p>
</blockquote>
<p>我相信，许多选择使用 flomo 的人，不仅因为它是一款新产品、它的轻量简洁，可能还有一部分原因来自于：  </p>
<ul>
<li>产品调性（很虚的东西，但又确实存在），产品给人的「感觉」   </li>
<li>创始人持续输出内容的加持（创始人气质），具体体现在服务号 flomo weekly 周刊文章中表达的各种观点，他们不仅造了工具，还在一些问题上给我们提供一些思路           </li>
<li>借助 API，flomo 原来还可以和这么多软件一起使用，flomo 就像是无处不在  </li>
<li>不少人会主动为 flomo 贡献自己写的代码、插件和用法等   </li>
<li>flomo 和许多其他软件推出了「弱弱联合」的活动，看到两个自己都在用的产品，有一天居然合作了，某种程度上算是一种惊喜</li>
</ul>
<h2 id="产品-思路"><a href="#产品-思路" class="headerlink" title="产品 &amp; 思路"></a>产品 &amp; 思路</h2><p>做产品可能有两种人：  </p>
<ul>
<li>一种是觉得做出来的产品能赚钱，所以我要去做；</li>
<li>一种是我想做的产品刚好是我要用到的，所以我要去做，做一个产品来取悦自己。</li>
</ul>
<p>看 flomo 的少楠老师写的东西，我会好奇：他是怎么写出那些高质量的内容的，他的思考能力是如何炼成的，他是如何处理自己输入的各种信息的。    </p>
<p>在做 flomo 之前，少楠老师在 Notion 上维护了一个付费专栏「产品沉思录」，每周向订阅者发送他筛选的有价值的信息。   </p>
<p>关于如何维护这个付费订阅服务，少楠老师在一期播客节目《“我想用flomo改善一代人的思考方式”》中谈到：  </p>
<blockquote>
<p>写产品沉思录，其实不是写，更多像是在「<strong>拼装</strong>」，把日常积累的想法、观点，一周大概 50-70 条左右的内容，在需要用到的时候调出来，再拿格式、语言组织一遍就完了，写作现在更像是拼积木的过程。</p>
</blockquote>
<p>播客节目文字稿 ➡️ <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tkgaIp7mQfMJMZuI2igVyQ">AhaClub X 少楠：“我想用flomo改善一代人的思考方式”（附文字版）</a>   </p>
<p>而他打造的 flomo，正是他用来存放日常产生的想法、观点的工具（容器）。    </p>
<p>但是，有了工具还不够，工具不是目的，而是达成目的——<strong>更多的记录，以及通过记录引发的思考</strong>——的路径。   </p>
<p>因此，他不仅提供了工具，还不余遗力地向我们提供用好工具的思路：    </p>
<blockquote>
<p>重要的不是记出漂亮的笔记，而是更好地思考。   </p>
<p>使用 flomo 的最好方法不是丢进去一个链接，或者全文收藏。而是把你需要的内容先标记出来，然后汇总；或者在阅读完成之后，用自己的理解再在 flomo 中写一遍。  </p>
<p>如果你在获取知识的途中没有做任何的加工（即用自己的话说出来），那么只是一个知识的搬运工。（最初源自卢曼）  </p>
<p>一个事实：任何漂亮的输出工具，都不能帮你解决输入过少的问题。而多数时候，难以输出的问题往往是后者。</p>
<p>所谓的「知识管理」只是一种手段，而不是目的。如果你本身没有需要解决的问题（或者说专注研究的领域），那么知识管理只是个伪命题。</p>
</blockquote>
<h2 id="弱弱联合"><a href="#弱弱联合" class="headerlink" title="弱弱联合"></a>弱弱联合</h2><p>与 flomo 合作过的软件名单：  </p>
<ul>
<li>轻芒  </li>
<li>白描 </li>
<li>滴答清单 </li>
<li>有知有行  </li>
<li>看理想  </li>
<li>简悦  </li>
<li>幕布  </li>
<li>得到</li>
</ul>
<p>弱弱联合，本质上是一种合作，像是「抱团取暖」，合作的基础可能是彼此气质相投，合作也是产品之间交换用户的过程：  </p>
<blockquote>
<p>用户可能本身就很喜欢自己在用的产品了，突然有一天，看到官方推荐了另外一个产品，基于此前的信任，可能会更倾向于尝试一下这个新产品。   </p>
</blockquote>
<h2 id="flomo-101"><a href="#flomo-101" class="headerlink" title="flomo 101"></a>flomo 101</h2><p>除了这些，flomo 的帮助文档「<strong>flomo 101</strong>」，也是一个比较特殊的存在：   </p>
<p>帮助文档名称包含的数字 101，来自于：</p>
<blockquote>
<p>「101课程」，通常是指 XXXX 的入门级课程。许多教程的第一章或者导论部分都会用「101」做标注，这个词汇渐渐的就被引申了出来，用来表示基础入门级课程，变成了一个代号，也就是<strong>基础课程的同义词</strong>。</p>
</blockquote>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/29/16432694521229.jpg"></p>
<p>为了让你更清晰地了解 flomo 101 的内容，我在幕布中梳理了首页的框架：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/29/16432695938219.jpg"></p>
<p>帮助文档中介绍产品是什么、能解决你的什么问题、产品从哪里来，这些都没毛病，但唯独有一个——<strong>flomo 不擅长什么</strong>，让人眼前一亮。  </p>
<p>不少产品在宣传的时候，都会扬长避短，往自己好的方面说，对做不来的事情避而不谈。</p>
<p>flomo 却明确列出了自己「不擅长」的地方，并附上链接，推荐了相应的工具。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/29/16432709591199.jpg"></p>
<p>列出自己的不擅长这种做法，一方面可能是在提醒自己明确产品的边界，只把当前的「小事」做好就够了，不要想着 All in one，一方面是让用户不要对 flomo 未来的迭代方向抱有过高的预期。   </p>
<h2 id="互动一下"><a href="#互动一下" class="headerlink" title="互动一下"></a>互动一下</h2><p>你有在用 flomo 吗？你使用 flomo 的原因是什么呢？</p>
<p>如果还没使用过，可以扫描下方的二维码注册，注册后可获得 28 天的 Pro 会员： </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/29/qrcodea--a1.jpg" alt="QRcode_A — a1"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-1-24-fcpx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-1-24-fcpx/" itemprop="url">用 FCPX 给视频加字幕 | MacBook</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-24T07:57:00+00:00">
                2022-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/8VCrqI_pDRlRDTFJZwOQtw">效率工具指南</a>」<br>文&#x2F;彭宏豪</p>
<p>Hello 各位好，我是小豪。</p>
<p>今天的文章，想来聊一下，如何给视频添加「观看体验更好」的字幕。  </p>
<p>👉 温馨提示：本文配合之前发过的一期视频食用更佳</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hS4y1M7ye">剪辑软件的隐藏用法，给视频加字幕真的太爽啦！</a>   </p>
<p>剪映电脑版出来之前，给视频添加字幕，不少人可能会使用 <strong>Arctime</strong>，一款免费的跨平台字幕软件，支持 Windows、macOS 和 Linux 系统。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16429905484613.jpg"></p>
<p>剪映出来后，对于简单的视频剪辑、给视频加字幕，用剪映都可以完成。  </p>
<p>以「加字幕」为例：</p>
<ul>
<li>内置的「识别字幕」和「识别歌词」功能，识别准确率很高，且完全免费</li>
<li>识别得到的字幕，还可以套用右侧栏的「预设样式」，让字幕更好看一些，或是让字幕与视频画面对比更明显、观众更容易看清</li>
</ul>
<p>当然，内置的字幕样式用起来是很方便，但不一定能满足所有人的需求。</p>
<p>因为它只是一个模板，只能满足需求的最大公约数——快、容易出效果、最好不要让「我」调整参数。   </p>
<p>譬如下面的「黑底白字」字幕样式，第一次使用可能会觉得没有什么问题，字幕下方的黑色背景，让字幕与画面可以很好地分隔开来。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16429903700576.jpg"></p>
<p>不过后来看了一些 Up 主的视频，会发现这个字幕样式还是会有一些问题：</p>
<p>白色的文字和黑色的背景挨得太近，左右和上下的间距很小，看起来有点拥挤。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16429963050436.jpg"></p>
<p>剪映目前只提供了更改黑色背景<strong>透明度</strong>的功能，暂不支持调节黑色背景的宽度。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16429984254858.jpg"></p>
<p>我觉得更理想的字幕样式，应该如下图所示，字幕文本和后面的黑色背景的四周留有一定的宽度，保持呼吸感。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16429985968994.jpg"></p>
<p>要实现这种字幕效果，目前我知道的两种方式，或者两个工具：</p>
<ul>
<li>Arctime</li>
<li>FCPX</li>
</ul>
<p>Arctime 的实现方法我在这里就不展开了，感兴趣的朋友可以去 B 站搜索 Arctime 相关的教程。 </p>
<p>下面说一下在剪辑软件 FCPX 上的实现方法： </p>
<h3 id="将-srt-字幕转换为-fcpxml"><a href="#将-srt-字幕转换为-fcpxml" class="headerlink" title="将 srt 字幕转换为 fcpxml"></a>将 srt 字幕转换为 fcpxml</h3><p>开始操作之前，请先准备好视频字幕文件 srt，接着打开网站 crossub，点击「去转换 .srt」。</p>
<p>crossub 网址：<br><em><a target="_blank" rel="noopener" href="https://crossub.xiaowude.com/">https://crossub.xiaowude.com/</a></em></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430016643361.jpg"></p>
<p>上传字幕文件后，调整下方的参数： </p>
<ul>
<li>目标输出：选择 FCPX 可用的「fcpxml」</li>
<li>帧速率：根据剪辑工程设置的帧率，选择相应的帧率</li>
<li>字幕风格：选择「自适应背景字幕」</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430017925080.jpg"></p>
<p>这里的「自适应背景字幕」中的<strong>自适应</strong>，说的是字幕文本后面<strong>黑色背景的宽度</strong>，会随文本字数的变化而变化，而不是一直保持不变。 </p>
<p>调节下面的两个参数，可以调整字幕文本与黑色背景四周的间距——</p>
<ul>
<li>X 轴边距比例：数值越大，字幕文本与黑色背景左右两侧的宽度越大</li>
<li>Y 轴边距比例：数值越大，字幕文本与黑色背景上下边缘的高度越大</li>
</ul>
<p>网站也提供了调整参数后的<strong>预览效果</strong>，你可以实时查看设置不同参数的效果。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430022239308.jpg"></p>
<p>经过测试后，我觉得 <strong>X 设置为 0.5，Y 设置为 0.3</strong>，得到的字幕文本与黑色背景四周的边距，是我比较满意的，供你参考。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430029084299.jpg"></p>
<p>调整好参数后，点击页面最下方的「导出文件」，下载转换后的 fcpxml 字幕文件。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430030173186.jpg"></p>
<p>下载得到的 fcpxml 文件，它的文件名多了一段后缀「.删除此后缀」，需要对文件进行<strong>重命名</strong>，删除后缀多余的文本，之后才能导入 FCPX。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16143501796977.jpg" alt="-w1560"></p>
<h3 id="FCPX-添加插件"><a href="#FCPX-添加插件" class="headerlink" title="FCPX 添加插件"></a>FCPX 添加插件</h3><p>在 FCPX 导入 fcpxml 字幕前，我们还需要给 FCPX 安装一个「自适应背景字幕」的插件。  </p>
<p>这个插件最初来自 B 站 Up 主 @少年广志，不过目前他的账号已经注销了，还好有另外一位 Up 主 @偷偷不偷懒 在经过授权后，将这个插件上传到了自己的网站上。  </p>
<p>插件下载地址：<br><em><a target="_blank" rel="noopener" href="https://crossub.xiaowude.com/plugins">https://crossub.xiaowude.com/plugins</a></em></p>
<p>在有些浏览器中，点击插件「下载」按钮可能会遇到无法下载的情况。</p>
<p>如果你无法顺利下载，可以在我的公众号「效率工具指南」后台回复【<strong>自适应</strong>】，获取插件的备用下载链接。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430035793342.jpg"></p>
<p>解压下载的插件，会得到一个文件夹，将这个文件夹移动到 <code>影片/Motion Templates/Titles</code> 路径下。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430039412090.jpg"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430040095351.jpg"></p>
<h3 id="03-将-fcpxml-字幕导入-FCPX"><a href="#03-将-fcpxml-字幕导入-FCPX" class="headerlink" title="03. 将 fcpxml 字幕导入 FCPX"></a>03. 将 fcpxml 字幕导入 FCPX</h3><p>安装好插件后，就可以导入 fcpxml 字幕了。</p>
<p>选择「文件 &gt;&gt; 导入」，选择 <strong>XML</strong>，导入 fcpxml 文件。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430046199831.jpg"></p>
<p>导入 fcpxml 文件后，它会在 FCP 中创建一个<strong>新的事件</strong>「crossub」，切换到新事件，再点击右侧的剪辑工程。  </p>
<p>在剪辑工程下方的<strong>时间轴</strong>上，就能看到所有的字幕文本，Cmd + A 全选所有字幕文本，再按下 Cmd + C 复制。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16143506613307.jpg" alt="-w1252"></p>
<p>点击时间轴中部的<strong>向左的箭头</strong>，切换到原来的剪辑工程中。   </p>
<p>将时间线移动到字幕开始的位置，再按下 Cmd + V 粘贴，操作无误的话，字幕与视频此时应该是刚好能对上的。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16143508723977.jpg" alt="-w1414"></p>
<p>下图就是在 FCPX 中的字幕效果，导入的字幕如果发现有错别字，<strong>双击字幕，就可以直接修改</strong>，不需要重新折腾一遍字幕格式转换。  </p>
<p>FCPX 中的字幕默认使用的是苹果的「苹方」字体，保险起见，建议将字体更改为<strong>免费可商用的字体</strong>，例如阿里巴巴普惠体或思源黑体。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430048942170.jpg"></p>
<p>在 FCPX 中调整字幕的字号大小，可能还会遇到一个问题：调整后的字幕文本偏离了原来的位置，无法居中显示。  </p>
<p>这个问题也很好解决，只需要全选所有字幕，调整右侧的「<strong>基线</strong>」参数，将字幕恢复到看起来<strong>垂直居中</strong>的位置即可。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/24/16430057071332.jpg"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">     </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-1-23-vuetemplate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-1-23-vuetemplate/" itemprop="url">VSCode 添加 Vue 模板</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-23T02:21:00+00:00">
                2022-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 大家好，我是小豪。  </p>
<p>昨晚在看 coderwhy 老师的 Vue 视频，其中有一小节讲到，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15741177Eh?p=12">如何在 WebStorm 里添加 Vue 模板</a>。</p>
<p>但我用的编辑器是 VS Code，且视频中没有讲到「<strong>如何在 VS Code 中添加 Vue 模板</strong>」，后来在网上搜了一下，找到了解决方法，写下这篇短文章作为记录。</p>
<p>本文想实现的需求是，在 HTML 中输入 <code>vue</code>，再按下 Tab 键，就可以快速添加下面👇的 <strong>Vue 模板（代码片段）</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#x27;你好啊&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>按照下面的路径，打开 VS Code 的<strong>用户片段</strong>。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/23/16429006381714.jpg"></p>
<p>在打开的窗口搜索 <code>html</code>，点击下方返回的 <code>html.json</code>。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/23/16429008140008.jpg"></p>
<p>如果你之前没有自定义代码片段，打开的 json 文件里，应该只有一个注释的示例。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/23/16429009345746.jpg"></p>
<p>在注释的代码下方，粘贴代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;Print to console&quot;: &#123;</span><br><span class="line">		&quot;prefix&quot;: &quot;vue&quot;,</span><br><span class="line">		&quot;body&quot;: [</span><br><span class="line">		&quot;&lt;div id=\&quot;app\&quot;&gt;&quot;,</span><br><span class="line">		&quot;\t&#123;&#123;message&#125;&#125;&quot;,</span><br><span class="line">		&quot;&lt;/div&gt; \n&quot;,</span><br><span class="line">		&quot;&lt;script src=\&quot;js/vue.js\&quot;&gt;&lt;/script&gt;&quot;,</span><br><span class="line">		&quot;&lt;script&gt;&quot;,</span><br><span class="line">		&quot;\tconst app = new Vue(&#123;&quot;,</span><br><span class="line">		&quot;\t\tel: &#x27;#app&#x27;,&quot;,</span><br><span class="line">		&quot;\t\tdata: &#123;&quot;,</span><br><span class="line">		&quot;\t\t\tmessage: &#x27;你好啊&#x27;&quot;,</span><br><span class="line">		&quot;\t\t&#125;&quot;,</span><br><span class="line">		&quot;\t&#125;)&quot;,</span><br><span class="line">		&quot;&lt;/script&gt;&quot;,</span><br><span class="line">		],</span><br><span class="line">		&quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>粘贴的代码，就是从文章开头的 Vue 模板（代码片段）演变而来的。  </p>
<p>要点：</p>
<ul>
<li>原先的代码片段，每一行开头和结尾都要加上引号，且末尾要加上英文逗号</li>
<li>两行代码之间有空行的，要在前一行代码末尾加上换行符 <code>\n</code></li>
<li>设置缩进的，需要在每一行代码的开头加上 <code>\t</code></li>
<li>html 标签设置的属性值，引号前面要加上转义符 <code>\</code></li>
<li>“prefix” 的值 “vue”，就是触发插入代码片段的文本，如果你不喜欢这个，可以更改为其他更好记的文本</li>
</ul>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">        </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/Envoy-%E9%9B%86%E6%88%90-Jaeger-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Envoy-%E9%9B%86%E6%88%90-Jaeger-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" itemprop="url">Envoy 集成 Jaeger 实现分布式链路跟踪</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-14T08:46:23+00:00">
                2022-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>当我们的应用架构，从单体系统演变为微服务时，一个永远不可能回避的现实是，业务逻辑会被拆分到不同的服务中。因此，微服务实际就是不同服务间的互相请求和调用。更重要的是，随着容器&#x2F;虚拟化技术的发展，传统的物理服务器开始淡出我们的视野，软件被大量地部署在云服务器或者虚拟资源上。在这种情况下，分布式环境中的运维和诊断变得越来越复杂。如果按照功能来划分，目前主要有 Logging、Metrics 和 Tracing 三个方向，如下图所示，可以注意到，这三个方向上彼此都有交叉、重叠的部分。在我过去的博客里，我分享过关于 <a href="/posts/3687594958">ELK</a> 和 <a href="/posts/1519021197">Prometheus</a> 的内容，可以粗略地认为，这是对 Logging 和 Metrics 这两个方向的涉猎。所以，这篇文章我想和大家分享是 Tracing，即分布式跟踪，本文会结合 Envoy、Jaeger 以及 .NET Core 来实现一个分布式链路跟踪的案例，希望能带给大家一点 Amazing 的东西。</p>
<p><img src="/Obserability_Metrics_Tracing_Logging.jpg" alt="可观测性：Metrics、Tracing &amp; Logging"></p>
<h1 id="分布式跟踪"><a href="#分布式跟踪" class="headerlink" title="分布式跟踪"></a>分布式跟踪</h1><p>如果要追溯分布式跟踪的起源，我想，Google 的这篇名为 <a target="_blank" rel="noopener" href="https://dirtysalt.github.io/html/dapper.html">《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a> 的论文功不可没，因为后来主流的分布式跟踪系统，譬如 <a target="_blank" rel="noopener" href="https://zipkin.io/">Zipkin</a>、<a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">Jeager</a>、<a target="_blank" rel="noopener" href="https://skywalking.apache.org/">Skywalking</a>、<a target="_blank" rel="noopener" href="https://lightstep.com/">LightStep</a>……等等，均以这篇论文作为理论基础，它们在功能上或许存在差异，原理上则是一脉相承，一个典型的分布式跟踪系统，大体上可以分为代码埋点、数据存储和查询展示三个步骤，如下图所示，Tracing 系统可以展示出服务在时序上的调用层级，这对于我们分析微服务系统中的调用关系会非常有用。</p>
<p><img src="/Basic-Principles-Of-Distributed-Tracking-System.png" alt="分布式跟踪系统基本原理"></p>
<p>一个非常容易想到的思路是，我们在前端发出的请求的时候，动态生成一个唯一的 <code>x-request-id</code>，并保证它可以传递到与之交互的所有服务中去，那么，此时系统产生的日志中就会携带这一信息，只要以此作为关键字，就可以检索到当前请求的所有日志。这的确是个不错的方案，但它无法告诉你每个调用完成的先后顺序，以及每个调用花费了多少时间。基于这样的想法，人们在这上面传递了更多的信息(<code>Tag</code>)，使得它可以表达层级关系、调用时长等等的特征。如图所示，这是一个由 <code>Jaeger</code> 产生的跟踪信息，我们从中甚至可以知道请求由哪台服务器处理，以及上&#x2F;下游集群信息等等：</p>
<p><img src="/Jaeger-Works-On-gRPC.png" alt="通过 Jaeger 收集 gRPC 请求信息"></p>
<p>目前，为了统一不同 Tracing 系统在 API、数据格式等方面上的差异，社区主导并产生了 <a target="_blank" rel="noopener" href="https://opentracing.io/">OpenTracing</a> 规范，在这个 <a target="_blank" rel="noopener" href="https://github.com/opentracing/specification/blob/master/specification.md">规范</a> 中，一个 Trace，即调用链，是由多个 <code>Span</code> 组成的有向无环图，而每个 <code>Span</code> 则可以含有多个键值对组成的 Tag。如图所示，下面是 <a target="_blank" rel="noopener" href="https://opentracing.io/">OpenTracing</a> 规范的一个简单示意图，此时，图中一共有 8 个 <code>Span</code>，其中 <code>Span A</code> 是根节点，<code>Span C</code> 是 <code>Span A</code> 的子节点， <code>Span G</code> 和  <code>Span F</code> 之间没有通过任何一个子节点连接，称为 <code>FollowsFrom</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       [Span A]  ←←←(the root span)</span><br><span class="line">           |</span><br><span class="line">    +------+------+</span><br><span class="line">    |             |</span><br><span class="line">[Span B]      [Span C] ←←←(Span C is a `ChildOf` Span A)</span><br><span class="line">    |             |</span><br><span class="line">[Span D]      +---+-------+</span><br><span class="line">              |           |</span><br><span class="line">          [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]</span><br><span class="line">                                      ↑</span><br><span class="line">                                      ↑</span><br><span class="line">                                      ↑</span><br><span class="line">                        (Span G `FollowsFrom` Span F)</span><br></pre></td></tr></table></figure>

<p>事实上，我们上面提到的 <a target="_blank" rel="noopener" href="https://zipkin.io/">Zipkin</a> 和 <a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">Jeager</a> 都兼容这一规范，这使得我们可以更加灵活和自由地更换 Tracing 系统。除了 <a target="_blank" rel="noopener" href="https://opentracing.io/">OpenTracing</a> 规范，目前，<a target="_blank" rel="noopener" href="https://opentelemetry.io/">OpenTelemetry</a> 在考虑统一 Logging、Metrics 和 Tracing，即我们通常所说的 APM，如果大家对这个感兴趣，可以做更进一步的了解。</p>
<h1 id="Envoy-Jaeger"><a href="#Envoy-Jaeger" class="headerlink" title="Envoy &amp; Jaeger"></a>Envoy &amp; Jaeger</h1><p>目前，主流的服务网格平台如 <a target="_blank" rel="noopener" href="https://istio.io/latest">Istio</a>，选择 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a> 作为其数据平面的核心组件。通俗地来讲，Envoy 主要是作为代理层来调节服务网格中所有服务的进&#x2F;出站流量，它可以实现诸如负载均衡、服务发现、流量转移、速率限制、可观测性等等的功能。考虑到不同的服务都可以通过 <code>Gateway</code> 或者 <code>Sidecar</code> 来互相访问，我们更希望通过 Envoy 这个代理层来实现分布式跟踪，而不是在每个应用内都去集成 SDK，这正是服务网格区别于传统微服务的地方，即微服务治理需要的各种能力，逐步下沉到基础设施层。如果你接触过微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/architecture/dapr-for-net-developers/getting-started">Dapr</a>，大概就能体会到我这里描述的这种变化。</p>
<p><img src="/Manaing-Microservice-With-Istio.png" alt="Envoy 在 Istio 中扮演着重要角色"></p>
<p>事实上，Envoy 提供了入口来接入不同的 Tracing 系统，以 <a target="_blank" rel="noopener" href="https://zipkin.io/">Zipkin</a> 或者 <a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">Jeager</a> 为例，除了前面提到的 <code>x-request-id</code>，它可以帮我们生成类似 <code>x-b3-traceid</code>、<code>x-b3-spanid</code> 等等的请求头。参照 <a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing#arch-overview-tracing">官方文档</a>，它大体上提供了下面 3 种策略来支撑系统范围内的跟踪：</p>
<ul>
<li>生成 <code>UUID</code> ：Envoy 会在需要的时候生成 <code>UUID</code>，并操作名为 <code>x-request-id</code> 的 HTTP 头部，应用可以转发这个 HTTP 头部用于统一的记录和跟踪。</li>
<li>集成外部跟踪服务：Envoy 支持可插拔的外部跟踪可视化服务，例如 LightStep、Zipkin 或者 Zipkin 兼容的后端（比如说 Jaeger）等等。</li>
<li>客户端跟踪 ID 连接：<code>x-client-trace-id</code> 这个 HTTP 头部可以用来把不信任的请求 ID 连接到受信的 <code>x-request-id</code> HTTP 头部上。</li>
</ul>
<p>这意味着，我们可以从客户端或者由 Envoy 来产生一个 <code>x-request-id</code>，只要应用转发这个 <code>x-request-id</code> 或者 外部跟踪系统需要的 HTTP 头部，Envoy 就可以帮我们完成把这些跟踪信息告诉这些外部跟踪系统，甚至在 <code>Sidecar</code> 模式下这一切都是自动完成的。我在写这篇博客时发现，官方还是比较推崇 <code>Sidecar</code> 模式，即一个服务就是一个 <code>Pod</code>，每个 <code>Pod</code> 里自带一个 Envoy 作为代理，对于 <code>Sidecar</code> 模式而言，它的分布式跟踪呈现出下面这样的结构，如果你认真阅读过官方的文档和示例，就会发现其 <a target="_blank" rel="noopener" href="https://github.com/envoyproxy/envoy/tree/main/examples">示例</a> 基本都是这种结构：</p>
<p><img src="/Envoy-Tracing-Sidecar.drawio.png" alt="Sidecar 模式下的分布式跟踪示意图"></p>
<p>考虑到，2022 年还有没有用上 <code>K8S</code> 的人，以及 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/">Catcher Wong</a> 大佬反映 <code>Sidecar</code> 模式比较浪费资源，这里我们还是用 <code>Gateway</code> 模式来实现，譬如我们有两个服务，订单服务(<code>OrderSevice</code>) 和 支付服务(<code>PaymentService</code>)，它们都由同一个 Envoy 来代理，当我们在订单服务中调用支付服务时，就会产生一条调用链。对于大多数的微服务而言，从它被拆分地那一刻起，就不可避免地走向了像蜘蛛网一般错综复杂的结局，此时，它的分布式跟踪呈现出下面的结构：</p>
<p><img src="/Envoy-Tracing-Gateway.drawio.png" alt="Gateway 模式下的分布式跟踪示意图"></p>
<p>如果从代码侵入角度来审视这个问题，<code>Sidecar</code> 模式，每个服务都由 Envoy 去生成或者是设置一系列相关的请求头；而如果采取 <code>Gateway</code> 模式，当你在订单服务里调用支付服务时，无论你使用 <code>HttpClient</code> 还是 <code>gRPC</code>，你都需要确保这一系列的请求头能传递下去，这意味着我们要写一点无关紧要的代码，这样看起来前者更好一点，不是吗？可惜，合适和正确，就像鱼和熊掌一样，永远不可兼得。</p>
<p><img src="/Jaeger-Span-Model.png" alt="Span 模型示意图"></p>
<p>关于 Jeager，这是一个由 Uber 开发的、受 Dapper 和 Zipkin 启发的分布式跟踪系统，它主要适用于：分布式跟踪信息传递、分布式事务监控、问题分析、服务依赖性分析、性能优化这些场景，因为它兼容 OpenTracing 标准，所以 <code>Span</code> 这个术语对它来说依然使用，什么是 <code>Span</code> 呢？它是一个跟踪的最小逻辑单位，可以记录操作名，操作开始时间 和 操作耗时，下面是 Jaeger 的架构示意图，大家可以混个眼熟：</p>
<p><img src="/Jaeger-Architecture-v1.png" alt="Jaeger 的架构示意图"></p>
<h1 id="第一个实例"><a href="#第一个实例" class="headerlink" title="第一个实例"></a>第一个实例</h1><p>OK，现在来分享本文的第一个示例，如前文所述，我们要实现的是一个 <code>Gateway</code> 模式下的请求跟踪。为此，我们准备了两个 ASP.NET Core 项目，分别来模拟订单服务(<code>OrderService</code>) 和 支付服务(<code>PaymentService</code>)，当我们通过 Envoy 访问 <code>OrderService</code> 的时候，会在其内部访问 <code>PaymentService</code>，以此来验证 Envoy 能否帮我们找到这条调用链。首先，我们来编写 <code>OrderService</code>，代码非常简单，从 HTTP 请求头中拿到 Jeager 需要的字段，并在调用 <code>OrderService</code> 的时候传递这些字段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Post</span>(<span class="params">[FromBody] OrderInfo orderInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> paymentInfo = <span class="keyword">new</span> PaymentInfo()</span><br><span class="line">  &#123;</span><br><span class="line">    OrderId = orderInfo.OrderId,</span><br><span class="line">    PaymentId = Guid.NewGuid().ToString(<span class="string">&quot;N&quot;</span>),</span><br><span class="line">    Remark = orderInfo.Remark,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置请求头</span></span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-request-id&quot;</span>, Request.Headers[<span class="string">&quot;x-request-id&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-b3-traceid&quot;</span>, Request.Headers[<span class="string">&quot;x-b3-traceid&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-b3-spanid&quot;</span>, Request.Headers[<span class="string">&quot;x-b3-spanid&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-b3-parentspanid&quot;</span>, Request.Headers[<span class="string">&quot;x-b3-parentspanid&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-b3-sampled&quot;</span>, Request.Headers[<span class="string">&quot;x-b3-sampled&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-b3-flags&quot;</span>, Request.Headers[<span class="string">&quot;x-b3-flags&quot;</span>].ToString());</span><br><span class="line">  _httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;x-ot-span-context&quot;</span>, Request.Headers[<span class="string">&quot;x-ot-span-context&quot;</span>].ToString());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用/Payment接口</span></span><br><span class="line">  <span class="keyword">var</span> content = <span class="keyword">new</span> StringContent(JsonConvert.SerializeObject(paymentInfo), Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">&quot;/Payment&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = response.IsSuccessStatusCode ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="keyword">new</span> &#123; Msg = <span class="string">$&quot;订单创建<span class="subst">&#123;result&#125;</span>&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，<code>PaymentService</code> 就会变得非常简单，因为我们不会真的去对接一个支付系统，所以，就简单意思一下好啦！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> [<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Post</span>(<span class="params">[FromBody] PaymentInfo paymentInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> requestId = Request.Headers[<span class="string">&quot;x-request-id&quot;</span>].ToString();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="keyword">new</span> &#123; Msg = <span class="string">$&quot;支付成功, 流水号：<span class="subst">&#123;requestId&#125;</span>&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务编写好以后，按照惯例，我们使用 <code>docker-compose.yaml</code> 文件来进行编排，除了 <code>OrderService</code> 和 <code>PaymentService</code>，我们还需要 <code>Envoy</code> 和 <code>Jeager</code>，即至少需要四个服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">envoy_gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">Envoy/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./Envoy/envoy.yaml:/etc/envoy/envoy.yaml&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./Envoy/logs/:/etc/envoy/logs/&quot;</span></span><br><span class="line">  <span class="attr">order_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">OrderService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">  <span class="attr">payment_service:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">PaymentService/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ASPNETCORE_URLS:</span> <span class="string">&quot;http://+&quot;</span></span><br><span class="line">  <span class="attr">jaeger:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jaegertracing/all-in-one</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COLLECTOR_ZIPKIN_HOST_PORT=9411</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;9411:9411&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;16686:16686&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时，重头戏终于来了，Envoy 是如何连接外部跟踪系统的呢？我们可以设置 <code>HttpConnectionManager</code> 这个过滤器下的 <code>tracing</code> 字段，这里我们选择 <code>ZipkinConfig</code> 这个类型，因为 Jaeger 完全兼容 Zipkin，所以，我们可以直接使用这个 Provider。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filter_chains:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">envoy.filters.network.http_connection_manager</span></span><br><span class="line">    <span class="attr">typed_config:</span></span><br><span class="line">      <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span></span><br><span class="line">      <span class="attr">generate_request_id:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">tracing:</span></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">envoy.tracers.zipkin</span></span><br><span class="line">          <span class="attr">typed_config:</span></span><br><span class="line">            <span class="string">&quot;@type&quot;</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.config.trace.v3.ZipkinConfig</span></span><br><span class="line">            <span class="attr">collector_cluster:</span> <span class="string">jaeger</span></span><br><span class="line">            <span class="attr">collector_endpoint:</span> <span class="string">&quot;/api/v2/spans&quot;</span></span><br><span class="line">            <span class="attr">collector_endpoint_version:</span> <span class="string">HTTP_JSO</span></span><br></pre></td></tr></table></figure>

<p>基本上，只要是官方支持的 Provider，我们都可以照猫画虎接入进来，当然每一种 Provider 的配置项可能会不一样，这里我们唯一要注意的是 <code>collector_cluster</code>, 它表示的是指向 Jeager 服务器的一个 Cluster，这意味着我们要为它单独定义一个 Cluster :</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jaeger</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">STRICT_DNS</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">0.</span><span class="string">25s</span></span><br><span class="line">  <span class="attr">lb_policy:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="attr">load_assignment:</span></span><br><span class="line">    <span class="attr">cluster_name:</span> <span class="string">jaeger</span></span><br><span class="line">    <span class="attr">endpoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lb_endpoints:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">endpoint:</span></span><br><span class="line">          <span class="attr">address:</span></span><br><span class="line">            <span class="attr">socket_address:</span></span><br><span class="line">              <span class="attr">address:</span> <span class="string">jaeger</span></span><br><span class="line">              <span class="attr">port_value:</span> <span class="number">9411</span></span><br></pre></td></tr></table></figure>

<p>还记得 Envoy 支撑系统内的分布式跟踪的三个支撑策略是什么吗？显然，我们可以通过 <code>generate_request_id</code> 字段来控制 Envoy 生成作用于 <code>x-request-id</code> 的 <code>UUID</code>，我们希望用户从 前端 或者 cURL 中发送的请求，都能自动地带上 <code>x-request-id</code> 请求头，所以，我们这里将其设为 <code>true</code>，这意味着，从现在开始，我们的请求有了这样一个 <code>x-request-id</code>， 其实，如果不考虑 Jeager 的话，我们请求已经可以实现跟踪了，只要后续的请求都像我这里一样传递 <code>x-request-id</code> 即可。原因我们已经在前面说过，此时，这些请求没有一个上下文的概念，更不要说要理清楚其中的调用层级，所以，接下来，我们还要做一点微不足道的工作：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">virtual_hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">domains:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">&quot;/Payment&quot;</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">prefix_rewrite:</span> <span class="string">/api/Payment</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">payment_service</span></span><br><span class="line">    <span class="attr">decorator:</span></span><br><span class="line">      <span class="attr">operation:</span> <span class="string">PaymentService</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">&quot;/Order&quot;</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="attr">auto_host_rewrite:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">prefix_rewrite:</span> <span class="string">/api/Order</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">order_service</span></span><br><span class="line">    <span class="attr">decorator:</span></span><br><span class="line">      <span class="attr">operation:</span> <span class="string">OrderService</span></span><br></pre></td></tr></table></figure>

<p>如上所示，如果我们希望 Envoy 能记录我们的请求，那么，我们的请求必须要从它这里经过。这听起来像一句废话，可是在我调用 <code>PaymentService</code>已经确保我的请求是从 <code>/Payment</code> 这个路由上发起。默认情况下，在生成 <code>Span</code> 的时候，Envoy 会使用 <code>--service-cluster</code> 这个参数来作为 <code>Span</code> 的名称，这个参数通常写在 Envoy 的启动命令里，在这个示例中，它的取值是 <code>reverse-proxy</code>。仔细一想，会觉得哪里不太对，这样一来，所以的 <code>Span</code> 不就是同一个名字了吗？事实上，一开始我做实验的时候，确实是这个结果。解决方是设置一个 <code>operation</code>。此时，如果我们通过 <code>Postman</code> 访问订单接口 <code>/Order</code>，不出意外的话，我们会收到订单创建成功的结果，在浏览器里输入<code>http://localhost:16686</code>，我们来看看 Jeager 都收集到了哪些信息：</p>
<p><img src="/Envoy-JeagerUI-01.png" alt="JeagerUI 数据查询"></p>
<p>从图中我们可以非常容易地识别出 Service 和 Operation 在 Envoy 中分别对应着什么，我们注意到这里检索到了三个 Span，因为博主后来又加了一个 <code>EchoService</code>，从这里我们能看到它整个过程从何时开始，经过多长时间以后结束。如果我们点击它，会看到更加详细的说明，如下图所示：</p>
<p><img src="/Envoy-JeagerUI-02.png" alt="JeagerUI 数据展示"></p>
<p>显然，这个调用关系是符合我们预期的，即客户端调用了<code>OrderService</code>，<code>OrderService</code>调用了<code>PaymentService</code>，对于每一次调用，我们均可以从 Span 的 Tag 中获得更多信息，文章中的第三张图，实际上就是出自这里，有了这些信息以后，我们排查或者分析微服务中的问题，是不是感觉容易了很多呢？结合 ELK，你可以知道要去找哪里的日志，而这些正是分布式跟踪的意义所在！</p>
<p><img src="/Jaeger-Works-On-gRPC.png" alt="通过 Jaeger 收集 gRPC 请求信息"></p>
<p>好了，到这里为止，关于 Envoy 在分布式跟踪上的探索，终于可以告一段落，完整的项目文件我已经放在 <a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2022/tree/master/src/EnvoyTrace">Github</a> 上供大家参考，谢谢大家！</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>可观测性(Logging、Metrics &amp; Tracing) 是当下微服务中重要的一个组成部分，从 ELk 收集日志，到 Prometheus 监控指标， 再到 Jeager 跟踪调用链，我们看到了一种完全不同于单体系统中打断点、单步调试的诊断思路，这是否说明，微服务的治理永远是一个绕不过去的话题。在这篇文章里，我们简单介绍了分布式跟踪系统，比如最常见的 <a target="_blank" rel="noopener" href="https://zipkin.io/">Zipkin</a>、<a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">Jeager</a>、<a target="_blank" rel="noopener" href="https://skywalking.apache.org/">Skywalking</a>、<a target="_blank" rel="noopener" href="https://lightstep.com/">LightStep</a>…等等，其基本思想是生成一个 <code>x-request-id</code>，并在不同的服务或者应用中传递这个信息。在此基础上，我们介绍了 <a target="_blank" rel="noopener" href="https://opentracing.io/">OpenTracing</a> 规范，即 一个调用链(Trace)，是由多个 <code>Span</code> 组成的有向无环图，而每个 <code>Span</code> 则可以含有多个键值对组成的 Tag。目前，Envoy 官方主推的是 <code>Sidecar</code> 模式，即每个服务分配一个 Envoy 作为代理，考虑到博主目前使用 <code>Gateway</code> 模式更多一点，故结合 ASP.NET Core 和 Jeager 实现了一个简单的示例，这个示例唯一的不足在于，服务或者应用必须显式地传递这些请求头，如果直接集成 SDK，效果应该会比现在好很多，可这样的话，就显得不那么云原生了，如果大家有更好的做法，欢迎在评论区留言和交流。大家可以稍微注意一下 <a target="_blank" rel="noopener" href="https://opentelemetry.io/">OpenTelemetry</a> 这个项目，如果你需要更完备的可观测性信息收集。好了，以上就是这篇博客的全部内容，晚安，世界。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-1-3-pixelmator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-1-3-pixelmator/" itemprop="url">近期值得关注的修图 App</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-03T03:47:00+00:00">
                2022-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3NLj0A5vsuepaqQKgVp6uA">效率工具指南</a>」<br>文&#x2F;彭宏豪  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/16411739441002.jpg"><br>☝☝ 扫码加入我的社群   </p>
<p>Hello 各位早上好，我是小豪。    </p>
<p>元旦假期出去玩，难免会拍照。  </p>
<p>今天就给大家介绍一个好用的修图应用——<strong>Pixelmator Photo</strong>。  </p>
<p>Pixelmator Photo，是 iPad 上一个功能强大的修图应用，可以调整图片的多个参数，如白平衡、色相饱和度、颜色平衡、色阶和曲线等，涵盖了修图会用到的大部分调整命令。</p>
<p>此外，你还可以通过 App 底部的滤镜预设，一键获得不同效果的图片，若你对添加了滤镜的图片效果不满意，还可以改变右侧栏的参数进行二次调整。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/16411327823014.jpg"></p>
<p>前段时间（去年 12 月），这个软件上线了 iOS 版本，上新价格为 25 元，原价 50 元。   </p>
<p>如果你之前通过「<strong>限免</strong>」活动下载了 iPadOS 版本，那么恭喜你：<strong>iOS App 也可以免费下载</strong>。 </p>
<p>打开图片，点击右上角的「调整」按钮，可以在底部调出内置的滤镜，随便应用一下，原本平平无奇的图片，瞬间就变得好看了。   </p>
<p>点击右下角的「…」图标，选择「<strong>显示调整</strong>」，可以打开 iPad 版本一样的工具栏，进行更精细化地调整。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/img1194.PNG" alt="IMG_1194"></p>
<p>滤镜是许多修图应用的基本操作了，不需要过多描述。  </p>
<p>Pixelmator Photo 还有两个值得一用的功能：  </p>
<ul>
<li>实时对比调整前后的图像</li>
<li>拷贝&#x2F;粘贴调整，实现批量修图</li>
</ul>
<p>点击左上角的 &lt;|&gt; 图标，它会在图片中央添加一条<strong>白线</strong>，白色两侧分别是调整前和调整后的对比，拖拽白线，可以实时对比前后的效果。  </p>
<p>调整好一张图片后，如果你想将调整好的效果，应用到剩下的 8 张图片，不需要手动重复 8 次。</p>
<p>可使用「更多」菜单中的「<strong>拷贝调整</strong>」，将调整好的效果批量「粘贴」到其他的图片。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/img61c6f277febe1.jpeg" alt="IMG_61C6F277FEBE-1"></p>
<p>第一次了解<strong>手机 App 也能批量修图</strong>，还是从女朋友用 VSCO 修图的时候知道的。</p>
<p>而这回，Pixelmator Photo 也有了，单纯从提高修图效率的角度而言，它就值得买入了。  </p>
<p>顺便一提，除了 Pixelmator Photo，这个团队还有另外两个产品：  </p>
<ul>
<li>iOS：Pixelmator，需付费 30 元才能下载  </li>
<li>macOS：Pixelmator Pro，需付费 128 元才能下载</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/16411315712660.jpg"></p>
<p>关于 Pixelmator Photo 和 Pixelmator Pro 的区别，有网友 @Ye Han 说到：  </p>
<blockquote>
<p>Pixelmator Photo 是 Pixelmator 团队在开发 iPadOS 平台的 Pixelmator Pro 时遇到困难，从 macOS 平台的 Pixelmator Pro 中剥离摄影后期功能单独发布的。</p>
</blockquote>
<h2 id="新的一年继续坚持分享"><a href="#新的一年继续坚持分享" class="headerlink" title="新的一年继续坚持分享"></a>新的一年继续坚持分享</h2><p>新年刚开始，这两天有在想，新的一年要做什么？要立下什么 flag？</p>
<p>但还没有很好的头绪，只想到一点——<strong>新的一年继续坚持「分享」</strong>。   </p>
<p>因为分享，我从网上认识了一些网友：  </p>
<p>在网上坚持分享，就是一种创造链接的方式，别人通过你写的东西，对你形成初步的印象，刚开始可能不会主动加你微信。</p>
<p>但由于你长期高价值的分享，他就会觉得你这个人有意思、值得交往，可能就会主动来「撩」你了。  </p>
<p>原先借由文章创造的弱连接（弱关系），就会变成一种长期、可频繁交流的强关系。</p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/pu-shi-wu-hua-de-zi-mei-ti-jing-li2001.png" alt="朴实无华的自媒体经历2.001"></p>
<p>也开始收获了一些物质回报： </p>
<p>2022 年第一天，我统计了去年从知乎和公众号获得的收入——19450 元。   </p>
<p>对比起别人的月入好几万，虽然不值一提，但它至少让我看到了坚持的回报。    </p>
<p>如果你在新的一年，也想有所变化，让自己成为更值得交往的人，可以试着<strong>从分享开始</strong>：  </p>
<ul>
<li>在朋友圈分享   </li>
<li>写公众号</li>
<li>录播客</li>
</ul>
<p>等等。</p>
<p>如果你对写公众号感兴趣，可以加入我的社群，查收我刚写的「公众号写作工具流」👇👇：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/03/image818285884554852.PNG" alt="image_818285884554852"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">        </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2022-1-1-qrcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022-1-1-qrcode/" itemprop="url">如何美化一个二维码？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-01T10:58:00+00:00">
                2022-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6wLSzIZ5YrU0hjX0q3a4RA">效率工具指南</a>」<br>文&#x2F;彭宏豪</p>
<p>Hello 各位好，我是小豪。<br>2022 新年第一天，祝各位新年快乐。   </p>
<p>今天这篇文章，来自于昨天同事在排版文章的时候，遇到的一个问题：<strong>如何更改默认二维码的黑白两色？</strong>    </p>
<p>想实现的效果如下，将二维码默认的黑色方块更改为红色，默认的白色方块更改为浅黄色。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/geng-gai-er-wei-ma-de-yan-se.png" alt="更改二维码的颜色"></p>
<p>最开始想到一个比较笨的方案：使用 PS 的抠图工具，将二维码黑色的小方块抠出来，再单独改色，但这样操作起来比较麻烦，而且方块太多，容易漏选，可能会导致处理后的二维码用不了。  </p>
<p>后来，想起了很久之前看过的一个 PS 教程，提到的一个知识点「<strong>渐变映射</strong>」。</p>
<p>跟着网上的小教程操作，一下就搞定了，不需要像个老实人，用魔棒工具一个一个点选抠图。   </p>
<p>下面是具体操作过程：   </p>
<p>将二维码导入 PS，长按 PS 右下角第 4 个「调整」按钮，在弹出的菜单，选择「渐变映射」。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410314693419.jpg"></p>
<p>右侧的图层面板会出现一个新的图层——<strong>调整图层</strong>，会改变下方图层的颜色，原先黑白两色的二维码变成了浅黄色。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410317227519.jpg"></p>
<p>要实现文章开头说到的效果——二维码默认的黑色方块变为红色，默认的白色方块变为浅黄色，还需要多一步操作。</p>
<p>单击右上角的渐变缩略图，打开渐变编辑器，点击渐变滑块下方的滑钮，更改颜色，就能影响二维码最终的颜色。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410320248684.jpg"></p>
<p>将渐变滑块左侧的浅黄色更改为红色，将滑块右侧的白色更改为浅黄色，就得到了我最终想要的效果，如下图。 </p>
<p>使用这种方法，真的比老老实实抠图方便多了，每天一个偷懒小技巧，你学会了吗？   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410323845499.jpg"></p>
<p>除了这个小技巧，再分享另外两个和「二维码」相关的网站。   </p>
<h2 id="草料二维码"><a href="#草料二维码" class="headerlink" title="草料二维码"></a>草料二维码</h2><p>草料二维码，可以对默认黑白两色的二维码进行美化。  </p>
<p>点击右侧的按钮，从本地上传二维码，使用网站顶部的工具栏，可以：  </p>
<ul>
<li>套用设计好的二维码样式</li>
<li>在二维码正中间添加一个 logo  </li>
<li>更改二维码的前景色和背景色  </li>
<li>给二维码添加文字</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410325552256.jpg"></p>
<p>提一下其中的「<strong>更改二维码的前景色和背景色</strong>」，可以实现前面用 PS 的「渐变映射」更改二维码颜色的效果。   </p>
<p>下图的「二维码颜色」，就是二维码的<strong>前景色</strong>，对应默认二维码的黑色。  </p>
<p>「背景色」就是二维码的<strong>背景色</strong>，对应默认二维码的白色。  </p>
<p>分别调整这两个颜色，就可以更改默认二维码的黑色两色。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410330547706.jpg"></p>
<p>草料二维码的这个功能，好像比 PS 的「渐变映射」更简单了？  </p>
<p>「草料二维码」网址：<br><em><a target="_blank" rel="noopener" href="https://mh.cli.im/">https://mh.cli.im/</a></em></p>
<h2 id="qrbtf-参数化二维码"><a href="#qrbtf-参数化二维码" class="headerlink" title="qrbtf 参数化二维码"></a>qrbtf 参数化二维码</h2><p>这是一个我之前一直在用的二维码工具，同样可以让黑白两色的二维码变得更漂亮。   </p>
<p>喜欢极简风格的朋友，推荐使用这个。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/16410335259275.jpg"></p>
<p>qrbtf 网址：<br><em><a target="_blank" rel="noopener" href="https://qrbtf.com/">https://qrbtf.com/</a></em>    </p>
<h2 id="📢-我的社群"><a href="#📢-我的社群" class="headerlink" title="📢 我的社群"></a>📢 我的社群</h2><p>最后，放一下我在知识星球上创建的社群，前 30 名加入 79 元，感兴趣的可以加入。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/hai-bao.png" alt="海报"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/01/01/image581185158512144.PNG" alt="image_581185158512144"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">        </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/2021-summary.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/2021-summary.html" itemprop="url">2021 年度总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-31T16:00:00+00:00">
                2021-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021 已经走到尽头，在这一年中，世界上发生了很多事情，疫情仍在持续，国际形势在不断发生改变，就连娱乐圈你也不知道第二天睡醒后会吃出什么大瓜，总而言之，这又是不平凡的一年。</p>
<p>但是，仍然有无数像我一样的平凡人在过着平凡的生活，每天生活三点一线，为了生计奔波忙碌。</p>
<p>本文就记录一个平凡人如何度过他平凡的一年，以此给 2021 年画上一个平凡的句号。</p>
<p>：）抱歉你可能已经不认识「平凡」这两个字了 </p>
<h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><h3 id="Q1：团队解散，找工作"><a href="#Q1：团队解散，找工作" class="headerlink" title="Q1：团队解散，找工作"></a>Q1：团队解散，找工作</h3><p>去年《<a target="_blank" rel="noopener" href="https://4ark.me/posts/2020-summary.html#%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%88%90%E9%95%BF">2021 年度总结</a>》中有提到年末时我选择了离开广州，并回到我老家清远，与一位师兄组建了一个创业团队，然而还是太年轻，远远低估了创业这条道路的艰辛和风险，不到三个月团队就解散了。</p>
<p>深刻反省一下当时做这个决定真的不够慎重，压根没有结合自身情况来考虑这件事情。</p>
<p>这段时间也并非全无收获，我感觉到在四线城市的生活节奏要相对缓慢一些，比起大城市，我更喜欢这里，因为我这里有家的感觉，她属于我，我也属于她。</p>
<p>但当务之急就是尽快入职来维持收入，不过这个四线城市没有多少互联网公司，也只能选择广州了，所以最终是在 BOSS 直聘上面海投简历，由于当时正值金三银四的时候，招聘的公司也很多，所以不到两天就把一个星期的面试安排给排满了，当然也是因为我对公司并没多少要求，所以约我面试的公司也没几家算得上是心仪的，总之最终入职了一家郊区的小公司，并在附近租了个房子，这段经历在《<a target="_blank" rel="noopener" href="https://4ark.me/post/2021-03-04-2020-feb-summary.html">二月总结</a>》中有提到。</p>
<h3 id="Q2：那一段悠闲的时光"><a href="#Q2：那一段悠闲的时光" class="headerlink" title="Q2：那一段悠闲的时光"></a>Q2：那一段悠闲的时光</h3><p>虽然大部分公司 HR 在面试的时候都会说公司基本不会加班，但大家懂的都懂：）</p>
<p>我之前也是待过小公司的，上班时间不会比大公司短，但我入职后，惊讶地发现大家几乎都在晚上六点准时下班。</p>
<p>由于我住的地方离公司比较近，通勤时间简直可以忽略不计，相当于每天工作只需要 6.5 个小时，我负责的工作内容就是写一些小程序、APP 内嵌的活动页，基本没有什么难度可言，经常会出现一天时间把活干完，剩下几天没事可干的情况。所以上班摸鱼也就习以为常了。但摸了不到一个月觉得这样下去自己迟早会废掉，索性将摸鱼的时间花在读源码上，于是又用了一个月时间把 Vue 生态库的源码都读了一遍，还顺便产出了一些笔记：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://4ark.me/post/vuex-score-code.html">《vuex 源码解析》</a></li>
<li><a target="_blank" rel="noopener" href="https://4ark.me/post/composition-api-score-code.html">《composition-api 源码解析》</a></li>
<li><a target="_blank" rel="noopener" href="https://4ark.me/post/vue-router-score-code.html">《vue-router 源码解析》</a></li>
</ul>
<p>所以那段时间我的生活写照是这样的：每天睡到九点，起床吃早餐去公司，如果没有工作就自己整点活，主要是看源码，摸到晚上六点就下班去买菜自己回家煮饭，接着看一个小时左右《史记》，在本博客输出一些自己不太成熟的读书感悟：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">《从思辨中学历史》</a></li>
<li><a target="_blank" rel="noopener" href="https://4ark.me/post/about-si-ma-qian.html">《司马迁是一个什么样的人？》</a></li>
</ul>
<p>这可以说是我工作以后过得最悠闲的日子了。</p>
<h3 id="Q3：那一段痛苦的时光"><a href="#Q3：那一段痛苦的时光" class="headerlink" title="Q3：那一段痛苦的时光"></a>Q3：那一段痛苦的时光</h3><p>可惜好景不长，迎来了一个不好的消息，公司要搬迁，从原本的郊区搬到市中心地段，美名其曰乡巴佬进城了，但我的通勤时间从原本五分钟变成了七十分钟，这无疑是非常痛苦的，通勤时间如此之长足以让任何一份神仙工作的优势荡然无存。</p>
<p>当然我是可以选择搬家的，说实话我当时也已经在看房了，但突然有一天我破防了，起因是有一天与一个老同学闲聊，得知他跳槽后的薪资已比我高一倍，这让我的焦虑感瞬间就上来了，我自认在学校的时候能力并不比他差，所以我不断反思毕业这两年到底干了些什么？那几天睡觉前都在思考几个问题，是否我现在过得太安逸了？是否我的能力已经早已远远低于别人？我是否应该作出某些改变？</p>
<p>后面慢慢清醒起来，承认这样的自己并不成熟，我没必要跟任何人比较，虽说工资的高低确实可以从某种程度看出能力的差距，但不代表我现在拿的薪资就是我个人能力真正的写照，因为我这几个月确实可以说是在躺平。</p>
<p>但我还是有了一些想法，我需要出去面试证明自己的能力，从而让我内心平衡一些，于是我开始复习、刷题。原本的计划是一边复习一边面试，一直到明年的金三银四，再试着挑战一下大厂。然而有一件事打破了我的计划，公司开始延迟发放工资，足足拖了二十天，这自然能从侧面看到目前公司现金流不足，这时候就只能及时止损了。</p>
<p>于是只能赶鸭子上架出去面试，这一次我没有选择胡乱海投，而是先选择心仪的公司再进行投递，但由于简历上存在不少硬伤，学历低、频繁跳槽，目前 base 低却要求涨幅过高，所以很多公司都不给面试机会，有些公司的 HR 也会拿简历上的硬伤来说事，以此压低薪资，所幸还是有几家比较满意的，这才让我稍微恢复了一些自信。</p>
<p>最终我选择了一家做科技媒体的公司，因为我本身就是该媒体的读者，并且参与研发的产品也是我比较感兴趣的。</p>
<h3 id="Q4：那一段充实的时光"><a href="#Q4：那一段充实的时光" class="headerlink" title="Q4：那一段充实的时光"></a>Q4：那一段充实的时光</h3><p>新公司的通勤时间相对上一家要短一半，终于不用每天早起，生活、工作又开始慢慢回到正轨。</p>
<p>相对上一家公司的悠闲，这里的工作量还是比较饱和的，也逐渐开始习惯。除了完成日常的工作任务以外，也开始整了一点活，比如这个：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/gd4Ark/husky/pull/1">support mercurial repo by gd4Ark</a></li>
</ul>
<p>另外还花了一个星期写了一篇技术文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a></li>
</ul>
<p>值得一提的是，这篇文章在掘金上发布后，被评为每周精选文章，收到奖品：一个马克杯和帆布袋。</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615563.image?imageMogr2/format/webp"></p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615795.png?imageMogr2/format/webp"></p>
<p style="text-align:center;">懒得拍了，网上找的图</p>

<p>总的来说，这段时间相对比较充实，不过也有一些习惯被落下了，明年需要重新拾起来。</p>
<p>再晒一下公司送的新年礼品：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291618945.png?imageMogr2/format/webp"></p>
<h2 id="年度盘点"><a href="#年度盘点" class="headerlink" title="年度盘点"></a>年度盘点</h2><h3 id="最喜欢的书"><a href="#最喜欢的书" class="headerlink" title="最喜欢的书"></a>最喜欢的书</h3><p>今年看过的书不多，其中比较喜欢的这几本：</p>
<ul>
<li><strong>《最初的爱情，最后的仪式》</strong></li>
<li><strong>《不平等的尸体》</strong></li>
<li><strong>《人间失格》</strong></li>
<li><strong>《丑陋的中国人》</strong></li>
</ul>
<h3 id="最喜欢的音乐"><a href="#最喜欢的音乐" class="headerlink" title="最喜欢的音乐"></a>最喜欢的音乐</h3><p>今年我从网易云音乐转到了 Spotify，终于可以实现听歌自由了。</p>
<p>今年最喜欢的音乐：</p>
<ul>
<li><strong>《梵高先生》</strong></li>
</ul>
<iframe src="https://open.spotify.com/embed/track/572mdcKFCEMVgtSELmoIuU?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>

<ul>
<li><strong>《差不多先生》</strong></li>
</ul>
<iframe src="https://open.spotify.com/embed/track/6fADwOnsMmCM70OAxDF3fc?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>

<ul>
<li><strong>《夕阳之歌》</strong></li>
</ul>
<iframe src="https://open.spotify.com/embed/track/5tVzG4tw3M9VLkcQ0fOtgF?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>


<h3 id="最喜欢的电影（电视剧）"><a href="#最喜欢的电影（电视剧）" class="headerlink" title="最喜欢的电影（电视剧）"></a>最喜欢的电影（电视剧）</h3><p>今年喜欢在 Netflix 看剧，所以看了不少的经典高分剧；另外用我的黑群晖下载了一些经典电影。</p>
<p>为此，我还特地用 notion 做了一个<a target="_blank" rel="noopener" href="https://4ark.notion.site/4b4180c7bf3249c2b47bc9127150b240?v=3df58ff87655451c9873a8aadd9a72db">页面</a>，来记录我看过的那些电影（电视剧）。</p>
<p>这里盘点一下我今年最喜欢的几部电影：</p>
<ul>
<li><strong>《杀人回忆》</strong></li>
<li><strong>《拯救大兵瑞恩》</strong></li>
<li><strong>《触不可及》</strong></li>
<li><strong>《指环王系列》</strong></li>
<li><strong>《金福南杀人事件》</strong></li>
<li><strong>《出租车司机》</strong>（是罗伯特·德尼罗主演， “Are You Talking to Me?” 那部</li>
</ul>
<p>下面是我今年最喜欢的电视剧：</p>
<ul>
<li><strong>《权利的游戏》</strong>（如果不烂尾的话多好</li>
<li><strong>《请回答 1988》</strong></li>
<li><strong>《性爱自修室》</strong></li>
<li><strong>《绝命毒师》</strong>、<strong>《风骚律师》</strong></li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这就是我平凡的一年，是一个年轻人迷茫的一年，我开始接受自己只是一个极其普通的平凡人，接受自己并不优秀的事实，我也并没有雄心壮志去改变世界，有时候甚至连改变自己都无法做到，我只想好好地活下去，做我喜欢做的事情。</p>
<p>我很喜欢罗翔老师的这几句话：</p>
<blockquote>
<p>人最大的痛苦就是在于无法跨越知道和做到的那个鸿沟。笛卡尔说：“我思故我在”，这个很对，但是，“我思故我在”会经常让我们沉浸于一种幻想之中，就是我们只要思考到了，我们就能做到。但其实不是这样。</p>
</blockquote>
<blockquote>
<p>因为人要接受事与愿违啊。我们太有限了，我们只能做我们觉得对的事情，然后，接受它的事与愿违。</p>
</blockquote>
<blockquote>
<p>我们登上并非我们所选择的舞台，演出并非我们选择的剧本。我们自己一生中能够决定的东西很少，可能只有百分之五的剧本，百分之九十五的东西是我们决定不了的。我们决定不了我们的出身，决定不了我们的智商，更决定不了我们一生中的贵人相助。很多时候我们经常会羡慕别人剧本，但是没有谁的剧本值得羡慕，很多人的剧本就是专门演给别人看的。而你要做的就是演好属于自己的剧本。如果你不幸遇到了某些挫折，你有两种选择，一种是弃演，一种是把既定的剧本演好，即使过程会痛苦，但一定很独特并很精彩。</p>
</blockquote>
<p>所以，就算「有人出生在罗马，有人生来是牛马」，我们也不要轻易放弃自己，即便我们并不优秀，你也要去接受，这就是属于你的剧本，无论你的选择是躺平还是奋斗，那是你的自由，没有人可以谴责你。</p>
<p>最后，以一首西城男孩演唱《平凡之路》，来结束这平凡的 2021。</p>
<iframe src="//player.bilibili.com/player.html?aid=592381368&bvid=BV17q4y1B7BR&cid=463084542&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h2 id="2022？"><a href="#2022？" class="headerlink" title="2022？"></a>2022？</h2><p>好好活着。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-12-31-my2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-12-31-my2021/" itemprop="url">我的 2021</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-31T13:30:00+00:00">
                2021-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>很快，2021 年也要过完了，快到让我感慨：2021 这个数字还没写熟，2022 就要来了。    </p>
<p>按照往年的惯例，简要写一下 2021 年的个人总结。   </p>
<h2 id="年度-flag-完成情况"><a href="#年度-flag-完成情况" class="headerlink" title="年度 flag 完成情况"></a>年度 flag 完成情况</h2><p>年初我在得到 App 的一个活动中，立了 3 个 flag：      </p>
<p>✅ 公众号 1 万关注（目前 1.4 万关注）<br>✅ 换份工作<br>✅ 和女朋友走得长长久久     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/img0738.PNG" alt="IMG_0738"></p>
<h2 id="公众号概况"><a href="#公众号概况" class="headerlink" title="公众号概况"></a>公众号概况</h2><ul>
<li>关注数</li>
</ul>
<p>从年初的 7038 到今天的 14605，关注净增 7567，一年的关注增长，就超过了好几年的努力，感谢各位读者的支持</p>
<ul>
<li>文章数量</li>
</ul>
<p>今年我特地在每篇原创文章前面加了一个标签 <strong>#2021</strong> ，标签会自动统计文章数量。</p>
<p>不包含这一篇，今年已发布 190 篇文章。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/16398394195524.jpg"></p>
<ul>
<li>公众号广告收入</li>
</ul>
<p>今年 5 月，我的公众号接到了第 1 条广告，公众号写了好多年，终于恰上饭了。   </p>
<p>我统计了一下，从 5 月份到 11 月，广告给我带来了 5550 元的收入，悲惨吧？   </p>
<p>老老实实、不懂变通搞自媒体，真的没有前💰途。   </p>
<p>多说一句，不要一看到，打着「轻松教你月入过万」为名的课程，脑子一热就去报名了，报名前请三思。    </p>
<h2 id="两件比较自豪的小事"><a href="#两件比较自豪的小事" class="headerlink" title="两件比较自豪的小事"></a>两件比较自豪的小事</h2><ul>
<li>公众号连续 100 天日更，详情见文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649914441&idx=1&sn=5bd3c94f845c03c7c3b0114511078ead&chksm=83a87864b4dff1722f10afce7028d9c65d4022015edf89dc21613a8ccfa634bc014c39328a22&token=1693022434&lang=zh_CN#rd">日更公众号100天，这个flag最终还是没倒</a>        </li>
<li>即将完成累积 100 次跑步，目前进度：95&#x2F;100</li>
</ul>
<p>写东西和运动，在我看来，都属于可以做、也可以不做的事，因为没人在背后监督你，做了短期也不会有报酬。      </p>
<p>陆陆续续坚持运动，最明显的一点体会：9 月份之后到现在，貌似没有感冒过了。     </p>
<h2 id="2021-看过的书"><a href="#2021-看过的书" class="headerlink" title="2021 看过的书"></a>2021 看过的书</h2><p>今天看过的书，还是很少，看的也有点杂，没有一个集中的主题。  </p>
<p>写一下其中值得一读的书：   </p>
<p>《文城》<br>《我们为什么要睡觉？》<br>《绝非偶然：撬动星球的头部效应》<br>《幕后产品：打造突破式产品思维》<br>《稀缺：我们是如何陷入贫穷与忙碌的》<br>《不拘一格：网飞的自由与责任工作法》  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/albumtemp1639828664.PNG" alt="album_temp_1639828664"></p>
<h2 id="今年买过的一件好物"><a href="#今年买过的一件好物" class="headerlink" title="今年买过的一件好物"></a>今年买过的一件好物</h2><p>非 Apple Watch 莫属。</p>
<p>它有很多使用场景：   </p>
<ul>
<li>戴口罩时解锁 iPhone   </li>
<li>解锁 Mac 电脑   </li>
<li>电脑下载软件或开启权限时，连按两次侧边按钮，可替代输入电脑密码   </li>
<li>在公司午休，设置闹钟不会吵到别人    </li>
<li>手机来电震动提醒，不会错过别人的电话</li>
</ul>
<p>了解更多，可以看我之前写过的一篇文章： </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649918282&idx=1&sn=768b3e70b4b10fbd9db2b41af4360782&chksm=83a88f67b4df0671cc3d4b5c94d1b2c12e563a7b091e1e0336c53031d7286ffcd22c125fe7fb&token=1693022434&lang=zh_CN#rd">Apple Watch 苹果手表的多种妙用</a>     </p>
<h2 id="今年开心的几件事"><a href="#今年开心的几件事" class="headerlink" title="今年开心的几件事"></a>今年开心的几件事</h2><ul>
<li>喜欢的歌手李健终于出新专辑💽了——「<strong>不期而遇</strong>」，有 15 首歌。这张新专辑，等了 5 年。</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/img0753.JPG" alt="IMG_0753"></p>
<ul>
<li><p>女朋友给了我一个惊喜：偷偷从深圳跑到广州，还来接我下班。        </p>
</li>
<li><p>从广州搬到深圳，结束了不到一年的异地恋。    </p>
</li>
<li><p>生日那天，同事刘容送了我一个蛋糕🍰。</p>
</li>
</ul>
<p>再透露同事一个很用心❤️的细节：她会把别人的生日添加到微信备注里，这样和别人聊天、或者刷朋友圈，就可以知道谁快生日了。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/16398371915371.jpg"></p>
<ul>
<li>在知乎发了好几年东西，有好几次想：知乎啥时候给我发盒粽子呢？</li>
</ul>
<p>知乎的粽子一直没等到，今年终于等来了第 1 份礼物，想感慨一句：多年的付出，终于被看见了。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/16398378682896.jpg"></p>
<h2 id="最漫长的一段时间"><a href="#最漫长的一段时间" class="headerlink" title="最漫长的一段时间"></a>最漫长的一段时间</h2><p>因为 5 月底的广州疫情，中间有好长一段时间没和女朋友见面（主要是她不想见），见面的频率从 2 周一次变成了 85 天见一次。    </p>
<p>间隔之长，让原先​每周末最期待的事情都落空了。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/18/16398337928078.jpg"></p>
<h2 id="2021-年进度条"><a href="#2021-年进度条" class="headerlink" title="2021 年进度条"></a>2021 年进度条</h2><ul>
<li>元旦凌晨到了何老师的家，她穿着睡衣给我开门     </li>
<li>5 月劳动节的时候去了惠州，和妈妈、姐姐、弟弟一起在惠州逛  </li>
<li>5 月底因为广州疫情，和何老师隔了 85 天之后才见面  </li>
<li>6 月 17 日，我的公众号终于达到 1 万关注了  </li>
<li>6 月 28 日，收到了在得到上买的机械键盘，人生的第一个机械键盘，可惜后来掉漆了   </li>
<li>第一次过上七夕情人节</li>
<li>8 月 2 日，收到了在拼多多买的 Apple Watch  </li>
<li>8 月 15 日，和何老师去罗湖站旁边的一家狗咖撸狗🐶      </li>
<li>8 月 31 日，是我在一周进步上的最后一天班，之后裸辞了 56 天</li>
<li>9 月 21 日，中秋节，和志铭去了清远古龙峡，第一次玩漂流，好刺激  </li>
<li>9 月 22 日，续费了腾讯云服务器，一次性买了 3 年，总价为 1131 元     </li>
<li>10 月 25 日，我从广州搬到了深圳</li>
<li>10 月 27 日，到知识星球上班的第一天    </li>
<li>11 月 7 日，收到了在拼多多买的 iPhone 13  </li>
<li>12 月 25 日，累计跑步 100 次达成</li>
</ul>
<h2 id="往年年度总结"><a href="#往年年度总结" class="headerlink" title="往年年度总结"></a>往年年度总结</h2><p>最后，附上我在过去 3 年写的年度总结：     </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649900020&idx=1&sn=ad8ebd361f716aa80e3da93369bd076a&chksm=83a847d9b4dfcecf3686e50154034bd2d6e43520d988e8fbbb9d235e259dc78ff1e43bfe39bb&token=1693022434&lang=zh_CN#rd">我的 2020 年度总结</a>    </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649881076&idx=1&sn=2cf2c3f5ac137f56d18c3fc70a8fa11d&scene=21#wechat_redirect">我的 2019 年简短总结</a>  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649880133&idx=1&sn=76b4bbe6d989b90e0f2a5ff09f7a4093&chksm=83abf268b4dc7b7e17f40126393083496e4a5e1f2218335afc85f956a21e2122ee9238c3ff1b&scene=21#wechat_redirect">我的2018年简短总结</a>    </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">      </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/12/2021-personal-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/2021-personal-summary/" itemprop="url">2021年终总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-31T13:00:00+00:00">
                2021-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <blockquote>
<p>关键词：不轴</p>
</blockquote>
<p>这一年信息量还是挺大，做了很多项目，但是业务产出较少（有一些外部因素），职级也未能得到晋升。经过这一年的时间沉淀，不再自以为是，以更开放的心态接受身边事物的改变。</p>
<p><img src="//www.fanhaobai.com/2021/12/2021-personal-summary/10183cff-d8cc-4e5f-97cb-b897a256bd41.png" alt="预览图">
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/12/2021-personal-summary/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/2021-12-31-summary-of-2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/2021-12-31-summary-of-2021/" itemprop="url">2021 年度小结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-30T16:00:00+00:00">
                2021-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2021 年新冠疫情仍然没有结束，我们甚至已经习惯了它的存在。</p>
<p>和蛋黄在昆山住了三年之后，今年最大的变化是我们搬到了上海。相比于之前在北京的一年，因为收入更高了也有条件在上海租更好的房子，离公司和地铁站都非常近，面积也并 <a target="_blank" rel="noopener" href="https://twitter.com/jysperm/status/1405473824515051521">不比昆山的房子小太多</a>。</p>
<p>因为在走之前我有些舍不得我投入了这么多精力改造的家，直到搬走前三天我们才开始高强度地打包收拾。这次我们的物品达到了 <a target="_blank" rel="noopener" href="https://twitter.com/jysperm/status/1402669620163584001">惊人的 1000 千克、7.9 立方米</a>，到了上海后又断断续续花了一个月收拾，买了沙发、桌子、电视、洗衣机、新的净水器，再次自己安装了窗帘杆，为了将洗碗机和洗衣机放到理想的位置做了不少改造，对于选择哪个房间做卧室（同时也决定了我们的桌子如何摆放）也纠结了很久。在又投入了这么多精力之后，我发现我也不会去想到昆山了，毕竟当下才是自己最理想的家。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2021/2021-shanghai-1.png"></p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2021/2021-shanghai-2.png"></p>
<p>上海的确有更多的地方可以逛、可以玩，但因为我周末总是下午才起床，所以我们不经常去比较远的地方。而是就像 2020 年一样，在夜里骑着电动车说走就走，走遍了家附近方圆七、八公里的区域。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2021/2021-shanghai-3.png"></p>
<p>新的环境也确实对我的情绪有一些改善。想到和蛋黄刚在一起的时候就说「重要的是我们在一起并不需要做出什么改变就可以很开心，而不一定要按照社会的期待去改变自己」，我得承认在一些事情上我没有做到，有时候会因为觉得大家都可以这样做而去要求蛋黄。但她却一直是这样做的，会包容我所有和其他人不一样的地方，从未要求我改变什么。</p>
<p>在工作方面最大的变化则是 LeanCloud 被心动收购，团队整体加入了 TapTap，办公地点也搬到了上海。公司被收购是一种非常独特的体验，整个过程充满了不确定性，自己和同事们也都在考虑各自后续的变化 —— 其实说起来那两个月都没什么心思工作。最后尘埃落定，加入一个新的公司时，你既是老员工，也是新员工，也有了更多的时间去审视自己与公司的关系。</p>
<p>我一直对于大公司非常抵触，我也绝对不会加入像阿里巴巴、拼多多、华为这样的公司。当公司规模大到老板无法知道每一个人在做什么的时候，就会开始引入组织架构。这种变化一方面带来了效率的降低 —— 部门间的利益和公司的利益不一定是一致的，需要大量的管理来「对齐」；另一方面也带来了一种系统性的压迫 —— 公司与员工的力量是如此地悬殊，制定和执行规则的人也与员工离得更远，他们会充分利用合同和协议将风险全部转移到员工身上，在这里要感谢我之前的两家公司从未让我有过这样的感觉。</p>
<p>心动的 CEO <a target="_blank" rel="noopener" href="https://twitter.com/DashHuang">黄一孟</a> 在社交媒体上很活跃，也曾分享过心动使用 Slack 和 Confluence 实现内部透明，TapTap 的「离职致意金」和无限假期等政策，尤其后两者以我的理解是在倒逼中层管理人员来提高管理水平，及时辞退不合适的员工。且不论结果如何，对于这种解决「大公司问题」的尝试我是认可的，也是心动不同于同等规模公司的地方。</p>
<p>今年下半年受邀参与了几个智能合约项目的代码审计，虽然实际完成的工作很少，但也算是补习了近几年智能合约和 DeFi 的发展。可以看到现在已经很少有人再去质疑 Bitcoin 或者 Ethereum 的意义了，而是将焦点放在了 DeFi 和 NFT 上，这说明了整个密码货币产业还在不断在向前发展，我几年前曾写过 <a target="_blank" rel="noopener" href="https://jysperm.me/2017/06/why-i-trade-bitcoin/">一篇文章</a> 说比特币是一场实验，那么我觉得在今天这个时间点可以说这场实验已经成功了。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2021/2021-cryptocurrency.png"></p>
<blockquote>
<p>图为我持有的所有密码货币在 2021 年的波动</p>
</blockquote>
<p>继软路由和 NAS 之后，今年投入了一些时间搭建 <a target="_blank" rel="noopener" href="https://twitter.com/jysperm/status/1450448737545834499">基于 Home Assistant 的智能家居</a>，花的精力不算太多，主要是将部分受支持的米家设备接入了操作体验更好的 HomeKit。</p>
<p>今年 <a target="_blank" rel="noopener" href="https://twitter.com/jysperm/status/1477688573470015489">和蛋黄一起玩了双人成行</a>、底特律：成为人类 和 DYSMANTLE，不同于之前引导蛋黄玩游戏的尝试，这三部作品都是素质过硬且适合双人游玩的游戏，我们也都通关了这三部作品。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%B5%85%E8%AE%AE%E9%9D%9E%E5%85%B8%E5%9E%8B-Web-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%B5%85%E8%AE%AE%E9%9D%9E%E5%85%B8%E5%9E%8B-Web-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" itemprop="url">浅议非典型 Web 应用场景下的身份认证</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-28T03:53:29+00:00">
                2021-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>据我所知，软件行业，向来是充满着鄙视链的，人们时常会因为语言、框架、范式、架构等等问题而争执不休。不必说 PHP 到底是不是世界上最好的语言，不必说原生与 Web 到底哪一个真正代表着未来，更不必说前端与后端到底哪一个更有技术含量，单单一个 C++ 的版本，1998 与 2011 之间仿佛隔了一个世纪。我真傻，我单知道人们会因为 GCC 和 VC++ 而分庭抗礼多年，却不知道人们还会因为大括号换行、Tab 还是空格、CRLF 还是 CR……诸如此类的问题而永不休战。也许，正如 <a target="_blank" rel="noopener" href="http://www.yinwang.org/">王垠</a> 前辈所说，编程这个领域总是充满着某种 <a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2015/04/03/paradigms">宗教原旨</a> 的意味。回想起刚毕业那会儿，因为没有 Web 开发的经验而被人轻视，当年流行的 SSH 全家桶，对我鼓捣 Windows 桌面开发这件事情，投来无限鄙夷的目光，仿佛 Windows 是一种原罪。可时间久了以后，我渐渐意识到，对工程派而言，一切都是工具；而对于学术派而言，一切都是包容。这个世界并不是只有 Web，对吧？所以，这篇博客我想聊聊非典型 Web 应用场景下的身份认证。</p>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>在讨论非典型 Web 应用场景前，我们不妨来回想一下，一个典型的 Web 应用是什么样子？打开浏览器、输入一个 URL、按下回车、输入用户名和密码、点击登录……，在这个过程中，Cookie&#x2F;Session用来维持整个会话的状态。直到后来，前后端分离的大潮流下，无状态的服务开始流行，人们开始使用一个令牌(Token)来标识身份信息，无论是催生了 Web 2.0 的 <code>OAuth 2.0</code> 协议，还是在微服务里更为流行的 <code>JWT(JSON Web Token)</code>，其实，都在隐隐约约说明一件事情，那就是在后 Web 时代，特别是微信兴起以后，人们在线与离线的边界越来越模糊，疫情期间居家办公的这段时间，我最怕听到 Teams 会议邀请的声音，因为无论你是否在线，它都会不停地催促你，彻底模糊生活与工作的边界。那么，屏幕前聪明的你，你告诉我，什么是典型的 Web 应用？也许，我同样无法回答这个问题，可或许，下面这几种方式，即 gRPC、SignalR 和 Kafka，可以称之为：非典型的 Web 应用。</p>
<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><p>相信经常阅读我博客的朋友，都知道这样一件事情，那就是，过去这半年多的时间，我一直在探索，如何去构建一个以 gRPC 为核心的微服务架构。想了解这方面内容的朋友，不妨抽空看看我前面写过的博客。从整体上来说，我们对于 gRPC 的使用上，基本可以分为对内和对外两个方面。对内，不同的服务间通过 gRPC 客户端互相通信，我们称之为：直连；对外，不同的服务通过 Envoy 代理为 JSON API 供前端&#x2F;客户端消费，我们称之为：代理。一个简单的微服务示意图，如下图所示：</p>
<p><img src="/gRPC-MicroService.drawio.png" alt="gRPC 微服务中的内与外"></p>
<p>目前，这个方案最大的问题，不同的服务间通过 gRPC 客户端直连的时候，无法提供身份认证信息，因为如果是单纯的读，即从某一个服务查询数据，其实是可以接受这种“裸奔”的状态，可一旦涉及到了写，这种方案就显得不大严谨。譬如现在的做法，如果从 <code>HttpContext</code> 里提取不到用户信息，就默认当前用户是 Sys，表示这是一个系统级别的操作。那么，如何解决这个问题呢？我们一起来看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">&quot;https://localhost:5001&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(channel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> metadata = <span class="keyword">new</span> Metadata();</span><br><span class="line">metadata.Add(<span class="string">&quot;Authorization&quot;</span>, <span class="string">$&quot;Bearer <span class="subst">&#123;token&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply = client.SayHello(<span class="keyword">new</span> HelloRequest(), metadata);</span><br></pre></td></tr></table></figure>

<p>可以注意到，这里的关键是构造一个<code>Metadata</code>，并在其中传入<code>Authorization</code>头部。当然，这一切的前提是你遵循并且沿用了 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-3.0&tabs=visual-studio"> ASP.NET Core 身份验证</a>，这里以最常见的 JWT 认证为例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">   x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">&#125; ).AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   x.RequireHttpsMetadata = <span class="literal">false</span>;</span><br><span class="line">   x.SaveToken = <span class="literal">true</span>;</span><br><span class="line">   x.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">  &#123;</span><br><span class="line">     ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">     IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtOptions.Secret)),</span><br><span class="line">     ValidIssuer = jwtOptions.Issuer,</span><br><span class="line">     ValidAudience = jwtOptions.Audience,</span><br><span class="line">     ValidateIssuer = <span class="literal">true</span>,</span><br><span class="line">     ValidateAudience = <span class="literal">true</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通常情况下，这里的<code>IssuerSigningKey</code>由一个证书文件来提供，例如最常用的是<code>X509SecurityKey</code>类。为了方便演示，这里采用一组字符串进行签名。不管采用哪一种方式，我们都应该保证它与生成令牌时的参数一致。例如，下面是一个典型的生成  <code>JWT</code> 令牌的代码片段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> claims = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">new</span> Claim(ClaimTypes.Name, userInfo.UserName),</span><br><span class="line">   <span class="keyword">new</span> Claim(ClaimTypes.Role, userInfo.UserRole)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtOptions.Value.Secret));</span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(signKey, SecurityAlgorithms.HmacSha256);</span><br><span class="line"><span class="keyword">var</span> jwtToken = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">   _jwtOptions.Value.Issuer,</span><br><span class="line">   _jwtOptions.Value.Audience, </span><br><span class="line">   claims, </span><br><span class="line">   expires: DateTime.Now.AddMinutes(_jwtOptions.Value.AccessExpiration), </span><br><span class="line">   signingCredentials: credentials</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">token = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(jwtToken);</span><br></pre></td></tr></table></figure>

<p> 除了以上两点，请确保你的正确地配置了认证和授权两个中间件，注意它们的顺序和位置：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    <span class="comment">// 注意顺序</span></span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以在 gRPC 中通过<code>IHttpContextAccessor</code>获取当前用户信息：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> userName = _httpContextAccessor.HttpContext.User?.Identity.Name;</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply &#123; Message = <span class="string">$&quot;Hello <span class="subst">&#123;userName&#125;</span>&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，考虑到我们使用 gRPC 客户端工厂的场景更多一点，我们更希望这个令牌可以在一开始就准备好，而不是每调用一个方法都需要传一次令牌。此时，我们可以使用下面的做法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpcClient&lt;Greeter.GreeterClient&gt;(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    o.Address = <span class="keyword">new</span> Uri(<span class="string">&quot;https://localhost:5001&quot;</span>);</span><br><span class="line">&#125;).ConfigureChannel(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> credentials = CallCredentials.FromInterceptor((context, metadata) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(_token)</span><br><span class="line">        metadata.Add(<span class="string">&quot;Authorization&quot;</span>, <span class="string">$&quot;Bearer <span class="subst">&#123;_token&#125;</span>&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    o.Credentials = ChannelCredentials.Create(<span class="keyword">new</span> SslCredentials(), credentials);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，关于 gRPC 的身份认证问题终于得到了解决，无论是对内的直连还是对外的代理，我们都可以获得用户的身份信息。需要说明的是，默认情况下，gRPC  允许调用方在不携带令牌的情况下调用接口，所以，我们这里的认证方案更像是一种君子协定。如果希望做更严格的限制，可以考虑在具体的服务上添加 <code>[Authorize]</code>特性，就像我们在控制器上使用该特性一样。</p>
<h1 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/introduction?view=aspnetcore-6.0">SignalR</a> 是由微软提供的一面向实时 Web 应用的、开源的库，你可以认为，它是集 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-6.0">WebSockets</a>、Server-Sent 事件 和 长轮询于一身的综合性的库。当你需要从服务端实时地推送消息到特定的客户端(组)的时候，SignalR 将会是一个不错的选择。譬如可视化的仪表盘或者监视系统，需要接收数据的变更通知以实时地刷新视图；即时通讯(IM)、社交网络、邮件、游戏、协作等方面地应用都需要及时地发出通知。ASP.NET Core 版本的 SIgnalR 在自动处理连接管理方面做出来不小的改善，可很多时候，SIgnalR 里面的 ConnectionId 对我们而言是没有意义的，我们更想知道连接到 Hub 的用户是谁，这样就催生出来 SignalR 身份认证的需求场景，下面，我们就来看看对应的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/authn-and-authz?view=aspnetcore-6.0">解决方案</a>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一、AccessTokenProvider </span></span><br><span class="line"><span class="keyword">var</span> hubConnection = <span class="keyword">new</span> HubConnectionBuilder()</span><br><span class="line">  .WithUrl(<span class="string">&quot;http://localhost:5000/echohub&quot;</span>,options =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    options.AccessTokenProvider = () =&gt; Task.FromResult(<span class="string">&quot;&lt;Your Token&gt;&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .WithAutomaticReconnect()</span><br><span class="line">  .Build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二、直接追加查询参数</span></span><br><span class="line"><span class="keyword">var</span> hubConnection = <span class="keyword">new</span> HubConnectionBuilder()</span><br><span class="line">  .WithUrl(<span class="string">&quot;http://localhost:5000/echohub?access_token=&lt;Your Token&gt;&quot;</span>)</span><br><span class="line">  .WithAutomaticReconnect()</span><br><span class="line">  .Build();</span><br></pre></td></tr></table></figure>

<p>首先，SignalR 的身份认证，整体上依然遵循 ASP.NET Core 里的这套认证&#x2F;授权流程，所以，我们可以继续沿用 gRPC 这部分的代码。考虑到 SignalR 首次发起的是一个 GET 请求，通常的做法是在查询参数中追加令牌参数。当然，现在官方提供了<code>AccessTokenProvider</code>这个属性，允许你构造一个委托来提供令牌。接下来，为了让这个令牌更符合一般的场景，譬如，按照约定它应该出现在 HTTP 请求头的 <code>Authorization</code> 字段上，我们有下面两种方式来对它进行处理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一、设置 JwtBearer 的 Events 属性</span></span><br><span class="line">services.AddAuthentication(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">.AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  x.Events = <span class="keyword">new</span> JwtBearerEvents()</span><br><span class="line">  &#123;</span><br><span class="line">    OnMessageReceived = context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> accessToken = context.Request.Query[<span class="string">&quot;access_token&quot;</span>];</span><br><span class="line">      <span class="keyword">var</span> path = context.HttpContext.Request.Path;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(accessToken) &amp;&amp; (path.StartsWithSegments(<span class="string">&quot;/echohub&quot;</span>)))</span><br><span class="line">        context.Token = accessToken;</span><br><span class="line">      <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，编写中间件，注意顺序</span></span><br><span class="line">app.Use((context, next) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> accessToken = context.Request.Query[<span class="string">&quot;access_token&quot;</span>].ToString();</span><br><span class="line">  <span class="keyword">var</span> path = context.Request.Path;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(accessToken) &amp;&amp; (path.StartsWithSegments(<span class="string">&quot;/echohub&quot;</span>)))</span><br><span class="line">    context.Request.Headers.Add(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">new</span> StringValues(<span class="string">$&quot;Bearer <span class="subst">&#123;accessToken&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.Invoke();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br></pre></td></tr></table></figure>

<p>可以注意到，不管是哪一种方式，核心目的都是为了让令牌能在 ASP.NET Core 的请求管道中出现在它期望出现的地方，这是什么地方呢？我想，应该是为执行认证&#x2F;授权中间件以前，所以，为什么我说这两个中间件的顺序非常重要，原因正在于此，一旦我们做了这一点，剩下的事情就交给微软，我们只需要通过 <code>HttpContext</code> 的 <code>User</code> 属性获取用户信息即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">Echo</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> userName = Context.User?.Identity?.Name;</span><br><span class="line">  Clients.Client(Context.ConnectionId).SendAsync(<span class="string">&quot;OnEcho&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;userName&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 SignalR 而言，同一个用户会对应多个 ConnectionId，当然，我并不需要过度地去关注这个东西，除非我们真的要分清每一个 ConnectionId 具体代表什么。类似地，SignalR 一样可以用 <code>[Authorized]</code> 特性来限制 Hub 是否可以在未认证的情况下使用，甚至它可以配合不同的 Policy 来做更细致的划分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRoleRequirement</span> : </span><br><span class="line">  <span class="title">AuthorizationHandler</span>&lt;<span class="title">UserRoleRequirement</span>, <span class="title">HubInvocationContext</span>&gt;, <span class="title">IAuthorizationRequirement</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">HandleRequirementAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    AuthorizationHandlerContext context, UserRoleRequirement requirement, HubInvocationContext resource</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> userRole = context.User.Claims.FirstOrDefault(x =&gt; x.Type == ClaimTypes.Role)?.Value;</span><br><span class="line">    <span class="keyword">if</span> (userRole == <span class="string">&quot;Admin&quot;</span> &amp;&amp; resource.HubMethodName == <span class="string">&quot;Echo&quot;</span>)</span><br><span class="line">      context.Succeed(requirement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们定义了一个<code>UserRoleRequirement</code>类，其作用是仅仅允许<code>Admin</code>角色访问<code>Echo()</code>方法。此时，为了让这个策略生效，我们还需要将其注册到容器中，如下面的代码片段所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services</span><br><span class="line">  .AddAuthorization(options =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    options.AddPolicy(<span class="string">&quot;UserRoleRestricted&quot;</span>, policy =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      policy.Requirements.Add(<span class="keyword">new</span> UserRoleRequirement());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>现在，我们可以在集线器(Hub)上控制 <code>Echo()</code> 方法访问权限，考虑到 <code>gRPC</code> 和 <code>SignalR</code> 都可以使用这套身份认证方案，所以，这个做法同样适用于 <code>gRPC</code>，如果你希望实现方法级的权限控制：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EchoHub</span> : <span class="title">Hub</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="meta">Authorize(<span class="string">&quot;UserRoleRestricted&quot;</span>)</span>]</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Task <span class="title">Echo</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> userName = Context.User?.Identity?.Name;</span><br><span class="line">    Clients.Client(Context.ConnectionId).SendAsync(<span class="string">&quot;OnEcho&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;userName&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>无独有偶，除了 SignalR ，我们还用到了消息中间件 Kafka，事实上，SignalR 会从 Kafka 拉取消息，并将其发布到订阅了该 Topic 的客户端上，所以，Kafka 在整个系统中，其实扮演着非常重要的角色。如果你只是需要让 Kafka 充当一个消息中介者，那么，你完全不需要考虑 Kafka 的身份认证问题。可一旦你考虑用 Kafka 来做具体的业务，这个问题就会立刻凸显出来。譬如，当我们用 Kafka 来实现一个分布式事务的时候，我们采用了 SAGA 模式，即让主事务负责事务的协调，每个子事务在收到主事务的消息后，执行相应的操作并回复主事务一条消息，再由主事务来决定整个事务应该提交还是回滚。如图所示，下面是一个针对 SAGA 模式的简单示意图：</p>
<p><img src="/Kafka-Distributed-Transaction.drawio.png" alt="分布式事务 SAGA 模式示意图"></p>
<p>关于这个模式的细节，感兴趣的朋友可以从 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/azure/architecture/reference-architectures/saga/saga">这里</a> 获取。这里我想说的是，当我们尝试用 Kafka 来做具体的业务的时候，我们其实是无法获得对应的用户信息的，因为此时此刻，基于 ASP.NET Core 的管道式的洋葱模型，对我们而言是暂时失效的，所以，我一直在说的非典型 Web 应用，其实可以指脱离了洋葱模型、脱离了授权&#x2F;认证流程的这类场景。和 gRPC 类似，当我们需要用户信息，而又无法获得用户信息的时候，该怎么办呢？答案是在 Kafka 的消息中传递一个令牌(Token)，下面是一个简单的实现思路：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> producerConfig = <span class="keyword">new</span> ProducerConfig &#123; BootstrapServers = <span class="string">&quot;192.168.50.162:9092&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> p = <span class="keyword">new</span> ProducerBuilder&lt;Null, <span class="built_in">string</span>&gt;(producerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="string">&quot;&lt;Your Token&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> topic = “&lt;Your Topic&gt;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    var document = new &#123; Id = &quot;</span><span class="number">001</span><span class="string">&quot;, Name = &quot;</span>张三<span class="string">&quot;, Address = &quot;</span>北京市朝阳区<span class="string">&quot;, Event = &quot;</span>喝水未遂<span class="string">&quot; &#125;;</span></span><br><span class="line"><span class="string">    var message = new Message&lt;Null, string&gt; &#123; Value = JsonConvert.SerializeObject(document) &#125;;</span></span><br><span class="line"><span class="string">    // 在 Kafka 消息头里增加 Authorization 字段</span></span><br><span class="line"><span class="string">    message.Headers = new Headers();</span></span><br><span class="line"><span class="string">    message.Headers.Add(&quot;</span>Authorization<span class="string">&quot;, Encoding.UTF8.GetBytes($&quot;</span>Bearer &#123;token&#125;<span class="string">&quot;));</span></span><br><span class="line"><span class="string">    var result = await p.ProduceAsync(topic, message);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>显然，这是非常朴素的一个想法，发送 Kafka 消息的时候，在 Kafka 的消息头里增加 <code>Authorization</code>字段，完美借鉴<code>HTTP</code>协议里的做法。那么，相对应地，消费 Kafka 消息的时候需要做一点调整，因为 Kafka 完全独立于 ASP.NET Core 的请求管道，所以，校验令牌的工作此时需要我们来独立完成。不过，请放心，这一切不会特别难，因为<code>JwtSecurityTokenHandler</code>这个类我们已经在前面用过一次：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> consumerConfig = <span class="keyword">new</span> ConsumerConfig &#123; BootstrapServers = <span class="string">&quot;127.0.0.1:9092&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> c = <span class="keyword">new</span> ConsumerBuilder&lt;Null, <span class="built_in">string</span>&gt;(consumerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">    c.Subscribe(<span class="string">&quot;&lt;Your Topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="keyword">var</span> jwtHandler = <span class="keyword">new</span> JwtSecurityTokenHandler();</span><br><span class="line">    <span class="keyword">var</span> tokenParameters = <span class="keyword">new</span> TokenValidationParameters()</span><br><span class="line">    &#123;</span><br><span class="line">      ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">      IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(<span class="string">&quot;&lt;Your Secret&gt;&quot;</span>)),</span><br><span class="line">      ValidIssuer = <span class="string">&quot;&lt;Your Issuer&gt;&quot;</span>,</span><br><span class="line">      ValidAudience = <span class="string">&quot;&lt;Your Audience&gt;&quot;</span>,</span><br><span class="line">      ValidateIssuer = <span class="literal">true</span>,</span><br><span class="line">      ValidateAudience = <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> userName = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">var</span> consumeResult = c.Consume(cts.Token);</span><br><span class="line">        <span class="keyword">var</span> headers = consumeResult.Message.Headers;</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="literal">null</span> &amp;&amp; headers.TryGetLastBytes(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">out</span> <span class="built_in">byte</span>[] values))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 校验令牌</span></span><br><span class="line">            <span class="keyword">var</span> jwtToken = Encoding.UTF8.GetString(values).Replace(<span class="string">&quot;Bearer&quot;</span>, <span class="string">&quot;&quot;</span>).Trim();</span><br><span class="line">            <span class="keyword">var</span> claimsPrincipal = jwtHandler.ValidateToken(jwtToken, tokenParameters, <span class="keyword">out</span> SecurityToken securityToken);</span><br><span class="line">            userName = claimsPrincipal.Identity.Name;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，我个人感觉，这样会增加消息消费方的工作，更好的做法是采用 <code>CallContext</code> 或者 <code>AsyncLocal</code> 来做统一的处理，这样，消息订阅方只需要关心消息怎么处理即可，考虑到 Kafka 属于 Pull 模式的消息队列，这种思路不见得在性能上有多少提升，更多的是一种简化啦，算是少写一点重复代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Subscribe</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">this</span> IConsumer&lt;TKey, TValue&gt; consumer, <span class="built_in">string</span> topic, </span></span></span><br><span class="line"><span class="params"><span class="function">  CancellationToken cancellationToken, Action&lt;TValue&gt; callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  consumer.Subscribe(topic);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> consumeResult = consumer.Consume(cancellationToken);</span><br><span class="line">      <span class="keyword">if</span> (consumeResult != <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> headers = consumeResult.Message.Headers;</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="literal">null</span> &amp;&amp; headers.TryGetLastBytes(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">out</span> <span class="built_in">byte</span>[] values))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">var</span> jwtToken = Encoding.UTF8.GetString(values).Replace(<span class="string">&quot;Bearer&quot;</span>, <span class="string">&quot;&quot;</span>).Trim();</span><br><span class="line">          <span class="keyword">var</span> userInfo = <span class="keyword">new</span> JwtTokenResloverService().ValidateToken(jwtToken);</span><br><span class="line">          UserContext.SetUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">            callback(consumeResult.Message.Value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ConsumeException e)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>UserContext</code>内部利用<code>AsyncLocal</code>在不同线程间共享用户信息，这可以让我们在任意位置访问用户信息，因为该扩展方法中会调用一次<code>SetUserInfo()</code>方法，所以，只要在 Kafka 的消息头上维护了<code>Authorization</code>字段，就可以从中解析出常用的用户信息，譬如用户名、用户角色等等。当然，按照 <a target="_blank" rel="noopener" href="https://jwt.io/">JWT</a> 的 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7519">规范</a>，我们最好还是不要在载荷(Payload)中存放敏感信息，如果需要更详细的信息，比如部门、权限等等，建议通过调接口或者查数据的库方式来实现。下面是<code>UserContext</code>的实现细节：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UserContext</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AsyncLocal&lt;UserInfo&gt; _localUserInfo = <span class="keyword">new</span> AsyncLocal&lt;UserInfo&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetUserInfo</span>(<span class="params">UserInfo userInfo</span>)</span> =&gt; _localUserInfo.Value = userInfo;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">GetUserInfo</span>()</span> =&gt; _localUserInfo.Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常的简单，对不对? 作为 <code>CallContext</code> 的继任者，<code>AsyncLocal</code>就是这样的优秀！也许，大家会好奇<code>JwtTokenResloverService</code>是什么？其实，它还是<code>JwtSecurityTokenHandler</code>那一堆东西，下面的代码片段展示了如何从<code>ClaimsPrincipal</code>中提取用户名和角色名称，再次说明，不要在这里放敏感信息：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> claimsPrincipal = _jwtHandler.ValidateToken(token, tokenParameters, <span class="keyword">out</span> SecurityToken securityToken);</span><br><span class="line"><span class="keyword">if</span> (claimsPrincipal != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">  userInfo.UserName = claimsPrincipal.Identity.Name;</span><br><span class="line">  userInfo.UserRole = claimsPrincipal.Claims.FirstOrDefault(x =&gt; x.Type == ClaimTypes.Role)?.Value;</span><br><span class="line">  <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们一开始的例子，可以简化成下面这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> consumerConfig = <span class="keyword">new</span> ConsumerConfig &#123; BootstrapServers = <span class="string">&quot;127.0.0.1:9092&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> c = <span class="keyword">new</span> ConsumerBuilder&lt;Null, <span class="built_in">string</span>&gt;(consumerConfig).Build())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">  c.Subscribe(<span class="string">&quot;&lt;Your Topic&gt;&quot;</span>, cts.Token, message =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// 获取当前用户信息</span></span><br><span class="line">    <span class="keyword">var</span> userInfo = UserContext.GetUserInfo();</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kafka 的故事，讲述到这里本该结尾，可世界上哪里会有完美的方案呢？如果考虑到 Kafka 发生消息堆积的可能性，一旦消息没有被及时处理，那么，这个放在消息头上的令牌可能会出现过期的情况。这种事情就和你使用缓存一样，如果不考虑缓存的击穿、穿透、雪崩三大灾难，那你对缓存的认知简直是肤浅。同样的道理，你要考虑令牌的过期、刷新、撤销，整个认知网络才算是真正建立起来，这些就交给我聪明的读者啦，或者以后有机会单独写一写这些话题。</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>2021年的最后一天，西安疫情可谓是涛声依旧，居家隔离、远程办公、买不到菜，注定要为这段时光写下注脚。也许，我们都习惯了饭来张口的外卖生活，可在这一刻，当一切线下互动被迫中止的时候，我们终于发现这些“典型”的生活场景变得不再“典型”；当人们开始在微信群里用接龙的方式来寻求生活物资的时候，微信这个社交工具的缺点就被不断地放大；当人们逐渐回归到一种“以物易物”的状态时，我不得不感慨这种从骨子里与生俱来的生存本能；当人们习以为常的“典型”被打破，其本身是否就是一种舒适圈？无论技术还是生活，你是否有做好随时面对“非典型”场景的准备？我想，在与新冠病毒长期对峙的后疫情时代，这是每一个人都应该去思考的问题，这篇博客断断续续地写了好几天，大概 2021 终究还是要这般潦草的过去罢。因为，我是一个长期悲观主义者，我确信这个世界依旧遵循熵增定律。如果你打算反驳，我会说：你说得对。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-12-26-githubshortcut/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-12-26-githubshortcut/" itemprop="url">GitHub 搭配快捷指令，自动记录每天的起床时间</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-26T14:03:00+00:00">
                2021-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 各位好。</p>
<p>今天想和各位分享一个有意思的小项目——用快捷指令 App 和 GitHub，自动记录每天的起床时间。  </p>
<p>这个项目源于之前介绍过的 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649917925&idx=1&sn=08dc018b0d3e65be81c1b5bc8572ce18&chksm=83a88dc8b4df04dee5b2716977fc1dba3b56a4a6952a164198d6c448335a8b4c288568b4a23c&token=1842935800&lang=zh_CN#rd">running_page</a> 作者 @yihong0618 的另外一个项目「早起记录」，它可以实现的效果如下：  </p>
<p>每天起床关闭闹钟后，触发快捷指令 App 运行程序，在 GitHub issue 下面会生成一段话，包含<strong>今天的气温、起床时间（具体到秒）、随机的一句诗</strong>。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405091835253.jpg"></p>
<p>我觉得这个小项目挺有意思的，不仅可以记录每天起床的时间，还能体会到自动化程序在我们日常生活中的应用。 </p>
<p>在项目作者 @yihong0618 老师的指导下，我也顺利了弄出了相同的程序，从此就可以记录我这只懒猪🐷的起床时间啦：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405106317511.jpg"></p>
<p>原作者 @yihong 0618 项目地址：<br><em><a target="_blank" rel="noopener" href="https://github.com/yihong0618/2021/blob/main/get_up.py">https://github.com/yihong0618/2021/blob/main/get_up.py</a></em>      </p>
<p>我的起床时间项目地址：<br><em><a target="_blank" rel="noopener" href="https://github.com/phh95/get_up">https://github.com/phh95/get_up</a></em>   </p>
<p>下面是实现自动记录起床时间的过程：  </p>
<h2 id="创建一个-GitHub-仓库"><a href="#创建一个-GitHub-仓库" class="headerlink" title="创建一个 GitHub 仓库"></a>创建一个 GitHub 仓库</h2><p>在 GitHub 上创建一个仓库，名字可以随意取，这里我将仓库取名为 get_up。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405112684921.jpg"></p>
<h2 id="复制代码"><a href="#复制代码" class="headerlink" title="复制代码"></a>复制代码</h2><p>从我的 get_up 仓库中复制 3 个文件，分别是：   </p>
<ul>
<li>.github&#x2F;workflows 路径下的 <code>get_up.yml</code> 文件</li>
<li><code>get_up.py</code> 文件</li>
<li><code>requirements.txt</code> 文件</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405113468011.jpg"></p>
<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>打开复制的 <code>get_up.py</code> 文件，定位到第 11 行代码，你可以修改中间的「懒猪🐷起床啦，赶紧去跑步，上班不迟到。」，这里的语句，决定了最终在 issue 中生成的内容，你可以将它改为你喜欢的内容。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405116523398.jpg"></p>
<p>定位到第 50 行代码，如果你每天起床的时间早于 6 点，那就需要将 6 更改为更小的数字，例如 4 或 5，这样程序才会正常运行。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405118489432.jpg"></p>
<h2 id="创建-issue"><a href="#创建-issue" class="headerlink" title="创建 issue"></a>创建 issue</h2><p>点击切换到 issues 选项卡，接着点击页面右侧的绿色按钮 <strong>New issue</strong>，创建一个 issue。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405115411040.jpg"></p>
<p>创建 issue 时，需要填入 issue 标题和内容，填入的内容可参考下图👇：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405120509132.jpg"></p>
<h2 id="获取-Token"><a href="#获取-Token" class="headerlink" title="获取 Token"></a>获取 Token</h2><p>首先打开网页 <code>https://github.com/settings/tokens</code>，点击右上角的 Generate new token，生成一个新的 Token。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16327915810978.jpg"></p>
<p>生成 Token 时，有两个注意点，将 Token 的<strong>有效期 Expiration</strong> 设置为 <strong>No expiration</strong>(长期有效)，<strong>勾选下面的所有复选框</strong>，将所有权限都打开。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405123026874.jpg"></p>
<p>生成的 Token，是一长串英文和数字混合的字符串，点击右侧的复制按钮，复制到剪贴板。  </p>
<p><strong>注意：这个 Token 后面还要用到，最好将 Token 保存到本地的 txt 或 word 文件中。</strong>  </p>
<p>打开仓库的 Settings 页面，左侧切换到 Secrets 选项卡，点击右上角的 <strong>New repository secret</strong>。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405124726993.jpg"></p>
<p>在打开的页面中，Name 输入 <strong>G_T</strong>，Value 粘贴刚复制到剪贴板的 Token。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405125338000.jpg"></p>
<h2 id="获取-GitHub-Actions-ID"><a href="#获取-GitHub-Actions-ID" class="headerlink" title="获取 GitHub Actions ID"></a>获取 GitHub Actions ID</h2><p>打开电脑的<strong>终端</strong>（Windows 系统上叫做<strong>cmd</strong> 或者 <strong>Powershell</strong>），在终端中粘贴下方的语句。   </p>
<p><code>curl https://api.github.com/repos/替换成你的GitHubId/这里替换成GitHub仓库名称/actions/workflows -H &quot;Authorization: token 这里的中文替换成GitHub仓库的Token&quot;</code></p>
<p>粘贴之前，这个语句有 3 处需要替换：  </p>
<ul>
<li>你的 GitHub ID</li>
<li>你的 GitHub 仓库名称  </li>
<li>你在前面操作中获得的 Token</li>
</ul>
<p>粘贴修改好的语句，按下 Enter 键，下方会返回 ID，这个 ID 可以复制到本地的 txt 或者 word 中，等下会用到。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/16405151424900.jpg"></p>
<h2 id="在手机上添加快捷指令"><a href="#在手机上添加快捷指令" class="headerlink" title="在手机上添加快捷指令"></a>在手机上添加快捷指令</h2><p>前面说到，让程序自动运行的触发条件是，关闭手机闹钟。  </p>
<p>因此，我们还需要在手机上进行配置，如果你的手机是 iPhone，可以使用快捷指令 App，如果是安卓手机，可以使用 tasker。</p>
<p>关于 tasker 的配置，可以参考下面的文章：</p>
<p><a target="_blank" rel="noopener" href="https://chenzaichun.github.io/post/2021-09-21-github-action-trigger-by-curl-tasker/">https://chenzaichun.github.io/post/2021-09-21-github-action-trigger-by-curl-tasker/</a>    </p>
<p>下面介绍 iPhone 上快捷指令 App 的配置： </p>
<p>扫描下方的二维码，将快捷指令添加到 App 中。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/qrcodea--a1-1.jpg" alt="QRcode_A — a1 -1-"></p>
<p>除了扫描二维码，还可以将下面的链接复制到 Safari 浏览器打开。   </p>
<p>二维码 ➡️ 链接：<a target="_blank" rel="noopener" href="https://www.icloud.com/shortcuts/703420fd5f2247a089a849f7849282c5">https://www.icloud.com/shortcuts/703420fd5f2247a089a849f7849282c5</a>  </p>
<p>添加快捷指令「早起时间 分享版」后，点击快捷指令右上角的三个小点点，进入快捷指令的配置页面。  </p>
<p>我们需要配置 4 个值： </p>
<ul>
<li>GitHub_Name：填入你的 GitHub ID </li>
<li>Rep_Name：填入你创建的仓库名  </li>
<li>GitHub_Token：填入前面获取的 Token</li>
<li>Action_ID：填入前面从终端获得的 ID</li>
</ul>
<p>配置好 4 个参数后，回到「所有快捷指令」的页面，点击快捷指令「早起时间 分享版」，程序就会自动运行。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/imga97db46ccffe1.jpeg" alt="IMG_A97DB46CCFFE-1"></p>
<p>稍等一小会，回到 GitHub 仓库的 issue 选项卡，在评论区就能见到程序运行后的结果。   </p>
<p>如果想让快捷指令在每次关闭闹钟后自动运行，可以切换到快捷指令的「<strong>自动化</strong>」页面，研究刚添加的快捷指令，在自动化里面创建一个同样的命令。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/26/img4ae19a6d29391.jpeg" alt="IMG_4AE19A6D2939-1"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">      </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-12-17-ipadapps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-12-17-ipadapps/" itemprop="url">iPad 上非常棒的 6 个应用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-17T15:12:00+00:00">
                2021-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>文&#x2F;彭宏豪，本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Qu3biF_wRllV0kb8llv-dA">效率工具指南</a>」      </p>
<p>Hello 各位晚上好。   </p>
<p>前几天在知乎上看到一个问题，「你认为最棒的前十位 iPad 应用是哪些」？</p>
<p>稍微想了下，自己在 iPad 上用过的软件也不多，从中选出 6 个，与各位分享。   </p>
<p>如果还有其他好用的 App，欢迎在留言区告诉我。     </p>
<h2 id="Procreate"><a href="#Procreate" class="headerlink" title="Procreate"></a>Procreate</h2><p>Procreate，一个非常值得购买的绘画软件。 </p>
<p>我不会画画，虽然之前用前同事的 Apple ID 账号免费下载了这个软件，但一直没打开过，因此无法分享相关的用法，只能单纯推荐。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/16392972050414.jpg"></p>
<p>软件目前更新到 5.2 版本，增加了一个硬核的功能——支持导入 3D 模型，且可以在 Procreate 给 3D 模型绘图，为模型制作材质&#x2F;贴图。  </p>
<p>有玩 3D 的朋友，可以试着把 3D 软件与 Procreate 联动起来。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/16394033006725.jpg"></p>
<h2 id="微软数学"><a href="#微软数学" class="headerlink" title="微软数学"></a>微软数学</h2><p>不像 iPhone，iPad 上没有内置计算器。  </p>
<p>为了解决这个问题，可以在 iPad 上安装微软推出的 App——微软数学。  </p>
<p>这款 App 有 3 种模式：<strong>扫描、手写</strong>和<strong>键盘</strong>，键盘就是常见的计算器，输入数字，自动得出结果。   </p>
<p>我觉得其中的手写最好玩了，在下方的区域手写想要计算的算式，经过软件识别，就可以得到相应的结果。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img0667.JPEG" alt="IMG_0667"></p>
<h2 id="Picsew"><a href="#Picsew" class="headerlink" title="Picsew"></a>Picsew</h2><p>这是一个多功能的图片处理 App，可用来：  </p>
<ul>
<li>图片拼接，例如将多张图片拼接为一张长图，弥补苹果设备无法长截图的不足     </li>
<li>图片标注，给图片添加文字或马赛克等   </li>
<li>给图片添加样机，例如给一张普通的截图加上一个 iPad 的外壳，显得更高级，效果如上一张图所示</li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img0668.PNG" alt="IMG_0668"></p>
<h2 id="ImgPlay"><a href="#ImgPlay" class="headerlink" title="ImgPlay"></a>ImgPlay</h2><p>这是一个制作 Gif 动图的 App，之前写 iPad 相关的文章时，有时会用它来制作 Gif。   </p>
<p>处理流程也很简单：先用 iPad 自带的录屏录制视频，再将视频导入 ImgPlay，去除无用的片段，就可以导出啦。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img0669.JPEG" alt="IMG_0669"></p>
<p>值得一提的是，ImgPlay 不仅支持导入视频，还支持导入静态图片、实况照片，导入后支持导出为 Gif 格式。   </p>
<h2 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h2><p>这是一个文件管理 App，可以像 iPad 自带的「文件」App 那样，查看 iPad 中存储的文件，这个是它的基本操作。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img674.JPEG" alt="IMG_674"></p>
<p>重点介绍这个 App 两个好用的功能：  </p>
<p>一个是<strong>本地视频倍速播放</strong>，最高支持 2 倍速，这解决了 iPad 相册不支持视频倍速播放的问题。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img673.JPEG" alt="IMG_673"></p>
<p>另一个是<strong>文件传输</strong>，可以很方便地在 Windows 电脑与 iPad 之间传输大文件。  </p>
<p>传输之前，先确保电脑与 iPad 处在同个局域网下，接着在电脑访问网站 docstransfer.com ，输入 App 生成的连接码，就可以开始传输文件啦。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/17/img0672.JPEG" alt="IMG_0672"></p>
<h2 id="Goodnotes"><a href="#Goodnotes" class="headerlink" title="Goodnotes"></a>Goodnotes</h2><p>最后，再放一个许多买 iPad 都会用的一类应用——笔记应用，尤其是带有手写功能的笔记应用。  </p>
<p>这类应用的选择也很多，比如非常知名的 <strong>Goodnotes</strong> 和 <strong>Notability</strong>，也有一些免费的应用，这里就不展开了。  </p>
<p>之前在一篇文章里写过，感兴趣的戳下方的链接：   </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649882277&idx=1&sn=fc34d4956d5dec0df38b8f10e1be2df3&chksm=83abfa88b4dc739e9e6e4960c0c77c6909cad1e80a58b6906c0d3222502e561661bbdec3fb13&token=1693022434&lang=zh_CN#rd">用iPad做笔记，这8款免费软件其实也挺香的。</a>        </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">             </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-12-13-mac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-12-13-mac/" itemprop="url">用苹果电脑，有时也是找罪受。</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-13T15:45:00+00:00">
                2021-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>文&#x2F;彭宏豪，本文首发于我的公众号「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_q6n1vL3ta8IXS0duABsOw">效率工具指南</a>」     </p>
<p>Hello 各位好。   </p>
<p>今天这篇文章，想来唱一下反调，讲讲使用苹果电脑 💻 一些不方便的地方。  </p>
<h2 id="PPT-中矢量文件无法取消组合"><a href="#PPT-中矢量文件无法取消组合" class="headerlink" title="PPT 中矢量文件无法取消组合"></a>PPT 中矢量文件无法取消组合</h2><p>有些我们会往 PPT 中插入公司或品牌的 logo，但同样是 logo，有些人的 logo 就高清无码，有些人的面目模糊、惨不忍睹。   </p>
<p>这两者的差别，很可能就是，一个用的是矢量格式的 logo 文件，一个用的是普通的 jpg&#x2F;png 位图文件。</p>
<p>矢量格式的优点在于，可以无限放大倍数，不会模糊失真。  </p>
<p><img src="/media/16394047144419/16394055312059.jpg"></p>
<p>你可以从 iconfont 下载 svg 格式的矢量文件，在较新版本的 Office 中，svg 文件可以直接插入 PPT 中，而不需要借助矢量软件 Adobe illustrator。  </p>
<p><img src="/media/16394047144419/16394059628897.jpg"></p>
<p>导入 svg 之后，如果你对矢量文件的配色不满意、或是想删除多余的元素，在 Windows 系统的 PPT，可以通过右键菜单的「组合 &gt;&gt; 取消组合」，将文件拆分，单独调整每个元素。   </p>
<p>但很遗憾，这一步在 Mac 上无法做到，如下图所示，「取消组合」的按钮是灰色的，处于不可用的状态。    </p>
<p><img src="/media/16394047144419/16394061290352.jpg"></p>
<p>对于这个问题，目前我找到了一种比较简单的方法——在 Mac 上安装多一个类似于 Office 的软件，例如下面要介绍的 <strong>OpenOffice</strong>。 </p>
<p>OpenOffice，是一个开源免费的办公软件，支持 Windows、macOS 和 Linux 系统。     </p>
<p><img src="/media/16394047144419/16394063642513.jpg"></p>
<p>OpenOffice 下载地址：<br><em><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/openofficeorg.mirror/">https://sourceforge.net/projects/openofficeorg.mirror/</a></em>     </p>
<p>OpenOffice 的界面如下图，开源软件最大的好处在于免费，但可能也是因为没有商业化，导致软件看起来有点复古，或者说是简陋。   </p>
<p><img src="/media/16394047144419/16394065529116.jpg"></p>
<p>说回正题，将 svg 文件直接拖拽到 OpenOffice 中，右击选择「中断」。   </p>
<p>这里的中断，等同于 Windows 系统 PPT 取消组合的操作。   </p>
<p><img src="/media/16394047144419/16394066740379.jpg"></p>
<p>接着点击左上角的保存按钮，将文件保存为 ppt 文件。   </p>
<p>在 Mac Office 上打开从 OpenOffice 导出的 ppt 文件，用鼠标框选图标，就可以看到图标拆分的所有元素了。     </p>
<p><img src="/media/16394047144419/16394079872452.jpg"></p>
<p>虽然解决方法的路径有点曲折，但庆幸还是解决了。。。   </p>
<h2 id="一个能打的-Gif-录制软件都没有"><a href="#一个能打的-Gif-录制软件都没有" class="headerlink" title="一个能打的 Gif 录制软件都没有"></a>一个能打的 Gif 录制软件都没有</h2><p>在 Windows 系统，录制 Gif 有比较多的选择：   </p>
<ul>
<li>开源免费的 ScreentoGif</li>
<li>GifCam   </li>
<li>Honeycam：收费的 Gif 录制软件，超好用，很值得入手。<strong>遗憾的是，它没有 Mac 版本</strong>。</li>
</ul>
<p>但在 Mac 上，试过几款 Gif 录制软件：</p>
<ul>
<li>GIF Brewery</li>
<li>Gifox</li>
<li>GIPHY CAPTURE</li>
</ul>
<p>对比在 Windows 上用的 Honeycam，Mac 上的这几款真的是小弟弟，没有一款可以打的。   </p>
<p>以 GIF Brewery 为例，录制之前，需要事先调整好 GIF Brewery 和下方要录制的内容的位置。  </p>
<p>但这里有个智障设计，如果临时要调整下方录制内容的位置或大小，即便 GIF Brewery 中间的窗口看起来是镂空的，你也无法直接越过镂空的区域，去拖拽或改变下方的内容，操作起来很不方便。     </p>
<p>（这里用文字描述起来有点难理解，只有对比过这两款软件，才会知道 Honeycam 有多好用） </p>
<p><img src="/media/16394047144419/16394087620347.jpg"></p>
<h2 id="软件快捷键，对不上号"><a href="#软件快捷键，对不上号" class="headerlink" title="软件快捷键，对不上号"></a>软件快捷键，对不上号</h2><p>软件快捷键，只想说说 PPT 和 PS 这两款软件。   </p>
<p>PPT 中的「组合」操作，在两个系统的对比：   </p>
<ul>
<li>Windows：Ctrl + G</li>
<li>macOS：Option + Command + G</li>
</ul>
<p>PS 中的「等比缩放」操作：   </p>
<ul>
<li>Windows：Alt + Shift  </li>
<li>macOS：Command + T，接着直接拖动控件，就是等比缩放</li>
</ul>
<p><img src="/media/16394047144419/16394095863268.jpg"></p>
<p>因为这些，如果从使用了多年的 Windows 换到 Mac 上，我觉得刚开始的作图效率，真的是大大下降。。。原先用熟产生的「肌肉记忆」，在 Mac 面前彻底无效。    </p>
<p>所以哇，买 Mac 之前，最好还是先三思一下吧。     </p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">          </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/gRPC-%E5%80%9F%E5%8A%A9-Any-%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/gRPC-%E5%80%9F%E5%8A%A9-Any-%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" itemprop="url">gRPC 借助 Any 类型实现接口的泛化调用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-10T03:53:29+00:00">
                2021-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>我发现，人们非常喜欢在一件事情上反复横跳。譬如，以编程语言为例，人们喜欢静态的、强类型语言的严谨和安全，可难免会羡慕动态的、弱类型语言的自由和灵活。于是，在过去的这些年里，我们注意到，<code>.NET</code> 的世界里出现了 <code>dynamic</code> 类型，<code>JavaScript</code> 的世界里出现了 <code>TypeScript</code>，甚至连 <code>Python</code> 都开始支持类型标注。这种动与静、强与弱的角逐，隐隐然有种太极圆转、轮回不绝的感觉。果然，“城外的人想冲进去，城里的人想逃出来”，钱钟书先生说的固然是婚姻，可世上的事情，也许都差不多罢！人们反复横跳的样子，像极了「九品芝麻官」里的方唐镜。曾经有段时间，好多人吹捧 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/">Vue3</a> + <a target="_blank" rel="noopener" href="https://www.tslang.cn/">TypeScript</a> 的技术栈，有位前辈一针见血地戳破了这种叶公好龙式的喜欢，“你那么喜欢 TypeScript，不还是关掉了 ESLint 的规则，项目里全部都用 Any”。对于这个吐槽，我表示非常真实，因为我们对于动与静、强与弱的心理变化是非常微妙的。常言道，“动态类型一时爽，代码重构火葬场”，你是如何看待编程语言里的动与静静、强与弱的呢？在 gRPC 中我们通过 Protobuf 来描述接口的参数和返回值，由此对服务提供&#x2F;消费方进行约束。此时，参数和返回值都是静态的、强类型的。如果我们希望提供某种“泛型”的接口，又该如何去做呢？所以，这篇文章我们来聊聊 gPRC 里的 Any 类型。</p>
<h1 id="Protobuf-里的-Any-类型"><a href="#Protobuf-里的-Any-类型" class="headerlink" title="Protobuf 里的 Any 类型"></a>Protobuf 里的 Any 类型</h1><p>在讲 Any 类型前，我想，我们应该想明白，为什么需要这样一个类型？现在，假设我们有下面的 <code>Protobuf</code> 定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vehicle</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="type">int32</span> VehicleId = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> FleetNo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Officer</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Officer</span> &#123;</span><br><span class="line">  <span class="type">int32</span> OfficerId = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> Department = <span class="number">2</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>此时，按照<code>Protobuf</code>的规范，我们必须像下面这样定义对应的集合：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VehicleList</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">VehicleList</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Vehicle List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OfficerList</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">OfficerList</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Officer List = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>考虑到，在<code>C#</code> 中我们只需要使用 <code>List&lt;Vehicle&gt;</code> 和 <code>List&lt;Officer&gt;</code> 即可，这样难免就会形成一种割裂感，因为你几乎要为每一种类型建立对应的表示集合的类型，从语义化的角度考虑，我们更希望使用下面的 <code>Protobuf</code> 定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Collection</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Any List = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>VehicleList</code> 和 <code>OfficerList</code> 就可以统一到 <code>Collection</code> 这个类型中，这样，不但减少了花在类型定义的时间，更能帮助我们打开一点思路。在过去，我们编写 API 的时候，通常会定义下面的类来返回结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiResult</span>&lt;<span class="title">TData</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> Msg &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> TData Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，当我们用 gPRC 来做微服务的时候，我们希望在 <code>Protobuf</code> 中沿用这个设计： </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ApiResult</span> &#123;</span><br><span class="line">  <span class="type">int32</span> Code = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> Msg = <span class="number">2</span>;</span><br><span class="line">  Any Data = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，它可以和我们在 <code>C#</code> 中的认知联系起来，不会让你有太多心智上的负担。基于上述两种诉求，我们发现， <code>Protobuf</code> 中存在着需要泛化的场景，你可以理解为，我们需要用 <code>Protobuf</code> 来表示泛型或者模板类这样的东西。幸运的是，Google 为我们定义了 <code>Any</code> 类型，它到底是何方神圣呢？我们一起来看看：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Any</span> &#123;</span><br><span class="line">  <span class="type">string</span> type_url = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bytes</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，它就是这样的朴实无华，甚至比古天乐还要平平无奇，简单来说，<code>type_url</code>字段告诉你这是一个什么类型，<code>value</code>字段里则存放对应的二进制数据，而这就是 <code>Any</code> 类型的全部秘密！</p>
<h1 id="在-NET-中使用-Any-类型"><a href="#在-NET-中使用-Any-类型" class="headerlink" title="在 .NET 中使用 Any 类型"></a>在 .NET 中使用 Any 类型</h1><p>好了，下面我们来演示，如何在 .NET 中使用 <code>Any</code> 类型。通过前面我们已经知道， <code>Any</code> 类型和我们自定义的消息没有区别，所以，它同样实现了 <code>IMessage</code> 和 <code>IMessage&lt;Any&gt;</code>两个接口，唯一不同的地方在于，它拥有<code>Pack()</code>、<code>Unpack&lt;T&gt;()</code>、<code>TryUnpack&lt;T&gt;()</code>这样几个静态方法，这是实现任意 <code>IMessage</code> 到 <code>Any</code> 相互转换的关键。现在，假设我们现在有如下的 <code>Protobuf</code> 定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">AnyRequest</span> &#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AnyResponse</span> &#123;</span><br><span class="line">  google.protobuf.Any Data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="type">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="type">string</span> Name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我们希望在 <code>AnyRequest</code> 或者 <code>AnyResponse</code> 里传递 <code>Any</code> 类型，我们可以这样做：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anyRequest = <span class="keyword">new</span> AnyRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo -&gt; Any，默认类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.Name = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar -&gt; Any, 自定义类型地址前缀</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line">bar.Name = <span class="string">&quot;Bar&quot;</span>;</span><br><span class="line">anyRequest.Data = Any.Pack(bar, <span class="string">&quot;type.company.com/bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>反过来，我们可以从 <code>Any</code> 中解析出 <code>IMessage</code> ：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.Data.Is(Foo.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Foo</span></span><br><span class="line">  <span class="keyword">var</span> foo = request.Data.Unapck&lt;Foo&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request.Data.Is(Bar.Descriptor))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Any -&gt; Bar</span></span><br><span class="line">  <span class="keyword">var</span> bar = request.Data.Unapck&lt;Bar&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的 <code>Any</code> 类型，只能对 <code>Protobuf</code> 生成的类型(即实现了 IMessage 接口)进行 <code>Pack</code> ，如果我们想做得更绝一点(最好还是不要)，那么，可以使用自定义的 <code>MyAny</code> 类型：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MyAny</span> &#123;</span><br><span class="line">  <span class="type">string</span> TypeUrl = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bytes</span> Value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，我们为 <code>MyAny</code> 类型编写一点扩展方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyAnyExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyAny <span class="title">Pack</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">object</span> obj, <span class="built_in">string</span> typeUrlPrefix = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> any = <span class="keyword">new</span> MyAny();</span><br><span class="line">        any.TypeUrl = <span class="string">$&quot;<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;obj.GetType().FullName&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(obj));</span><br><span class="line">        any.Value = Google.Protobuf.ByteString.CopyFrom(bytes);</span><br><span class="line">        <span class="keyword">return</span> any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Unpack</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> MyAny any, <span class="built_in">string</span> typeUrlPrefix = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$&quot;<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (typeUrl == any.TypeUrl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = Encoding.UTF8.GetString(any.Value.ToByteArray());</span><br><span class="line">            <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Is</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> MyAny any, <span class="built_in">string</span> typeUrlPrefix = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> typeUrl = <span class="string">$&quot;<span class="subst">&#123;typeUrlPrefix&#125;</span>/<span class="subst">&#123;<span class="keyword">typeof</span>(T).FullName&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> typeUrl == any.TypeUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以对任意类型进行处理，虽然，此时此刻，从严格意义上来讲，它已不再属于 <code>Protobuf</code> 的范畴，因为序列化&#x2F;反序列化都交给了 JSON ：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = serviceProvider.GetService&lt;ProtobufAny.Greeter.GreeterClient&gt;();</span><br><span class="line">client.Ping(<span class="keyword">new</span> Foo() &#123; Name = <span class="string">&quot;Foo&quot;</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> Bar() &#123; Name = <span class="string">&quot;Foo&quot;</span> &#125;.Pack());</span><br><span class="line">client.Ping(<span class="keyword">new</span> &#123; X = <span class="number">0</span>, Y = <span class="number">1</span>, Z = <span class="number">0</span> &#125;.Pack());</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是非常酷？我始终认为，这件事情是有意义的，一个系统中最多的接口显然是查询接口，此时，我们可以构建一个通用的 <a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/DynamicSearch">查询</a> 来处理，使用者只需要传递一个实体、一个Proto，一组过滤条件，它就可以返回对应的数据，这样是不是比写一个又一个差不多的接口要好一点呢？过去我们开发 API，主张用数据传输对象(DTO)来隔离持久化层和业务层，从这个角度来看，Protobuf 本身就是 一种 DTO ，对于大多数相似的、模板化的、套路化的接口，我们完全可以考虑用这种方案来实现，只要双方约定好类型即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在业务层构建通用的查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> QueryReply <span class="title">Query</span>&lt;<span class="title">TInput</span>, <span class="title">TOutput</span>&gt;(<span class="params">SearchParameters searchParameters</span>) <span class="keyword">where</span> TInput : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = _chinookContext.Set&lt;TInput&gt;().AsQueryable().Search(searchParameters).ToList();</span><br><span class="line">    <span class="keyword">var</span> output = result.Adapt&lt;List&lt;TOutput&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reply = <span class="keyword">new</span> QueryReply();</span><br><span class="line">    reply.List.AddRange(output.Select(x =&gt; x.Pack()));</span><br><span class="line">    <span class="keyword">return</span> reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x =&gt; &#123; 1, 2, 3 &#125;.Contains(x.AlbumId)</span></span><br><span class="line"><span class="keyword">var</span> searchParameters = SearchParameters();</span><br><span class="line">searchParameters.QueryModel = <span class="keyword">new</span> QueryModel();</span><br><span class="line">searchParameters.QueryModel.Add(<span class="keyword">new</span> Condition() &#123; Field = <span class="string">&quot;AlbumId&quot;</span>, Op = Operation.StdIn, Value = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在服务层解析参数，完全可以由调用方提供 SearchParameters</span></span><br><span class="line"><span class="keyword">var</span> inputType = Type.GetType(request.InputType);</span><br><span class="line"><span class="keyword">var</span> outputType = Type.GetType(request.OutputType);</span><br><span class="line"><span class="keyword">if</span> (inputType != <span class="literal">null</span> &amp;&amp; outputType != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> queryMethod = _queryService.GetType().GetMethod(<span class="string">&quot;Query&quot;</span>).MakeGenericMethod(inputType, outputType);</span><br><span class="line">    QueryReply queryResult = (QueryReply)queryMethod.Invoke(_queryService, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; </span><br><span class="line">      <span class="keyword">new</span> DynamicSearch.Core.SearchParameters()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Task.FromResult(queryResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>对于编程语言中的动与静、强与弱，我个人觉得还是要看场景，只要双方定义好契约，我相信，它都可以运作起来，当然，更多的时候，我们是在灵活与严谨间反复横跳。作为一门 DSL，Protobuf 虽然可以对服务提供&#x2F;消费方产生一定约束，可当我们面对需要泛型或者模板类的场景的时候，这种做法就变成了一种负担，更不必说它缺乏对继承的支持。想象一下，你要写二十多个大同小异的接口，譬如为每一张数据表写一个 <code>GetXXXById()</code> 的接口。此时，我们可以借助 <code>Any</code> 类型来实现类似泛型、模板类的东西，它本质上还是 <code> IMessage</code> 接口的实现类，唯一的不同是增加了 Pack&#x2F;Unpack 这组静态方法，可以帮助我们实现 <code>Any</code> 和 <code>IMessage</code> 的相互转换，关于本文中使用的的实例，可以参考：<a target="_blank" rel="noopener" href="https://github.com/Regularly-Archive/2021/tree/master/src/ProtobufAny">ProtobufAny</a>，好了，以上就是这篇博客的全部内容，如果有朋友对文章中的内容和观点存在疑问，欢迎在评论区积极留言，谢谢大家！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021-12-6-gitblog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021-12-6-gitblog/" itemprop="url">你可以用 RSS 订阅 GitHub 博客了</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-06T13:40:00+00:00">
                2021-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>Hello 各位晚上好。   </p>
<p>之前写过一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649917076&idx=1&sn=d20090e8fc66cd31cd93e0b978d071a6&chksm=83a882b9b4df0bafae78793b2e0b541e6fb4c5c122d8f0b315c8a24e06ad18c6ea755bf96139&token=730756799&lang=zh_CN#rd">用 GitHub Issues 来写博客</a>的文章，后来看到有一位名为 @航大 的网友，跟着我写的文章，也在 GitHub 弄了一个同样的博客。   </p>
<p>看到自己写的文章能影响到他人，这对我来说是一种非常大的激励。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/06/16387948080498.jpg"></p>
<p>不过有点遗憾的是，这位网友后来停止更新了，最新的一篇文章停在了 9 月 17 日，不知道是他比较忙、没时间写东西，抑或是忘了博客这件事。    </p>
<p>对比公众号，GitHub 博客没法知道阅读文章的人、阅读数，缺少反馈。   </p>
<p>还有更致命的一点，GitHub 博客没有很好的 Push 机制，不能很好地把新文章推送给读者。  </p>
<p>世界上最远的距离，莫过于，作者辛勤更新博客，读者却没有收到更新通知，以至于完全忘了这个博客。    </p>
<p>但是，幸好我们还有 RSS。    </p>
<p>上周看到一位网友 @frostming 给 gitblog 项目提交了一个<strong>增加 RSS 订阅</strong>的请求，项目作者 @yihong0618 将请求合并到项目中，实现了<strong>用 RSS 订阅 GitHub 博客</strong>的目的。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/06/16387959181623.jpg"></p>
<p>以我在 GitHub 创建的博客 gitblog 为例，RSS 订阅链接 🔗：   </p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/phh95/gitblog/master/feed.xml">https://raw.githubusercontent.com/phh95/gitblog/master/feed.xml</a>       </p>
<p>将 RSS 链接添加到 RSS 阅读器中，就可以看到发布在 GitHub 的博客了。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/06/16387963248007.jpg"></p>
<p>相比最初只能在 GitHub 上阅读博客，增加 RSS 订阅链接后，获取博客更新又多了一个渠道。   </p>
<p>整个流程下来，感觉：没有 RSS 订阅链接的博客，真的没有灵魂啊。     </p>
<p>本来现在就没多少人喜欢阅读文章，没了 RSS，岂不是更惨。     </p>
<p>最后，简单写一下，给 GitHub Issues 博客增加 RSS 订阅链接的方法—— </p>
<p>修改项目中的 4 个文件：   </p>
<ul>
<li>generate_readme.yml   </li>
<li>.gitignore</li>
<li>main.py   </li>
<li>requirements.txt</li>
</ul>
<p>具体修改了哪些地方？可以参考下图及对应的链接：<br><em><a target="_blank" rel="noopener" href="https://github.com/yihong0618/gitblog/commit/c8eb186406acff31a1353590770bd130ffa47359">https://github.com/yihong0618/gitblog/commit/c8eb186406acff31a1353590770bd130ffa47359</a></em>    </p>
<p>下图红色背景的代码行，代表修改前；绿色背景的代码行，代表修改后，上下两行对比着修改自己的文件，耐心一点就可以了。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/12/06/16387966420177.jpg"></p>
<h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>以上，就是本次想和你分享的内容，希望能够对你有一点帮助。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2021/05/28/gong-zhong-hao-wei-bu-er-wei-ma-dailogo.png" alt="公众号：效率工具指南">          </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><a class="extend next" rel="next" href="/page/12/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
