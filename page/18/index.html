<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/18/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/18/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/bao-ren-shao-qing-shu.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/bao-ren-shao-qing-shu.html" itemprop="url">报任少卿书</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-08T12:02:07+08:00">
                2021-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>在这里先安利一个电台<a target="_blank" rel="noopener" href="https://music.163.com/radio/?id=336387122&userid=284852689">《软件那些事儿》</a>，该电台专门讲一些科技史，主播是北大的研究生，白天打羽毛球，晚上开滴滴，偶尔在电台吹吹牛逼，风格幽默，是我在互联网上认识为数不多的有趣的灵魂，他最近开始”不务正业“讲起史记来了，刚好我最近也在读史记，自然是要收听的，他现在在讲《报任少卿书》，感兴趣可以去听听。当然了，我建议最好还是要亲自读原文。</p>
<p>此信被古人推崇为「千古第一书信」，可以用八个字来总结全文：披肝沥胆，挖心掏肺。</p>
<p>司马迁在这封信中把自己心中最深的感情和隐衷全部交代出来，告诉他的好朋友任少卿，他在「李陵之祸」中因为替李陵讲话而被判处死刑，但他因为自己人生中最重要的事情还没完成——《史记》这本书，所以他宁可选择自行宫刑，承受世间上最大的耻辱，以此苟活在这个世界上得以继续完成《史记》。现在司马迁的好朋友任少卿因为「巫蛊之祸」被判处死刑，写信给司马迁希望他再次像之前那样推贤进士——救任少卿，司马迁在这封书信中拒绝了他的请求，但他并不是因为贪生怕死，而是《史记》还没做完，他不敢再次冒这个风险。</p>
<p>这封信篇幅虽短，但可谓字字血泪，怎能不动人呢？</p>
<p>下面对一些我比较感兴趣的句子做一下解析。</p>
<blockquote>
<p>太史公牛马走司马迁再拜言</p>
</blockquote>
<p>这是原文的第一句，大概意思就是说：为《太史公》这本书可以做牛做马的司马迁再拜致意。</p>
<p>这句话是《报任少卿书》中最受争议的一句话，我们知道，太史公是一个称号，并不是一个官职，大部分时候太史公指的就是司马迁自己，少部分时候指的是司马迁的父亲，但在这里，它指的是《史记》这本书，为什么呢？</p>
<p>因为古人写书大部分都是以人物的名字作为书名，如：《孟子》、《荀子》、《韩非子》等。</p>
<p>也就是说《史记》的原名叫做《太史公》。</p>
<p>这个结论不是我瞎扯的，早在钱穆先生的《太史公考释》就有考证。</p>
<blockquote>
<p>究天人之际，通古今之变，成一家之言。</p>
</blockquote>
<p>这句话有多经典想必不用我多说，大部分熟知《史记》的人，想到的第一句话可能就是这一句。</p>
<p>但其实这句话只在《报任少卿书》中出现过，但它几乎成为了《史记》的代言词，可见《报任少卿书》的影响力，那这这句话是什么意思呢？</p>
<ul>
<li>究天人之际<ul>
<li>究：研究、缕清</li>
<li>天人：这里的「天」指的是上天注定，但不是封信迷信的那个老天爷，而是说凡人力所不可及者，谓之「天」</li>
<li>际：这里的「际」指的是两堵墙相接的边，也就是天和人的交汇。</li>
<li>所以这句话的大概意思就是说：搞清楚历史上的这些事迹，哪些是靠人的选择、哪些是靠运气，如何运用它们？</li>
</ul>
</li>
<li>通古今之变<ul>
<li>有一个句话叫做「谈古论今」，谈古是为了论今，如果讲史只是为了知道在古代什么时间什么地点发生了什么事，而对今世的我们没有一点帮助，那谈它有何用？</li>
<li>要知道，以前的史书，基本都会讲到当代史，《史记》讲汉代更是花了大部分篇幅来讲汉武帝，但从《汉书》以后，中国的史书基本只讲到上一代，不会讲当代史，这就是一个巨大的变化。</li>
</ul>
</li>
<li>成一家之言<ul>
<li>何谓「家」，这里的家不是家国的「家」，而是「儒家」、「道家」的「家」。</li>
<li>要成「家」，必然在学术上面要有自己的思想，所以司马迁他说「成一家之言」，这里的家就是：「史家」。</li>
<li>所以《史记》这本书绝不是一本单纯记载历史的书，它是一本有自己的思想、精神的书，否则他也不会一开始把这本书叫做《太史公》。</li>
</ul>
</li>
</ul>
<blockquote>
<p>人固有一死，死有重于泰山，有轻于鸿毛。 用之所趋异也。</p>
</blockquote>
<p>这句话相信大家都听过，它正是出自《报任少卿书》，正是出自这个因为判处死刑想继续存活下去，而不得不自行宫刑的司马迁，他是贪生怕死之人吗？并不是，如果他就这么死了，后世只知道他是一个被处以死刑的太史令，可能甚至根本没人知道他，所以他一定要写《史记》，后世的人才知道他到底是一个怎么样的人。</p>
<p>其实《报任少卿书》还有大量的精彩句子，它们背后隐藏着司马迁心里最深的伤痛、也代表着他为了完成《史记》甘愿忍受天下所有人的耻笑的精神。</p>
<p>但由于本人才疏学浅，没有能力把整篇讲好，所以有对中国历史或文学感兴趣的同学，强烈建议阅读这封千古第一书信。</p>
<p>另外，我认为在网络上讲《报任少卿书》最好的是吕世浩，以上大部分内容正是参考他的，感兴趣的同学可以自行到油管搜索。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/02/07/2021/use-github-actions-to-deploy-hexo-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/07/2021/use-github-actions-to-deploy-hexo-blog/" itemprop="url">使用 GitHub Actions 自动部署 Hexo 博客</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-07T04:05:38+08:00">
                2021-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>联动三年前的文章：<a target="_blank" rel="noopener" href="https://prinsss.github.io/deploy-hexo-blog-automatically-with-travis-ci/">使用 Travis CI 自动部署 Hexo 博客</a></p>
<p>今天更新了一下博客，寻思着好歹也改一下页脚的 Copyright 年份，改完 push 上去以后却发现 GitHub Pages 迟迟没有更新。进去 Travis CI 一看，发现任务一直处于 Queued 状态，半小时了都没开始构建。</p>
<p>查了一下，并不是只有我遇到了类似情况（似乎是因为 Travis CI 正在将  travis-ci.org 迁移至 travis-ci.com）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://travis-ci.community/t/builds-hang-in-queued-state/10250">Builds hang in queued state</a></li>
<li><a target="_blank" rel="noopener" href="https://travis-ci.community/t/builds-queuing-for-hours-with-public-git-repo/10351">Builds queuing for hours with public git repo</a></li>
</ul>
<p>看了一圈感觉有点悬，干脆换成 GitHub Actions 吧。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/02/07/2021/use-github-actions-to-deploy-hexo-blog/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/30/2021-01-30-us-stock-short-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/30/2021-01-30-us-stock-short-event/" itemprop="url">关于做空的一些新理解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-30T20:37:49+08:00">
                2021-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在美股市场上出了一件大新闻，散户一起对抗做空机构，最终使得做空机构亏了几十亿美金，新闻见：<a target="_blank" rel="noopener" href="https://www.laohu8.com/post/313513574">《史诗级散户血洗华尔街三天三夜！感受人民的力量吧！》</a>。</p>
<p>这件事情让我对于做空有了新的理解，分享给大家。</p>
<h2 id="什么是做空"><a href="#什么是做空" class="headerlink" title="什么是做空"></a>什么是做空</h2><p>对于不了解做空的朋友，我在这里稍微给大家解释一下什么是做空。</p>
<p>在股票市场上，做空一只股票就是从券商那里借来这只股票，然后卖掉。由于股票是借来的，所以最后还是需要买入股票，将买来的股票还给券商。做空的赢利来自于最后买入股票的时候，目标股票下跌，于是获利。</p>
<h2 id="做空保证金"><a href="#做空保证金" class="headerlink" title="做空保证金"></a>做空保证金</h2><p>做空不是随随便便都可以操作的，他需要你的帐户里面有一定的保证金。</p>
<p>我举一个具体交易的例子。假如一只股票价值 100 美金。你做空这只股票，从券商那里借入 1 股股票，把它卖掉。这个时候你的账户上马上会得到 100 美金。如果这只股票如你所愿股价下跌，那么你最后就可以以低于 100 美金的价格把它买回来还给券商。</p>
<p>但是如果这只股票最后价格还在持续上涨。由于券商要求你最后有能力将股票买回来还给他。所以你就需要往你的股票账户里面添加相应的保证金。如果股票涨到 200 美金，那么理论上你的股票账户上就应该有 200 美金的现金用于保证你能将这支股票买回来。</p>
<p>具体的保证金规则比上面的举例要复杂，但大体的规则都是随着股价上涨，帐户需要提供更多的保证金。下图是盈透证券的<a target="_blank" rel="noopener" href="https://www.interactivebrokers.com/cn/index.php?f=2432&p=stk">保证金规则</a>：</p>
<img src="/images/short-ensure.jpg" class="">

<h2 id="散户与机构的战争"><a href="#散户与机构的战争" class="headerlink" title="散户与机构的战争"></a>散户与机构的战争</h2><p>当你的保证金即将不足的时候，你就会面临券商的强行平仓。理论上做空一支股票，你的收益最高则是这个股票卖空时的价值，但这个股票如果一直上涨的话，你的理论亏损是无穷大的。假设股票卖空时值100美元，下图是收益图：</p>
<img src="/images/put-stock.jpg" class="">

<p>由于标的一直上涨，亏损会无穷大，同时没有谁的账户有无穷多的保证金，所以做空机构如果保证金不足以承担买回做空的股票时，就会被券商强制平仓。</p>
<p>强制平仓时，做空机构的钱会全部用来买回之前做空的股票。而这种行为，又会进一步推高股价。</p>
<p>所以这次做空机构公开了做空的标的后，散户选择了与做空机构对着干，核心的目的就是使机构爆仓。而这些做空机构真的被强大的人民群众的海量资金爆仓了！于是人民群众收割到了几十亿美金的收益。</p>
<h2 id="我对这种行为的理解"><a href="#我对这种行为的理解" class="headerlink" title="我对这种行为的理解"></a>我对这种行为的理解</h2><p>这件事情让我对做空产生了一个新的理解。当机构对一个股票进行做空或者散户在逼空的时候。这个公司的股票已经完全无法与他的真实价值相关联。</p>
<p>最终散户和做空机构比拼的是谁的钱多。因为当散户集体推高价格的时候，做空机构需要不停地提供账户保证金，才能保证自己不被爆仓。而只有资金多的一方可以坚持到最后。</p>
<p>输的那一方，需要交出投入到牌桌的所有的资金；而赢的一方，可以拿走所有。这一点和德州扑克倒是挺像的。</p>
<p>拿这次的事件来说，做空机构输掉的，是他们帐户里面所有的保证金。</p>
<p>当你不知道力量的双方谁的钱多的时候，这就完全是一种赌博了。但是有意思的是，这居然还是合法的。</p>
<h2 id="这种行为合法吗？"><a href="#这种行为合法吗？" class="headerlink" title="这种行为合法吗？"></a>这种行为合法吗？</h2><p>这件事情后续又出了很多衍生的事件。</p>
<p>也许是这些做空机构给券商施加了压力，这次涉及的几支股票在随后被<a target="_blank" rel="noopener" href="http://cn.dailyeconomic.com/finance/2021/01/29/23150.html">限制散户交易</a>，这在崇尚自由的美国立刻引发了质疑和诉讼，很快这些限制又被<a target="_blank" rel="noopener" href="https://www.sohu.com/a/447515639_119759">解除了</a>。</p>
<img src="/images/tiger-notice.jpg" class="">

<p>而马斯克也看热闹不嫌事大，在 Twitter 上说卖空是<a target="_blank" rel="noopener" href="https://new.qq.com/rain/a/20210129A01YXP00">合法的骗局</a>，因为特斯拉也经历过多年的做空。</p>
<img src="/images/elon-talk-about-put.jpg" class="">

<p>这种行为合法吗？在现有的法律框架下，看起来这是合法的。但是细想一下，这又似乎是一个合法的抢钱游戏，游戏规则是：谁的钱多，谁就可以抢走进场玩的其他人的所有钱。</p>
<p>我想以后任何做空机构在做空的时候，都会心有顾忌了。因为人们可能不再理性的把股票买卖当作价值投资，而是把做空机构的钱抢走做为目标。</p>
<p>在基本的道德、公平、自由的原则下，看起来应该立法规范这种行为，因为这种行为就只是一种合法的赌博，并且对社会无益。</p>
<h2 id="价值投资为什么不怕做空"><a href="#价值投资为什么不怕做空" class="headerlink" title="价值投资为什么不怕做空"></a>价值投资为什么不怕做空</h2><p>相对于做空，正常的买入股票被围猎的风险就要小很多。因为虽然股票可能长期被低估，但是你永远不用担心保证金的事情，因为拥有股票并不需要提供保证金。</p>
<p>而对于一家经营业绩良好的公司来说，它可以用分红，回购等多种手段来对抗股价的低迷。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1、做空与逼空者的游戏，是一种比拼谁钱多的，赢者通吃的赌博。</p>
<p>2、永远不要做空。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/24/%E9%80%9A%E8%BF%87Python%E5%88%86%E6%9E%902020%E5%B9%B4%E5%85%A8%E5%B9%B4%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/24/%E9%80%9A%E8%BF%87Python%E5%88%86%E6%9E%902020%E5%B9%B4%E5%85%A8%E5%B9%B4%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%95%B0%E6%8D%AE/" itemprop="url">通过 Python 分析 2020 年全年微博热搜数据</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-24T22:36:47+08:00">
                2021-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>几天前， <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994">Catcher Wong</a> 大佬告诉我，他终于写完了 2020 年的年终总结。在看完大佬的年终总结以后，我有一种“<strong>前浪被后浪拍死在沙滩上</strong>”的感觉，正如当学生时都看“<strong>别人家的孩子</strong>”，工作以后看的都是“<strong>别人的年终总结</strong>”。我们的生活，其实就是由“<strong>别人</strong>”和“<strong>我们</strong>”交织在一起，而更多的时候，是成为“<strong>大多数</strong>”的“<strong>我们</strong>”，去关注成为“<strong>少数</strong>”的“<strong>别人</strong>”。我想说的是，世间万物互为装饰，就像卞之琳在《断章》里写道，“<strong>明月装饰了你的窗子，你装饰了别人的梦</strong>”。<strong>即便一个人在历史长河中，尤如一叶飘泊不定的孤舟在波涛中摇荡，可每一朵浪花都曾以自己的方式美丽过</strong>，所以，看“别人”的生活，联想“我们”的生活，这便是我同 2020 告别的一种方式，为此，博主决定抓取 2020 年全年 366 天的微博热搜，通过可视化的方式来串联起 2020 年的回忆。</p>
<h1 id="热搜抓取"><a href="#热搜抓取" class="headerlink" title="热搜抓取"></a>热搜抓取</h1><p>首先，我们来考虑微博热搜的数据来源。 <a target="_blank" rel="noopener" href="https://weibo.com/">微博</a> 官方提供了一个热搜排行榜的页面：<a target="_blank" rel="noopener" href="https://s.weibo.com/top/summary">https://s.weibo.com/top/summary</a>，可惜这个网站只支持查看当天的热搜，显然这无法满足我们的需求。在搜索引擎的帮助下，找到了两个网站，它们分别是：<a target="_blank" rel="noopener" href="https://www.weibotop.cn/">微博时光机</a> 和 <a target="_blank" rel="noopener" href="https://www.enlightent.cn/research/rank/weiboSearchRank">热搜神器</a>。经过一番权衡，决定选择页面结构更简单一点的 <a target="_blank" rel="noopener" href="https://www.weibotop.cn/">微博时光机</a> 。</p>
<p>通过抓包，可以快速获得两个关键的接口，它们分别是 <a target="_blank" rel="noopener" href="https://www.weibotop.cn/apis/androidrouter/?versioncode=1&=&data=WyJnZXRjbG9zZXN0dGltZSIsWyIyMDIxLTAxLTIwVDIzOjA4OjAyIl1d">获取 timeId 接口</a> 和 <a target="_blank" rel="noopener" href="https://www.eecso.com/test/weibo/apis/currentitems.php?timeid=326021">获取历史热搜接口</a>。</p>
<p><img src="https://i.loli.net/2021/01/22/1pFhJkgodvP5U3G.png" alt="Firefox抓包示意图"></p>
<p>简单来说，我们指定一个日期，第一个接口会返回<code>timeId</code>。接下来，通过这个<code>timeId</code>调用第二个接口就可以获得热搜数据。仔细观察的话，第一个接口传递的<code>data</code>参数像是一个<code>BASE64</code>加密后的结果，尝试解密后发现我的猜想是对的，加密前的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;getclosesttime&quot;,[&quot;2021-01-20T23:08:02&quot;]]</span><br></pre></td></tr></table></figure>

<p>这意味着我们只需要改变这里的日期就可以啦，因此，我们的思路无非就是从 2020 年 1 月 1 日开始，依次请求热搜接口获取数据，直到 2020 年 12 月 31 日。这里想顺便吐槽下这个网站的接口设计，居然清一色地全部用数组来返回结果，难道是为了省掉这几个字段来节省流量吗？</p>
<p><img src="https://i.loli.net/2021/01/22/G9x8LiybNanBVg2.png" alt="接口返回值说明-1"></p>
<p><img src="https://i.loli.net/2021/01/22/zamj3Fntp9kbQws.png" alt="接口返回值说明-2"></p>
<p>吐槽归吐槽，这里我们可以非常容易地写出对应的代码，由于日期和<code>timeId</code>的对应关系是固定的，为了减少后续的请求数量，我们使用<code>MongoDB</code>来对数据进行持久化。同样地，抓取热搜采用了类似的方式，因为历史热搜同样是确定的数据，这里只给出关键的代码，<strong>并不代表你可以无脑地复制、粘贴</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取指定日期对应的timeId</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_timeId</span>(<span class="params">date, cookie</span>):</span><br><span class="line">    cacheKey = date.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">    records = <span class="built_in">list</span>(store.find(TABLE_TIME_ID, &#123;<span class="string">&#x27;date&#x27;</span>: cacheKey&#125;))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(records) &gt; <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> records[<span class="number">0</span>][<span class="string">&#x27;timeId&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = <span class="string">&quot;[\&quot;getclosesttime\&quot;,[\&quot;&#123;d&#125;\&quot;]]&quot;</span>.<span class="built_in">format</span>(d=cacheKey)</span><br><span class="line">        data = base64.b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        url = <span class="string">&#x27;https://www.weibotop.cn/apis/androidrouter/?versioncode=1&amp;=&amp;data=&#x27;</span> + <span class="built_in">str</span>(data, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        timeId = json.loads(data)[<span class="number">0</span>]</span><br><span class="line">        store.insert(TABLE_TIME_ID, [&#123;<span class="string">&#x27;date&#x27;</span>: cacheKey, <span class="string">&#x27;timeId&#x27;</span>: timeId &#125;])</span><br><span class="line">        <span class="keyword">return</span> timeId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定timeId对应的热搜</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weibo_trending</span>(<span class="params">timeId, cookie</span>):</span><br><span class="line">    records = <span class="built_in">list</span>(store.find(TABLE_TRENDING, &#123;<span class="string">&#x27;timeId&#x27;</span>: timeId&#125;))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(records) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> records</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">&#x27;https://www.eecso.com/test/weibo/apis/currentitems.php?timeid=&#x27;</span> + timeId</span><br><span class="line">        data = request(url, cookie)</span><br><span class="line">        data = json.loads(data)</span><br><span class="line">        trendings = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:&#123;<span class="string">&#x27;title&#x27;</span>:x[<span class="number">0</span>], <span class="string">&#x27;createdDate&#x27;</span>:x[<span class="number">1</span>], <span class="string">&#x27;updatedDate&#x27;</span>:x[<span class="number">2</span>], <span class="string">&#x27;rank&#x27;</span>:<span class="built_in">int</span>(x[<span class="number">3</span>])&#125;, data))</span><br><span class="line">        <span class="keyword">for</span> trending <span class="keyword">in</span> trendings:</span><br><span class="line">            trending[<span class="string">&#x27;timeId&#x27;</span>] = timeId</span><br><span class="line">            trending[<span class="string">&#x27;href&#x27;</span>] = <span class="string">&#x27;https://s.weibo.com/weibo?q=&#x27;</span> + trending[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">            trending[<span class="string">&#x27;createdDate&#x27;</span>] = datetime.datetime.strptime(trending[<span class="string">&#x27;createdDate&#x27;</span>], <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">            trending[<span class="string">&#x27;updatedDate&#x27;</span>] = datetime.datetime.strptime(trending[<span class="string">&#x27;updatedDate&#x27;</span>], <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        store.insert(TABLE_TRENDING, trendings)</span><br><span class="line">        <span class="keyword">return</span> trendings</span><br></pre></td></tr></table></figure>

<p>至此，我们就完成了微博热搜数据的抓取工作！</p>
<h1 id="热搜分析"><a href="#热搜分析" class="headerlink" title="热搜分析"></a>热搜分析</h1><p>好了，在采集到这些热搜数据以后，我们就可以着手准备热搜数据的分析工作啦！其实，目前这份热搜数据挺简陋的，它只有热搜话题、上榜时间、更新时间以及话题热度这样四个关键字段。而作为辅助，我们增加了热搜话题的链接，如果后续需要更详尽的信息，可能需要从这里来寻找突破口。在今天这篇博客里，我们主要从下面四个维度来分析和挖掘 2020 年全年的微博热搜：</p>
<h2 id="全年热搜热度分析"><a href="#全年热搜热度分析" class="headerlink" title="全年热搜热度分析"></a>全年热搜热度分析</h2><p>首先，我们要分析的是全年热搜的热度。何谓热度呢？我个人认为，可以从话题的使用频率和话题的持续时间两个方面来考虑，即，一个话题转发或者参与的人越多，话题持续的时间越长，则认为该话题越“热”。例如罗翔老师说 2020 年进入了“<strong>全民网课</strong>”的时代，因为“网课”是一个热门话题，而当时的背景则是因为疫情原因无法上学(班)，一时间远程会议&#x2F;办公&#x2F;教育变得炙手可热。所以，分析全年的热搜热度，可以让我们去关注每个月都发生了什么事情，而这样，我们就有了和这个世界建立联系的思绪，想想当时的你在做什么，心里又作何感想，这会是一件非常有趣的事情：</p>
<p><img src="https://i.loli.net/2021/01/26/OvqeDkFz8IRnKbc.jpg" alt="2020全年微博热搜热度变化趋势"></p>
<p>首先，我们看到的是：<strong>2020 全年微博热搜热度变化趋势</strong>。通过这张图，我们可以注意到：在 3 月份左右国内疫情得到控制以后，大家都渐渐地回归到日常的工作和生活中，相应地，人们在社交媒体上的关注是逐渐下降的，直到 7 月份以后逐渐开始出现回升。我个人认为可能与下面这件事情有关，<strong>第一，是腾讯公司因为一份虚假合同而起诉老干妈的事件；第二、因为疫情而姗姗来迟的高考推迟到了 7 月 7 日和 7 月 8 日这两天；第三、张一山、宋妍霏、阚清子、宋茜等一众明星频频登上热搜榜。</strong>对于前两个因素，可以覆盖整个 7 月份的大多数时间段；对于第三个因素，更多的是从微博这样一个泛娱乐化的平台的属性去考虑，还有什么比吃明星的瓜更开心的事情吗？再往后，我们都知道，迎来了美国大选，不管这场大选闹出了多少风波，此时此刻，终于尘埃落定。</p>
<p><img src="https://i.loli.net/2021/01/26/A2gsuvdGqCylpoP.jpg" alt="2020全年微博热搜数量变化趋势"></p>
<p>接下来，我们看到的是：2020 全年微博热搜数量变化趋势。通过这张图，我们可以注意到：热搜数量的变化趋势整体上是吻合热搜热度的变化趋势的，两者的“<strong>低谷</strong>”都出现在 7 月份，不同的是热搜数量的变化要更为“<strong>缓和</strong>”一点，这可能和新浪微博的热搜榜单有一定的关系，不知道是不是因为微博的推荐算法，决定了每个月“<strong>吃瓜</strong>”的次数是差不多的，可如果没有算法来约束这一切，完全由用户及其粉丝自行主导，这会不会演变成现实版的美国大选呢？我特别心疼那位新浪微博的研发小哥<a target="_blank" rel="noopener" href="https://weibo.com/u/2006147847">@丁振凯</a>，<strong>人生中三次遭遇热搜引发的“宕机”：结婚时撞上鹿晗公布恋情，海外度假时撞上双宋官宣、老婆待产撞上华晨宇承认和张碧晨未婚生有一女，简直永远都在扩容的路上</strong>，被誉为“<strong>史上最惨新浪程序员</strong>”一点都不冤枉啊……</p>
<h2 id="全年热搜情感分析"><a href="#全年热搜情感分析" class="headerlink" title="全年热搜情感分析"></a>全年热搜情感分析</h2><p>李诞在 2020 年年底策划了一期反跨年晚会，从头到尾都是脱口秀这种“语言类”节目，在这期节目里，有人以毛不易的“歌词”调侃了 2020 年大家的心境变化，从“<strong>像我这样优秀的人</strong>”到“<strong>消愁</strong>”，有时候打脸就是这么的猝不及防。坦白来说，我有段时间过得特别“<strong>丧</strong>”，“<strong>丧</strong>”到要靠《当幸福来敲门》来打鸡血。那么，整个 2020 年“<strong>活</strong>”在热搜里的人们的心态变化又是怎么样的呢？所以，接下来我们通过 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 对 2020 年全年的热搜话题的情感倾向进行分析，到底大家是过得“<strong>积极</strong>”还是“<strong>消极</strong>”呢，让我们一起拭目以待，为了达到更好的效果，博主提前对 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 进行了训练，因为 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a> 自带的语料库主要是电商评论，与我们此刻的场景多少有一点差异。</p>
<p><img src="https://i.loli.net/2021/01/26/gCcHX7vWlwsZhnI.jpg" alt="2020全年微博热搜情感变化趋势"></p>
<p>果然，2020 年真的是“<strong>丧</strong>”到家啦，366 天里平均置信概率在 0.5 以上的堪称寥寥啊。我有时候会想，我们常常希望在感情中有足够的安全感，希望对方可以“懂”我。诚然，我可以从一个人的朋友圈、微博去分析对方的情感变化，可身为人类的我们，并不是冷冰冰的计算机器。多年后，当我懊恼于曾经没有进行及时的沟通的时候，我静静地坐在电脑面前，你说这些字里行间没有透露出足够充足地信息，可我们依然有办法去反映过去一年里的喜怒哀乐。世事无常，每天都开开心心地面对，固然是心向往之，而生命中更朴实无华地大多数时刻，其实就是此刻如白开水一般索然无味，如果理性的思维最终还是要输给感性的直觉，我希望我可以两者兼有之，今年可能要在外地一个人度过春节啦，希望我的心情可以超过 0.5 呢……</p>
<h2 id="全年热搜词云分析"><a href="#全年热搜词云分析" class="headerlink" title="全年热搜词云分析"></a>全年热搜词云分析</h2><p>其实，在做这个分析的时候，我一直在想，也许“<strong>新冠</strong>”或者“<strong>疫情</strong>”这样的字眼会成为 2020 年的共同记忆吧！至少对博主这样即将步入中年的 90 后而言，这场疫情留下的深刻记忆丝毫不亚于 08 年的汶川地震。可转念间又安慰自己道，相比国外愈演愈烈的疫情，我们在三月份左右的时候就基本得到了控制，如果说互联网是没有记忆的，人们对这一切应该会遗忘地非常快，就像这热搜榜上的话题，简直是“你方唱罢我登场”。可惜，互联网的确是有记忆的，即使过去了整整一年，这一切还是通过数据被挖掘出来。这里，我们通过结巴分词对热搜话题进行分词，再通过这些关键词来绘制词云。对于这个结果，突然就变得感性起来，可能这就是所谓的“冥冥之中自有天意”吧，甚至对于 2021 年来说，<strong>疫情</strong>目前依然是人们关注的热搜话题：</p>
<p><img src="https://i.loli.net/2021/01/22/dTVD9lNIP4OwefC.png" alt="2020年全年微博热搜关键词词云"></p>
<h2 id="全年热搜人物分析"><a href="#全年热搜人物分析" class="headerlink" title="全年热搜人物分析"></a>全年热搜人物分析</h2><p>曾经在知乎上读到过这样一句话，“<strong>人们宁愿去关心一个蹩脚电影演员的吃喝拉撒和鸡毛蒜皮，而不愿了解一个普通人波涛汹涌的内心世界</strong>”，这句话如果放到 2020 年的语境中，或许就是，人们在危难的时候会突然关心“<strong>国士无双</strong>”，而在安稳的时候则会更关注“<strong>娱乐八卦</strong>”，考虑到新浪微博是借鉴新浪博客的“名人效应”而起家，所以，我更关心在过去一年里有哪些人都登上过热搜。说实话，我挺怀念某位七十多岁高龄的老人，他和我奶奶差不多同龄，在这个“丧”如此普遍的年代，他带给了我们多少欢乐啊，虽然我预感到会有许多明星靠着“<strong>否认</strong>”、“<strong>道歉</strong>”、“<strong>心疼</strong>”、“<strong>回应</strong>”、“<strong>声明</strong>”等等字眼而登上热搜，可我还是想知道答案啊……</p>
<p><img src="https://i.loli.net/2021/01/25/ZV2zgo7Ssi6XFL8.png" alt="2020全年微博热搜上榜人物分析.png"></p>
<p>果然，“<strong>说曹操曹操到</strong>”，2020 年以压倒性优势多次登上微博热搜的，居然真的是前美国总统特朗普。虽然说这位美国前总统喜欢孜孜不倦地发推特，史称“<strong>推特治国</strong>”，可在一个某明星代孕风波快速令“<strong>拼夕夕</strong>”事件烟消云散的社交平台上，这位老人能频频进入我们的视野，大概就能说明过去一年里国际形势的风起云涌。我们嘲笑他为“懂王”，甚至“亲切”地称之为“川建国”同志。<strong>有一段时间里，好像每一个人都觉得自己比这位老人更会做总统；同样地，好像每一个人都觉得自己比张小龙更懂得微信</strong>。我无意讨论政治相关的东西，可我依然感谢这位老人在疫情期间带给我们的欢乐，因为我并不觉得，他像媒体眼中的那样滑稽而愚蠢，一个能在商人、明星和总统多重身份中切换自如的人，无论如何会都有他的过人之处，疫情这件事情，换一个人来当这个总统未必会做得比他好。回过头来看，他在 2020 年都做了哪些事情呢？</p>
<p><img src="https://i.loli.net/2021/01/25/9FL8ZMc6blYjy5u.png" alt="2020年特朗普的微博热搜"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>其实，在规划这篇博客的时候，我一直在想，该以一种什么样的心态去回顾 2020，因为当我看着“<strong>别人</strong>”的年终总结的时候，总有一种难以言说的失落感。一方面，时间在不经意间匆匆逝去，身边的一切都在刻意地想你强调着“<strong>物是人非</strong>”。而另一方面，你需要去面对诸如买房、结婚这种所谓“<strong>某某年龄应该去做的事情</strong>”。当我看到身边的同事，整天坐在一起讨论的无外乎是房子、车子、股票等一切所谓“投资”的事情的时候，我时而会觉得他们有一点枯燥，就是那种我们曾经都不愿意成为的“中年人”。等翻过年，我即将迎来我的 29 岁，可令人心动的 Offer 里的“<strong>背水辉</strong>”一样的被嫌弃的年纪，而距离 IT 行业所谓的“<strong>35 岁</strong>”门槛还剩下年时间。</p>
<p>虽然给自己订了几个目标，可有时候难免会感到懈怠，尤其是当你意识到你再无法抓住某一样东西的时候，或许，你唯一的能做的事情，就是让自己永远不要忘记吧！写数据挖掘相关的内容，不管是在数据的抓取还是分析阶段，都需要投入大量的精力去试验，结合实际去调整写作的方向，在这篇博客中甚至还花了大量时间去训练 <a target="_blank" rel="noopener" href="https://github.com/isnowfy/snownlp">SnowNLP</a>。“<strong>悟已往之不谏，知来者之可追</strong>”，2021 年 flag 我在心里记下来，我不想写出来，因为我怕到时候脸会疼，如果大家觉得这篇博客对你有帮助，欢迎<strong>点赞</strong>和<strong>收藏</strong>，如果可以<strong>一键三连</strong>，那就更好啦！2020，再见！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/post/87ba8d8b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/87ba8d8b.html" itemprop="url">从 Composition API 源码分析 getCurrentInstance() 为何返回 null</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-16T22:39:55+08:00">
                2021-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果同学们已经开始使用 Composition API，那么我们可能都会遇到类似的问题，那就是有时候我们调用 <code>getCurrentInstance()</code> ，它返回的居然是 <code>null</code> ，举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase&quot;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    defineComponent,</span></span><br><span class="line"><span class="language-javascript">    ref,</span></span><br><span class="line"><span class="language-javascript">    getCurrentInstance</span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/composition-api&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">useIncrease</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 假设我们还要访问当前实例来做些什么</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">getCurrentInstance</span>().<span class="property">doSomething</span> <span class="comment">// 但 getCurrentInstance() 返回的是 null</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      count,</span></span><br><span class="line"><span class="language-javascript">      increase</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> &#123; count, increase &#125; = <span class="title function_">useIncrease</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        count,</span></span><br><span class="line"><span class="language-javascript">        increase</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或许有些同学已经知道，只要我们把该方法的调用摆到外面，那它就能正常工作了：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function useIncrease() &#123;</span><br><span class="line"><span class="addition">+  const vm = getCurrentInstance()</span></span><br><span class="line">  const count = ref(0)</span><br><span class="line"></span><br><span class="line">  function increase() &#123;</span><br><span class="line">    count.value++</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   getCurrentInstance().doSomething</span></span><br><span class="line"><span class="addition">+   vm.doSomething // 这时能够正常访问</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    count,</span><br><span class="line">    increase,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外其实不止 <code>getCurrentInstance()</code> ，还有诸如： <code>useStore</code> 、 <code>useRouter</code> 这些跟 Vue 实例沾边的都会有这个问题，不过本文只讨论 <code>getCurrentInstance()</code>，至于其它这些我不太清楚，所以不敢乱下结论。</p>
<p>我之前对此一直没怎么深究，满足于知道这样做能使它正常工作就足够了。但是，当我今天看到这篇文章《<a target="_blank" rel="noopener" href="https://juejin.cn/post/6917592199140458504">使用 Vue3 的 CompositionAPI 来优化代码量</a>》的时候，里面也提到了一样的问题，只是这位同学认为像 <code>getCurrentInstance()</code> 方法只能在 <code>setup()</code> 中调用，而无法在外部的 <code>hooks</code> 方法中调用时，我意识到这个问题必须得讲清楚，否则会造成很多误解。</p>
<p>但当我想在评论区提醒一波时，我发现其实我也不清楚背后的缘由，索性就趁此机会，好好了解一下为什么会有这么神奇的事情。毕竟，只知道能工作的解决方法是不够的，还要知道它为什么会这样。</p>
<p>但 Google 一番，发现没有对这个问题做太多解读（难道这件事不值得疑惑吗？），从 Composition API 官方仓库的 <a target="_blank" rel="noopener" href="https://github.com/vuejs/composition-api/issues/455">issue</a> 中，也只是给出了与上面类似的解决方案，但并没有说为什么要这样，对此我就更加疑惑了。</p>
<p>所以，本文就来分析一下，到底为什么在不同的位置调用 <code>getCurrentInstance()</code> 得到的结果会不一样呢？</p>
<h2 id="太长不读"><a href="#太长不读" class="headerlink" title="太长不读"></a>太长不读</h2><p>为了不浪费同学们宝贵的时间，我先把重点放到前面，首先是到底什么时候才能访问通过 <code>getCurrentInstance()</code> 当前实例：</p>
<ol>
<li>只要在 <code>setup()</code> 内部调用的任何方法，都能获取到当前实例，无论函数调用栈有多深</li>
<li>但只能在同步代码中才能访问，其它的诸如 <code>setTimeout</code>、 <code>DOM 事件</code> 、 <code>Promise</code> 这类异步代码均无法访问（建议再回头看看上面的例子</li>
</ol>
<p>无法访问的原因是：</p>
<ol>
<li>Composition API 会在调用组件的 <code>setup()</code> 前，先拿一个变量存放当前实例，以供调用 <code>getCurrentInstance()</code> 时返回，源码：<a target="_blank" rel="noopener" href="https://github.com/vuejs/composition-api/blob/master/src/mixin.ts#L95">mixin.ts#L95</a> 和 <a target="_blank" rel="noopener" href="https://github.com/vuejs/composition-api/blob/master/src/utils/instance.ts#L116">instance.ts#L116</a></li>
<li>执行完 <code>setup()</code> 以后，会把用于存放当前实例的变量值恢复到以前的模样（也就是 <code>null</code> ），源码：<a target="_blank" rel="noopener" href="https://github.com/vuejs/composition-api/blob/master/src/utils/instance.ts#L126">instance.ts#L126</a></li>
<li>所以，当 Composition API 内部执行到我们组件的 <code>setup()</code> 时，所有的同步代码都能访问到当前实例，但那些异步代码再去访问时，它已经恢复成 <code>null</code> 了。</li>
</ol>
<p>好了，就是这么简单，相信同学们下次再遇到这种问题时，就不会疑惑为什么 <code>getCurrentInstance()</code> 会返回 <code>null</code> ，因为我们知道背后的运行逻辑。</p>
<p>结论说完了，下面开始分享一下我分析这个问题的整个过程，也希望能对同学们有一些启发。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>想知道问题的所在，最直接的方法就是看源码，但是直接 clone 项目下来从头看，显然不及通过打断点来得高效，毕竟我们现在的目的还不是学习它的源码设计，只是想知道它其中一部分的运行逻辑。</p>
<p>我们用下面的代码来做例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; defineComponent, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/composition-api&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">debugger</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getCurrentInstance</span>())</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">debugger</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getCurrentInstance</span>())</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们在两处调用的地方之前都加了一个断点， 先看看它们执行起来有何不同。</p>
<p>第一次调用的内部是这样的，这时候它能够访问：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/image.png"></p>
<p>而第二次调用的内部是这样的，这时候它已经变成了 <code>null</code> ：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224432.png"></p>
<p>可以看到 <code>getCurrentInstance()</code> 的内部非常简单，只是将 <code>currentInstance</code> 给返回出来了，而这个变量显然是在外部定义的，那为什么两次调用，它的值就发生了变化呢？</p>
<p>我们留意到断点进来的文件是：vue-composition-api.esm.js，那我们直接在 <code>node_modules</code> 下打开这个文件，先搜索一下有哪些地方修改了 <code>currentInstance</code> 这个变量，根据上图就能看到是通过 <code>setCurrentInstance()</code> 方法来修改，于是我们搜索一下这个方法的调用：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224450.png"></p>
<p>可以看到一共有四处（其中一处是定义），但是光靠肉眼看也很难看出来什么，所以还是老方法，在每个调用之前加一个断点（是的，我们可以直接修改 <code>node_modules</code> 下的代码来进行调试），然后我们发现第一次调用是在 <code>activateCurrentInstance</code> ：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224510.png"></p>
<p>这时候我们仔细看看这个方法的内部，就能看出些端倪：</p>
<ol>
<li>上图显示 <code>preVm</code> 是一个 <code>null</code></li>
<li>而 <code>vm</code> 是一个 Vue 的实例</li>
<li>执行完 <code>fn(vm)</code> 后，又将 <code>preVm</code> 传入到 <code>setCurrentInstance()</code> 去了</li>
</ol>
<p>所以，我们看看这个 <code>fn(vm)</code> 内部是什么，搜索 <code>activateCurrentInstance()</code> 的调用，发现一个很可疑的地方：</p>
<p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20210116224526.png"></p>
<p>很明显这里就是执行组件 <code>setup()</code> 函数的地方，再结合上图来看，我们得出结论：</p>
<ol>
<li>在执行组件 <code>setup()</code> 函数前，先把当前实例存放起来</li>
<li>然后执行组件 <code>setup()</code> 函数时， <code>setup()</code> 函数内部自然就能通过 <code>getCurrentInstance()</code> 访问当前实例了</li>
<li>等执行完 <code>setup()</code> 后，又将 <code>currentInstance</code> 重置回 null 去了（注意是同步执行 <code>setup()</code></li>
<li>后面 <code>setup()</code> 内部的异步代码再去调用 <code>getCurrentInstance()</code> ，其实已经是 <code>null</code> 了</li>
</ol>
<p>如果还不太理解的同学，建议先补一下 JavaScript 的：事件循环、同步、异步、宏任务、微任务这些概念。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个分析过程就结束了，你可能也会觉得很简单，我觉得你上你也行，所以不要觉得这些底层库的运行原理很难捉摸，出了问题也先别一味抱怨或者尝试各种 HACK，为何不直接看看它的运行逻辑呢？</p>
<p>所以，大胆 debug 吧，少年。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/14/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%A0%E7%9A%84Python%E7%88%AC%E8%99%AB%E6%8F%90%E9%80%9F%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E7%A7%8D%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/14/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%A0%E7%9A%84Python%E7%88%AC%E8%99%AB%E6%8F%90%E9%80%9F%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E7%A7%8D%EF%BC%9F/" itemprop="url">使用多线程为你的 Python 爬虫提速的 N 种姿势，你会几种？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-14T20:35:47+08:00">
                2021-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>最近博主在优化一个爬虫程序，它是博主在 2017 年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进 30 岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关键的环节，所以，整个优化的核心，无外乎提升程序的稳定性、提高抓取速度。所以，接下来，我会带大家走近 Python 中的多线程编程，涉及到的概念主要有<code>线程(池)</code>、<code>进程(池)</code>、<code>异步I/O</code>、<code>协程</code>、<code>GIL</code>等，而理解这些概念，对我们而言是非常重要的，因为它将会告诉你选择什么方案更好一点。想让你的爬虫更高效、更快吗？在这里就能找到你的答案。</p>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>现在，假设我们有一组图片的地址(URL)，我们希望通过<code>requests</code>来实现图片的下载，为此我们定义了<code>Spider</code>类。在这个类中，我们提供了<code>getImage()</code>方法来完成下载这个动作。我们可以非常容易地写出一个“单线程”的版本，但这显然这不是我们今天这篇博客的目的。此时，我们来考虑一个问题，怎么样实现一个“多线程”的版本？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, urls</span>):</span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = fake_useragent.UserAgent().random</span><br><span class="line">        self.session.headers[<span class="string">&quot;Referer&quot;</span>] = <span class="string">&quot;https://www.nvshens.org&quot;</span></span><br><span class="line">        self.urls = urls</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getImage</span>(<span class="params">self, url, fileName, retries=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">            response = self.session.get(url, </span><br><span class="line">              allow_redirects=<span class="literal">False</span>, </span><br><span class="line">              timeout=<span class="number">10</span>, </span><br><span class="line">              proxies=<span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">            data = response.content</span><br><span class="line">            imgFile = <span class="built_in">open</span>(fileName, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">            imgFile.write(data)</span><br><span class="line">            imgFile.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">                retries -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.getImage(url, fileName, retries):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h1 id="线程与线程池"><a href="#线程与线程池" class="headerlink" title="线程与线程池"></a>线程与线程池</h1><p>既然提到了线程，我们会非常自然地想到 <code>Thread</code> 和 <code>ThreadPool</code> ，而这几乎是所有编程语言里都有的通用型概念。可是，Python 中的多线程其实是一种“假”的多线程，这又从何说起呢？答案是<strong>全局解释器锁</strong>(<strong>GIL</strong>)，原来在设计 Python 解释器的时候，为了保证同时只有一个线程在运行，引入了这样一个锁，你可以类比游戏开发时主循环的概念来辅助理解。那为什么又说 Python 中的多线程是一种“假”的多线程呢？这是因为它没法发挥出多核的优势，每个线程在执行前都要先获得 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock">GIL</a> ，这就导致一个问题，即使你有多个核心，线程永远只能用到其中一个核，因为多线程在 Python 中只能交替执行。以一言蔽之， Python 中 I&#x2F;O 密集型任务相比 CPU 密集型任务更能充分发挥多线程的好处。所以，像爬虫这种和网络打交道的事物，是非常适合使用多线程来提高效率的。在这里，我们我们要介绍的是 <code>Thread</code> 和 <code>ThreadPool</code> 以及 <code>ThreadPoolExecutor</code>。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>首先，我们需要了解的是，Python 中的 Thread ，实际上先后有<code>thread</code>和<code>threading</code>两种模块，它们的关系有一点像 .NET 里的<code>Thread</code>和<code>Task</code>，考虑到<code>thread</code>的使用频率非常低，这里我们更推荐大家使用<code>threading</code>，它提供了更高级的、完全的线程管理。例如，我们现在面临的这个“多线程”下载的问题，使用<code>threading</code>的话可以这样解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Thread下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThread</span>(<span class="params">self</span>):</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.urls)):</span><br><span class="line">        thread = threading.Thread(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>,)</span><br><span class="line">        )</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thread.start()</span><br></pre></td></tr></table></figure>
<p>可以注意到，当我们需要构造一个线程时，只需要指定<code>target</code>和<code>args</code>两个参数，其中，前者是指线程执行的方法，后者是指传递给线程所执行的方法的参数。当我们需要启动线程时，只需要调用线程的<code>start()</code>方法，而通过<code>setDaemon()</code>方法则可以设置一个线程为守护线程。关于守护线程，这里简单说明一下，一旦一个线程被设置为守护线程，那么，只要线程执行的方法中存在等待时间譬如<code>time.sleep(1)</code>，此时等待时间下面的代码都不会再执行。如果线程中执行的方法是一个耗时的操作，此时，我们还可以通过<code>join()</code>方法来阻塞主线程，以确保主线程再子线程执行完后再结束。除了这种函数式的使用方法以外，我们还可以通过继承<code>Thread</code>类并重写其<code>run()</code>方法的方式，对于这一点可以参考官方文档中的<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/threading.html#thread-objects">线程对象</a>。</p>
<p><img src="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png" alt="使用Thread下载"></p>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>对于线程，我们都知道它是作为一种系统资源而存在的，所以，和这个世界上的大多数资源一样，无法供我们肆意地挥霍和浪费。在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2414960312/">.NET Core 中对象池(Object Pool)的使用</a> 这篇博客中，我曾经大家介绍过“对象池”这种设计，和这篇博客中所提到的原理一样，线程池相对于普通线程而言多了一种可复用的可能性，这意味着我们可以用有限的线程来下载可能无限多的图片资源。在 Python 中我们使用 <code>threadpool</code> 模块来实现线程池的功能，需要注意的是这是一个第三方的模块。下面，我们来一起看看具体的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPool下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThreadPool</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append((<span class="literal">None</span>, &#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = threadpool.ThreadPool(poolSize)</span><br><span class="line">    requests = threadpool.makeRequests(self.getImage, args)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure>
<p>在这里，我们声明了一个指定大小的线程池，通过一个方法<code>getImage()</code>和一组参数<code>args</code>来构造“请求”，再将这些请求全部放进线程池里，此时，线程池会自动等待这些“请求”执行完毕。这里唯一比较难理解的，可能是如何构造参数<code>args</code>，尤其是当被执行的方法需要传递多个参数的时候。其实这里有两种传参的方式，第一种是按数组来解构，此时我们可以写<code>[([&#39;&#39;,&#39;&#39;], None), ([&#39;&#39;,&#39;&#39;], None)]</code>；而第二种则是按字典来解构，此时我们可以写<code>[(None, &#123;&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;&#125;), (None, &#123;&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;&#125;)</code>。两者的区别主要在<code>None</code>的位置，不知道大家有没有发现规律。这里我们准备了张图片，而线程池最大线程是 3 个，理论上某个线程会被重复使用，实际结果又是如何呢？</p>
<p><img src="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png" alt="使用ThreadPool下载"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>对于<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a>，相信不用我多说什么，你就能知道它是做什么的吧，这就是博主反复提及的命名规范的问题。简而言之，Python 在 <code>concurrent.futures</code>中为我们提供了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor">ProcessPoolExecutor</a> 两个高级接口，它们都继承自同一个抽象类<code>Executor</code>，它可以让我们在线程池或者进程池中异步地执行回调函数，属于官方提供的标准的“<strong>线程池</strong>”和“<strong>进程池</strong>”模块，下面，我们来一起看看具体的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPoolExecutor下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThreadPoolExecutor</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">      args.append(&#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=poolSize)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        task = pool.submit(self.getImage(arg[<span class="string">&#x27;url&#x27;</span>], arg[<span class="string">&#x27;fileName&#x27;</span>]), arg)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    wait(tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    <span class="comment"># tasks = pool.map(lambda arg:self.getImage(arg[&#x27;url&#x27;], arg[&#x27;fileName&#x27;]), args)</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，<code>submit()</code>方法和<code>map()</code>方法的区别，前者相当于声明线程后并不立即执行，故而，需要<code>wait()</code>方法来等待所有任务执行结束；而后者则相当于声明线程并理解执行，故而，返回值实际是每一个任务执行的结果的集合，这里就隐隐有一点 .NET 中 <code>Task</code> 的味道啦！同样地，我们给了一个最大线程数：3，它能否得到和<code>threadpool</code> 类似的结果呢？我们拭目以待：</p>
<p><img src="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png" alt="使用ThreadPoolExecutor下载"></p>
<h1 id="进程与进程池"><a href="#进程与进程池" class="headerlink" title="进程与进程池"></a>进程与进程池</h1><p>看到这里，可能有读者朋友会忍不住吐槽，博主你三十岁不到，怎么越来越糊涂了啊，你这博客标题明明写的是多线程，怎么写着写着就写到进程上来了呢？其实，这里是紧接着 GIL 这个话题来讲的。既然 Python 中的多线程更适合 I&#x2F;O 密集型的任务，那么，是不是说 Python 不适合处理 CPU 密集型的任务呢？答案是否定的，我们这里将多进程理解为并行就会更容易想明白一点。我们都知道操作系统可以同时执行多个任务，而这每一个任务其实就是一个进程，而每个进程内又可以同时执行多个子任务，这每一个子任务其实就是一个线程。这样说，我们或许就能明白，这意味着，如果我们的确需要并行地去处理某些任务，进程(池)或许是个不错的选择。同样地，这里介绍的是，<code>Process</code>、<code>ProcessPool</code> 和 <code>ProcessPoolExecutor</code>。</p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>关于进程，我个人感觉比线程要更好理解一点，因为不论是 Windows 下的任务管理器，亦或者是我们经常听到的“杀进程”，它都不算是一个特别陌生或者抽象的概念，而线程这种东西呢，大概是只有程序员会关注，同时爱之弥深、恨之弥切的一种事物。庆幸的是，在 Python 中线程与进程在代码的编写上是非常相似的，这里我们需要用到的是<code>multiprocessing</code>模块，下面，我们来一起看看 Python 中的进程的的使用方法，你会发现只需要改一下<code>threading.Thread()</code>这部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Process下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcess</span>(<span class="params">self</span>):</span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.urls)):</span><br><span class="line">        proc = multiprocessing.Process(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>,)</span><br><span class="line">        )</span><br><span class="line">        process.append(proc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process:</span><br><span class="line">        proc.start()</span><br></pre></td></tr></table></figure>
<p>此时，我们可以得到下面的结果，可以发现它都是在主线程上运行：</p>
<p><img src="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png" alt="使用Process下载"></p>
<h2 id="ProcessPool"><a href="#ProcessPool" class="headerlink" title="ProcessPool"></a>ProcessPool</h2><p>既然有“线程池”，又怎么能少得了进程池呢？同样地，它位于<code>multiprocessing</code>模块中，通过<code>apply()</code>方法来执行某个任务，下面是一个基本的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用multiprocessing.Pool()下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcessPool</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append((self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>, ))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = multiprocessing.Pool(poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.apply(self.getImage, arg)</span><br></pre></td></tr></table></figure>

<p>有朋友难免会好奇“进程池”和“线程池”有什么不一样，我想，下面这张图会告诉你答案：</p>
<p><img src="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png" alt="使用multiprocessing.Pool()下载"></p>
<h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p>和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a> 类似，我们还可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor">ProcessPoolExecutor</a> 来实现“进程池”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ProcessPoolExecutor下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcessPoolExecutor</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append(&#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.submit(self.getImage(arg[<span class="string">&#x27;url&#x27;</span>], arg[<span class="string">&#x27;fileName&#x27;</span>]), arg)</span><br></pre></td></tr></table></figure>

<p>可以看到，“进程池”中的代码都是在主线程上执行的，这一点和<code>multiprocessing.Pool()</code>完全一致：</p>
<p><img src="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png" alt="使用ProcessPoolExecutor下载"></p>
<h1 id="协程与异步-I-O"><a href="#协程与异步-I-O" class="headerlink" title="协程与异步 I&#x2F;O"></a>协程与异步 I&#x2F;O</h1><p>其实，如果单单从 I&#x2F;O 密集型和 CPU 密集型两种场景而言，这篇博客到这里就差不多应该结束啦！不过呢，博主好奇 Scrapy 这个爬虫框架的实现原理，发现它是基于 Twisted 这样一个异步网络框架，考虑到目前为止，我们通过 <code>requests</code> 来下载图片都是采用同步的方式，除了任务调度上的优化以外，任务本身还存在一定的优化空间，所以，这里就顺带着一起整理出来，这里主要结合 <code>asyncio</code> 和 <code>requests</code> 来对 Python 中关于异步 I&#x2F;O 、协程等的使用方法进行演示和说明。</p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio.html">asyncio</a> 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async&#x2F;await</strong> 语法，它是构建 I&#x2F;O 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。它提供了类似并发地执行<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine">协程</a>、网络 I&#x2F;O 和进程间通信(<strong>IPC</strong>)、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-eventloop.html#asyncio-event-loop">事件循环</a>等等的能力，例如，我们可以通过下面的代码来创建和使用<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine">协程</a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">what, delay</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># Python 3.7 + </span></span><br><span class="line">asyncio.rum(main())</span><br><span class="line"><span class="comment"># Python 3.7 -</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>参考官方文档，我们还可以使<code>create_task()</code>方法来创建<code>asyncio</code>的并发任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Python 3.7 + </span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># Python 3.7 -</span></span><br><span class="line">    task1 = asyncio.get_event_loop().(say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.get_event_loop().(say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>这是因为 Python 中的协程、任务 和 Future 都是可等待对象，故而，凡有 <strong>async</strong> 处皆可 <strong>await</strong> ，果然，主流编程语言的最终走向是如此的一致啊，回头想想 .NET 中 Thread 、 ThreadPool 、 Task 的进化历程，是不是有种“<strong>天下大势，分久必合</strong>”的感觉呢？</p>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>好了，当我们对异步 I&#x2F;O、协程有了一个基本的了解以后，我们就可以考虑结合着 <code>requests</code> 来做一点小小的尝试，我们大多数时候写的 <code>requests</code> 相关的代码，基本上都是博主这里<code>getImage()</code>类似的画风，最多再加上流式传输(Stream) 和 <code>iter_content</code>。为了配合异步 I&#x2F;O 来使用，我们这里需要定义一个异步的方法<code>getImageAsync()</code>，一起来看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">getImageAsync</span>(<span class="params">self, url, fileName, retries=<span class="number">5</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: fake_useragent.UserAgent().random,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&quot;https://www.nvshens.org&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        future = asyncio.get_event_loop().run_in_executor(</span><br><span class="line">            <span class="literal">None</span>, </span><br><span class="line">            functools.partial(requests.get, url, headers=headers)</span><br><span class="line">        )</span><br><span class="line">        response = <span class="keyword">await</span> future</span><br><span class="line">        data = response.content</span><br><span class="line">        imgFile = <span class="built_in">open</span>(fileName, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        imgFile.write(data)</span><br><span class="line">        imgFile.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">await</span> self.getImageAsync(url, fileName, retries):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们还需要定义<code>downloadAsync()</code>方法，这里我们使用了<code>create_task()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">downloadAsync</span>(<span class="params">self</span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        url = self.urls[index]</span><br><span class="line">        fileName = <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.get_event_loop().create_task(self.getImageAsync(url, fileName))</span><br></pre></td></tr></table></figure>

<p>此时，我们可以在入口函数中这样调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spider = Spider(urls)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(spider.downloadAsync())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<p>看看结果：</p>
<p>![异步I&#x2F;O + Requests 实现并行下载]](<a target="_blank" rel="noopener" href="https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png">https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png</a>)</p>
<p>这里，针对本文中提到的各种方法，博主做了一个简单对比：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>Thread</td>
<td>0:00:01.789790</td>
</tr>
<tr>
<td>ThreadPool</td>
<td>0:00:00.134065</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>0:00:06.510224</td>
</tr>
<tr>
<td>Process</td>
<td>0:00:00.100506</td>
</tr>
<tr>
<td>ProcessPool</td>
<td>0:00:11.046871</td>
</tr>
<tr>
<td>ProcessPoolExecutor</td>
<td>0:00:02.226153</td>
</tr>
<tr>
<td>AsyncIO</td>
<td>0:00:04.096083</td>
</tr>
</tbody></table>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文从线程(池)、进程(池)和异步 I&#x2F;O 三个方面探讨和尝试了多线程编程在 Python 爬虫领域的简单应用。其实，除了以上这些优化的思路以外，我们还可以借助队列(<strong>Queue</strong>)这类数据结构来改善现有方案的设计，大家可以注意到我给<code>getImage()</code>方法增加了错误重试的机制，这同样是为了增强爬虫程序的健壮性，而关于这个错误重试机制，考虑通过装饰器来进行改良则又是一个新的努力的方向，所以说，没有 deadline 才能让我们不断地自我改善，而有 deadline 只能让我们赶紧做完赶紧清净。好了，以上就是这篇博客的全部内容啦，最后要送给大家一个福利，本文中援引的爬虫程序已开源，地址是：<a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/zngirls">https://github.com/qinyuanpei/zngirls</a>，感兴趣的朋友可以自己去玩一玩，你懂的哦！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/10/2021/2021-01-10-macbook-air-apple-silicon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/10/2021/2021-01-10-macbook-air-apple-silicon/" itemprop="url">入手 MacBook Air (Apple Silicon)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-10T00:00:00+08:00">
                2021-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>最近两年几乎买齐了苹果的全线产品，越来越看好苹果，甚至买了一些苹果的股票，当然为什么选择苹果生态这个话题可以放在单独的文章里来说。</p>
<blockquote>
<p>我在 Small talk 的第二期「<a target="_blank" rel="noopener" href="https://1byte.io/small-talk-e2-apple-silicon/">聊聊用 M1 芯片的新 Mac</a>」中也聊到了 Apple Silicon 的话题，欢迎大家收听，但这期播客录制时间较早，如有冲突还是以本文为准。</p>
</blockquote>
<h2 id="第一体验"><a href="#第一体验" class="headerlink" title="第一体验"></a>第一体验</h2><p>在 11 月 17 日的发布会后我又观望了一周才下单，最后在 12 月 4 日拿到了搭载 <a target="_blank" rel="noopener" href="https://www.apple.com.cn/newsroom/2020/11/apple-unleashes-m1/">M1 处理器</a> 的 MacBook Air，我将内存升级到了 16G ，存储则还是低配的 256G。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2021/macbook-order.png"></p>
<p>选择这一款是因为从测评来看 Air 和 Pro 的性能差别并不显著，也不想为了 Touch Bar 和屏幕亮度支付额外 2000 元的价格，不如把这个钱加到内存上。</p>
<p>说到内存，新的 Mac 使用了「统一内存架构（UMA）」，可以消除 CPU 和显卡等专用计算单元之间的内存拷贝，既提高了速度，又减少了内存使用。一些朋友表示 8G 的内存对于不开虚拟机的中度使用也非常够用，但相信硬件的提升很快就会被软件消化，如果你希望新的 Mac 有一个比较长的使用周期，还是建议升到 16G 内存。对于新的 Mac 来说最高也只能选配 16G 内存，据说是因为总线 IO 的瓶颈，只有 2 个雷电接口也是这个原因。</p>
<p>至于存储空间，我属于最低的存储空间都够用的那一类人 —— 我希望设备上有最高性能的本地存储，但我并不会用这么昂贵的空间去存储冷数据，毕竟我才刚刚花了大功夫 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/273394399">自己搭了一个 NAS</a>。</p>
<p>拿到 MacBook Air 开始，最亮眼的还是发热和续航的表现，我偶尔会把 MacBook 放在腿上使用，之前的 Intel MacBook 十几分钟就会觉得烫，而 M1 Mac 则在日常使用时几乎感觉不到温度，在 CPU 跑满的情况下温热，只有 CPU 和 GPU 同时跑满才会有烫的感觉。相应地，M1 的续航表现也非常亮眼，后面的性能测试中会有详细的说明。</p>
<p>然后把它和我们家其他的 Mac 对比一下跑分，果然是用最低的价格提供了最高的分数：</p>
<table>
<thead>
<tr>
<th>Mac</th>
<th>Air (M1)</th>
<th>Pro (2020)</th>
<th>Pro (2017)</th>
<th>mini (2018)</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>M1</td>
<td>I5-1038NG7</td>
<td>I5-7360U</td>
<td>I7-8700B</td>
</tr>
<tr>
<td>GPU</td>
<td>7-Core</td>
<td>Iris Plus</td>
<td>Iris Plus 640</td>
<td>Intel UHD 630</td>
</tr>
<tr>
<td>Memory</td>
<td>16G</td>
<td>16G</td>
<td>8G</td>
<td>16G</td>
</tr>
<tr>
<td>Geekbench SC</td>
<td>1678</td>
<td>1136</td>
<td>852</td>
<td>1117</td>
</tr>
<tr>
<td>Geekbench MC</td>
<td>7225</td>
<td>4237</td>
<td>2020</td>
<td>5621</td>
</tr>
<tr>
<td>Geekbench Metal</td>
<td>19138</td>
<td>8498</td>
<td>4930</td>
<td>3776</td>
</tr>
<tr>
<td>Price</td>
<td>¥9499</td>
<td>¥14499</td>
<td>¥11888</td>
<td>¥11909</td>
</tr>
</tbody></table>
<blockquote>
<p>数据来自 everymac.com 和 geekbench.com</p>
</blockquote>
<p>其中 MacBook Pro 2020 是我 2020 年初时购买的最后一代 Intel MacBook，使用第十代 i5，倒是没什么问题，只是目前来看就买得实在太亏了；MacBook Pro 2017 是蛋黄一直在用，最近她开始学习 Swift 就一直在吐槽电脑实在太慢了，同时电池也进入了待维护状态；Mac mini 2018 是我目前工作用的电脑，当时虽然选了最高配的 i7 CPU，但没考虑到 Intel UHD 630 的性能实在太差了，即使我只是接了一块 4k 屏，系统的界面响应就已经非常卡顿了，现在 GPU 成为了整台电脑的瓶颈。</p>
<h2 id="ARM-生态"><a href="#ARM-生态" class="headerlink" title="ARM 生态"></a>ARM 生态</h2><p>应该说这次从 x86 到 ARM 的切换比我想象中的要顺利，苹果的第一方应用和 masOS 独占的应用都第一时间进行了适配，其他没有适配的应用则可以用 Rosetta 2 来运行。Rosetta 2 用起来是完全无感的，系统会自动将 x86 的应用以转译的方式来运行，无论是图形界面应用还是命令行的 binary 文件。性能上的差别对于大部分应用来说也并不明显，很多时候感觉不到自己是否使用了 Rosetta 2。</p>
<p>M1 芯片之前对我来说最大的变数在于对 Docker 的支持，但就在前几天 Docker for Mac 也发布了 <a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/apple-m1/">针对 M1 芯片的测试版本</a>。测试版中默认会运行一个 ARM 架构的 Linux 虚拟机，默认运行 linux&#x2F;arm64 架构的镜像（说起来在 M1 之前 linux&#x2F;arm64 大概主要是被用在树莓派上吧）；对于没有提供 linux&#x2F;arm64 架构的镜像则会自动使用 QEMU 来运行 x64_64 的镜像，性能就比较差了。</p>
<p>macOS 吸引我的一大理由就是 Homebrew —— 可能是桌面开发环境中最好用的包管理器。在 M1 上 Homebrew 目前 <a target="_blank" rel="noopener" href="https://brew.sh/2020/12/01/homebrew-2.6.0/">推荐大家使用 Rosetta 2 来运行</a>，所安装的包也都是需要 Rosetta 2 转译运行的 x86 版本，即使这个包已经提供了 ARM 版本。</p>
<p>这是因为 Rosetta 2 虽然可以完美运行 x86 的 binary，但当一个脚本中会以字符串的方式传递架构名、会调用多种不同的架构的程序，且这些程序同样关心当前的架构时就出问题了，不同的程序无法对这台机器的架构达成一致 —— 这往往发生在编译脚本里，也就是 Homebrew 的主要工作。解决这个问题目前只能是让整个脚本都运行在 x86（即 Rosetta 2）下，Homebrew 目前也是这样做的。</p>
<p>当然你可以选择在另外一个路径 <a target="_blank" rel="noopener" href="https://github.com/mikelxc/Workarounds-for-ARM-mac">安装 ARM 版的 Homebrew</a> 来安装 ARM 版的包，但目前这种方式缺少官方指引、需要自己尝试一个包的 ARM 版是否可以工作、需要从源码编译。目前大多数无法工作的包是受限于上游依赖的发布周期（如支持 darwin&#x2F;arm64 的 Go 1.16 要等到 2021 年二月才会发布），对于不涉及特定架构、或已经在其他平台提供有 ARM 版本的包，届时只需重新编译就可以提供 ARM 版本。</p>
<p>M1 的 Mac 可以直接安装 iOS 应用这一点我倒不是很在意，一方面是很多国内的毒瘤应用第一时间就从 Mac 商店下架，不允许安装。另一方面 iOS 基于触屏的交互逻辑本来就不适合 Mac，我也不觉得 Mac 之后会加入触屏的支持。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>以极低的功耗实现高于之前 MacBook 的性能是这次 M1 Mac 的亮点，在我购买之前实际上就已经看了很多视频自媒体的测评，在他们的测试中 M1 Mac 在使用 Final Cut Pro X 进行视频剪辑和导出有着碾压级的性能表现。</p>
<p>但显然这并不能代表 M1 在所有工作负载下的表现，因此我根据我日常的工作负载设计了 7 组共 15 项测试，主要将搭载 M1 的 MacBook Air 和我目前在使用的最后一代 Intel MacBook Pro (2020, i5 10th) 进行对比，以下数据均以后者为基准。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>MacBook Pro (i5 10th)</th>
<th>MacBook Air (M1, x86)</th>
<th>MacBook Air (M1, ARM)</th>
</tr>
</thead>
<tbody><tr>
<td>Node.js npm install</td>
<td>2m 41s</td>
<td>1m 38s (+39%)</td>
<td>1m 2s (+61%)</td>
</tr>
<tr>
<td>Node.js webpack build</td>
<td>54s</td>
<td>38s (+30%)</td>
<td>27s (+50%)</td>
</tr>
<tr>
<td>Xcode build Swift SDK</td>
<td>11m 30s</td>
<td>N&#x2F;A</td>
<td>6m 47s (+41%)</td>
</tr>
<tr>
<td>Xcode start iOS Simulator</td>
<td>49s</td>
<td>N&#x2F;A</td>
<td>16s (+67%)</td>
</tr>
<tr>
<td>Docker Redis benchmark</td>
<td>128k QPS</td>
<td>133k QPS (+4%)</td>
<td>261k QPS (+96%)</td>
</tr>
<tr>
<td>Docker build Node.js app</td>
<td>2m 56s</td>
<td>4m 43s (-61%)</td>
<td>3m 17s (-12%)</td>
</tr>
<tr>
<td>Visual Studio Code startup</td>
<td>7s</td>
<td>17s (-142%)</td>
<td>3s (+57%)</td>
</tr>
<tr>
<td>Visual Studio Code open and close tabs</td>
<td>36s</td>
<td>37s (-3%)</td>
<td>40s (-11%)</td>
</tr>
<tr>
<td>Chrome Speedometer 2.0</td>
<td>88 times&#x2F;m</td>
<td>121 times&#x2F;m (+38%)</td>
<td>214 times&#x2F;m (+143%)</td>
</tr>
<tr>
<td>Safari Speedometer 2.0</td>
<td>111 times&#x2F;m</td>
<td>N&#x2F;A</td>
<td>227 times&#x2F;m (+105%)</td>
</tr>
<tr>
<td>Safari 10% battery for Bilibili</td>
<td>32m</td>
<td>N&#x2F;A</td>
<td>1h 50m (+244%)</td>
</tr>
<tr>
<td>Final Cut Pro X background rendering</td>
<td>9m</td>
<td>N&#x2F;A</td>
<td>6m 20s (+30%)</td>
</tr>
<tr>
<td>Final Cut Pro X export H.264</td>
<td>8m 25s</td>
<td>N&#x2F;A</td>
<td>7m 8s (+15%)</td>
</tr>
<tr>
<td>Steam Oxygen Not Included</td>
<td>25 ~ 40 fps</td>
<td>45 ~ 50 fps (+25 ~ 80%)</td>
<td>Not support</td>
</tr>
<tr>
<td>Steam Sid Meier’s Civilization VI</td>
<td>p99 22 fps</td>
<td>p99 51 fps (+132%)</td>
<td>Not support</td>
</tr>
</tbody></table>
<p>对于 Node.js 依赖安装、前端项目构建、Swift 代码编译这些 CPU 密集且内存访问频繁、其中一些步骤依赖单核性能的场景，M1 有着非常明显的提升，即使使用 Rosetta 2 转译也要显著好于 i5。</p>
<p>最值得一提的是得益于 M1 的统一内存架构的高带宽和低延迟，Redis 跑出了 26 万 QPS 的成绩（无论是否在 Docker 中这个数据都差不多），而 i5 仅有 6 万。在调整 redis-benchmark 的数据长度参数时，M1 的结果几乎没有什么变化，而 i5 则随着数据长度的增加 QPS 逐步下降。说不定未来搭载 M1 的 Mac mini 会成为运行遇到 CPU 瓶颈的 Redis 的最佳硬件。</p>
<p>而使用 Docker for Mac 构建镜像则没有提升，这可能是因为构建的过程有很多零散的 IO，CPU 会有比较多的时间休息。而如果使用 Docker 去构建 x86_64 架构的镜像的话，性能损失就非常严重了（-61%）。</p>
<p>我编写了一个反复开关标签页的脚本来测试 VSCode 的性能，结果表明对于这类负载并不重的 GUI 程序，Rosetta 2 转译并不会影响性能，同样编译到 ARM 也不会对性能有多少提升，Rosetta 2 主要是会比较明显地增加启动速度。在 VSCode 的测试数据中出现了比较奇怪的现象 —— Rosetta 2 转译的版本竟然比 ARM 还快，我目前倾向于这是实验的误差，两者的速度实际上是几乎相同的。</p>
<p>在浏览器的测试中我们选择了 Speedometer，它会运行上百个由主流 Web 框架编写的 Todolist。结果显示无论是 Chrome 还是 Safari，其 ARM 版本都有一倍以上的性能提升，同样即使经过 Rosetta 2 转译也仍然比 i5 要快。浏览器的场景其实和前面 Node.js、Swfit 和 Redis 很像，都是 CPU 密集且内存访问频繁、其中一些步骤依赖单核性能，这也是 Intel CPU 之前的痛点。</p>
<p>我还基于浏览器进行了续航测试，我在中等亮度下播放 Bilibili 上 4K 120 帧的视频，开启弹幕的情况下 M1 使用前 10% 的电池播放了惊人的 1 小时 50 分钟，在这段时间的日常使用体验也是如此，我毫不怀疑官网给出的 18 小时视频播放时间。</p>
<p>在 Final Cut Pro X 的视频渲染和导出上，虽然 M1 确实有提升，但远不如之前一些媒体宣传的那么夸张，目前我还不清楚原因。</p>
<p>游戏方面我测试了我经常玩的 Oxygen Not Included（缺氧）和 Sid Meier’s Civilization VI（文明 6），我使用的都是中后期的存档、默认画面预设，在大多数时间都有 50 帧以上，是完全可以流畅游玩的。</p>
<p>可以看到 M1 的 Mac 在之前低配的价位上实现了中配甚至高配的计算性能，得益于专用的加速芯片，在苹果第一方和 macOS 独占的应用上有非常惊人的表现，而对于必须经过 Rosetta 2 转译的应用，仍有可以接受的性能表现，也是远高于之前同一价位的 Mac 的。</p>
<h2 id="多用户模式"><a href="#多用户模式" class="headerlink" title="多用户模式"></a>多用户模式</h2><p>因为蛋黄和我对新的 MacBook 都很有兴趣，因此我们各建了一个账户，这段时间是在轮流使用这台 MacBook，这也是我第一次使用 macOS 的多用户模式。整体体验还是很不错的，macOS 允许两个用户同时登录，在不退出程序的情况下在两个用户间切换，这使得我和蛋黄同时使用一台电脑的体验非常流畅。</p>
<p>16G 的内存也非常够用，即使另外一个用户运行了 XCode、Final Cut Pro X 或大量标签页的 Chrome，也不会有任何感觉。倒是 256G 的存储空间对于两个用户同时使用有些不够，不过这样的状态应该不会持续太久，后面我也会入手一台 M1 的 Mac。</p>
<h2 id="对-Mac-的展望"><a href="#对-Mac-的展望" class="headerlink" title="对 Mac 的展望"></a>对 Mac 的展望</h2><p>Rosetta 2 为什么会有这么好的性能呢？之前 Surface 等 x86 模拟器性能不佳的一个原因是 x86 与 ARM 在一个有关内存顺序的机制上有着不同的行为，在 ARM 上模拟这一行为会导致很大的性能损失。而苹果选择直接 <a target="_blank" rel="noopener" href="https://twitter.com/ErrataRob/status/1331735383193903104">在 M1 芯片中实现了一套 x86 的内存机制</a>，大大加速了 Rosetta 2 的性能。据说苹果同样在芯片层面对 JavaScript 和 Swfit 中一些特定场景进行了优化，还有大量的专用计算芯片来加速编视频编解码、密码学计算等特定的任务。</p>
<p>这是一个非常有趣的方向，过去很长一段时间都是应用来适配芯片，但只要对硬件和操作系统的控制力足够强，芯片也可以反过来去对最常用、性能问题最突出的应用进行芯片层面的优化或加入专用的计算芯片，和应用程序一起进行迭代更新。M1 中有的是对 Rosetta 2 的优化，而下一代的 M2 芯片则可能不再需要 Rosetta 2，而是可以根据需要去优化当时的热门场景。</p>
<p>对于苹果来说切换到 ARM 最重要的是提升了其垂直整合的能力、自主控制 Mac 产品线的更新周期。因为苹果对于操作系统的控制力和对应用生态的号召力，可以最大限度地发挥出自主设计的 ARM 芯片的效果。Windows 阵营当然可以切换到 ARM，会享受到前面提到的一些好处，毕竟苹果已经证明了这条路是可行的。但因为软硬件不是同一家公司控制、Windows 对应用生态的号召力弱，微软又不敢破釜沉舟地投入到 ARM 上，因此短期内可能 Windows 阵营还很难实现。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/09/2021-1-9-wechatdecade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/09/2021-1-9-wechatdecade/" itemprop="url">微信十年，弹指一挥间</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-09T23:00:00+08:00">
                2021-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2021 年 1 月 21 日，是微信发布 10 周年的日子，弹指一挥间，这个国民级产品已经燃烧了将近 10 年。</p>
<p>在微信的宣传语中，有这么一句话，「微信是一个生活方式」，而不是「一种生活方式」，就像「一千个读者就有一千个哈姆雷特」，每个人都能在使用微信的过程中，用出独属于自己的生活方式，而如果把「一个」换成「一种」，它就消除了其他可能的生活方式。</p>
<p>鉴于之前推荐过不少应用，我发现，富有吸引力的产品，或多或少都有这样的特征：它具备想象空间，有延展性，每个使用它的人，可以找到各种各样的用法&#x2F;玩法，微信也如此。</p>
<p>我是 2014 年刚上大学才用的微信，刚开始使用时，我本能地排斥它，心里会想：有了 QQ，为啥还要使用微信呢？腾讯是闲得蛋疼，没事又弄多一个新的社交软件。</p>
<p>但后来变成了不得不用的状态，因为当你身边的人都被卷入了微信，例如班里的同学都用微信、通过微信群接收班级通知，如果就你不用的话，你不就落单了吗？</p>
<p>人作为一种社会性动物，内心深处还是害怕孤独，害怕与别人格格不入。</p>
<p>起初刚接触微信，除了弄清基本功能的用法，最让我感兴趣的是，莫过于微信公众号，它对我来说是一个新东西，我想知道推送内容的后台长什么样，萌发了想注册一个公众号的想法，但直到 2015 年，我才注册了自己的微信公众号，但那时我并不知道公众号未来会有各种「红利」，也不知道自己能写点什么。</p>
<p>除了不知道写什么，公众号还有一个让人头疼的地方在于，它会在文章底部左下角显示阅读量，它会让刚开始写东西的我非常在意（现在当然也非常在意，但在意的原因不一样），因为当我把自己觉得好不容易写好的文章转发到朋友圈，阅读量还是没有什么增长，我就会觉得很丢脸，以至于后来很长时间我都不敢把自己写的东西转发到朋友圈。</p>
<p>显示阅读量有利也有弊，好的地方在于，它让一切更加<strong>透明</strong>，他人能通过阅读量反推公众号的关注数，能给你的公众号广告提供一个报价；不好的地方在于，它让许多新媒体人唯阅读量至上，激发出了人性的各种恶，如抄袭洗稿、尬蹭热点、吃「人血馒头」等等。</p>
<h2 id="最孤单的时刻"><a href="#最孤单的时刻" class="headerlink" title="最孤单的时刻"></a>最孤单的时刻</h2><p>微信起于熟人社交，但发展到今天，不少人添加的好友已经超出了熟人的范畴，根据微信之父张小龙在 2020 年初微信公开课上公开的数据，有将近 100 万人的微信好友数接近 5000 人，抵达了原先的微信好友上限。</p>
<p>通讯录好友数量上去了，但还是少不了会感到孤独，因为这里的好友并不是真正意义上的好友，并不等同于能说得上心里话的知心朋友。</p>
<p>这些年我使用微信最孤独的时刻，莫过于：我以为自己是在做一件正义的事情，但旁边多数人都是无动于衷、默默围观，不会给你任何反馈，那种感觉就像是，广场上突然出现了一个疯子，疯子在一旁大喊，旁边的人们仍继续做着自己的事情，这似乎也没有什么问题，这也不是在责备谁，只能说「人类的悲欢并不相通」。</p>
<p>有过同样感觉的，应该不止我一个吧？</p>
<h2 id="我的互联网启蒙"><a href="#我的互联网启蒙" class="headerlink" title="我的互联网启蒙"></a>我的互联网启蒙</h2><p>我之所以喜欢上互联网，很大程度上与公众号「小道消息」的作者 Fenng （真实的名字叫冯大辉）有关。</p>
<p>从冯老师那里，我看到了一个「大度」的人是怎样的，我之前曾在他的付费知识星球「小道消息的订阅服务」里发表过一段从心底里夸冯老师的话：</p>
<blockquote>
<p>在网上泡了挺多年，我见过最「大方」的人，莫过于无码科技的 Fenng 老师。</p>
<p>他很早就写公众号，算是科技圈里的一个个人大号，前期积攒了不少关注者。后来他免费推荐过不少公众号，有人是因为他的推荐，有了一定的读者，才坚持写把公众号写下来。</p>
</blockquote>
<p>也正是因为冯老师的推荐，我得以关注了不少有价值的公众号，进一步扩宽了我对互联网的认知，让我更加坚定地选择了从事互联网相关的工作。</p>
<p>不过，知道冯老师之前，还得感谢李笑来老师和他的公众号「学习学习再学习」（现改名「笑来」），那时是他转载了冯老师的一篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/z6VB1duhnDhd-asyegkvSA">冯大辉：有关健康常识的基本认知（2016 版）</a>》，我才知道了 Fenng 这个人，去微信里面搜了下，他的公众号叫「小道消息」，这个名字很容易让人产生误会，但看了一下发布的内容，觉得还不错，并不像公众号名字那样，于是就关注到了现在。  </p>
<h2 id="我的写作启蒙之路"><a href="#我的写作启蒙之路" class="headerlink" title="我的写作启蒙之路"></a>我的写作启蒙之路</h2><p>我之所以会在互联网上写东西，首先要感谢的还是李笑来老师，虽然我现在已经不看他写的内容了，但在 2015 年的时候，我还是很喜欢他写的东西，也看过他的一本畅销书《把时间当作朋友》。</p>
<p>李笑来老师主张人人都要掌握写作这个能力，它是一种带有「复利」和「杠杆」效应的能力，复利说的是只要把时间往后拉得足够长，日积月累之后，它能给人带来意想不到的影响，而杠杆效应强调写作是一个「一次付出，可获得多次回报」的行为。</p>
<p>以作家为例，作家写作一本书，他花费的时间就是从零到写完一本书的时间，出版之后，每当有一个人购买了他的书，他写作的时间就被出售了一次，如果有 1000 万人购买他的书籍，他的同一份时间就可以被出售 1000 万次，数量越多，越符合经济学上追求的「规模效应」，从理性的角度说，这是一笔非常划算的买卖。</p>
<p>除了出版，现实中还有好多东西也符合杠杆效应：</p>
<ul>
<li>付费视频课程：老师录完一次课程，后续可售出多次     </li>
<li>付费社群：社群群主提供的付费服务（如咨询、回答社群成员的提问等）的成本起初是相对恒定的，一个人加入的维护成本是那么多，1 万个人加入的维护成本也是那么多，只不过后者带来了更可观的收入。    </li>
<li>App Store 中的付费 App：开发出一个付费 App 后，上架苹果应用商店 App Store，可以卖给多个用户。当然 App 后续的维护和更新，也要付费高昂的成本，以至于后来很多 App 从一次买断转向了按年付费订阅的模式，这是后话。</li>
</ul>
<p>放到自己身上，虽然出不了书，但在网上公开分享，同样具备杠杆效应，试想一下，同样一条有价值的内容，发布在几个人的微信里 VS 发布在一个公开的社区里，它的潜在价值也是不同的，发布在公开社区的内容，它可以突破时间和空间的限制，让你能够在不同的时间、与来自不同地方的人们进行多次交流，而不仅仅局限在一对一的私密交流，相比之下，一对 N 的交流更加有效率。</p>
<p>如果你想早日达到更加自由（首先是精神自由，其次是物质自由）的状态，一定要从现在开始，着手做那些具有复利和杠杆效应的事情，从分享身边的小事做起，从每天写一点东西开始。</p>
<h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><p>微信的出现，推动了二维码在互联网世界内的普及，后来许多 App 跟着使用二维码，其中也有微信的一份功劳。</p>
<p>2012 年 5 月，张小龙在自己的朋友圈布过这么一条动态：</p>
<blockquote>
<p>PC 互联网的入口在搜索框，移动互联网的入口在二维码。    </p>
</blockquote>
<p>那时候的二维码，远未像今天这样看起来稀松平常，后来别的 App 之所以跟着用，还是因为微信把事做成了，在移动互联网时代建立了一个新的标准。</p>
<p>对于同样一件事情，有些人是先相信再看见，有些人是先看见再相信。我不知道那时候发布这条动态的时候，张小龙心里在想什么，但我相信他也是属于前者——先选择相信这件事能做成，再投入各种资源和努力，将预想中的理想情况变成现实，最终被看见。       </p>
<p><img src="http://cdn.penghh.fun/mweb/v2-4d6a6baa963809daa3a0a7c06824e801_r.jpg" alt="v2-4d6a6baa963809daa3a0a7c06824e801_r"></p>
<h2 id="什么是好的产品？"><a href="#什么是好的产品？" class="headerlink" title="什么是好的产品？"></a>什么是好的产品？</h2><p>张小龙在 2019 年的微信公开课上，化用了德国的产品设计师 Rams 总结的好的设计的十个原则，将十个原则中的「设计」一词替换为「产品」二字：    </p>
<p>第一个原则是好的产品富有创意，必须是一个创新的东西；<br>第二个是好的产品是有用的；<br>第三个是好的产品是美的；<br>第四个是好的产品是容易使用的；<br>第五个是好的产品是很含蓄不招摇的；<br>第六个原则是好的产品是诚实的；<br>第七个是好的产品经久不衰，不会随着时间而过时；<br>第八个原则是好的产品不会放过任何细节；<br>第九个是它是环保的，不浪费任何资源的；<br>第十个是尽可能少的设计，或者说少即是多。     </p>
<p>这些原则，在微信身上多少都会有体现，以「少即是多」为例：    </p>
<p>张小龙曾说过，微创新是永无止境的，别人总可以加一点东西来跟你不太一样。<strong>我们这个功能已经做到最简化了，别人没法超越</strong>——我们当时是有这种自信的……产品极简，反而有利于在网络这个大生命体中<strong>自我繁衍</strong>，并且产品是面向连接的。</p>
<p>产品做加法，做功能的堆砌很简单，因为它可能是一种最偷懒的方式，按一亿想教张小龙做产品的人说的加功能就好了，也不用到处去做用户调研和需求的洞察。</p>
<p>当然，产品保持极简与复杂并不是对立的，也并不是说它不能加入新的功能。需求或底层的逻辑可以很复杂，但当它呈现在用户面前，它必须是简洁的，给用户带来的体验是自然而然的，使用时不需要引导，不需要看说明书，符合人最原始、本能的反应。     </p>
<h2 id="我喜欢的微信功能"><a href="#我喜欢的微信功能" class="headerlink" title="我喜欢的微信功能"></a>我喜欢的微信功能</h2><ul>
<li>公众号，它是我在数字世界的一个家，存放了我从最初到现在写过的所有内容，即便是以前删掉的内容，在公众号后台的「图文素材」也能看到，也让我看到了不一样的世界</li>
<li>微信小程序，省去了安装不高频使用的应用，小内存容量手机的福音</li>
<li>可以关闭「发现」页不需要用到的功能</li>
<li>朋友圈动态不显示浏览量（对比 QQ 空间）</li>
<li>浏览他人朋友圈相册不会留下痕迹</li>
<li>浮窗功能</li>
<li>赞赏功能，通过赞赏获得的收入，不会被抽成</li>
</ul>
<h2 id="我不喜欢的微信功能"><a href="#我不喜欢的微信功能" class="headerlink" title="我不喜欢的微信功能"></a>我不喜欢的微信功能</h2><ul>
<li>朋友圈仅三天可见</li>
<li>删除好友不具备双向删除的能力（有人说之所以这样设计，是为了预防诈骗发生时，骗子删掉你的微信后，不会留下任何证据）</li>
</ul>
<h2 id="2016-年-·-蝴蝶效应"><a href="#2016-年-·-蝴蝶效应" class="headerlink" title="2016 年 · 蝴蝶效应"></a>2016 年 · 蝴蝶效应</h2><p>在 2016 年微信公开课开幕的前夜，微信上线了一个名为「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HOs_26OIA7yHyiH3SEX7Ig">我和微信 2015</a>」的页面，原本是想作为公开课前的预热小插曲，让参加公开课的人进行签到，了解自己第一次使用微信、第一次发布朋友圈的时间等等，但没想到这个链接被泄漏并传播开来，过多的人同时向服务器发出请求，导致页面瘫痪了。</p>
<p>页面挂掉之后，它被一些别有用心的人利用，制造出了一个谣言：它会盗用微信号，甚至是盗取微信钱包里的钱，引起了朋友圈内许多人的恐慌，许多人为了资金的安全，纷纷解绑了自己的银行卡。</p>
<p>我还清晰地记得，那天晚上我在教室外面背着书，在为第二天的期末考试准备着，最开始看到那些数据，会让人欣喜，但随之而来的谣言，又让我变得坐立不安，我会去频繁地刷新朋友圈，看看朋友圈中是否有知道具体情况的，期待有人能给出一个确定的答案。</p>
<p>微信之父张小龙在第二天的微信公开课上（这也是张小龙第一次在微信公开课上演讲），也以这个传播事件作为开头，以「蝴蝶效应」来类比这场突如其来的意外。</p>
<p><img src="http://cdn.penghh.fun/mweb/7558F18E-1D5B-4F44-97CE-335AC7903E32.png" alt="7558F18E-1D5B-4F44-97CE-335AC7903E32">截图来自 《<a target="_blank" rel="noopener" href="https://tech.qq.com/a/20160111/025385.htm">微信张小龙公开演讲：未来要开发“应用号”</a>》</p>
<p>也因为这场意外，微信自此不再策划这种类似「年度报告」或「年度回顾」的活动，对比其他 App 每年都会有的、看起来是正常诉求的「年度报告」，你可能会觉得微信少了一点温度。</p>
<h2 id="微信公开课主题"><a href="#微信公开课主题" class="headerlink" title="微信公开课主题"></a>微信公开课主题</h2><p>2017 年：下一站 Let’s reset !<br>2018 年： to be 正当时<br>2019 年： 同行 WITH US<br>2020 年： Always Beta<br>2021 年：激发 WeBuild</p>
<h2 id="张小龙微信公开课演讲"><a href="#张小龙微信公开课演讲" class="headerlink" title="张小龙微信公开课演讲"></a>张小龙微信公开课演讲</h2><p>2014 年：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qRHGtL-6L3YGqLBDGgNfFw">微信公开课 PRO 版张小龙演讲全文</a><br>2016 年：<a target="_blank" rel="noopener" href="https://tech.qq.com/a/20160111/025385.htm">微信张小龙公开演讲：未来要开发“应用号”</a><br>2017 年：<a target="_blank" rel="noopener" href="https://tech.qq.com/a/20161228/016787.htm">张小龙首次公开解读小程序：小程序在微信没有入口 1月9号正式推出</a><br>2018 年：<a target="_blank" rel="noopener" href="https://daxue.qq.com/content/content/id/3842">张小龙 2018 微信公开课演讲全程视频，微信将有哪些新变化？</a><br>2019 年：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54490834">2019 微信公开课PRO版张小龙演讲全文（官方完整版）</a><br>2020 年：<a target="_blank" rel="noopener" href="https://v.qq.com/x/cover/mzc00200fyleel7/f304841frck.html">张小龙：微信的短内容一直是要发力的方向 顺利的话近期或将上线</a></p>
<p>关于张小龙的更多介绍，可以查看这篇可能是目前网上写得最翔实的文章，且文末附上了一份详细的参考链接：《<a target="_blank" rel="noopener" href="https://coffee.pmcaff.com/article/2075760897470592/">张小龙22年</a>》      </p>
<h2 id="向往的团队"><a href="#向往的团队" class="headerlink" title="向往的团队"></a>向往的团队</h2><p>从这些年使用微信的经历来说，微信确实是国内众多互联网产品中的异类，在商业化或者说变现方面，它显得足够克制，没有开屏广告，没有像微博那样遍地的信息流广告，也不会主动向用户 Push 系统消息，在许多方面，它确实是把用户当成用户、当成朋友来对待。        </p>
<p>爱屋及乌，因为喜欢微信，也会对微信背后的微信团队产生了好感。微信团队在招聘链接上曾经有这么一句话，让我印象深刻：     </p>
<blockquote>
<p>和我们一起做个伟大产品取悦自己！     </p>
</blockquote>
<p>在知乎上的一个问题「在微信工作是怎样一番体验？」，其中有个匿名回答说到：     </p>
<blockquote>
<p>这里的员工更多的是自我成就的驱动，而非 KPI 的压力。    </p>
</blockquote>
<p>张小龙在 2019 年的微信公开课上也曾说过：      </p>
<blockquote>
<p>很多人问我们（指微信团队），你们跟别人有什么不一样？我觉得有一个不一样是这样的，我们在思考问题或者是思考做什么的时候我们经常会问自己一个问题，就是我们在做这个事情的意义是什么？     </p>
<p>我当然知道很多团队做这个事情他是不问这个意义的，他只问我们的 KPI 是什么？但是说老实话微信团队从开始成立到现在从来没有瞄准 KPI 去奋斗过，但是并不妨碍团队能够越做越好。因为就像小程序，如果围绕 KPI 去做，我们不知道怎么制定 KPI，因为它没有这个东西，没有办法制订它的 KPI，如果围绕一个 KPI，大家可能不会做这个事情。    </p>
</blockquote>
<p>如果说这辈子只剩下最后一次工作机会，我希望我能去微信团队。之所以排到最后一次，还是因为现在的我太辣鸡了。     </p>
<p>以上。   </p>
<p>来个互动：在使用微信这么多年的时间里，有什么让你难忘或者印象深刻的？你是否有因为微信而让你变得与众不同的经历吗？     </p>
<p>欢迎在下方留言。        </p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/09/%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E9%95%BF%E6%88%AA%E5%9B%BE%E7%9A%84%E5%B8%B8%E8%A7%81%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/09/%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E9%95%BF%E6%88%AA%E5%9B%BE%E7%9A%84%E5%B8%B8%E8%A7%81%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" itemprop="url">实现网页长截图的常见思路总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-09T20:37:47+08:00">
                2021-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index">
                    <span itemprop="name">独立博客</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>作为一个经常写博客的人，我有时会在<a target="_blank" rel="noopener" href="https://weibo.com/">微博</a>上分享博客内容，可不知道从什么时候开始，国内互联网越来越丧失信仰，所有的厂商都在试图打造一个<strong>“只进不出”</strong>的信息孤岛，进而达到增强<strong>“用户黏度”</strong>的目的。以微博为例，微博中的外链永远都会被转化为短地址，并且无法通过微博内置的浏览器进行跳转。即使你通过手动复制链接的方式打开链接，你依然需要至少两个步骤方能见到<strong>“庐山真面目”</strong>。借鉴&#x2F;抄袭这一陋习的还有<a target="_blank" rel="noopener" href="https://www.jianshu.com/">简书</a>，花时间做了一个第三方链接跳转提示页面，唯独不愿意在上面加一个 a 标签，你还是要手动复制黏贴。坦白说，我觉得国内互联网正在丧失着信仰，看起来电商、物流、外卖、打车、支付……此起彼伏逐渐渗透到我们生活的方方面面，成为名副其实的<strong>“互联网+”</strong>，可在信息泛滥的今天，我们越来越难找到真正有价值的信息……既然外链注定要被屏蔽掉，那我就勉为其难地顺应潮流发<strong>“长截图”</strong>咯，所以，接下来我会为大家分享实现网页<strong>“长截图”</strong>的常见思路，希望对有类似烦恼或者需求的小伙伴们有所帮助。</p>
<h1 id="通过浏览器实现"><a href="#通过浏览器实现" class="headerlink" title="通过浏览器实现"></a>通过浏览器实现</h1><p>要实现网页长截图，显然是和网页打交道，而和网页打交道最多的是谁呢？自然是我们每天都要用的浏览器啦！值得庆幸的是，不管是 Chrome 还是 Firefox ，我们都可以通过它们来是实现这个想法。</p>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>对于 Chrome 来说，我们只需要“F12”打开开发者工具，并在其中找到“控制台”选项卡，在平时输入 JavaScript 脚本的地方(即 Console 选项卡)输入<code>Ctrl + Shift + P</code>命令，然后你会得到一个类似 VSCode 命令行体验的输入窗口，接下来，输入：<code>Capture full size screenshot</code>并回车。此时，我们就可以得到完整的页面截图。而如果你希望截取网页中的一部分，则可以在选中指定 DOM 元素后采用相同的方式输入命令：<code>Capture node screenshot</code>。此外，更常用的截取浏览器可见范围内的内容，可以使用：<code>Capture screenshot</code>。可能相对于一般可以进行拖拽截图的工具而言，这个方案显得有点笨拙且简陋，可它真的可以完美地实现我们的想法，而且不需要安装任何扩展或者插件。</p>
<p><img src="https://i.loli.net/2021/01/10/9kNwf8b2rnCiuop.png" alt="使用 Chrome 的截图功能"></p>
<h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>对于 Firefox 而言，它本身自带截图功能，并且支持拖拽截图，对于我们这些需要长截图的人而言，唯一需要做的就是点击几下数据，确实要比敲命令行要简单一点、友好一点，我个人更喜欢用 Firefox 一点，因为 Chrome 正在从屠龙少年变成恶龙，为了让这个世界上不是只有 Chrome 一种浏览器内核，我决定支持一下 Firefox ，2020 年因为疫情的原因， Mozila 裁员 25%约 250 人，这家几乎靠着理想主义在维护 Gecko 内核的公司，之后可能再无法和 Google 的 Chrome 抗衡，而这个世界只有一种浏览器的时代我们都曾经经历过，它的名字叫做 IE6 ，不禁令人感慨，简直是开放 Web 的罗曼蒂克消亡史。</p>
<p><img src="https://i.loli.net/2021/01/10/CgNzF8DA4fYGcHM.png" alt="使用 Firefox 的截图功能"></p>
<h1 id="通过-Selenium-实现"><a href="#通过-Selenium-实现" class="headerlink" title="通过 Selenium 实现"></a>通过 Selenium 实现</h1><p>在我的认知中，有浏览器的地方就有爬虫，而有爬虫的地方就有 <a target="_blank" rel="noopener" href="https://www.selenium.dev/">Selenium</a> 。原本好端端的 UI 自动化测试框架，怎么就助纣为虐做起爬虫来了呢？其实，主要原因是它提供了一个可以和浏览器交互的环境，从某种意义上来讲，<a target="_blank" rel="noopener" href="https://www.selenium.dev/">Selenium</a> 、<a target="_blank" rel="noopener" href="https://phantomjs.org/download.html">PhantomJS</a> 以及 <a target="_blank" rel="noopener" href="https://github.com/microsoft/playwright-python">Playwright</a> 都可以认为是类似的技术，这里我们以 Selenium 为例，而通过 Selenium 实现网页长截图则主要有两种方式：其一，是构造一个足够“大”的浏览器，然后调用<code>save_screenshot()</code>方法进行截图；其二，是通过“拖拽”滚动条来滚动截图，然后再通过<code>PIL</code>进行拼接，下面来看具体的代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_screenshot</span>(<span class="params">url, fp_pic</span>):</span><br><span class="line">    fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">    fireFoxOptions.set_headless()</span><br><span class="line">    driver = webdriver.Firefox(firefox_options=fireFoxOptions)</span><br><span class="line">    driver.get(url)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 设置浏览器宽度和高度</span></span><br><span class="line">    width = driver.execute_script(</span><br><span class="line">      <span class="string">&quot;return document.documentElement.scrollWidth&quot;</span></span><br><span class="line">    )</span><br><span class="line">    height = driver.execute_script(</span><br><span class="line">      <span class="string">&quot;return document.documentElement.scrollHeight&quot;</span></span><br><span class="line">    )</span><br><span class="line">    driver.set_window_size(width, height)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    driver.save_screenshot(fp_pic)</span><br><span class="line">    driver.close()</span><br></pre></td></tr></table></figure>

<p>这里我使用的是 Firefox 的驱动，喜欢 Chrome 的按个人喜好即可，这里我假设你已经掌握了 Python 和 Selenium，如果需要一点辅助知识，可以参考博主的这篇文章：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3602353334/">作为技术宅的我，是这样追鬼滅の刃的</a> 。这种方式的“长截图”实现起来非常简单，可是因为需要构造一个非常“大”的浏览器，所以，如果页面适配没有做好的话，可能会出现页面元素变形的问题，其次，这种方式生成的图片体积普遍比较大，所以，从总体上看主要就是这两个缺点。而“滚动截图”实现起来会稍微复杂一点，因为里面会涉及到一小部分计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_screenshot2</span>(<span class="params">url, fp_pic</span>):</span><br><span class="line">    fireFoxOptions = webdriver.FirefoxOptions()</span><br><span class="line">    fireFoxOptions.set_headless()</span><br><span class="line">    driver = webdriver.Firefox(firefox_options=fireFoxOptions)</span><br><span class="line">    driver.fullscreen_window() <span class="comment"># 全屏窗口</span></span><br><span class="line">    driver.get(url)</span><br><span class="line">    window_height = driver.get_window_size()[<span class="string">&#x27;height&#x27;</span>] <span class="comment"># 窗口高度</span></span><br><span class="line"> </span><br><span class="line">    page_height = driver.execute_script(</span><br><span class="line">      <span class="string">&#x27;return document.documentElement.scrollHeight&#x27;</span></span><br><span class="line">    ) <span class="comment"># 页面高度</span></span><br><span class="line">    driver.save_screenshot(<span class="string">&#x27;temp.png&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> page_height &gt; window_height:</span><br><span class="line">        n = page_height // window_height <span class="comment"># 需要滚动的次数</span></span><br><span class="line">        base_mat = np.atleast_2d(Image.<span class="built_in">open</span>(<span class="string">&#x27;temp.png&#x27;</span>)) <span class="comment"># 打开截图并转为二维矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        driver.execute_script(</span><br><span class="line">          <span class="string">f&#x27;document.documentElement.scrollTop=<span class="subst">&#123;window_height * (i+<span class="number">1</span>)&#125;</span>;&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        time.sleep(<span class="number">.5</span>)</span><br><span class="line">        driver.save_screenshot(<span class="string">f&#x27;temp_<span class="subst">&#123;i&#125;</span>.png&#x27;</span>) <span class="comment"># 保存截图</span></span><br><span class="line">        mat = np.atleast_2d(Image.<span class="built_in">open</span>(<span class="string">f&#x27;temp_<span class="subst">&#123;i&#125;</span>.png&#x27;</span>)) <span class="comment"># 打开截图并转为二维矩阵</span></span><br><span class="line">        base_mat = np.append(base_mat, mat, axis=<span class="number">0</span>) <span class="comment"># 拼接图片的二维矩阵</span></span><br><span class="line">        Image.fromarray(base_mat).save(fp_pic, <span class="built_in">format</span>=<span class="string">&#x27;PNG&#x27;</span>)</span><br><span class="line">        os.remove(<span class="string">f&#x27;temp_<span class="subst">&#123;i&#125;</span>.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    os.remove(<span class="string">&#x27;temp.png&#x27;</span>)</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>
<p>这个方案本身没有太大的问题，可如果你的网页是那种页面滚动时头部固定的设计，譬如类似博主的博客这样的风格，此时这种方案就会有一点问题，每次截取都会包含头部这部分，和我们最后想要实现的效果有一点出入，如果可以计算出头部的高度，截图或者拼接的时候把这个高度考虑进去，就可以彻底解决这个问题，可这样这个问题就从一个通用型问题变成一个局部型问题啦，果然，世上没有完美的解决方案呢……</p>
<h1 id="通过-JavaScript-实现"><a href="#通过-JavaScript-实现" class="headerlink" title="通过 JavaScript 实现"></a>通过 JavaScript 实现</h1><p>有人可能要说，博主你好偏心，为什么 Python 都出来了，作为前端三剑客之一的 JavaScript 还没有出现？嗯，对此我想说——你不用说，我知道不就是<strong>“人生苦短，我用 Python”</strong>吗？人家前端世界里有个叫做 <a target="_blank" rel="noopener" href="http://html2canvas.hertzen.com/">html2canvas</a> 的库，博主你可有耳闻？我笑了笑，我并没有看了看我的劳力士，因为我没有劳力士。好吧，既然这里提到了这个库，那就来说说这个库的实现思路吧，人家不是说了嘛？一切可以实现的东西，最终可以用 JavaScript 来实现，我们来看看具体的代码实现，这里，首先准备一个 HTML 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./html2canvas.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 768px; overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">        请输入URL: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;capture&quot;</span>&gt;</span>截取<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;view&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">v-bind:src</span>=<span class="string">&#x27;url&#x27;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">ref</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>非常简单，输入一个地址，然后通过一个 iframe 进行预览，点击按钮进行截图。下面给出 JavaScript 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            url: &#x27;https://regularly-archive.github.io/2020/Matrix/&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            capture: function() &#123;</span><br><span class="line">                var self = this;</span><br><span class="line">                var iframe = self.$refs.view.contentWindow;</span><br><span class="line">                var iframeBody = iframe.document.getElementsByTagName(&#x27;body&#x27;)[0]</span><br><span class="line">                html2canvas(iframeBody).then(canvas =&gt; &#123;</span><br><span class="line">                    document.body.appendChild(canvas);</span><br><span class="line">                    //canvas转图片</span><br><span class="line">                    let canvasImg = canvas.toDataURL(&quot;image/png&quot;);</span><br><span class="line">                    //模拟下载</span><br><span class="line">                    var a = document.createElement(&#x27;a&#x27;)</span><br><span class="line">                    a.href = canvasImg;</span><br><span class="line">                    a.download = self.url;</span><br><span class="line">                    let event = document.createEvent(&quot;MouseEvents&quot;)</span><br><span class="line">                    event.initMouseEvent(&quot;click&quot;, true, false,</span><br><span class="line">                       window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)</span><br><span class="line">                    a.dispatchEvent(event)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下，你可以点击 <a target="_blank" rel="noopener" href="https://regularly-archive.github.io/2020/html2canvas/">这里</a> 访问在线演示 DEMO：</p>
<p><img src="https://i.loli.net/2021/01/11/KO9Hx4gbLlzkUDG.gif" alt="使用html2canvas实现的长截图"></p>
<p>这里使用 iframe 可能会引入跨域的问题，大家可以参考我的这篇文章：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3846545990/">聊聊前端跨域的爱恨情仇</a> ，而 <a target="_blank" rel="noopener" href="http://html2canvas.hertzen.com/">html2canvas</a> 本身就提供了关于跨域问题的解决方案，大家可以参考这里：<a target="_blank" rel="noopener" href="http://html2canvas.hertzen.com/configuration">http://html2canvas.hertzen.com/configuration</a>。</p>
<h1 id="通过第三方工具实现"><a href="#通过第三方工具实现" class="headerlink" title="通过第三方工具实现"></a>通过第三方工具实现</h1><p>我知道程序员都喜欢自己去折腾，如果是前无古人、后无来者的东西，我建议去折腾，因为梦想还是要有的，万一实现了呢？而我们这个圈子里同样有一句经典的话，叫做“不要重复制造轮子”，所以，博主这里找到了几个轮子供大家参考，不喜欢在冬天动手写代码的人，可以收藏下这几个工具，这个冬天实在是太冷了，冷到什么程度呢?大概听见笑话都不大愿意笑，用罗翔老师的话说这叫做搞笑未遂。</p>
<h2 id="wkhtml2image"><a href="#wkhtml2image" class="headerlink" title="wkhtml2image"></a>wkhtml2image</h2><p><a target="_blank" rel="noopener" href="https://wkhtmltopdf.org/downloads.html">wkhtml 系列</a>，一个命令行工具，可以将本地 HTML 文件或者远程 URL 指向的网页转化为图片，该系列产品中还有 wkhtml2pdf，顾名思义，网页转 PDF，实际使用过程中基本没什么问题，输出的图片 1:1 还原网页，唯一的缺点是偶尔会丢失样式，尤其是页面中引入了第三方的 JavaScript 或者 CSS 的时候，整体上远程 URL 比本地 HTML 要稳定一点，推荐系数：4 星。</p>
<p><img src="https://i.loli.net/2021/01/10/YtlZdITauS7eGv4.png" alt="长截图03.png"></p>
<h2 id="PickFrom"><a href="#PickFrom" class="headerlink" title="PickFrom"></a>PickFrom</h2><p><a target="_blank" rel="noopener" href="https://zh.pickfrom.net/html2png">PickFrom</a>，一个在线的网页转图片的服务，填写 URL 然后点击按钮即可，提供免费预览一部分图片的功能，完整图片的查看、下载均需要支付一定费用，服务质量还可以，但不适合我们这种被迫“白嫖”的穷人家的孩子，土豪们随意，推荐系数：4 星</p>
<p><img src="https://i.loli.net/2021/01/10/m273LUTZxsKHeb4.png" alt="PickFrom"></p>
<h2 id="Tiomg"><a href="#Tiomg" class="headerlink" title="Tiomg"></a>Tiomg</h2><p><a target="_blank" rel="noopener" href="https://tiomg.org/webpage-screenshot">Tiomg</a>，接下来是博主要重点推荐，它和 <a target="_blank" rel="noopener" href="https://zh.pickfrom.net/html2png">PickFrom</a> 提供着相同的服务，唯一不同的是，它是完全免费的，我现在主要用这个来工具来生成“长截图”，不错，我背叛了上面我写的那些代码，为什么要重复造轮子呢？有时候我想不明白，为什么国内公司都喜欢那种“大而全”的软件，恨不得要拥有竞争对手所有的特性，可明明大家都“卷”成这样了，为什么不试试差异化的路线呢？可能，是因为低端竞争太多吧！推荐系数：5 星</p>
<p><img src="https://i.loli.net/2021/01/10/injWyCsFNOVZSgT.png" alt="Tiomg"></p>
<p>冬天实在是没有动力去写有技术含量的东西啊！关于“长截图”这个话题，差不多是从一周前开始关注、做实验的，所以，请允许在下偶尔写这样一篇“水文”吧！关于“视频是不能 P 的系列”，因为 Dlib 安装起来实在讨厌，而 OpenCV 提供的 68 特征点算法目前只支持 C++ ，研究起来难免要花一点时间，好了，这篇博客暂时先写到这里吧，博主要先去冬眠啦，再见!</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/07/2021-01-07-the-difference-between-software-and-hardware-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/07/2021-01-07-the-difference-between-software-and-hardware-development/" itemprop="url">为什么开发一款软件只要 3 个月，开发一款硬件却要一年</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-07T08:28:23+08:00">
                2021-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/readerpen.jpg" class="">

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们公司在软件开发上的速度极快：</p>
<ul>
<li>2012 年猿辅导公司刚成立的时候，想做一款教育微博，我们花了 3 个月的时间做完上线。</li>
<li>2013 年我们想做猿题库，我们花了 2 个月的时间做完上线。</li>
<li>2014 年我们想做小猿搜题，我们仅花了 1 个月时间，就完成了功能开发。</li>
</ul>
<p>而我们在开发斑马点读笔（题图）的时候，前后却花了将近 10 个月的时间，远远超过软件开发的时间。</p>
<p>2020 年我们有多款在研的硬件产品，我们试图压缩硬件产品的研发周期。但是执行下来发现，在极端顺利的情况下，也需要 6 个月的开发周期。稍有一些意外，就可能拖到 8 个月甚至 10 个月才能完成量产。</p>
<p>教育硬件还算简单的，我们再来看看手机产品。熟悉苹果的朋友都知道，苹果一般需要花 2 年时间，才能发布一个全新的手机设计。中间间隔的那一年，苹果仅仅会做一个小改款，升级一下 CPU 主频或者摄像头像素，整体的设计并没有什么变化。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么硬件研发的周期远高于软件研发呢？</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="原因一：硬件的链条长，环节复杂，但是对调整的容忍度低"><a href="#原因一：硬件的链条长，环节复杂，但是对调整的容忍度低" class="headerlink" title="原因一：硬件的链条长，环节复杂，但是对调整的容忍度低"></a>原因一：硬件的链条长，环节复杂，但是对调整的容忍度低</h3><p>软件研发的时候，最后一刻有严重 Bug，我们可以熬熬夜修好再上线。上线之后有小问题，我们可以在几天之后发布一个小版本升级。所以，软件可以用 Scrum 来快速迭代，业界常见的迭代周期是两周一次发布。</p>
<p>硬件如果最后一刻发现有严重的 Bug，那么不好意思，你需要重新制作模具。而不算模具的修改评审时间，仅仅开模的时间通常都需要 30 天左右。而开模前还需要重新做结构设计的调整，开模之后需要重新试模，外观调整之后可能涉及的 IC 排布的调整，包装设计的调整，3C 重新认证，运输测试重做等等，基本上相当于一夜回到解放前。</p>
<p>打个比方，硬件的外观大的调整有点类似于大家玩陶瓷，你好不容易做好了，进熔炉烧制好了，然后你发现有一个设计缺陷，那这个陶瓷只能完全报废掉了。</p>
<img src="/images/taochi.jpg" class="">

<p>不止是硬件部分，电子部分的调整其实也很难。教育硬件产品通常逻辑不复杂，为了节省成本和功耗，硬件产品的逻辑通常使用 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A9%E6%A8%A1/22217511">掩模</a> 的工艺来进行烧录。这种烧录的能力现在还是集中在台湾地区，所以烧录时间要好几周。而且烧录有量的要求，一次烧录的起订量通常是 5K 左右的。</p>
<p>如果你研发到量产阶段，才发现有一个逻辑要修改，那么对不起，整个 IC 部分至少 5000 的起订量需要报废掉重做，重做周期可能好几周。这还没有算上 PCBA 电路板的重新贴片带来的时间成本。</p>
<p>所以，硬件的外观、电子逻辑在研发过程中的调整，都可能对整个产品的研发进度产生极大的影响。</p>
<p>为了防止这种事件发生，硬件在研发环节中，加入了多次的确认和检查，比如在开模之前先做 EVT 验证，又比如工业（ID）设计和结构（MD）设计做出来要打手板验证等。于是，我们就有了一个相对来说比较复杂的项目管理流程。</p>
<p>下图是小米公司的项目计划模版，可以看出一个硬件的研发牵扯的环节非常多。稍微不注意就会有差错。</p>
<img src="/images/hardware-plan.png" class="">

<p>即便这样，也还是很容易出错。我们在实践中，单单在包装工程上就出现过多次失误。比如和供应商时，不能很好地控制包装方案与成本；又比如设计的包装不利于运输，使得物流箱的成本变得很高。又或者打样的时候来回多次沟通，每次都打样不到位等。</p>
<p>但就像只要有程序就一定有 Bug 一样，硬件研发过程很难保证一定是完美的。所以如果有大问题只能召回或者报废，小问题只能忍着先发布，下一版再迭代。iPhone 每一代新品发布，就还是伴随着一些问题，历史上最有名的是 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102872087">iPhone 4 的死亡之握</a>，最终苹果没办法，所有人免费送了一个手机壳才解决。</p>
<h3 id="原因二：硬件的资金成本更高"><a href="#原因二：硬件的资金成本更高" class="headerlink" title="原因二：硬件的资金成本更高"></a>原因二：硬件的资金成本更高</h3><p>硬件当前的 3D 打印技术和电子电路的技术，仅可以用来做用户试用，验证一些功能设计上的问题。</p>
<p>但是硬件产品从一个高保真的原型手板到量产，其实需要克服很多工艺上的问题，在这个过程中，就需要花很多钱。这些钱都是需要摊薄到未来的大规模量产上的，否则就很不经济。</p>
<p>打个比方，我们做一款玩教具，假设这个玩教具的开模费用是 20 万，那么如果我们只生产 2000 台，那么摊到每台上的模具费用都有 100 块钱。而一个模具通常可以用 50 万次，正常量产后的每台玩教具的模具费用只有 0.5 元。这里面差了 200 倍的成本。</p>
<p>所以为了把产品的成本控制下来，同时也为了保证开模注塑工厂的利益（不然别人不跟你玩），通常首批玩教具生产的量都需要是 5000 左右的，这就是一笔不小的投入费用。</p>
<p>IC 的部分也一样，掩模烧录的起订量通常也是 5000，这也是一笔不小的费用。</p>
<p>最后假设我们什么都很顺利，花 20 万开了模，做了 5000 套玩具，假设每款玩具的制造成本是 100 块，那么一共就花了 70 万元。</p>
<p>硬件第一批产品出去后，多多少少会有一些问题，这个时候你就需要尽快把存货卖出去，否则你回收不回来资金，很难启动第二轮的生产。我看 <a href="/2018/07/19/elon-musk/">《马斯克传》</a>，当年 Tesla 的第一代车就是因为有很多小毛病差点卖不出去，最终他没办法让所有员工都出去卖车，才逃过一劫。乐视当年做手机，手机卖不出去，最后好多都直接送出去，因为放在仓库里面电池亏电太久也报废了。</p>
<p>第一代产品有小毛病没卖好，资金又都压在存货上，有大量公司都被库存和资金周转搞死了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>硬件研发链条长，在研发过程中的任何调整，都可能对整个产品的研发进度产生极大的影响。</li>
<li>硬件的研发需要基础量和开模，使得资金门槛高，给后续库存和资金周转带来挑战。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/06/2021-1-6-qiuyepptcopy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/06/2021-1-6-qiuyepptcopy/" itemprop="url">致公众号「职场神助攻」的助攻姐：写东西还是要点脸吧。</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-06T00:00:00+08:00">
                2021-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>本文首发于我的公众号「效率工具指南」，这里作为备份。    </p>
<p><img src="http://cdn.penghh.fun/mweb/16099814864382.png"></p>
<p>Hello 大家好，我是安哥。</p>
<p>以前我很享受自己写的东西能发布在公司的大号上，因为同样的一篇文章，付出同样的努力，放在不同量级的公众号上，它的效用是不同的。</p>
<p>关注量更大的号，它带来的曝光更多，可能也可以帮到更多的人，这是我一直以来相信的。</p>
<p>而且我也知道一些关注者更喜闻乐见的内容，例如传播盗版软件、整理 100G 你收藏了也不会去看的学习资料等等，但我选择不写，因为我相信：</p>
<p>用优质内容而非套路获取关注者的信任，才是一种靠谱、长期可持续的方式，自己写的时候也写得心安理得。</p>
<p>但后来，我发现，更大的曝光量也会带来一些负面影响，例如被别人抄袭或者洗稿。</p>
<p>昨天下午，同事给我看了一篇秋叶 PPT 旗下的新号「职场神助攻」发的一篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NzMxNTk2Ng==&mid=2247523168&idx=1&sn=f767c953d84e0ff895c14dd412b95f08&scene=21#wechat_redirect">涨知识了，原来简单的电脑锁屏还能玩出这么多花样！</a>》</p>
<p>说实话，这篇文章，和我去年 9 月份发布的文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649890610&idx=1&sn=80b1a1693d942d5ec57fe9181ebcbfb4&scene=21#wechat_redirect">这12个好玩的电脑屏保，让你成为别人眼中最靓的仔。</a>》非常像，我本能地觉得自己被抄了：</p>
<p>同样是工具号，写相同的选题，无可厚非，我也不能说什么，但连行文方式都一样，就有点此地无银三百两了。</p>
<p>这篇抄袭的文章，开头所使用的引入方式，和我写的文章几乎一模一样，都是在吐槽 Windows 自带的屏保程序难看：</p>
<p><img src="http://cdn.penghh.fun/mweb/16099816108279.png"></p>
<p>此外，这篇文章中还引用了我自己起的一个短语「匍匐前进的布朗熊」：</p>
<p><img src="http://cdn.penghh.fun/mweb/16099816273693.jpg"></p>
<p>为了验证这个短语是我最先起的，我在 Google 中用关键字「匍匐前进的布朗熊 电脑屏保」进行搜索，并将时间限定在「2020 年 1 月 1 日 - 2021 年 1 月 5 日」。</p>
<p>搜索出来，排在第一位且发布在知乎的文章，就是我写的，时间为 2020 年 9 月 3 日，而第二条结果也用到了「匍匐前进的布朗熊」，时间是在稍晚的 2020 年 11 月 18 日。</p>
<p><img src="http://cdn.penghh.fun/mweb/16099816420250.png"></p>
<p>当我在微博上质疑助攻姐抄袭我的这个短语时，她也拿出了其他搜索结果来自证清白，解释说写文章的时候参考的是其他资料，并不知道这个短语最开始是我写的：</p>
<p><img src="http://cdn.penghh.fun/mweb/16099816520164.png"></p>
<p><img src="http://cdn.penghh.fun/mweb/16099816632076.png"></p>
<p><img src="http://cdn.penghh.fun/mweb/16099816734616.png">这篇知乎文章的发布时间为 2020 年 10 月 30 日，链接 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/270286326">https://zhuanlan.zhihu.com/p/270286326</a></p>
<p>除了这个，之前我在怀疑「职场神助攻」抄袭同事 Cherry 的另外一个选题「医疗工具」，同事在群里说了一下后台的数据：</p>
<p>助攻姐连续两周在公司的公众号「一周进步」后台的阅读和分享数都是排名第一。</p>
<p><img src="http://cdn.penghh.fun/mweb/16099816939429.png"></p>
<p>有微信公众号后台数据作为证据，想问助攻姐，你可以说完全没有把我们公司公众号的文章作为你写文章时的参考资料吗？</p>
<p>除了我这个「电脑屏保」选题，这个号之前疑似抄袭过我们另外的选题：</p>
<p>原文：“看病百度，癌症起步” 权威的健康科普平台，推荐这些！<br>Copy：别一生病就百度，这7个健康科普平台才靠谱！</p>
<p>抄袭标题：</p>
<p>原标题：微软推出的逆天神器，让我抛弃用了5年的 Chrome。<br>Copy：微软推出的新版Edge浏览器，让我抛弃用了5年的Chrome！</p>
<p>原标题：这款相见恨晚的效率神器，让我卸载了80%的软件。<br>Copy：这款超1.2亿次下载的小体积效率神器，让我卸载了电脑上80%的软件！</p>
<p>抄选题就算了，惊呼这届新媒体人都不会起标题了？？？还是连标题都懒得起了？</p>
<p>秋叶 PPT 旗下的这个新号「职场神助攻」，其实有一种套路：</p>
<p>为了迅速做大，快速产出内容，就会去研究同行的工具号，看他们发布文章的选题和阅读量，然后依葫芦画瓢照着 Copy 一篇，留下参考文章中介绍的部分工具，再加入一些新的工具（或者把两篇参考文章的内容拼凑在一起），就变成了一篇新的原创文章，冷血麻木，比我这个木得感情的工具人还木得感情！</p>
<p>嗯，我写的东西是垃圾，公众号确实也做得不咋地，连写的垃圾都被人抄袭，那抄的人是连垃圾都不如吗？</p>
<h2 id="另外一个抄袭-·-未经授权使用我的图片"><a href="#另外一个抄袭-·-未经授权使用我的图片" class="headerlink" title="另外一个抄袭 · 未经授权使用我的图片"></a>另外一个抄袭 · 未经授权使用我的图片</h2><p>据我所知，助攻姐还负责运营秋叶家的另外一个知乎账号「秦阳」，她在一个回答里面用到的两张截图，也是来自我之前写的一篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMjY0NTY5OA==&mid=2649880429&idx=1&sn=6f626406d88a421fd518a88d899fe9b3&chksm=83abf340b4dc7a56221f4e0571af4d48ed27b93520ae7ffacb974dc4ee0d399fc4e84036183e&scene=21#wechat_redirect">Win10发布四年，这30个技巧还有很多人不知道！</a>》。</p>
<p><img src="http://cdn.penghh.fun/mweb/16099815394214.jpg"></p>
<p>这两张图片太有辨识度了：</p>
<p>一张介绍的是 Windows 的云剪贴板功能，不幸的是，图片里面的剪贴板内容，如「你在哪儿？我看不见」、「测试一下云剪贴板的个数」，就是那时我测试这个功能时自己随便输入的内容。</p>
<p>另外一张图，使用的是我去年非常喜欢的一个在线样机工具 Screely，那时我总喜欢先把截图上传到这个样机网站，套上一个类似 Mac 窗口截图的样机，再插入文章中。</p>
<p>请问助攻姐，你怎么解释这两张一模一样的图片呢？</p>
<p>因此，也不是我今天才冤枉你抄袭，因为你的抄袭是：</p>
<p>有「前科」的。<br>有「前科」的。<br>有「前科」的。</p>
<p>还有一个非常尴尬的事情是，那时我刚发现被未经授权引用了这两张图片，就在知乎上艾特了他们，但他们还是无动于衷，未对回答做出修改。</p>
<p>截至发本文的时候，那两张图片还在。感兴趣的朋友欢迎前去知乎围观，别说我冤枉他们：</p>
<p>秦阳在知乎问题「有哪些小白非常有必要知道但又不知道的 Windows 使用技巧？」的回答：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/42056923/answer/1012248907">https://www.zhihu.com/question/42056923/answer/1012248907</a>  </p>
<p><img src="http://cdn.penghh.fun/mweb/16099815128712.png"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>写这篇文章，一方面是为了泄恨，另一方面，是为了想让一些读者知道，一些你们所喜欢的大号、所以为的光明伟岸的新媒体团队，他们的真实嘴脸，原来是如此不堪，如此面目可憎。</p>
<p>希望屠龙少年最终不会成为恶龙，也自我告诫。</p>
<p>以上。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/03/2021-01-03-search-tool-competition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/03/2021-01-03-search-tool-competition/" itemprop="url">我所经历的拍照搜题的竞争</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-03T20:28:11+08:00">
                2021-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <img src="/images/search-tool-icons.jpg" class="">

<h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>最近听说学霸君似乎陷入了危机，见<a target="_blank" rel="noopener" href="https://money.163.com/20/1229/08/FV0KET3M00259DLP.html">报道 1</a>，<a target="_blank" rel="noopener" href="https://finance.sina.com.cn/tech/2020-12-29/doc-iiznctke9086285.shtml">报道 2</a>。我突然想把这段拍照搜题的竞争回顾一下，分享给大家。</p>
<h2 id="二、拍照搜题的玩家入场"><a href="#二、拍照搜题的玩家入场" class="headerlink" title="二、拍照搜题的玩家入场"></a>二、拍照搜题的玩家入场</h2><p>学霸君是中国最早做拍照搜题的公司，拍照搜题这个需求挖掘得非常精准，到现在也是整个 k12 行业最大的工具类需求。</p>
<p>拍照搜题本身也有着非常强的技术和内容门槛，所以当学霸君上一定规模的时候，市场的竞争对手并不多。我记得当时学霸君对外宣称：自己的拍照搜题技术壁垒有 5 年。</p>
<p>这句话其实不对，对于有 AI 算法研究团队的公司来说，拍照搜题的技术壁垒也就最多 6 个月时间。</p>
<p>相对于算法的壁垒，题目内容的录入反倒更难，因为你需要收录国内上亿道题目，才可能提供这种服务。</p>
<p>所以，在 2014 年和 2015 年，我们猿辅导、百度的作业帮先后入场拍照搜题。猿辅导在做猿题库的时候就积累了很多题目，作业帮在做内容学习社区的时候也积累了很多题目。算法对于我们来说都不是很难的事情。</p>
<p>我刚好是这个竞争的重度参与者，作为小猿搜题的产品技术负责人，我从 14 年产品立项就一直跟进这个产品，我们大概花了 2 个月做出来了小猿搜题第一个版本，14 年 9 月教师节那天上线。</p>
<p>作业帮的反应速度也很快，作业帮在 14 年还是一个同学间作业互助的社区，到 15 年初也改成主要提供拍照搜题的工具软件。</p>
<p>15 年还有一家拍照搜题公司风头很大，叫学习宝。</p>
<img src="/images/xuexibao-app.jpg" class="">

<p>于是，到了 15 年中，学霸君，小猿搜题，作业帮，学习宝开始了商业的竞争。</p>
<h2 id="三、竞争的发展"><a href="#三、竞争的发展" class="headerlink" title="三、竞争的发展"></a>三、竞争的发展</h2><p>工具类产品竞争，核心是比拼什么？</p>
<p>有人说是体验，有人说是算法正确率，有人说是内容。但是我看来，这些都很难做出极大的用户差异。</p>
<p>我们定期做算法评测，日复一日的优化算法和录入新的题目内容。长年维持着一个上百人的实习生团队。但这些事情，都不足以让大家拉开差距。</p>
<p>因为你在做的时候，别人也在做，而内容和算法的优化对于用户体验来说，感受是细微的。98% 的准确率和 97% 的准确率对于算法来说可能需要好多个月地努力，但是用户要差不多拍 100 次才能有一次感受到差异。事实上这一点算法差异用户根本就感受不到，没有用户会认真地评测搜题软件的准确率。</p>
<p>所以，如何规模化的获客，才是搜题软件竞争得关键。</p>
<p>学习宝是第一个看到这个核心的，他们非常早就开始了大规模的获客投放。但他们也是第一个掉队的，因为他们连基础的算法和内容补充都没有做好。我们和学霸君，作业帮的算法差距一直都在几个点这样，但是学习宝能够比我们差 20%~30% 的准确率。这肯定不行，用户简单搜两三次就会发现差距。于是他们在市场上连续投放几个月之后，就没有了声音。</p>
<p>学霸君在这个事情上犯了致命错误，他在所有方面都占优的情况下，在 15 年没有大规模的获客。因为他们之前太舒服了。</p>
<p>你想想：一款直击用户痛点的拍照搜题产品，在 2015 年之前没有竞争对手出现，用户口碑传播的效果肯定非常好。所以学霸君在竞争开始前，已经习惯了非常舒服的用户增长，口碑传播这一套，而且效果很好。他们很自然地继续希望用这种低成本的方式扩张。</p>
<p>这个决策失误带来的代价就是，我们和作业帮在商业上的投放使得我们迅速加速占领了增量的市场。2015 年猿辅导还是一家小公司，我们想了很多办法来降低获客成本。</p>
<p>最终完成这场竞争的其实是猿辅导市场部的同事们，他们用了很多创新的方法来寻找低成本渠道，最终我们探索出来很多低价的获客方式。</p>
<p>而学霸君，在拥有上百万存量用户的情况下，被我们很快超过了。我为什么知道他们被超过了？因为他们的用户 ID 是 “自增的”，每次注册，用户的 User ID 加 1。于是我们只需要每个月注册一个新用户，就知道他这个月新增了多少。到 2015 年底，我们已经甩开学霸君很多了。</p>
<p>到了 2016 年，拍照搜题的用户量排名是：作业帮，小猿搜题，学霸君。而这个排次也一直到了现在。</p>
<h2 id="四、题拍拍"><a href="#四、题拍拍" class="headerlink" title="四、题拍拍"></a>四、题拍拍</h2><img src="/images/tipaipai.png" class="">

<p>学而思后知后觉，20 年突然觉得自己不能在课堂上推荐竞争对手的产品，于是出了一个题拍拍。题拍拍挖了不少小猿搜题的同事过去。</p>
<p>竞争上，算法内容肯定没得比，所以他们主打搜不到的话真人答疑。其实大家都知道这个事情用户成规模之后根本做不到，但是学而思的逻辑应该是我先说我有，把用户吸引过来再说，而且用户量小的时候，我还真能做到真人答疑。</p>
<p>1000 个答题官，答题平均花费 5 分钟，高峰期的时候每小时也就只能服务 1 万多学生。搜题的用户高峰每小时至少是几百万用户，99% 的人排队是什么体验？或者学而思有能力招 10 万个答题官？</p>
<p>Anyway，从竞争角度看，初期用户规模小的时候用这个策略还行。长远来看，构不成差异化竞争。</p>
<h2 id="五、结束语"><a href="#五、结束语" class="headerlink" title="五、结束语"></a>五、结束语</h2><p>时光倒回，学霸君如果在 14 年就融资并大规模推广，有可能就会是这个行业最大的玩家并垄断市场，想到这儿也挺替学霸君惋惜的。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/posts/2020-summary.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/2020-summary.html" itemprop="url">2020 年度总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-01T15:23:42+08:00">
                2021-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020 年，是奇幻的一年，我们共抗疫情，见证了太多太多。对于我来说，2020 年也是非常不寻常的一年，在这一年中，既有收获，也有失去，那么就以本文来总结一下 2020 年我做了哪些事情，收获了什么，同时也是给自己一个交代，有习惯则继续保持，不好的习惯则应戒掉。</p>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="关于写文章"><a href="#关于写文章" class="headerlink" title="关于写文章"></a>关于写文章</h3><p>说来惭愧，在今年，我整整大半年没有更新博客，于是八月份的时候我在《<a target="_blank" rel="noopener" href="https://4ark.me/posts/tai-jiu-mei-geng-xin-blog-de-yi-xie-fan-si.html">太久没更新博客的原因和反思</a>》中进行反思，主要原因是我变懒了，另外一个原因就是我认为没有东西什么值得写的，后来我坦然了，其实写博客这件事真的不能太功利，我认为我写博客更多是写给自己看，当然也希望能够帮助到他人，但我最终目的是为了给以后的自己看，因为人的想法会随着年龄的增长而改变，我想把我的想法记录下来，放在互联网上。</p>
<p>于是后面我有了写月总结的习惯，因为一年太长了，我怕等到写年总结的时候，忘了自己之前做了哪些事，所以每隔一个月记录一下是挺有用的。</p>
<p>今年写在本站的大部分文章都是比较偏个人想法或记录类的，技术性文章不多，但我今年在工作中却是做了不少技术性相关的文章，也有一部分发布到知乎专栏，虽然点赞的人不多，但我并不在意，因为我知道这些都是我工作过程中实际解决的问题，我更喜欢写这类文章，虽然没有这篇《<a target="_blank" rel="noopener" href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么（超详细版）</a>》吸引眼球，但前者给我收获要更大。</p>
<h3 id="关于抄袭"><a href="#关于抄袭" class="headerlink" title="关于抄袭"></a>关于抄袭</h3><p>林子大了什么鸟都有，在数月前，发生了一件让我不太愉快的事，我偶然间发现了一个人抄袭我的文章，还在各大技术社区以原创的形式发布，这让我非常恼火，关于这件事情的讨论可以看 <a target="_blank" rel="noopener" href="https://v2ex.com/t/703344#reply85">这篇 V2EX 的帖子</a>。</p>
<p>这件事给我最大的感触就是，这种人很多，这不是第一个，也绝对不是最后一个，我作为一个普通人，没有太多精力去维权，我能做的也只是看到就顺手举报一下，所以我希望国内对于知识产权要更加重视，本来中文互联网的优质内容已经逐渐减少，如果再让这种剽窃他人成果的行为泛滥，最终只会寒了大家的心。</p>
<p>另外这里我要吐槽一下微信公众号平台，它本身的封闭性决定了我永远不会在上面发布内容，并且它的审查机制只会根据本平台现有的内容来做原创判断，也就意味着别人可以任意将一些没有在微信公众号发表为原创的文章标记为自己原创，这过程可能只需要几分钟，而申诉者却要花上大半个小时才能填写好它那个极其不人性化的表单，最后还要整整七个工作日才会<strong>下发</strong>（我很不喜欢这个词）处理结果。</p>
<h2 id="工作与成长"><a href="#工作与成长" class="headerlink" title="工作与成长"></a>工作与成长</h2><p>去年 11 月份我在《<a target="_blank" rel="noopener" href="https://4ark.me/posts/why-i-became-a-programmer">我为什么会成为一名程序员</a>》一文中讲述我进入这行业的初心，以及我当时对现状的一个忧虑，当时我知道我需要一个能够带领我成长的团队，所以在同一个月，我回到广州工作，加入了一个让我感到兴奋的团队，在《<a target="_blank" rel="noopener" href="https://4ark.me/posts/review-summary.html">面试总结</a>》中我总结了我与团队内其他成员的差距，面试时我曾信誓旦旦地说半年后我能达到他们的高度，当然后面并没有做到，但在下半年，由于团队内一些核心人员的流失，我开始负责一些比较重要的任务，在这过程中，我完成了从别人带着干活发展到能够独当一面，这其中的成长让我知道，我兑现我曾许下的诺言，虽然花了整整一年的时间。</p>
<p>但由于我个人的学历原因，以及公司的制度变更，我意识到我可能无法在这家公司转正，这时候刚好我的一个师兄找我一起回去创业，我思考了很久，我想起我当时为什么要回广州，我觉得我现在已经没有当时的顾虑了，我坚信即使不在现在的团队，我也依然能够保持现有的工作习惯和职业素养，再综合一些其他因素，我认为这是我当下的最好选择，所以我离开了广州，关于这件事的想法我也写在《<a target="_blank" rel="noopener" href="https://4ark.me/posts/hui-guang-zhou-yi-nian-you-gan.html">回广州一年有感</a>》一文中。</p>
<p>我回来已经有一个多月，虽然前期有点不太适应，但已经逐渐把心态调整过来，我正在把我之前团队的文化带来这里，同时我也相信这里能够给我带来更多不一样的成长。</p>
<h2 id="阅读与兴趣"><a href="#阅读与兴趣" class="headerlink" title="阅读与兴趣"></a>阅读与兴趣</h2><p>如果说我今年最大的两个兴趣，那就是：阅读 RSS 和 历史了。当然今年我也看了一些书。</p>
<h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>现在还用 RSS 阅读的人估计不多了，现在是公众号、各大平台的推荐机制的天下，RSS 这种古老的东西已经渐渐没落。</p>
<p>那我又是怎么与 RSS 结缘的呢？是因为我想要一个统一汇总阅读我感兴趣的内容、并且不算推荐算法所影响的阅读平台，这时候 RSS 就重新走到我面前，试用一段时间后发现，这就是我想要的。</p>
<p>在这里要感谢两个开源项目：<a target="_blank" rel="noopener" href="https://github.com/DIYgod/RSSHub">RSSHub</a> 和 <a target="_blank" rel="noopener" href="https://github.com/HenryQW/Awesome-TTRSS">ttrss</a>，这让 RSS 有了更多玩法，我可以随意订阅一切我感兴趣的内容，这才是我认为的互联网，与微信公众号完全不一样。</p>
<p>另外对 RSS 感兴趣的同学，如果你是 Mac&#x2F;iOS，那么强烈推荐使用 Reeder 这款阅读器，我希望所有软件都可以像它一样使用起来如此丝滑。</p>
<p>我利用 RSS 阅读什么？很多，除了一些常规的 RSS 订阅源，我还折腾了一些其他的：</p>
<ul>
<li>看书<ul>
<li>epub 转 html，每天推送一章</li>
</ul>
</li>
<li>看历史文章<ul>
<li>将某个博客网的所有历史文章标题和链接爬下来，每天推送几篇</li>
</ul>
</li>
<li>看图<ul>
<li>诸如 100photos 这样的图册，每天看一张图片背后的故事</li>
</ul>
</li>
</ul>
<p>RSS 在我看来本身就一个利用碎片时间阅读，如果要真正构建知识体系，还是认认真真地看书吧。</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>今年另一个重大改变就是对历史感兴趣了，起初是因为看了《明朝那些事儿》这本书，后来一发不可收拾，然后阅读了《中国大历史》、《中国近代史》。闲人读历史，目的大概有三种，一种是证明了自己博学，一种是追溯上古的八卦，一种是想弄明白为什么是现在这个样子，起初我是第二种，后来我发现历史中可以学到很多东西，包括历史是如何发展的，以及古人面对如何处理事情，这都给我很大收获。</p>
<p>当然了，读历史，怎能不读《史记》呢？所以我最近开始读史记，起初想直接读原文，后来感觉有点吃力，于是找了个白话文与原文对照着看，希望明年能够针对这本书上的一些事迹写下自己的感悟。</p>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>我读书一直是比较佛性的人，能看下去的就接着看，看不下去也不要强迫自己，所以经常会出现，一本书看了前面两章，然后就被搁置，后来开的坑越来越多，真正能读完的也没几本，希望明年我能看更多好书吧。</p>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>提升英语能力是我一直非常想做，但是又一直在逃避的事，我从去年就开始下定决心提升英语，也做过各种各样的尝试，包括背单词、读英文书、看英文视频，不能说没有效果，但我都坚持不下去。</p>
<p>我也曾想过可能是我做这件事的意愿不够，没有找到真正适合我的方法，但不管怎么说，我还是会继续尝试。</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>一年过去了，虽然在生活上过的比较苦逼，但我认为这一年我还是比较充实的，也坚信明年的生活会过得好一点。</p>
<p>2021 年，我会继续保持现在的好习惯，我也希望我能在思想方面有更大的提升，建立自己的知识体系和观点，做到不随波逐流。</p>
<p>关于立 Flag 这件事，其实我已经不想再做了，因为我觉得我不知道明年会有哪些新的兴趣爱好，会有哪些重大改变，所以一切都随缘吧，但我希望我能够认真对待我所做的每一件事，这就足够了。</p>
<p>最后，祝大家新年快乐！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/31/2020/2020-12-31-summary-of-2020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/31/2020/2020-12-31-summary-of-2020/" itemprop="url">2020 年度小结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-31T00:00:00+08:00">
                2020-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2020 可能对于每一个人都是非常特殊的一年，中间发生的几乎每一件事都能和疫情联系起来。本来盼望了很久能在春节去蛋黄的老家放烟花，然而随着新冠疫情愈演愈烈，我们最后在 1 月 17 日决定取消了行程。</p>
<p>在疫情的初期也就是春节期间，事件的发展有着很大的不确定性，这种不确定性和媒体中对立的观点对我的情绪影响也很大，从这里开始，应该说这一整年我的情绪都很差。这次疫情也打破了我之前对于科技和未来的一些想象 —— 原来在今天，病毒会对人类社会造成这么大的影响、给我们的生活带来这么大的变化，而且这种变化很有可能常态化地持续下去。</p>
<p>年初蛋黄开始在我的指导下比较系统地开始学习 JavaScript 和 Web，中间短暂地工作过几个月，后面又开始学 Swift。一开始我非常着急希望蛋黄能学会一些技能然后开始工作，为此经常吵架。但后来蛋黄工作后我的情绪也没有变好，变得越来越难调节自己的情绪、总是在患得患失，也发生了很多不开心的事情。在这种情况下也很难去规划未来，只能先调整情绪，这个过程中全靠蛋黄哄着我。这对我的内容创作影响也很大，今年的内容输出非常少。希望我们能早些回到刚搬到昆山时的状态。</p>
<p>在年初我们参加了一次 <a target="_blank" rel="noopener" href="https://twitter.com/QQSun/status/1215148321821446147">烧火节</a> 的线下活动，以此为契机拍摄制作了我的第一个 Vlog「<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1s7411V73p">第一届烧火节 Vlog：钻木取火、烧烤露营</a>」。在之后我陆续购买了新的相机和稳定器等设备、拍摄了大量的素材，也制作了其他几个视频，但回过头来看烧火节的 Vlog 仍然是我最满意的一个视频。在疫情有了一定缓解之后我们还去了迪士尼和横店，也拍了很多视频，不过一直没有来得及剪辑成片。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2020/2020-fire-festival.png"></p>
<p>今年我业余时间完成的最大的一个项目是 NAS，我花了半年的时间，先在树莓派上做实验，然后购买了 HPE MicroServer Gen 10 作为正式环境，希望能解决未来十年的存储需求。我还将整个过程写成了一篇文章「<a target="_blank" rel="noopener" href="https://jysperm.me/2020/11/my-opensource-nas-build/">我的 NAS 选型与搭建过程</a>」。它的主机名叫 <code>infinity</code>，实际投入使用后确实给了我很大的安全感 —— 这是一个由我所熟悉的开源软件构建的、有着先进的备份和纠错机制的存储系统，数据一旦被导入其中就几乎不可能再丢失。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2020/2020-nas.png"></p>
<p>所幸在疫情期间我也找到了一些投资机会，在全面的货币增发的情况下，今年收入和个人资产都有不小的增长，尤其在年底，密码货币差不多已经涨回了 2017 年的高点。从我工作以来这种收入和资产的不断增长，让我一直对未来保持着一种乐观的态度。</p>
<p>在工作方面，今年最大的变化是我需要花更多的时间去协调其他同事的工作，拆分工作、制定计划、参与面试，将自己的知识和经验分享给新加入的同事。随着工作年限的增加，工作本身会要求你承担更重要、更复杂（但可能没那么有趣）的工作，如果跟不上这种变化可能就需要给别人让位了，我想这应该就是所谓的「35 岁危机」。</p>
<p>一转眼从北京回到昆山也两年多了，开始觉得昆山实在是待够了 —— 现在我们几乎把昆山能逛的地方都逛了遍。我们接下来大概率会搬到上海，因为相比于其他选择，这可能是最容易做出的一个改变。其实这有点像我三年前搬去北京的理由，但我觉得上海无论是环境还是生活节奏应该都会比北京好很多。</p>
<p><img src="https://r2-lc-cn.jysperm.me/pictures/2020/2020-fog-of-world.png"></p>
<p>在有了搬去上海这个想法之后，我发现我越来越害怕失去，之前每次搬家的过程中会扔掉很多东西，但现在就想把所有东西都留着；我会舍不得昆山的办公室；舍不得我们在昆山的房子 —— 我们在这里住了三年，留下了很多回忆，同时在不断地改造这个房子，让人觉得很难有比这里更舒服的地方了。我也会担心皮蛋豆腐 —— 它们今年经常会吐，中间豆腐还有那么半个月食欲不佳，虽然最后去医院检查时一切正常。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/30/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0%EF%BC%8C%E7%94%B1ADO.NET%E4%B8%8EDapper%E6%89%80%E8%81%94%E6%83%B3%E5%88%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/30/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0%EF%BC%8C%E7%94%B1ADO.NET%E4%B8%8EDapper%E6%89%80%E8%81%94%E6%83%B3%E5%88%B0%E7%9A%84/" itemprop="url">温故而知新，由 ADO.NET 与 Dapper 所联想到的</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-30T12:49:47+08:00">
                2020-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p> 这段时间在维护一个“遗产项目”，体验可以说是相当地难受，因为它的数据持久化层完全由 ADO.NET 纯手工打造，所以，你可以在项目中看到无所不在的 DataTable，不论是读操作还是写操作。这个 DataTable 让我这个习惯了 Entity Framework 的人感到非常别扭，我并不排斥写手写 SQL 语句，我只是拥有某种自觉并且清醒地知道，自己写的 SQL 语句未必就比 ORM 生成的 SQL 语句要好。可至少应该是像 Dapper 这种程度的封装啊，因为关系型数据库天生就和面向对象编程存在隔离，所以，频繁地使用 DataTable 无疑意味着你要写很多的转换的代码，当我看到<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapter</code>这些熟悉的“底层”的时候，我意识到我可以结合着 Dapper 的实现，从中梳理出一点改善的思路，所以，这篇博客想聊一聊<strong>ADO.NET</strong>、<strong>Dapper</strong>和<strong>Dynamic</strong>这三者间交叉的部分，希望能给大家带来新的启发。</p>
<h1 id="重温-ADO-NET"><a href="#重温-ADO-NET" class="headerlink" title="重温 ADO.NET"></a>重温 ADO.NET</h1><p>相信大家都知道，我这里提到的<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapte</code>以及<code>DataTable</code>、<code>DataSet</code>，实际上就是 ADO.NET 中核心的组成部分，譬如<code>DbConnection</code>负责管理数据库连接，<code>DbCommand</code>负责 SQL 语句的执行，<code>DbDataReader</code>和<code>DbDataAdapter</code>负责数据库结果集的读取。需要注意的是，这些类型都是抽象类，而各个数据库的具体实现，则是由对应的厂商来完成，即我们称之为“驱动”的部分，它们都遵循同一套接口规范，而<code>DataTable</code>和<code>DataSet</code>则是“装”数据库结果集的容器。关于 ADO.NET 的设计理念，可以从下图中得到更清晰的答案：</p>
<p><img src="https://i.loli.net/2020/12/31/dEN2tajehboDiTl.png" alt="ADO.NET架构"></p>
<p>在这种理念的指引，使用 ADO.NET 访问数据库通常会是下面的画风。博主相信，大家在各种各样的<code>DbHelper</code>或者<code>DbUtils</code>中都见过类似的代码片段，在更复杂的场景中，我们会使用<code>DbParameter</code>来辅助<code>DbCommand</code>，而这就是所谓的<strong>SQL 参数化查询</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">&quot;Chinook.db&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SQLiteConnection(<span class="string">$&quot;Data Source=<span class="subst">&#123;fileName&#125;</span>&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.State != ConnectionState.Open) connection.Open();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> command = connection.CreateCommand())</span><br><span class="line">    &#123;</span><br><span class="line">        command.CommandText = <span class="string">&quot;SELECT AlbumId, Title, ArtistId FROM [Album]&quot;</span>;</span><br><span class="line">        command.CommandType = CommandType.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路1：使用DbDataReader读取数据</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> reader = command.ExecuteReader())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (reader.Read())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//各种眼花缭乱的写法:)</span></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;AlbumId=<span class="subst">&#123;reader.GetValue(<span class="number">0</span>)&#125;</span>&quot;</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Title=<span class="subst">&#123;reader.GetFieldValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Title&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;ArtistId=<span class="subst">&#123;reader.GetInt32(<span class="string">&quot;ArtistId&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路2：使用DbDataAdapter读取数据</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> adapter = <span class="keyword">new</span> SQLiteDataAdapter(command))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> dataTable = <span class="keyword">new</span> DataTable();</span><br><span class="line">            adapter.Fill(dataTable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里经常会引发的讨论是，<code>DbDataReader</code>和<code>DbDataAdapter</code>的区别以及各自的使用场景是什么？简单来说，前者是按需读取&#x2F;只读，数据库连接会一直保持；而后者是一次读取，数据全部加载到内存，数据库连接用完就会关掉。从资源释放的角度，听起来后者更友好一点，可显然结果集越大占用的内存就会越多。而如果从易用性上来考虑，后者可以直接填充数据到<code>DataSet</code>或者<code>DataTable</code>，前者则需要费一点周折，你看这段代码是不是有点秀操作的意思：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种眼花缭乱的写法:)</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;AlbumId=<span class="subst">&#123;reader.GetValue(<span class="number">0</span>)&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Title=<span class="subst">&#123;reader.GetFieldValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Title&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;ArtistId=<span class="subst">&#123;reader.GetInt32(<span class="string">&quot;ArtistId&quot;</span>)&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个“遗产项目”中，<code>DbDataReader</code>和<code>DbDataAdapter</code>都有所涉猎，后者在结果集不大的情况下还是可以的，唯一的遗憾就是<code>DataTable</code>和<code>LINQ</code>的违和感实在太强烈了，虽然可以勉强使用<code>AsEnumerable()</code>拯救一下，而前者就有一点魔幻了，你能看到各种<code>GetValue(1)</code>、<code>GetValue(2)</code>这样的写法，这简直就是成心不想让后面维护的人好过，因为加字段的时候要小心翼翼地，确保字段顺序不会被修改。明明这个世界上有<a target="_blank" rel="noopener" href="https://github.com/StackExchange/Dapper">Dapper</a>、<a target="_blank" rel="noopener" href="https://github.com/donet5/SqlSugar">SqlSugar</a>、<a target="_blank" rel="noopener" href="https://smartsql.net/">SmartSql</a>这样优秀的 ORM 存在，为什么就要如此执著地写这种代码呢？是觉得 MyBatis 在 XML 里写 SQL 语句很时尚吗？</p>
<p>所以，我开始尝试改进这些代码，我希望它可以像 Dapper 一样，提供<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法足矣！如果要把结果集映射到一个具体的类型上，大家都能想到使用反射，我更想实现的是 Dapper 里的<code>DapperRow</code>，它可以通过“·”或者字典的形式来访问字段，现在的问题来了，你能实现类似 Dapper 里 DapperRow 的效果吗？因为想偷懒的时候，dynamic 不比 DataRow 更省事儿吗？那玩意儿光转换类型就要烦死人了，更不用说要映射到某个 DTO 啦！</p>
<h1 id="实现-DynamicRow"><a href="#实现-DynamicRow" class="headerlink" title="实现 DynamicRow"></a>实现 DynamicRow</h1><p>通过阅读 Dapper 的源代码，我们知道，Dapper 中用<a target="_blank" rel="noopener" href="https://github.com/StackExchange/Dapper/blob/main/Dapper/SqlMapper.DapperTable.cs">DapperTable</a>和<a target="_blank" rel="noopener" href="https://github.com/StackExchange/Dapper/blob/main/Dapper/SqlMapper.DapperRowMetaObject.cs">DapperRow</a>替换掉了 DataTable 和 DataRow，可见这两个玩意儿有多不好用，果然，英雄所见略同啊，哈哈哈！其实，这背后的一切的功臣是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.dynamic.idynamicmetaobjectprovider?view=net-5.0">IDynamicMetaObjectProvider</a>，通过这个接口我们就能实现类似的功能，我们熟悉的<code>ExpendoObject</code>就是最好的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> person = <span class="keyword">new</span> ExpandoObject(); </span><br><span class="line">person.FirstName = <span class="string">&quot;Sherlock&quot;</span>; </span><br><span class="line">person.LastName = <span class="string">&quot;Holmes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line">(person <span class="keyword">as</span> IDctionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)[<span class="string">&quot;FirstName&quot;</span>] = <span class="string">&quot;Sherlock&quot;</span>;</span><br><span class="line">(person <span class="keyword">as</span> IDctionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)[<span class="string">&quot;LastName&quot;</span>] = <span class="string">&quot;Holmes&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里，我们用一种简单的方式，让 DynamicRow 继承者 DynamicObject，下面一起来看具体的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicRow</span> : <span class="title">DynamicObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDataRecord _record;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicRow</span>(<span class="params">IDataRecord <span class="keyword">record</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _record = <span class="keyword">record</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="built_in">object</span> result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> index = _record.GetOrdinal(binder.Name);</span><br><span class="line">        result = index &gt; <span class="number">0</span> ? _record[binder.Name] : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//支持像字典一样使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">string</span> field] =&gt;</span><br><span class="line">       _record.GetOrdinal(field) &gt; <span class="number">0</span> ? _record[field] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>DynamicObject</code>这个类型而言，里面最重要的两个方法其实是<code>TryGetMember()</code>和<code>TrySetMember()</code>，因为这决定了这个动态对象的读和写两个操作。因为我们这里不需要反向地去操作数据库，所以，我们只需要关注<code>TryGetMember()</code>即可，一旦实现这个方法，我们就可以使用类似<code>foo.bar</code>这种形式访问字段，而提供一个索引器，则是为了提供类似<code>foo[&quot;bar&quot;]</code>的访问方式，这一点同样是为了像 Dapper 看齐，无非是 Dapper 的 DynamicRow 本来就是一个字典！</p>
<p>现在，我们来着手实现一个简化版的 Dapper，给<code>IDbConnection</code>这个接口扩展出<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法，我们注意到<code>Query&lt;T&gt;()</code>需要用到<code>DbDataReader</code>或者<code>DbDataAdapter</code>其一，对于<code>DbDataAdapter</code>而言，它的实现完全由具体的子类决定，所以，对于<code>IDbConnection</code>接口而言，它完全不知道对应的子类是什么，此时，我们只能通过判断<code>IDbConnection</code>的类型来返回对应的 DbDataAdapter。读过我之前<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3086300103/">博客</a>的朋友，应该对 Dapper 里的数据库类型的字典有印象，不好意思，这里历史要再次上演啦！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">dynamic</span>&gt; <span class="title">Query</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> reader = connection.CreateDataReader(sql);</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">DynamicRow</span>(<span class="params">reader <span class="keyword">as</span> IDataRecord</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Query</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>) </span></span><br><span class="line"><span class="function">  <span class="keyword">where</span> T : <span class="keyword">class</span>, <span class="keyword">new</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> reader = connection.CreateDataReader(sql);</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">reader <span class="keyword">as</span> IDataRecord</span>).<span class="title">Cast</span>&lt;<span class="title">T</span>&gt;()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>CreateDataReader()</code>和<code>Cast()</code>都是博主自定义的扩展方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IDataReader <span class="title">CreateDataReader</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteReader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> T <span class="title">Cast</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IDataRecord <span class="keyword">record</span></span>) <span class="keyword">where</span> T:<span class="keyword">class</span>, <span class="keyword">new</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="function"><span class="keyword">var</span> property <span class="keyword">in</span> <span class="title">typeof</span>(<span class="params">T</span>).<span class="title">GetProperties</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="keyword">record</span>.GetOrdinal(property.Name);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> propertyType = property.PropertyType;</span><br><span class="line">        <span class="keyword">if</span> (propertyType.IsGenericType &amp;&amp; </span><br><span class="line">          propertyType.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(Nullable&lt;&gt;))</span><br><span class="line">            propertyType = Nullable.GetUnderlyingType(propertyType);</span><br><span class="line">        property.SetValue(instance, </span><br><span class="line">          Convert.ChangeType(<span class="keyword">record</span>[<span class="title">property.Name</span>], <span class="title">propertyType</span>));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>Execute()</code>方法则要简单的多，因为从<code>IDbConnection</code>到<code>IDbCommand</code>的这条线，可以直接通过<code>CreateCommand()</code>来实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteNonQuery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现参数化查询"><a href="#实现参数化查询" class="headerlink" title="实现参数化查询"></a>实现参数化查询</h1><p>大家可以注意到，我这里的参数 param 完全没有用上，这是因为<code>IDbCommand</code>的<code>Paraneters</code>属性显然是一个抽象类的集合。所以，从<code>IDbConnection</code>的角度来看这个问题的时候，它又不知道这个参数要如何来给了，而且像 Dapper 里的参数，涉及到集合类型会存在<code>IN</code>和<code>NOT IN</code>以及批量操作的问题，比普通的字符串替换还要稍微复杂一点。如果我们只考虑最简单的情况，它还是可以尝试一番的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetDbParameter</span>(<span class="params"><span class="keyword">this</span> IDbCommand command, <span class="built_in">object</span> param = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (param == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (param <span class="keyword">is</span> IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用字典作为参数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> arg <span class="keyword">in</span> param <span class="keyword">as</span> IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">var</span> newParam = command.CreateParameter();</span><br><span class="line">              newParam.ParameterName = <span class="string">$&quot;@<span class="subst">&#123;arg.Key&#125;</span>&quot;</span>;</span><br><span class="line">              newParam.Value = arg.Value;</span><br><span class="line">              command.Parameters.Add(newParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名对象作为参数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> property <span class="keyword">in</span> param.GetType().GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">var</span> propVal = property.GetValue(param);</span><br><span class="line">              <span class="keyword">if</span> (propVal == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">var</span> newParam = command.CreateParameter();</span><br><span class="line">              newParam.ParameterName = <span class="string">$&quot;@<span class="subst">&#123;property.Name&#125;</span>&quot;</span>;</span><br><span class="line">              newParam.Value = propVal;</span><br><span class="line">              command.Parameters.Add(newParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，为了能在<code>Query&lt;T&gt;()</code>和<code>Execute()</code>两个方法中使用参数，我们需要修改相关的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span> param = <span class="literal">null</span>, IDbTransaction trans = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    command.SetDbParameter(param);</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteNonQuery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IDataReader <span class="title">CreateDataReader</span>(<span class="params"><span class="keyword">this</span> IDbConnection connection, <span class="built_in">string</span> sql, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">object</span> param = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = connection.CreateCommand();</span><br><span class="line">    command.CommandText = sql;</span><br><span class="line">    command.CommandType = CommandType.Text;</span><br><span class="line">    command.SetDbParameter(param);</span><br><span class="line">    <span class="keyword">return</span> command.ExecuteReader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，唯一的问题就剩下<code>DbType</code>和<code>@</code>啦，前者在不同的数据库中可能对应不同的类型，后者则要面临 Oracle 这朵奇葩的兼容性问题，相关内容可以参考在这篇博客：<a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/3086300103/">Dapper.Contrib 在 Oracle 环境下引发 ORA-00928 异常问题的解决</a>。到这一步，我们基本上可以实现类似 Dapper 的效果。当然，我并不是为了重复制造轮子，只是像从 Dapper 这样一个结果反推出相关的技术细节，从而可以串联起整个 ASO.NET 甚至是 Entity Framework 的知识体系，工作中解决类似的问题非常简单，直接通过 NuGet 安装 Dapper 即可，可如果你想深入了解某一个事物，最好的方法就是亲自去探寻其中的原理。现在基础设施越来越完善了，可有时候我们再找不回编程的那种快乐，大概是我们内心深处放弃了什么……</p>
<p>考虑到，从微软的角度，它鼓励我们为每一家数据库去实现数据库驱动，所以，它定义了很多的抽象类。而从 ORM 的角度来考虑，它要抹平不同数据库的差异，Dapper 的做法是给<code>IDbConnection</code>写扩展方法，而针对每个数据库的“方言”，实际上不管什么 ORM 都要去做这部分“脏活儿”，以前是分给数据库厂商去做，现在是交给 ORM 设计者去做，我觉得 ADO.NET 里似乎缺少了一部分东西，它需要提供一个 IDbAdapterProvider 的接口，返回 IDbAdapter 接口，这样就可以不用关心它是被如何创建出来的。你看，同样是设计接口，可微软和 ServiceStack 俨然是两种不同的思路，这其中的差异，足可窥见一斑矣！实际上，Entity Framework 就是在以 ADO.NET 为基础发展而来的，在这个过程中，还是由厂商来实现对应的 Provider。此时此刻，你悟到了我所说的“温故而知新”了嘛？</p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文实则由针对 DataSet&#x2F;DataTable 的吐槽而引出，在这个过程中，我们重新温习了 ADO.NET 中<code>DbConnection</code>、<code>DbCommand</code>、<code>DbDataReader</code>、<code>DbDataAdapter</code>这些关键的组成部分，而为了解决 DataTable 在使用上的种种不变，我们想到了借鉴 Dapper 中的 DapperRow 来实现“动态查询”，由此引出了.NET 中实现 dynamic 最重要的一个接口：<code>IDynamicMetaObjectProvide</code>，这使得我们可以在查询数据库的时候返回一个 dynamic 的集合。而为了更接近 Dapper 一点，我们基于扩展方法的形式为<code>IDbConnection</code>编写了<code>Query&lt;T&gt;()</code>和<code>Execute()</code>方法，在数据库读写层面上彻底终结了 DataSet&#x2F;DataTable 的生命。最后，我们实现了一个简化版本的参数化查询，同样是借鉴 Dapper 的思路。这说明一件什么事情呢？<strong>当你在一个看似合理、结局固定的现状中无法摆脱的时候，“平躺”虽然能让你获得一丝喘息的机会，但与此同时，你永远失去了跳出这个层级去看待事物的机会</strong>，就像我以前吐槽同事天天用<code>StringBuider</code>拼接字符串一样，一味地吐槽是没有什么用的，重要的是你会选择怎么做，所以，后来我向大家推荐了<a target="_blank" rel="noopener" href="https://github.com/dotliquid/dotliquid">Linquid</a>，<strong>2021 年已经来了，希望你不只是增长了年龄和皱纹</strong>，晚安！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/27/2020/12/hexo-to-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/27/2020/12/hexo-to-docker/" itemprop="url">使用Docker轻松部署Hexo博客系统</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-27T14:00:00+08:00">
                2020-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">系统设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>我的 <a target="_blank" rel="noopener" href="https://www.fanhaobai.com/">博客</a> 停服已经有几个月了，主要原因是使用的 <a target="_blank" rel="noopener" href="https://cloud.google.com/free/">Google Cloud</a> 免费服务器已经到期了，而整个博客系统的迁移成本很大，因此迟迟没有开启服务。</p>
<p><img src="//www.fanhaobai.com/2020/12/hexo-to-docker/704035c6-348e-439b-9048-d05a2a18ef1f.png" alt="预览图">
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/12/27/2020/12/hexo-to-docker/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/26/2020-12-26-how-to-apply-international-bank-card/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/26/2020-12-26-how-to-apply-international-bank-card/" itemprop="url">如何申请境外银行卡</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-26T08:36:21+08:00">
                2020-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>老有人问我怎么申请的境外银行卡，今天就给大家分享一下我知道的境外银行卡开户方式。</p>
<h2 id="一、肉身出境办理"><a href="#一、肉身出境办理" class="headerlink" title="一、肉身出境办理"></a>一、肉身出境办理</h2><p>现在因为疫情出境游受限，其实平时大家可能都有境外游的机会，这个时候可以考虑直接在当地办卡。香港地区可以直接下卡，也没有资产的限制，美国我几年前旅游的时候，在当地的唐人街中国银行问了一下，只需要提供护照及一个当地固定的接收帐单地址，也可以直接办卡。</p>
<p>这种办理的方法的好处是不用受一些限制，你可以比较随意挑银行来办。性价比最高的应该就是去香港办理了。</p>
<h2 id="二、国内银行"><a href="#二、国内银行" class="headerlink" title="二、国内银行"></a>二、国内银行</h2><p>国内比较大的银行也可以申请办理境外银行卡，比如招商，中行，不过限制都比较多。比如招商银行需要有 500 万的资产在招行才可以办理。中国银行我几年前问的时候，说名额有限，需要预约，然后我登记之后就一直没有消息了。</p>
<p>现在招商银行有针对我司的特别政策，如果是猿辅导的员工，即可办理境外账户的开立服务。包含招商永隆银行（借记卡账户）+招银国际（证券账户）。</p>
<p>除了境外账户的开户，招行还提供了针对性的私人银行服务（无限次机场贵宾厅服务+PP卡）和金葵花理财服务。该两项服务有硬性的资产要求，但都有相关办理的优惠。</p>
<p>所以你也可以考虑<a target="_blank" rel="noopener" href="http://hr.yuanfudao.com/apply/fenbi/29#/">加入猿辅导</a>。</p>
<img src="/images/pp-card.jpeg" class="">

<h2 id="三、境外银行的国内机构"><a href="#三、境外银行的国内机构" class="headerlink" title="三、境外银行的国内机构"></a>三、境外银行的国内机构</h2><p>恒生、汇丰、花旗等银行在国内设有机构网点，所以其实可以去这类银行办理，相关的条件会比国内银行要低得多。</p>
<p>我个人就是在颐堤港的恒生银行办理的香港卡（下图）。2年前的要求是需要办 10 万块的非保本理财（挂钩恒生指数）或者办理 50 万的保本理财。这两种理财均为一年，到期后即可以转出。</p>
<img src="/images/hengseng.jpg" class="">

<p>现在应该这类银行也有政策，不过具体的条件我很久没有关注了，或许有变化。</p>
<h2 id="四、华美银行-Velo"><a href="#四、华美银行-Velo" class="headerlink" title="四、华美银行 Velo"></a>四、华美银行 Velo</h2><img src="/images/velo.jpg" width="300px" />

<p>我有一个同事成功办理了这个银行卡。华美银行是设立在美国，但是专门为华人服务的银行，可以直接在网上申请它的银行卡。华美银行相对于上面那些银行较小，但也是纳斯达克上市公司（股票代号：EWBC）。</p>
<p>具体的申请方式可以参考华美银行的 <a target="_blank" rel="noopener" href="https://www.velobank.com/cn.html">Velo官网</a>。</p>
<h2 id="五、其它"><a href="#五、其它" class="headerlink" title="五、其它"></a>五、其它</h2><h3 id="管理费"><a href="#管理费" class="headerlink" title="管理费"></a>管理费</h3><p>就我所知，似乎所有境外卡在卡内余额小于一定数额时，都会收取一定的小额管理费。不同银行政策不太一样。管理费每月大概需要 100 元人民币左右。</p>
<h3 id="风险提示"><a href="#风险提示" class="headerlink" title="风险提示"></a>风险提示</h3><p>依据中华人民共和国法律法规，中国大陆境内个人办理购汇业务时不得用于境外买房、证券投资、购买人寿保险和投资性返还分红类保险等尚未开放的资本项目。</p>
<p>所以，即使你有境外卡，外汇的来源也需要注意合法合规。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>从办理门槛来看，我个人推荐的是恒生银行或者<a target="_blank" rel="noopener" href="https://www.velobank.com/cn.html">华美银行</a>。</p>
<p>从使用体验来看，我推荐有条件的人选择去香港亲自办理，或者在国内的招行、中行办理。</p>
<p>当然，如果你恰好特别巧想换工作又对猿辅导感兴趣，也可以考虑<a target="_blank" rel="noopener" href="http://hr.yuanfudao.com/apply/fenbi/29#/">加入我们</a>，办理招行的永隆银行卡。</p>
<p>就酱~</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/25/%E8%A7%86%E9%A2%91%E6%98%AF%E4%B8%8D%E8%83%BDP%E7%9A%84%E7%B3%BB%E5%88%97%EF%BC%9AOpenCV%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/25/%E8%A7%86%E9%A2%91%E6%98%AF%E4%B8%8D%E8%83%BDP%E7%9A%84%E7%B3%BB%E5%88%97%EF%BC%9AOpenCV%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/" itemprop="url">视频是不能 P 的系列：OpenCV 人脸检测</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-25T22:49:47+08:00">
                2020-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>恍惚间，2020 年已接近尾声，回首过去这一年，无论是疫情、失业还是“996”，均以某种特殊的方式铭刻着这一年的记忆。也许，是这个冬天的西安雾霾更少一点。所以，有时透过中午的一抹冬阳，居然意外地觉得春天的脚步渐渐近了，甚至连圣诞节这种“洋节日”都感到亲切而且期待，我想，这大概是我丧了一段时间的缘故吧！可不管怎样，人们对未来的生活时常有一种“迷之自信”，果然生还还是要继续下去的呀！趁着最近的时间比较充裕，我决定开启一个信息的系列：视频是不能 P 的。这是互联网上流传的一个老梗了，正所谓“视频是不能 P 的，所以是真的”。其实，在如今这个亦真亦假的世界里，哪里还有什么东西是不能 PS 的呢？借助人工智能“改头换面”越来越轻而易举，而这背后关于隐私和伦理的一连串问题随之而来，你越来越难以确认屏幕对面的那个是不是真实的人类。所以，这个系列会以 OpenCV 作为起点，去探索那些好玩、有趣的视频&#x2F;图像处理思路，通过技术来证明视频是可以被 PS 的。而作为这个系列的第一篇，我们将从一个最简单的地方开始，它就是人脸检测。</p>
<h1 id="第一个入门示例"><a href="#第一个入门示例" class="headerlink" title="第一个入门示例"></a>第一个入门示例</h1><p>学习 OpenCV 最好的方式，就是从官方的示例开始，我个人非常推荐的两个教程是 <a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/db/d28/tutorial_cascade_classifier.html">OpenCV: Cascade Classifier</a> 和 <a target="_blank" rel="noopener" href="https://pythonexamples.org/python-opencv/">Python OpenCV Tutorial</a>，其次是 <a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo">浅墨大神</a> 的<a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo/category_9262318.html">【OpenCV】入门教程</a>，不同的是， <a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo">浅墨大神</a> 的教程主要是使用 C++，对于像博主这样的“不学无术”的人，这简直无异于从入门到放弃，所以，建议大家结合自己的实际情况，选择适合自己的“难度”。好了，思绪拉回我们这里，在 OpenCV 中实现人脸检测，主要分为以下三个步骤，即，首先，定义联级分类器<strong>CascadeClassifier</strong>并载入指定的模型文件；其次，对待检测目标进行灰度化和直方图均衡化处理；最后，对灰度图调用<code>detectMultiScale()</code>方法进行检测。下面是一个简化过的入门示例，使用世界上最省心的 Python 语言进行编写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">&#x27;./haarcascades/haarcascade_frontalface_alt2.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">target = cv2.imread(<span class="string">&#x27;target.jpg&#x27;</span>)</span><br><span class="line">target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(target, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Face Detection&#x27;</span>, target)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows() </span><br></pre></td></tr></table></figure>
<p>正常情况下，你会得到下面的结果，这里选取的素材是经典日剧《半泽直树》：</p>
<p><img src="https://i.loli.net/2020/12/25/DcQRW32aUTBx5lY.png" alt="OpenCV人脸检测效果展示"></p>
<p>怎么样？是不是被 OpenCV 的强大给震惊到了？下面我们针对每个步骤做更详细的说明：</p>
<ul>
<li>第 1 行引入 OpenCV，需要我们安装 OpenCV 的<a target="_blank" rel="noopener" href="https://pypi.org/project/opencv-python/">Python 版本</a>。</li>
<li>第 4 行实例化级联分类器 CascadeClassifier，关于这个级联分类器，它是 OpenCV 下做目标检测的模块，内置<strong>Haar</strong>、<strong>HOG</strong>和<strong>LBP</strong>三类特性算法，而所谓“级联”，则是指它通过多个强分类器串联实现最终分类的思路。在初始化级联分类器的时候，需要载入指定的模型文件，这些模型文件是官方提前训练好的，可以从<a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/tree/master/data/haarcascades">Github</a>上进行下载，不同的模型文件对应不同的功能，这里使用的<code>haarcascade_frontalface_alt2.xml</code>主要针对面部检测，而像<code>haarcascade_eye_tree_eyeglasses.xml</code>则可以对眼睛进行检测。除此之外，我们还通过训练获得自己的模型文件，当然，这一切都是后话啦！</li>
<li>第 7~9 行，我们载入了一张图片素材，并对其进行了灰度化和直方图均衡化处理。这里需要关注的三个函数是：<a href=".">imread</a>、<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab">cvtColor</a> 和 <a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d6/dc7/group__imgproc__hist.html#ga7e54091f0c937d49bf84152a16f76d6e">equalizeHist</a>，它们的作用分别是读取图片、转换颜色和直方图均衡化处理。其中，对人脸检测而言，灰度图是必要的条件，而直方图均衡化则是可选的一个过程。</li>
<li>第 12~14 行，通过 <a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d1/de5/classcv_1_1CascadeClassifier.html#aaf8181cb63968136476ec4204ffca498">detectMultiScale</a> 方法我们就可以对待检测目标进行检测，关于它的参数，常用的有 scaleFactor、minNeighbors、minSize、maxSize，它可以对人脸检测做进一步的细节上控制，对于我们而言，我们更关心检测的结果，这里我们将检测到的人脸区域以矩形的方式绘制出来。</li>
<li>第 17~19 行，主要是为了方面大家观察结果，实际使用中可能会输出为文件或者实时渲染，这里需要关注的重点函数是：<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/df/d24/group__highgui__opengl.html#gaae7e90aa3415c68dba22a5ff2cefc25d">imshow</a>，顾名思义，它可以让图片展示在窗口中，类似我们这个示例中的效果。</li>
</ul>
<h1 id="柴犬界的“网红”"><a href="#柴犬界的“网红”" class="headerlink" title="柴犬界的“网红”"></a>柴犬界的“网红”</h1><p>曾经，有“好事者”分析过微信和 QQ 的年度表情，表情包文化流行的背后，实际上表达方式多样化的一种体现，例如：“笑哭”这一符号，固然有哭笑不得的含义在里面，可又何尝不是<strong>二十多岁人生总是边哭边笑的真实写照</strong>呢？而“捂脸”这一符号在我看来更多的是一种无可奈何，甚至有一种自我嘲讽的意味在里面。至于“呲牙”，<strong>朴实无华的微笑背后，大抵是看惯了庭前花开花落，可以“不以物喜，不以己悲”地笑对人生吧</strong>！其实，在这许许多多地表情里，我最喜欢的是微博里的“Doge”，这个眉清目秀的“狗头”能表达出各种丰富的含义，相比之下，微信里的“Doge”就有一点拙劣的模仿的意味了，俗话说<strong>“狗头保命”</strong>，在一个互联网信仰缺失的时代，用这样一种表情作为人类的保护色，又是不是一种反讽呢？而大家都知道，这个“Doge”表情，实际上是源于一个叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Homestar%20Runner">Homestar Runner</a>的网上动画系列，其原型则来源于一只名为<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1567521374438179&wfr=spider&for=pc">Kabosu</a>的柴犬，由于它融合了萌宠和故意搞笑两大特点，因此在网络上迅速走红，并由此衍生出一系列二次创作。</p>
<p><img src="https://i.loli.net/2020/12/26/i3OZfYwHvugT6JU.png" alt="微信年度表情"></p>
<p><img src="https://i.loli.net/2020/12/26/lN9ZgjuXxfs54cF.jpg" alt="QQ年度表情"></p>
<p>现在，让我们唤醒身体里的中二灵魂，通过 OpenCV 让这个柴犬界的网红出现在我们面前。这里的思路是，在检测到人脸后，在人脸区域绘制一个“狗头”表情，为此，我们需要定义一个<code>copyTo()</code>函数，它可以将一张小图(MaskImage)绘制到大图(SrcImage)的指定位置，我们一起来看它的具体实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyTo</span>(<span class="params">srcImage, maskImage, x, y, w, h</span>):</span><br><span class="line">    <span class="comment"># 按照区域大小对maskImage进行缩放</span></span><br><span class="line">    img_h, img_w, _ = maskImage.shape</span><br><span class="line">    img_scale = h / img_h</span><br><span class="line">    new_w = <span class="built_in">int</span>(img_w * img_scale)</span><br><span class="line">    new_h = <span class="built_in">int</span>(img_h * img_scale)</span><br><span class="line">    img_resize = cv2.resize(maskImage ,(new_w ,new_h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># “粘贴”小图到大图的指定位置</span></span><br><span class="line">    <span class="keyword">if</span> (srcImage.shape[<span class="number">2</span>] != maskImage.shape[<span class="number">2</span>]):</span><br><span class="line">        y1, y2 = y, y + img_resize.shape[<span class="number">0</span>]</span><br><span class="line">        x1, x2 = x, x + img_resize.shape[<span class="number">1</span>]</span><br><span class="line">        alpha_s = img_resize[:, :, <span class="number">3</span>] / <span class="number">255.0</span></span><br><span class="line">        alpha_l = <span class="number">1.0</span> - alpha_s</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            srcImage[y1:y2, x1:x2, c] = (</span><br><span class="line">                alpha_s * img_resize[:, :, c] + alpha_l * srcImage[y1:y2, x1:x2, c]</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        srcImage[y:y + img_resize.shape[<span class="number">0</span>], x:x + img_resize.shape[<span class="number">1</span>]] = img_resize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> srcImage</span><br></pre></td></tr></table></figure>
<p>在这里，我们首先要关注这样一件事情，即 OpenCV 默认使用的是由 R、G、B 组成的三通道，可对于像 PNG 这种格式的图片，它会含有一个 Alpha 通道。这样，当我们尝试把一张含 Alpha 通道的小图，“粘贴”到只有 R、G、B 三个通道的大图上时，就会出现通道数对不上的问题，所以，这个函数实际上对这种情况做了特殊处理。其次，每一个 OpenCV 中的图片，即 Mat，其 shape 属性是一个由三个元素组成的元组，依次为图片高度、图片宽度和图片通道数。“黏贴”的过程实际上是修改对应位置处的像素信息。好了，现在，我们来修改一下第一版的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">&#x27;./haarcascades/haarcascade_frontalface_alt2.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># cv2.IMREAD_UNCHANGED表示保留Alpha通道信息</span></span><br><span class="line">doge = cv2.imread(<span class="string">&#x27;doge-4.png&#x27;</span>, cv2.IMREAD_UNCHANGED) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">target = cv2.imread(<span class="string">&#x27;target.jpg&#x27;</span>)</span><br><span class="line">target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    target = copyTo(target, doge, x, y, w, h) <span class="comment"># 粘贴“狗头”表情至每一个面部区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;Face Detection&#x27;</span>, target)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows() </span><br></pre></td></tr></table></figure>

<p>此时，我们就可以得到下面的结果：</p>
<p><img src="https://i.loli.net/2020/12/26/Y9Al67cnvtgWmBz.png" alt="全员Doge!"></p>
<p>其实，我本人更喜欢这张，一张充满精神污染意味的图片：</p>
<p><img src="https://i.loli.net/2020/12/26/8QaJlR5XIxLftCo.png" alt="来自神烦狗的精神污染"></p>
<h1 id="视频级-PS-入门"><a href="#视频级-PS-入门" class="headerlink" title="视频级 PS 入门"></a>视频级 PS 入门</h1><p>OK，相信到这里为止，各位读者朋友，都已经顺着博主的思路实现了图片级别的“PS”，既然我们这个系列叫<strong>做视频是不能 P 的</strong>，那么大家要问了，视频到底能不能 P 呢？答案显然是可以，不然博主写这个系列就不是“人脸检测”而是“人肉打脸”啦！下面，我们来继续对今天的这个例子做一点升级。考虑在 OpenCV 中，<strong>VideoCapture</strong>可以通过摄像头捕捉视频画面，所以，我们只需要把这个“狗头”绘制到每一帧画面上，就可以实现视频级别的 PS 啦！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 步骤1: 定义联级分类器CascadeClassifier并载入指定的模型文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">&#x27;./haarcascades/haarcascade_frontalface_alt2.xml&#x27;</span>)</span><br><span class="line">doge = cv2.imread(<span class="string">&#x27;doge-4.png&#x27;</span>, cv2.IMREAD_UNCHANGED)</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>) <span class="comment">#笔记本自带摄像头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read() </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2: 对待检测目标进行灰度化和直方图均衡化处理</span></span><br><span class="line">    <span class="comment"># 读取视频中每一帧</span></span><br><span class="line">    target = frame</span><br><span class="line">    target_gray = cv2.cvtColor(target, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    target_gray = cv2.equalizeHist(target_gray)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤3: 人脸检测</span></span><br><span class="line">    faces = faceCascade.detectMultiScale(target_gray)</span><br><span class="line">    <span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">        target = copyTo(target, doge, x, y, w, h)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4: 展示结果</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Face Detection&#x27;</span>, target)</span><br><span class="line">    <span class="comment"># 按Q退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release() </span><br><span class="line">cv2.destroyAllWindows() </span><br></pre></td></tr></table></figure>

<p>一起来看看实现的效果吧！可能当你看完这篇博客的时候，你会觉得我写这玩意儿到底有什么用？不好意思，这玩意儿还真有用！它解决了像博主这样腼腆、不敢在公开场合抛头露面的人的困惑。暴走大事件里“王尼玛”一直戴着头罩，所以，很多人都好奇他本人到底长什么样子，如果当时能考虑这个思路的话，是不是可以不用一直戴着头罩。同样地，还有在浪客剑心真人版里饰演志志雄真实的藤原龙也，全身上下缠满绷带的造型其实对演员来说是非常不友好的，如果当时能考虑这个思路的话，是不是演员可以不用受那么大的罪。如果说这些都有些遥远的话，那么，至少在采访后期希望保护受访者隐私的场景下，这个思路是完全可行的，就像大家看到的它可以完全的遮挡住我的脸，而类似的打马赛克等等技术，本质上还是对图像进行处理，甚至美颜相机里的各种特效，底层都离不开 OpenCV 里的这些算法。怎么样？现在有没有觉得博主其实是一个非常有趣的人，哈哈!</p>
<p><img src="https://i.loli.net/2020/12/26/CZi4SYOgzsoy8Qk.gif" alt="视频级别的“PS”"></p>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客主要分享了 OpenCV 在人脸检测方面的简单应用，OpenCV 中的 CascadeClassifier 整合<strong>Haar</strong>、<strong>HOG</strong>和<strong>LBP</strong>三类特性算法，通过预置的模型文件可以实现不同程度的目标检测功能，而在人脸检测的基础上，我们可以通过训练来实现简单的人脸识别，正如今年爆发的新冠疫情让人脸识别出现新的挑战一样，虽然人脸识别的场景正在变得越来越复杂，可作为一个世界上最流行的计算机视觉库，OpenCV 中的各种模块、算法还是一如既往的经典。结合 imread()、resize()、cvtColor()等等的方法，我们可以将“狗头”表情贴到图片或者视频中的人脸区域，而这个思路可以为人脸遮挡相关的场景做一点探索。</p>
<p>在一个流行美颜的时代，人们对于别人甚至自己的期望在无限拔高，像博主本人一直不怎么喜欢拍照，有时候我们埋怨别人没有把我们拍得好看一点，可那究竟是你眼中的自己还是别人眼中的自己呢？正如相亲的时候，人们总喜欢把最好的、美化过的一面展示给别人，因为只有这样才能让别人对你产生兴趣，可往往现实的落差会让这种来得快的兴趣消失得更快。所以，我想说，虽然在技术面前万物似乎皆可“PS”，可对于我们自己而言，你是否了解真正的自己呢？关于我博客的写作风格，我一直不确定是要用偏严谨还是偏活泼的方式来表达，因为眼看着被后浪们一点点超越，这实在是种难以言说的感觉，欢迎大家在评论区留下你对博客内容或者观点的想法，祝大家周末愉快，一个人一样要活得浪漫！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/24/2020-12-24-2020summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/24/2020-12-24-2020summary/" itemprop="url">我的 2020 年度总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-24T08:00:00+08:00">
                2020-12-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>2020 年即将过去，这是不平凡的一年，以一个人们始料未及的方式开始，至今在国外依然没有看到好转的趋势。</p>
<p>我中间有好长一段时间没有关注国外的数据，后来在一个群里看到一位网友 @boyzcl 发布的截图，才意识到：它让全人类付出的代价实在是太惨重了。</p>
<p>数据是一串串冰冷的数字，但背后是一条条鲜活的生命，但愿不好的数字能早一刻停滞下来。</p>
<p><img src="http://cdn.penghh.fun/mweb/IMG_7559.jpeg" alt="IMG_7559"></p>
<p>按照去年的做法，我也想试着写一下 2020 年的个人总结。</p>
<h2 id="微信公开课"><a href="#微信公开课" class="headerlink" title="微信公开课"></a>微信公开课</h2><p>今年年初很幸运，通过微博抽奖，免费获得了一张微信公开课的门票，原以为能见到张小龙本人，还进了一个叫「广州市民张小龙个人演唱会」的微信群，但 1 月 9 日开场的时候，只看到了张小龙提前录好的 VCR，虽然票是免费的，但其实我内心还是挺失落的。</p>
<p>张小龙原先就深居简出，不怎么接受外界的采访，后来甚至连朋友圈都不怎么发了，因为他的朋友圈耳目众多，一不小心就给没有道德操守的媒体截图，解读出各种自以为是的内容，而且张小龙还不能放下身段，主动去反驳他们，因为真理总是越辨越黑，所以最好的方式还是——不发朋友圈。</p>
<p>外界要想客观地获得第一手的张小龙产品心法，还得依靠一年一度的「微信公开课」，由于是自己亲手打造的产品，张小龙出来演讲，一方面是为自己的产品代言，看好自己对产品的规划和设计，另一方面，其实也是想借这个机会，来澄清外界对微信这个产品、微信背后的这个团队的误解，解释清楚：为什么许多用户想要的功能，他们不做？</p>
<p>来听张小龙演讲的人，其实也并不轻松，因为不少人可能都是抱着这么一种想法：试图从他的只言片语中，解构出微信下一步的动向，找到新的流量洼地或者所谓的风口。</p>
<p>但我没有那么大的诉求，我只是想听听看，这个已经打造出一个 10 亿级用户的产品经理，他对产品的一些最新思考、对微信这个产品本身的看法（例如为什么要推出某个特性或者某个 idea 是如何想到的）。</p>
<h2 id="知识星球运营"><a href="#知识星球运营" class="headerlink" title="知识星球运营"></a>知识星球运营</h2><p>今年 5 月份我创建了一个免费的知识星球「效率工具指南」，它可以看成是我的另外一个朋友圈，主要分享我遇到的各种效率工具、软件使用技巧，以及有时回答一些朋友的提问，顺便一提，它也是可以匿名提问的。</p>
<p><img src="http://cdn.penghh.fun/mweb/image_88512424255582_4.jpg" alt="image_88512424255582_4"></p>
<p>截至目前，这个星期创建了 211 天，有 497 位朋友加入，发布了 332 条动态，这里的动态包含一些网友的提问、一些网友对我发布的作业的互动和一位网友 @Janenesome 发布的动态。</p>
<p>单看数据，我这个星球运营得确实不怎么样，互动量极少，尤其是前期的点赞和评论都非常少，但幸运的是，有三位朋友经常来给我的动态点赞和评论，其中一位朋友还对我发布的内容给了极大的肯定：</p>
<blockquote>
<p>你那个星球早就应该收费了，要对自己的交付有信心。</p>
</blockquote>
<p><img src="http://cdn.penghh.fun/mweb/1608569144.jpeg" alt="1608569144"></p>
<h2 id="年度-flag-完成情况"><a href="#年度-flag-完成情况" class="headerlink" title="年度 flag 完成情况"></a>年度 flag 完成情况</h2><p>年初的时候，我立下了三个 flag，分别是：</p>
<ul>
<li>脱单</li>
<li>能从写作赚到更多的钱</li>
<li>高质量的输出</li>
</ul>
<p><img src="http://cdn.penghh.fun/mweb/16087427082637.jpg">目前我完成了一个，高质量的输出成了一句空谈，因为今年没有写出一篇自我感觉满意的文章。</p>
<p>质量不够，数量来凑。年中有一段时间进行了连续 30 天的日更，确实有些辛苦，阅读量也没有见长，但至少勉强做到了，以后有更充裕的时间，再立个新的 flag 挑战至少 30 天的日更～</p>
<h2 id="年度音乐"><a href="#年度音乐" class="headerlink" title="年度音乐"></a>年度音乐</h2><ul>
<li>梁博 - 想念</li>
<li>李健 - 美丽生灵</li>
<li>达达乐队 - 南方</li>
<li>五条人 - 梦幻丽莎发廊</li>
<li>Eels - Ordinary Man</li>
<li>Banners - Shine A Light</li>
<li>约翰·列侬 - Imagine</li>
<li>White Cherry - MELANCHOLY</li>
<li>棱镜乐队 - 机场雷雨</li>
<li>失眠飞行（特供版）</li>
</ul>
<p>梁博，中国好声音第一季的冠军，2014 年打工的暑假第一次听到他在好声音翻唱的《私奔》，这几年断断续续听他的歌，例如《男孩》、《日落大道》、《表态》、《我不知道》，创作力旺盛。这首《想念》是今年元旦当天发布的，我喜欢这首歌的第一句歌词「其实孤独从来都和那些节日无关，像外面曾与我无关」。等情况稳定，梁博开演唱会，一定要去看一次。</p>
<p>盼了一年，李健拖了五年的专辑，还是没见到影子，我都想脱粉了。《美丽生灵》是一首初听不觉得惊艳，但越听越觉得耐听的歌曲。我发现我不只是喜欢李健写的歌词，还喜欢他在歌词中加入的拟声词和「吟唱」，例如这首歌里面的「嗯」，《风吹麦浪》里面的「嗯啦嗯啦」。</p>
<p>达达乐队、五条人是看了乐队的夏天 2 后才知道的两支乐队：</p>
<ul>
<li>达达唱的这首《南方》很民谣</li>
<li>五条人给我的感觉是人歌合一，自带笑点，因为他们俩是汕尾人，听他们用方言唱的歌，不会有陌生感，基本都能听得懂</li>
</ul>
<p>这周日要去长隆看五条人和达达的演出，想想就开心（辛苦了同事 @Cherry 苦口婆心说服了我一下午，详见这里《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/a8tajky5SxJ1Fkpum2TSyA">做人太有趣了，下辈子我还想做人。</a>》）</p>
<p>《Ordinary Man》和《Shine A Light》这两首是美剧《良医》中的背景音乐，前一首沧桑的嗓音，一听就是有故事的人哈哈哈哈，很对我的胃口；后一首听着就觉得激动人心，至于那道光是什么，每个人有每个人的理解。</p>
<p>《MELANCHOLY》是一首纯音乐，最初是在室友刷的一条抖音视频上听到的，通过听歌识曲就找到了歌名，舒缓的旋律，可以用作摇篮曲。</p>
<p>《机场雷雨》是何老师分享给我的歌，应该是我听到的第一首棱镜的歌，喜欢这种白描式的歌词，一句歌词就是一个画面。来自四川的宝藏乐队，还有其他好听的歌，例如《总有一天你会出现在我身边》。</p>
<h2 id="好用的应用"><a href="#好用的应用" class="headerlink" title="好用的应用"></a>好用的应用</h2><p>滴答清单：把待办事项 App 当成我的日记本。  </p>
<p>一个比较欣慰的事情是，昨天有位滴答清单的工作人员加了我的微信，说要给我寄一份礼物，感谢我之前推荐过他们的产品，这可以算是在网上分享带来的一个意外之喜。</p>
<p><img src="http://cdn.penghh.fun/mweb/16087428597229.jpg" alt="-w418">  </p>
<p>Seven：一个付费的运动 App，它让我养成了做每天做运动的微习惯，中途有间断，但至少坚持下来了（比较尴尬的是，年底这 10 多天我又停下来了）。   </p>
<p>小宇宙：即刻团队推出的播客 App，虽然我使用小宇宙的次数不多，但这个应用的交互非常棒，就你一使用，可以明显地感觉到它与其他同类应用的差别，别人还是在做一个凑合可以用的产品，而他们是在用心做产品。    </p>
<p>Day One：这是一款日记软件，有时想起来就会用，由于没有购买会员，使用手机记录的东西不会同步到电脑端。它会记录下你写日记时的地理位置，虽然定位不那么精确，但以后走过（或待过）比较多地方的时候，看起来应该会有一种别样的感觉，就像夜晚的天空，星星飘落在不同的地方。愿你的生命有足够多的星星，来造成一个璀璨的银河。  </p>
<p>OffScreen：它一定程度上帮我减少了手机的使用时间，因为每当看到这个 App 的「你在就寝后又玩了 XX 分钟」、「今天已经拿起手机 XX 次」提醒时，多少会有一种「罪恶感」。<br>谜底时钟：这是 OffScreen 团队的另外一个作品，最吸引我的是时钟的设计，颜值让它在众多同类应用中脱颖而出。   </p>
<p>谜底时钟的出现，可能也可以成为买苹果产品的一个理由：苹果生态吸引人的，不仅是好用的苹果系统，更重要的是，上面有各种各样好用、好看的应用。</p>
<p>良好的生态可以激励更多的开发者到这上面来开发更好的产品，良好的生态包含：</p>
<ul>
<li>开发者可以在这里体面地赚到钱</li>
<li>开发者开发出来的产品，被他人盗版的成本较高</li>
</ul>
<p>此外，苹果在今年主动降低了对开发者的抽成比例：年收入少于 100 万美元的应用，抽成比例由 30% 调整为 15%。</p>
<p>别说了，现在学 iOS 开发，还来得及吗？</p>
<h2 id="友情推荐"><a href="#友情推荐" class="headerlink" title="友情推荐"></a>友情推荐</h2><p>这里还要给一位朋友推荐一下他们家的产品——点赞抽奖，这是微信上的一款抽奖小程序，可用来创建红包抽奖，也可参与他人发起的抽奖。</p>
<p>年底到了，如果你想给支持自己的关注者或小伙伴等发放福利，可以考虑使用这个工具。</p>
<p><img src="http://cdn.penghh.fun/mweb/IMG_7560.jpeg" alt="IMG_7560"></p>
<h2 id="购物清单-一些值得的投资"><a href="#购物清单-一些值得的投资" class="headerlink" title="购物清单&#x2F;一些值得的投资"></a>购物清单&#x2F;一些值得的投资</h2><p>微信周边「阿绿」：好几次出现在我拍的照片中，就是那只绿色萌萌的狗狗，在微信上有它和「阿白」的官方表情包<br>iMac 2020<br>西部数据 2TB 移动硬盘<br>佳能 M50<br>红米路由器 AX6<br>喜马拉雅买 1 送 13 会员：价格好像是 200+，和我家的姐姐弟弟一起分摊的，送的会员各取所需，我拿了其中的网易云和腾讯视频<br>小米冲牙器：刚买没多久，只用了一次，设计有点丑，体积有点大，带出去有些占地方</p>
<p>值得的投资：</p>
<ul>
<li>洗牙</li>
<li>得到电子书年度会员</li>
<li>Seven App</li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>去年一起工作的同事，不少都走了，最开始有些不舍，但后来想了想，这就有点像是大学毕业时的情况，有些人选择继续升学，有些人选择工作，有些人选择回家继承家业……有缘相聚，同时也意味着会有告别的一天。</p>
<h3 id="各自为战"><a href="#各自为战" class="headerlink" title="各自为战"></a>各自为战</h3><p>以前我会以为，一个公司的所有部门会主动联合起来，齐力断金，一致对外，但后来发现是我想多了，不管大公司小公司，到了某个阶段，不同部门明面上是一个整体，但实际上是各自为战，锦上添花不多见，部门间甩锅才是稀松平常的事，工作得越久，这种体会越深刻。</p>
<p>之前看过 caoz 老师写的一篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/L8ctSpEiKnlrjG_NH7dK_A">谈谈巨头的逻辑</a>》，其中谈的也是这个现象：</p>
<blockquote>
<p>巨头（内的各部门）从来不是一个整体，也会存在不同部门的利益诉求……巨头内部很多时候也会有一种尴尬，就是为什么明明我们是一家公司，我跟其他部门提个需求，还没有外部合作伙伴的优先级高，这在巨头，是常态，如果你在巨头打工时间比较长，你会有很多类似这样的案例体会。</p>
</blockquote>
<h3 id="工作的焦虑"><a href="#工作的焦虑" class="headerlink" title="工作的焦虑"></a>工作的焦虑</h3><p>每次开始写新的文章，可以说是一个新的轮回或者说开始。每个周末都要想一下，下周要写点什么，其间有过焦虑和抓耳挠腮的时刻。</p>
<p>焦虑的是，有时我觉得自己陷入了一种套路式的重复，总是在重复过去的东西，写工具文章给我带来的新鲜感和刺激变少了，觉得自己停止成长了；抓耳挠腮是因为发愁要写什么东西，其实我从今年年初就开始考虑「选题枯竭」的问题，但侥幸的是，这一年我还是勉强撑过来了。</p>
<h3 id="工作与生活"><a href="#工作与生活" class="headerlink" title="工作与生活"></a>工作与生活</h3><p>在上一家公司的时候，我会主张工作与生活要有明显的界限，而且还非常认同在豆瓣日历上看到的一句话：</p>
<blockquote>
<p>既然为了活命而工作，为什么又要为了工作而卖命？</p>
</blockquote>
<p><img src="http://cdn.penghh.fun/mweb/16086442245901.jpg"></p>
<p>但后来我的工作换成了写东西，这也是我的兴趣所在，即使是在没事的周末，我有时也会想着写东西的事情，选题也好，还是发在自己公众号上的文章，我并不会说刻意区分哪些是工作内的事情，哪些是自己的事情，当然这些事情之间存在着优先级。</p>
<p>重要的是，现在做的事情，和自己的长期目标（建立自己的个人品牌和影响力）是统一的，就还有值得做下去的理由。</p>
<p>说这些并不是想夸自己，因为自己也是个普通人，也会有犯懒、不想工作，只想咸鱼葛优躺的时候，但想着人生漫长，家里无矿，还是要保持一个积极的心态，时不时给自己加油打气。</p>
<p>末了，前两天还看到我喜欢的一位 Up 主 @极地手记 发布的一个视频《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/C03fCgIPrXbFHaQK6l9pwA">写给三年前辞职拍视频的自己</a>》，视频的形式比较简单，就是这位 Up 主读着一封写好的信，回顾辞职三年以来做全职 Up 主的经历，没有刻意突出自己一路走来有多么不容易，就纯粹是在讲故事，没有过多的叙述技巧，其中提到：</p>
<blockquote>
<p>很抱歉，现在的我对于如何过好这一生，依然没有什么明确的答案，但是找到一份让你热爱的事业，遇到一个人生伴侣，做对别人有价值的事情，是我用这三年的时间写给自己的回答。</p>
</blockquote>
<p>对了，还有一个非常奇妙的事情是，这位 Up 主和我是同一天生日。  </p>
<h2 id="2020-年幸运的事情"><a href="#2020-年幸运的事情" class="headerlink" title="2020 年幸运的事情"></a>2020 年幸运的事情</h2><ul>
<li>公众号有一段时间来了好多新的关注者，从最初的 3000+ 增加到现在的接近 7000（感谢各位朋友的支持）</li>
<li>遇到了何老师</li>
<li>同事帮我过生日，准备了一个蛋糕，给了我一个惊喜</li>
<li>拿到了期待已久的驾驶证（我是 2018 年上半年报名学车的，看到这如果有还在上学的朋友，请在校就把驾照拿了，不要拖。工作之后再来练车，不但费时间更费钱）</li>
</ul>
<h2 id="2021-年的-flag"><a href="#2021-年的-flag" class="headerlink" title="2021 年的 flag"></a>2021 年的 flag</h2><ul>
<li>把公众号做到 1 万关注，希望能接到广告</li>
<li>多做一些视频内容，不然对不起自己买的 Mac</li>
<li>培养一个习惯，早睡早起</li>
<li>多出去走走，看看这个大世界</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果你有幸看到了这里，那我还是想提一个和去年一样的建议：请试着写一下自己的 2020 年度总结。</p>
<p>这个总结可以比较正式，也可以比较随意，重要的是，它是你写给自己的，你不要担心它写得好或坏，开始写就起了一个非常好的头，跟随自己内心的想法写下来，才是最重要的。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9kCLzPnY5NRVB9OAKdjRxg">我的 2019 年简短总结</a></p>
<p>以上。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2020/12/18/2020-12-18-2020-stock-trade-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/18/2020-12-18-2020-stock-trade-summary/" itemprop="url">2020年我的股票交易总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-18T22:50:52+08:00">
                2020-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>今年股票美股的收益整体大概是 40% 左右，无图无真相，以下是老虎的统计数据：</p>
<img src="/images/stock-2020.jpg" class="">

<p>比较巧的是，A股的收益整体也是 40% 左右，无图无真相，以下是平安证券的数据：</p>
<img src="/images/stock-2020-a.jpg" class="">

<p>主要收益来自于疫情期间买入的各种股票，主要包括：</p>
<ul>
<li>哔哩哔哩，买入价 22-25 美元</li>
<li>谷歌，买入价 1222 美元</li>
<li>腾讯，买入价 299 元</li>
<li>茅台，美的，格力，海尔等</li>
</ul>
<p>今年我也有亏的，重仓的陌陌亏了大概 30% 。</p>
<p>以下是今年股票交易的一些认知。</p>
<h2 id="贪婪和恐惧是关键"><a href="#贪婪和恐惧是关键" class="headerlink" title="贪婪和恐惧是关键"></a>贪婪和恐惧是关键</h2><p>疫情期间，很多人很恐慌，而我却觉得这是一个很好的机会，于是选择 1&#x2F;4 仓位入市，然后慢慢加到 1&#x2F;2，其间也有过多次犹豫和担心，现在看起来，整体决策还是对的。在别人恐惧的时候贪婪，通常就可以买到极低的价格。</p>
<h2 id="不要做空"><a href="#不要做空" class="headerlink" title="不要做空"></a>不要做空</h2><p>疫情期间尝试了好几个做空，有一些差点得手的，比如游轮股，也有一些差点死很惨的，比如跟谁学。</p>
<p>我一直认为跟谁学没有猿辅导好，现在股价确实证明我是对的，但是跟谁学的那波暴涨，很可能把我的做空给逼爆仓。</p>
<p>这种极度考验心理，并且依赖于保证金的做空，以后我是不愿意再参与的了。</p>
<p>还好最后没赚没赔。</p>
<h2 id="好的股票不应该过早卖"><a href="#好的股票不应该过早卖" class="headerlink" title="好的股票不应该过早卖"></a>好的股票不应该过早卖</h2><p>去年底我持有了 4 支股票，分别是：</p>
<ul>
<li>阿里巴巴，成本价 144</li>
<li>特斯拉，成本价 242</li>
<li>腾讯，成本价 403</li>
<li>拼多多，成本价 24</li>
</ul>
<p>最终我卖掉了特斯拉和拼多多。这两个收益都不到 100%，但如果换成现在的我，我可能会一直持有。如果我一直持有的话，特斯拉应该可以带来 10 倍以上的回报，拼多多可以带来 5 倍以上的回报。</p>
<p>当时我开玩笑说：希望买特斯拉股票可以帮我挣一辆特斯拉，结果如果我不早卖的话，这个玩笑真的就实现了。</p>
<p>不过这也是我应该交的学费。每一笔学费都是用钱来强烈刺激我，让我难忘。</p>
<p>为什么好的股票不应该过早卖呢？我现在的感受是两点：</p>
<ul>
<li>找到好标的难度太大，市场的机会并不多。</li>
<li>好的股票未来的持续成长能力是很强的，即便短期超出你对它的估值，但是不应该太短视，因为市场很多时候并不理性，你如果过早卖掉，你不一定还能买得回来。</li>
</ul>
<h2 id="为何买入哔哩哔哩"><a href="#为何买入哔哩哔哩" class="headerlink" title="为何买入哔哩哔哩"></a>为何买入哔哩哔哩</h2><p>我今年在疫情期间就很看好哔哩哔哩，于是在 25 元左右的价格就买入了很多。也是因为去年把特斯拉卖得太早了，所以我在哔哩哔哩上面就很有耐心。我周围的朋友有 40 多卖掉的，有 50 多卖掉的，但我一直持有到现在。</p>
<p>最近哔哩哔哩涨到了 80 多，我帐面上大概挣了 2 倍多，如下图：</p>
<img src="/images/bilibili-1.jpg" class="">

<p>另外还有一笔即将到期的看涨期权，挣了 4 倍多，如下图：</p>
<img src="/images/bilibili-2.jpg" class="">

<p>我为什么会买哔哩哔哩？主要是我当时发现，年轻人都在用哔哩哔哩，它在视频网站中拥有独特的社区文化和价值。有人说它是中国的 youtube，我觉得有一些道理。我和一些朋友讨论了一下，确定了它是一个好的标的。</p>
<p>然后我就在想如何为它估价，于是我翻了一些估值模型，以下是我 2020年3月14日 的记录：</p>
<blockquote><p>如何估值哔哩哔哩？与 youtube 对标来计算：</p>
<ul>
<li>可以按月活折算可能的收入，然后按收入乘以某一个倍数来计算估值。</li>
<li>如果对标youtube的话，youtube，月活 19亿，收入210亿$，估值 1500 亿</li>
<li>bilibili, 18年全年，收入 41 亿，估值 280 亿人民币？<a target="_blank" rel="noopener" href="https://www.huxiu.com/article/294183.html">https://www.huxiu.com/article/294183.html</a></li>
<li>19年预估，1亿月活，60亿收入，估值 420 亿人民币？60亿美金。</li>
<li>如果保持增速，20 年应该 90 亿美金估值。</li>
<li>收入&#x2F;月活，哔哩哔哩大概是 60，youtube 大概是 77，差不太多。</li>
<li>估值&#x2F;收入，哔哩哔哩大概是 7， youtube 大概是 7，基本一样。</li>
<li>但是因为哔哩哔哩的商业化还没有大规模尝试，所以未来增长会乐观一些。</li>
</ul>
<p>如何估值哔哩哔哩？按单用户价值来计算：</p>
<ul>
<li>youtube ，月活 20 亿，估值 1500 亿$，单用户约 75$ <a target="_blank" rel="noopener" href="https://xw.qq.com/cmsid/20190504A09WCZ00">https://xw.qq.com/cmsid/20190504A09WCZ00</a></li>
<li>哔哩哔哩，月活 1 亿，估值 75 亿$，单用户约 75$</li>
<li>快手，月活3.41亿，286亿$,单用户 84$ <a target="_blank" rel="noopener" href="https://finance.jrj.com.cn/tech/2019/12/04072928486505.shtml">https://finance.jrj.com.cn/tech/2019/12/04072928486505.shtml</a></li>
<li>陌陌，月活1亿，50亿，单用户 50$ <a target="_blank" rel="noopener" href="http://m.ebrun.com/361912.html">http://m.ebrun.com/361912.html</a></li>
<li>单用户价值：youtube(75$), 哔哩哔哩(75$), 快手(84$)，陌陌(50$)</li>
</ul>
</blockquote>

<p>当时哔哩哔哩大概估值 75 亿美元，于是我觉得是符合这个模型的，但是我觉得未来 B 站的用户量还有上涨空间，于是就买入了。</p>
<p>现在拿这个模型看，哔哩哔哩的估值是偏高的，但是这确实反映了它数据增长的优秀，因为不到一年，它的月活就达到了 2 亿。它的商业化也做得很好。</p>
<p>未来 B 站值多少钱？我不知道。我想等它的用户量稳定，收入稳定后，估值可能才会回归到一个合理的水平。在这之前，可能会有很多波动。现在不卖，有可能我挣不到这么多，但是卖掉，也可能失去一个挣 5 - 10 倍收益的标的。</p>
<p>所以这次，我想试试多看个几年，不管结果是好还是坏，它都将再次修正我的认知，这是我看重的。</p>
<h2 id="为什么在陌陌上亏了"><a href="#为什么在陌陌上亏了" class="headerlink" title="为什么在陌陌上亏了"></a>为什么在陌陌上亏了</h2><p>我在陌陌 20 和 15 的时候分别买入了不少，现在陌陌 13 块多，整体我亏了 30% 的样子。</p>
<p>买入陌陌，核心是认为陌陌的估值太便宜。帐上有 20 亿美金的现金，每年挣个几亿美金，而估值才 40 亿美金（现在已经跌到 28 亿美金）。所以现在的陌陌，如果估值减掉自己持有现金，市盈率才不到 4 。</p>
<p>所以直到现在，我仍然认为陌陌是便宜的。如果一家公司一直亏钱，那么它最终可能资不抵债，但陌陌一直在挣钱，所以它不可能一直跌，它帐上的 20 亿美金现金就是它最低的价值。</p>
<p>但是为什么我亏钱了呢，还亏了 30% 呢？我低估了资本市场对于业绩下滑的悲观情绪。</p>
<p>陌陌是挣钱，但是它的月活在慢慢下降，利润也在下降。这背后可能是陌陌背后的金主用户们受疫情影响不太愿意给主播打赏了。在疫情期间，别的视频网站月活都在涨，而陌陌却没有，所以这更让资本市场不看好陌陌长远的发展。唐岩作为陌陌的创始人还离开了 CEO 职位，这让外界更加对陌陌没有信心。</p>
<p>我会卖掉陌陌的股票吗？有可能。取决于我能不能发现更好的标的。当前情况下，我还是持有陌陌的。陌陌虽然便宜，虽然下跌空间有限，但是这种股票也很难翻几倍了，所以很难给我带来很高的预期。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一些今年的小结：</p>
<ul>
<li>不要做空。</li>
<li>好的标的应该一直持有。</li>
<li>要逆向思维，别人恐惧的时候贪婪。</li>
</ul>
<p>还有，别以为我挣了多少，我只是拿很少一些不影响我生活质量的小钱在玩，主要是为了提升自己的认知而已。如果你心态上玩不起，你就已经输了。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/73/">73</a><a class="extend next" rel="next" href="/page/19/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1451</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
