<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Liunx Python Rust Goalng DevOPS" />










<meta name="description" content="个人随想，瞎子的世界">
<meta property="og:type" content="website">
<meta property="og:title" content="逐流小站">
<meta property="og:url" content="https://blog.feedscoin.com/page/53/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="个人随想，瞎子的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Liunx Python Rust Goalng DevOPS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/page/53/"/>





  <title>逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/personal-projects">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/personal-projects" itemprop="url">The importance of personal side projects</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-05T18:05:00+08:00">
                2016-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          Side projects are fun, and they will add value to your daily work when it is most needed.
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/personal-projects">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/25/%E4%BD%BF%E7%94%A8Mono%E6%89%93%E9%80%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84.NET%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/%E4%BD%BF%E7%94%A8Mono%E6%89%93%E9%80%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84.NET%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6/" itemprop="url">使用 Mono 打造轻量级的.NET 程序运行时</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-25T12:47:58+08:00">
                2016-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          我们将编译好的程序命名为 Launcher.exe，放置我们前面定义的 Mono 运行时目录结构的根目录下，这个文件将作为启动文件暴露给用户，当用户点击这个程序后就可以打开主文件 Main.exe;因为 Mono 和.NET 都可以执行 IL 代码，所以我用 Mono 来作为.NET 程序的运行时是一个顺理成章的想法;本文通过 Mono 实现了一个轻量级的.NET 程序运行环境，从某种程度上来说，它间接地实现了.NET 程序脱离.NET Framework 运行
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/03/25/%E4%BD%BF%E7%94%A8Mono%E6%89%93%E9%80%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84.NET%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6/">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/20/2016-03-19-text-animation-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/20/2016-03-19-text-animation-guide/" itemprop="url">如何实现自己没实现过的需求之文本动画</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-20T21:34:23+08:00">
                2016-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <blockquote>
<p>吕伟（<a target="_blank" rel="noopener" href="http://weibo.com/u/1660258615">@我在罪恶坑的日子</a>）iOS 开发者，这些年在上海工作。专业：扯淡，兼职：开发。<br>感谢投稿，<a target="_blank" rel="noopener" href="http://www.ismash.cn/post/ru-he-shi-xian-zi-ji-mei-shi-xian-guo-de-xu-qiu-zhi-wen-ben-dong-hua-pian">原文链接</a>。</p>
</blockquote>
<p>大家好，我是非知名程序员，想跟大家说一段传统相声节目，额，对不起，说错了。想跟大家分享一点关于文本和动画的东西。这不是一篇纯血统，高、精、尖的技术文章，但依然希望有人能像喜欢混血美女一样喜欢。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得以前看到过一个很赞的文字效果的动画，类似于这样：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13845905/1e55a5d0-ec7e-11e5-9631-68aaf6b07ba1.gif" alt="textanimation"></p>
<p>当时被惊艳到了，最近偶然间又再次见到，依然还是那么喜欢。假设我们现在需要实现这样的需求。一般碰到需求我们都会去 GitHub 上看看，俗称找轮子（GitHub 基本上只有你想不到的，就没有它没有的）。大多数情况下，没有问题。或者说有点小问题：轮子太多，无从下嘴。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p>选轮子就像选姑娘，你不知道后面等着你的是什么 —–罪恶坑小程如是说</p>
</blockquote>
<p>程序员江湖，每位大侠的武功和套路不尽一样，少林，武当，昆仑各门各派，百花争艳。实现轮子的思路自然也不一样。有的轮子高深晦涩难懂，功能强大，有的清晰明了，功能简单。不过有一点相同是，选错了就会被坑，只是坑大坑小问题。选轮子自然需要无比谨慎，既要匹配需求同时也要能在掉坑里的时候填上（废话，出 bug 了，你不填，谁填），要能 hold 住。然而填坑哪能那么简单呢，首先轮子实现思路，代码的结构，运行时序你要搞清楚吧，提供了哪些功能，没提供哪些功能，你要了解吧。基本上一个复杂点的轮子，研究下来就要好些时间了。这还不包括你开会，沟通，解 bug，喝茶，倒水，上厕所，抽烟，骂娘，吐槽产品需求的时间。所以，妹子们，不要问我们今天加不加班，要问今天能不能在你睡前下班。（项目快上线了，小程不加班谁加班。嗯哼。）</p>
<h2 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h2><blockquote>
<p>如果能用代码扮演上帝话，苍老师的量产不是问题，就看产品经理定的需求是拟物还是扁平。—-罪恶坑小程如是说</p>
</blockquote>
<p>既然选轮子的时间成本也不低，那有时候我们可以自己造一个轮子。其实写一个的好处也多，有成就感，写好了可以吹牛逼，写坏了填坑速度快。但问题是，以前没写过怎么办？没把握怎么办？比如我们现在需要实现上面的文字效果，但是又不知道怎么写，怎么办？</p>
<p>没关系，上帝创造世间也分了七步走，跟着这位带头大哥后面学，总不会错的。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>罗马不是一天建成的，毛片不是一次性拍完的 —-罪恶坑小程如是说 </p>
</blockquote>
<p>咦，好像扯得有点多了。对不起，现在开始正式拍（苍老师准备下，小程也准备下，Action）：</p>
<h4 id="1-分解任务"><a href="#1-分解任务" class="headerlink" title="1. ** 分解任务 **"></a>1. ** 分解任务 **</h4><p>通过简单观察我们可以马上知道，上面那个动画效果是通过对每个字符做动画完成的。而在 iOS 里，文本显示控件最常见和常用的是 UILabel。而 iOS 的 Explicit Animation 有 Properties Animation 和 keyframe Animation 两种。</p>
<p>但是 UILabel 控件没有提供对其 Text 中每个字符的控制的功能，我们需要改造下。既然要对每个字符做动画，那少不了需要<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>，这些属性。<br>这样看来我们需要两个武器：一个做排版功能的 framework，不用说，肯定是 <a target="_blank" rel="noopener" href="http://objccn.io/issue-5-1/">TextKit</a>。而另一个是能显示单个字符也拥有<code>frame</code>，<code>bounds</code>，<code>position</code>，<code>transform</code>等属性的类，很自然，我们想到<code>CATextLayer</code>。</p>
<h4 id="2-先解决文本布局"><a href="#2-先解决文本布局" class="headerlink" title="2. ** 先解决文本布局 **"></a>2. ** 先解决文本布局 **</h4><p>TextKit 里主要是三个类 <code>NSTextStorage</code>，<code>NSLayoutManager</code>，<code>NSContainer</code>。它们一起帮组我们解决文字布局，排版的工作。</p>
<ul>
<li><p><strong>NSTextStorage</strong>：<code>NSMutableAttributedString</code>的子类，持有文字内容，当字符发生改变时，通知<code>NSLayoutManager</code>对象</p>
</li>
<li><p><strong>NSLayoutManager</strong>: 我们的男主角，从<code>NSTextStorage</code>里获取文字内容后，转换成对应的 glyph，根据<code>NSTextContainer</code>的 visible Region 显示 glyph。</p>
</li>
<li><p><strong>NSContainer</strong>: 确定一个 region 来放置 text。这个 region 被<code>NSLayoutManager</code>用来决定哪里可以 break lines</p>
</li>
</ul>
<p>不过可惜 UILabel 没有这三个类作为自己的属性对象，我们需要自己解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class TextAnimationLabel: UILabel,NSLayoutManagerDelegate &#123;   </span><br><span class="line">     let textStorage:NSTextStorage = NSTextStorage(string: &quot;&quot;)</span><br><span class="line">     let textLayoutManager:NSLayoutManager = NSLayoutManager()</span><br><span class="line">     let textContainer:NSTextContainer = NSTextContainer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此以外我们还需要两个 Array 用来保存文本变换前的旧字符和变换后的新字符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var oldCharacterTextLayers:[CATextLayer] = [] </span><br><span class="line">var newCharacterTextLayers:[CATextLayer] = []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为我们需要用我们自己的 textStorage 对象，所以我们需要覆盖 text 和 attributedText 等属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">override var text:String!&#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        return super.text</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        super.text = text</span><br><span class="line">        let attributedText = NSMutableAttributedString(string: newValue)</span><br><span class="line">        let textRange = NSMakeRange(0,newValue.characters.count)</span><br><span class="line">        attributedText.setAttributes([NSForegroundColorAttributeName:self.textColor], range: textRange)</span><br><span class="line">        attributedText.setAttributes([NSFontAttributeName:self.font], range: textRange)</span><br><span class="line">        let paragraphyStyle = NSMutableParagraphStyle()</span><br><span class="line">        paragraphyStyle.alignment = self.textAlignment</span><br><span class="line">        attributedText.addAttributes([NSParagraphStyleAttributeName:paragraphyStyle], range: textRange)</span><br><span class="line">        self.attributedText = attributedText</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">override var attributedText:NSAttributedString!&#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        return self.textStorage as NSAttributedString</span><br><span class="line">    &#125;</span><br><span class="line">    set&#123;</span><br><span class="line">        cleanOutOldCharacterTextLayers()</span><br><span class="line">        oldCharacterTextLayers = Array(newCharacterTextLayers)</span><br><span class="line">        textStorage.setAttributedString(newValue)</span><br><span class="line">        self.startAnimation &#123; () -&gt; () in</span><br><span class="line">        &#125;</span><br><span class="line">            self.endAnimation(nil)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 TextStorage 的文本内容改变时，会触发一个通知 send textLayoutManager 以便重新布局排版。显然我们可以在排版布局完成后来为每个字符创建设置一个 CATextLayer，并设置相应的 frame 以便正确的显示内容。我们可以有个函数来完成计算。并且 layout finish 完成时调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Mark:NSLayoutMangerDelegate</span><br><span class="line">func layoutManager(layoutManager: NSLayoutManager, didCompleteLayoutForTextContainer textContainer: NSTextContainer?, atEnd layoutFinishedFlag: Bool) &#123;</span><br><span class="line">        calculateTextLayers()</span><br><span class="line">        print(&quot;\(textStorage.string)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//MARK:CalculateTextLayer</span><br><span class="line">func calculateTextLayers()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们的主要想法，是找到 text 里每个 character 以及对应的 glyph rect. 然后用 character 和 glyph rect 创建 CATextLayer</p>
<p>首先我们要有一个空数组用来存放新的 CATextLayer。并且获取 textStorage 的 attributedText。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func calculateTextLayers()</span><br><span class="line">&#123;</span><br><span class="line">    newCharacterTextLayers.removeAll(keepCapacity:false)</span><br><span class="line">    let attributedText = textStorage.string</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们要通过 LayoutManger 找到 TextContainer 的 used Rect，这样方便我们可以让文本垂直居中，就像普通的 Label 那样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func calculateTextLayers()</span><br><span class="line">&#123;</span><br><span class="line">    newCharacterTextLayers.removeAll(keepCapacity:false)</span><br><span class="line">    let attributedText = textStorage.string</span><br><span class="line">    let wordRange = NSMakeRange(0, attributedText.characters.count)</span><br><span class="line">    let attributedString = self.internalAttributedText();</span><br><span class="line">    let layoutRect = textLayoutManager.usedRectForTextContainer(textContainer)</span><br><span class="line">    var index = wordRange.location</span><br><span class="line">    let totalLength = NSMaxRange(wordRange)</span><br><span class="line">    while index &lt; totalLength &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们开始迭代处理文本里的每个字符，创建一个 glyphRange 并且用这个 glyphRange 找到对应的 character，然后我们将 glyph index 丢给 LayoutManager 得到 textContainer，再用 container 和 glyphRange 取得 glyphRect(这里需要注意下 kerning 的问题)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let glyphRange = NSMakeRange(index, 1)</span><br><span class="line">let characterRange = textLayoutManager.characterRangeForGlyphRange(glyphRange, actualGlyphRange: nil)</span><br><span class="line">let textContainer = textLayoutManager.textContainerForGlyphAtIndex(index, effectiveRange: nil)</span><br><span class="line">var glyphRect = textLayoutManager.boundingRectForGlyphRange(glyphRange, inTextContainer: textContainer!)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终我们还需要注意的就是 glyph 的 kerning，如果 <code>kerningRange.location == index</code>，我们需要将前一个 textLayer 取出来调整其 Rect 的宽度至新的 glyphRect 的最右边，保证 glyph 不会被裁切掉（可以对比下面两张图片）</p>
<img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854816/4a6b5258-eca8-11e5-9870-15ed2d4f0d70.png">

<img width="122" src="https://cloud.githubusercontent.com/assets/3759810/13854821/4c5b947e-eca8-11e5-811e-e9abb161345f.png">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let kerningRange = textLayoutManager.rangeOfNominallySpacedGlyphsContainingIndex(index)</span><br><span class="line">if kerningRange.location == index &amp;&amp; kerningRange.length &gt; 1 &#123;</span><br><span class="line">    if newCharacterTextLayers.count &gt; 0 &#123;</span><br><span class="line">        // 如果前一个 textlayer 的 frame.size.width 不变大的话，</span><br><span class="line">        // 当前的 textLayer 会遮挡住字体的一部分，比如 “Yes” 的 Y 右上角会被切掉一部分</span><br><span class="line">        let previousLayer = newCharacterTextLayers[newCharacterTextLayers.endIndex - 1]</span><br><span class="line">        var frame = previousLayer.frame</span><br><span class="line">        frame.size.width += CGRectGetMaxX(glyphRect) - CGRectGetMaxX(frame)</span><br><span class="line">        previousLayer.frame = frame</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里关于 kerning 和 glyph 要多说一点。先来说下 glyph，简单来说 glyph 是表示一个 character 的具体样式 , 但他们却不是一一对应的关系，比如一个字母 “A” 可以有不同的写法来表示例如：</p>
<img width="417" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878224/e142bef8-ed4a-11e5-9c84-798cb5939f36.png">

<p>除此以外，还有这种情况：</p>
<img width="243" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878392/fab15e02-ed4b-11e5-9d38-2dc00ed45b0b.png">

<p>上面是的 “ff” 虽然是两个 character，但是 glyph 却是一个。<br>不过不用担心，强大 LayoutManager 提供了两个方法帮助我们通过一个找到对应另外那个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func characterIndexForGlyphAtIndex(_ glyphIndex: Int) -&gt; Int</span><br><span class="line">func glyphIndexForCharacterAtIndex(_ charIndex: Int) -&gt; Int</span><br></pre></td></tr></table></figure>

<p>现在我们说下 kerning。通常，在水平排布的文本中，glyph 都是一个挨着一个放置的，但是在某些时候为了让文本的可读性更好，看上去更加优雅美观，一个字形和另外一个字形之间可能会稍微的错位下，比如下面这种情况：</p>
<img width="601" alt="" src="https://cloud.githubusercontent.com/assets/3759810/13878767/7631a33c-ed4e-11e5-9d03-46d89d8af9c8.png">
这也是上面为什么”Y“会出现显示不全的原因了。

<p>接下来就比较简单了，创建 Textlayer, 设置垂直居中，添加到数组当中，<code>index += characterRange.length</code>，开始下次循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glyphRect.origin.y += (self.bounds.size.height/2)-(layoutRect.size.height/2)</span><br><span class="line">let textLayer = CATextLayer(frame: glyphRect, string: attributedString.attributedSubstringFromRange(characterRange));</span><br><span class="line">layer.addSublayer(textLayer);</span><br><span class="line">newCharacterTextLayers.append(textLayer);</span><br><span class="line">index += characterRange.length</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-动画实现"><a href="#3-动画实现" class="headerlink" title="3. ** 动画实现 **"></a>3. ** 动画实现 **</h4><p>上面我们解决了字符排版的问题，接下来动画的实现就相对的容易了，仔细观察那个动画，很容易得出主要是对 <code>opacity</code> 和 <code>transform</code> 两个属性做属性动画，<code>opacity</code> 让每个字体逐渐显示和逐渐消失，而 <code>transform</code>则做了两种变形，一种是往下移动，另外一种是旋转。用 <code>CABasicAnimation</code> 可以解决单个属性动画，而 <code>CAAnimationGroup</code> 则帮我们解决多个动画叠加的复合效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func groupAnimationWithLayerChanges(old olderLayer:CALayer, new newLayer:CALayer) </span><br><span class="line">     -&gt; CAAnimationGroup? &#123;</span><br><span class="line"></span><br><span class="line">    var animationGroup:CAAnimationGroup?</span><br><span class="line">    var animations:[CABasicAnimation] = [CABasicAnimation]()</span><br><span class="line"></span><br><span class="line">    if !CATransform3DEqualToTransform(olderLayer.transform,</span><br><span class="line">    newLayer.transform) &#123;</span><br><span class="line">         let basicAnimation = CABasicAnimation(keyPath: &quot;transform&quot;)</span><br><span class="line">         basicAnimation.fromValue = NSValue(CATransform3D: olderLayer.transform)</span><br><span class="line">         basicAnimation.toValue = NSValue(CATransform3D: newLayer.transform)</span><br><span class="line">         animations.append(basicAnimation)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    if olderLayer.opacity != newLayer.opacity &#123;</span><br><span class="line">       let basicAnimation = CABasicAnimation(keyPath: &quot;opacity&quot;)</span><br><span class="line">       basicAnimation.fromValue = olderLayer.opacity</span><br><span class="line">       basicAnimation.toValue = newLayer.opacity</span><br><span class="line">       animations.append(basicAnimation)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    if animations.count &gt; 0 &#123;</span><br><span class="line">       animationGroup = CAAnimationGroup()</span><br><span class="line">       animationGroup!.animations = animations</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要注意一个问题，就是隐式动画的问题，Core Animation 基于一个假说，就是屏幕上的任何东西都可以 (或者可能) 做动画，我们平时在写代码时应该有这种印象就是你只是 layer 设置了一个值，没有添加动画，但是你会看到一个平滑过渡的显示效果而不是非常突兀的变化。这就是隐式动画。当我们改变一个属性时，Core Animation 帮我们做了一个动画，动画时间取决于当前 NSTransaction 的设置，而动画类型取决于图层行为。</p>
<p>这里有个有趣的东西，多说一点，就是当我们对 UIView 关联的图层做动画而不是一个单独的图层做动画，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func changeColor()</span><br><span class="line">&#123;</span><br><span class="line">    CATransaction.begin();</span><br><span class="line">    CATransaction.setAnimationDuration(1.0)</span><br><span class="line">    CGFloat red = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br><span class="line">    CGFloat green = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br><span class="line">    CGFloat blue = CGFloat(arc4random() / (CGFloat)INT_MAX);</span><br><span class="line">    self.layerView.layer.backgroundColor = UIColor.(colorWithRed:red green:green blue:blue alpha:1.0).CGColor;</span><br><span class="line">    CATransaction.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图层的颜色瞬间切换到新的值，而不是之前的平滑过渡，隐式动画似乎给关闭了。<br>我们知道 UIView 和 CALayer 最重要的关系就是 UIView 是 CALayer 的 delegate，<br>当我们改变 CALayer 的属性时，它会调用 <code>func actionForKey(_ event: String) -&gt; CAAction?</code> </p>
<p>这个方法，接下来发生的事情在官方文档里都有写，实际上是如下几步:</p>
<ul>
<li><p><em>If the layer has a delegate that implements the actionForLayer:forKey: method, the layer calls that method. The delegate must do one of the following:</em></p>
<ol>
<li><p>Return the action object for the given key.</p>
</li>
<li><p>Return the NSNull object if it does not handle the action.</p>
</li>
</ol>
</li>
<li><p><em>The layer looks in the layer’s actions dictionary for a matching key&#x2F;action pair.</em></p>
</li>
<li><p><em>The layer looks in the style dictionary for an actions dictionary for a matching key&#x2F;action pair.</em></p>
</li>
<li><p><em>The layer calls the defaultActionForKey: class method to look for any class-defined actions.</em></p>
</li>
</ul>
<p>UIView 作为它关联图层的 Delegate，实现了 <code>actionForLayer(_ layer: CALayer, forKey event: String) -&gt; CAAction?</code> ，当不在一个动画块中，UIView 返回 nil，而在动画块中则返回一个非空值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;OutSide:\(self.view.actionForLayer(self.view.layer, forKey: &quot;backgroundColor&quot;))&quot;)</span><br><span class="line">UIView.beginAnimations(nil, context: nil)</span><br><span class="line">print(&quot;InSide:\(self.view.actionForLayer(self.view.layer,</span><br><span class="line">forKey: &quot;backgroundColor&quot;))&quot;)</span><br><span class="line">UIView.commitAnimations()</span><br></pre></td></tr></table></figure>
<p>显示结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutSide:Optional(&lt;null&gt;)</span><br><span class="line">InSide:Optional(&lt;CABasicAnimation: 0x7f7f93ff81b0&gt;)</span><br></pre></td></tr></table></figure>

<p>当然返回 nil 并不是禁用隐式动画的唯一方法，下面这样也行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATransaction.setDisableActions(true)</span><br></pre></td></tr></table></figure>

<p>那为什么说这个问题呢？因为我们在对每个字符做动画的时候需要先将隐式动画关闭，否者将会做两次动画，比如下面这样:</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13857496/2443d70a-ecb5-11e5-8661-a499e9c8719d.gif" alt="closeimplicitanimation"></p>
<p>那么，我们先生成一份 oldlayer, 然后改变相应的属性，生产新的 newLayer。然后创建相应的动画组，添加显式动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let olderLayer = animationObjc.animatableLayerCopy(layer)</span><br><span class="line">CATransaction.begin()</span><br><span class="line">CATransaction.setDisableActions(true)</span><br><span class="line">newLayer = effectAnimationClosure(layer: layer)</span><br><span class="line">CATransaction.commit()</span><br><span class="line">var animationGroup:CAAnimationGroup?</span><br><span class="line">animationGroup = groupAnimationWithLayerChanges(old: olderLayer, new: newLayer!)</span><br><span class="line">layer.addAnimation(textAniamtionGroup, forKey: textAnimationGroupKey)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="收工"><a href="#收工" class="headerlink" title="收工"></a>收工</h2><p>好了，当上面所有的工作完成之后，就是我们最开始看到的那个效果，代码已经上传 GitHub，你可以从 <a target="_blank" rel="noopener" href="https://github.com/morpheus1984/TextKitAndAnimationEffect.git">这里</a> 下载。其实这个 demo 里实现的 label 还有很大优化的空间。比如支持多种类型的动画效果，动画效果可配置等等。这是我接下来打算做的事情。<br>本人才疏学浅，错漏难免，欢迎大家批评指正。如果你发现 bug，可以提个 pull request。如果你有更好地思路也请告诉我，让我进步，我请你喝咖啡 ：）。</p>
<p>这是我的微信号（未完结，请往下看）：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3759810/13864468/9fdcae9c-ecdc-11e5-9c49-278b327d1ba7.png" alt="wechat"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不知不觉工作许多年了，这几年萝莉变成了姑娘，姑娘变成了孩子妈。大家从 QQ 空间杀到朋友圈。从晒女朋友，到晒结婚照继而到晒娃。这几年鸣人同志都不负众望当上了火影 (丫也不请吃饭)。大家都在发生变化。</p>
<p>学会开始写点东西分享可能是我想要的一个变化。</p>
<p>本来作为非知名程序员，平时都是自己上 GitHub 玩，自认为比起一干牛人既没本领可以提振民心士气，又没有独门绝技可以分享。直到我收到了一封来自组织的信。</p>
<p>最近我加入了一个公会，里面云集了各类高手，轻功，内力，暗器，大家各有所长，时不时分享下自己的看家本领。还是那句老话，不看不知道，一看吓一跳。世界还是外面的大，姑娘还是城里的靓。在群里，大家都很积极活跃，学习氛围异常的好。其实自打做起程序员起，这么多年来，虽然生性慵懒，但是自学却未敢放下，毕竟逆水行舟，不进则退。不可否认的是一个人的学习是很苦闷无聊的，但一群人陪着你一起苦闷无聊也是很欣慰的。</p>
<p>最后我想引用那封邮件里面的话来表达下我对公会的看法:</p>
<blockquote>
<p>这个社群的意义证明了，在互联网时代，依然有这么多人愿意为知识的积累和个人的成长付费，知识本身的价值得到重新的认知，人们以一种去中心化的方式连接起来，P2P 的创作和分享，可能会让知识和技能的积累、传播达到了一种新的高度、深度和广度</p>
</blockquote>
<p>我想一贯懒散的我为何突然想写这么个 blog 可能也是因为这个，毕竟知识的受益者永远是那些积极参与学习并持续思考的人。</p>
<p>额，最后想说的是，是的，那段引用的文字你没看错，这是个需要付费的群，免费时代的付费群，它叫 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=402078207&idx=1&sn=c0b437784c7fc789e06767eedf5cdf87&scene=18#wechat_redirect">攻城狮之路</a>。</p>
<p>知识是很昂贵的，我一直这么认为。另外，其实这是篇硬广。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/18/2016/php-namespace-autoload-and-implementation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/18/2016/php-namespace-autoload-and-implementation/" itemprop="url">PHP 命名空间自动加载与实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-18T18:22:15+08:00">
                2016-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>Blessing Skin Server 也经过蛮长时间的开发了，但是类文件都只是简单的堆放在同一个文件夹中。虽然我知道有命名空间这玩意，但是总共就几个类，也不是很有必要。</p>
<p>然而在上周加入了数据对接之后，<code>includes</code> 文件夹就开始爆满了：</p>
<p><img src="https://img.prin.studio/legacy/image.php?di=3G97" alt="includes dir"></p>
<p>这尼玛还怎么忍？必须命名空间走起啊。</p>
<p>然而我只是知道有这玩意，在框架里也用过，但是并不知道如何实现对其的自动加载。</p>
<p>于是我去网上看了一些自动加载的实例，然后自己写了一个自动加载。说实话刚看到的时候还是有点迷的，所以在这里记录一下。由于我的项目是用类名与文件名相同的方式来组织存储的，所以就懒得管 PSR-4 啦（笑）。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/03/18/2016/php-namespace-autoload-and-implementation/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/13/2016-03-13-iOS-transition-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/13/2016-03-13-iOS-transition-guide/" itemprop="url">iOS 视图控制器转场详解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-13T16:15:47+08:00">
                2016-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <blockquote>
<p>作者：<a target="_blank" rel="noopener" href="http://weibo.com/u/1815689155">seedante</a>，神秘人士，他的 <a target="_blank" rel="noopener" href="https://github.com/seedante">GitHub</a>。<br>感谢投稿，<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition">原文链接</a>。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>屏幕左边缘右滑返回，TabBar 滑动切换，你是否喜欢并十分依赖这两个操作，甚至觉得 App 不支持这类操作的话简直反人类？这两个操作在大屏时代极大提升了操作效率，其背后的技术便是今天的主题：视图控制器转换(View Controller Transition)。</p>
<p>视图控制器中的视图显示在屏幕上有两种方式：最主要的方式是内嵌在容器控制器中，比如 UINavigationController，UITabBarController, UISplitController；由另外一个视图控制器显示它，这种方式通常被称为模态(Modal)显示。View Controller Transition 是什么？在 NavigationController 里 push 或 pop 一个 View Controller，在 TabBarController 中切换到其他 View Controller，以 Modal 方式显示另外一个 View Controller，这些都是 View Controller Transition。在 storyboard 里，每个 View Controller 是一个 Scene，View Controller Transition 便是从一个 Scene 转换到另外一个 Scene；为方便，以下对 View Controller Transition 的中文称呼采用 Objccn.io 中的翻译「转场」。</p>
<p>在 iOS 7 之前，我们只能使用系统提供的转场效果，大部分时候够用，但仅仅是够用而已，总归会有各种不如意的小地方，但我们却无力改变；iOS 7 开放了相关 API 允许我们对转场效果进行全面定制，这太棒了，自定义转场动画以及对交互手段的支持带来了无限可能。</p>
<p>本文并非华丽的转场动画教程，相反，文中的转场动画效果都十分简单，但本文的内容并不简单，我将带你探索转场背后的机制，缺陷以及实现过程中的技巧与陷阱。阅读本文需要读者至少要对 ViewController 和 View 的结构以及协议有基本的了解，最好自己亲手实现过一两种转场动画。如果你对此感觉没有信心，推荐观看官方文档：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1">View Controller Programming Guide for iOS</a>，学习此文档将会让你更容易理解本文的内容。对你想学习的小节，我希望你自己亲手写下这些代码，一步步地看着效果是如何实现的，至少对我而言，看各种相关资料时只有字面意义上的理解，正是一步步的试验才能让我理解每一个步骤。本文涉及的内容较多，为了避免篇幅过长，我只给出关键代码而不是从新建工程开始教你每一个步骤。本文基于 Xcode 7 以及 Swift 2，Demo 合集地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo.git">iOS-ViewController-Transition-Demo</a>。</p>
<h2 id="Chapter1">Transition 解释</h2>

<p>前言里从行为上解释了转场，那在转场时发生了什么？下图是从 WWDC 2013 Session 218 整理的，解释了转场时视图控制器和其对应的视图在结构上的变化：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/The%20Anatomy%20of%20Transition.png?raw=true" alt="The Anatomy of Transition"></p>
<p>转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画，动画的方式非常多，所以限制最终呈现的效果就只有你的想象力了。图中的 Parent VC 可替换为 UIViewController, UITabbarController 或 UINavigationController 中的任何一种。</p>
<p>目前为止，官方支持以下几种方式的自定义转场：</p>
<ol>
<li>在 UINavigationController 中 push 和 pop;</li>
<li>在 UITabBarController 中切换 Tab;</li>
<li>Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于<code>modalPresentationStyle</code>属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式;</li>
<li>UICollectionViewController 的布局转场：UICollectionViewController 与 UINavigationController 结合的转场方式，实现很简单。</li>
</ol>
<p>官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。</p>
<p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：</p>
<p>1.<strong>转场代理(Transition Delegate)：</strong></p>
<p>自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。有如下三种转场代理，对应上面三种类型的转场：</p>
<pre><code>&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。
&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。
&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。
</code></pre>
<p>这里除了<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitioningDelegate_protocol/index.html#//apple_ref/doc/uid/TP40013060"><code>&lt;UIViewControllerTransitioningDelegate&gt;</code></a>是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。</p>
<p>转场发生时，UIKit 将要求转场代理将提供转场动画的核心构件：动画控制器和交互控制器(可选的)；由我们实现。</p>
<p>2.<strong>动画控制器(Animation Controller)：</strong></p>
<p>最重要的部分，负责添加视图以及执行动画；遵守<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerAnimatedTransitioning_Protocol/index.html#//apple_ref/doc/uid/TP40013387"><code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></a>协议；由我们实现。</p>
<p>3.<strong>交互控制器(Interaction Controller)：</strong></p>
<p>通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerInteractiveTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013059"><code>&lt;UIViewControllerInteractiveTransitioning&gt;</code></a>协议；系统已经打包好现成的类供我们使用。</p>
<p>4.<strong>转场环境(Transition Context):</strong></p>
<p>提供转场中需要的数据；遵守<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerContextTransitioning_protocol/index.html#//apple_ref/doc/uid/TP40013057"><code>&lt;UIViewControllerContextTransitioning&gt;</code></a>协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。</p>
<p>5.<strong>转场协调器(Transition Coordinator)：</strong></p>
<p>可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinator_Protocol/index.html#//apple_ref/doc/uid/TP40013295"><code>&lt;UIViewControllerTransitionCoordinator&gt;</code></a>协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法<code>transitionCoordinator()</code>返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。</p>
<p>总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。</p>
<h2 id="Chapter2">阶段一：非交互转场</h2>

<p>这个阶段要做两件事，提供转场代理并由代理提供动画控制器。在转场代理协议里动画控制器和交互控制器都是可选实现的，没有实现或者返回 nil 的话则使用默认的转场效果。动画控制器是表现转场效果的核心部分，代理部分非常简单，我们先搞定动画控制器吧。</p>
<h3 id="Chapter2.1">动画控制器协议</h3>

<p>动画控制器负责添加视图以及执行动画，遵守<code>UIViewControllerAnimatedTransitioning</code>协议，该协议要求实现以下方法：</p>
<pre><code>//执行动画的地方，最核心的方法。
(Required)func animateTransition(_ transitionContext: UIViewControllerContextTransitioning)
//返回动画时间，&quot;return 0.5&quot; 已足够，非常简单，出于篇幅考虑不贴出这个方法的代码实现。
(Required)func transitionDuration(_ transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval
//如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。
(Optional)func animationEnded(_ transitionCompleted: Bool)
</code></pre>
<p>最重要的是第一个方法，该方法接受一个遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议的转场环境对象，上一节的 API 解释里提到这个协议，它提供了转场所需要的重要数据：参与转场的视图控制器和转场过程的状态信息。</p>
<p>UIKit 在转场开始前生成遵守转场环境协议<code>&lt;UIViewControllerContextTransitioning&gt;</code>的对象 transitionContext，它有以下几个方法来提供动画控制器需要的信息：</p>
<pre><code>//返回容器视图，转场动画发生的地方。
func containerView() -&gt; UIView?
//获取参与转场的视图控制器，有 UITransitionContextFromViewControllerKey 和 UITransitionContextToViewControllerKey 两个 Key。 
func viewControllerForKey(_ key: String) -&gt; UIViewController?
//iOS 8新增 API 用于方便获取参与参与转场的视图，有 UITransitionContextFromViewKey 和 UITransitionContextToViewKey 两个 Key。
func viewForKey(_ key: String) -&gt; UIView? AVAILABLE_IOS(8_0)
</code></pre>
<p>通过<code>viewForKey:</code>获取的视图是<code>viewControllerForKey:</code>返回的控制器的根视图，或者 nil。<code>viewForKey:</code>方法返回 nil 只有一种情况： UIModalPresentationCustom 模式下的 Modal 转场 ，通过此方法获取 presentingView 时得到的将是 nil，在后面的 Modal 转场里会详细解释。</p>
<p>前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。几种转场方式的转场操作都是可逆的，一种操作里的 fromView 和 toView 在逆向操作里的角色互换成对方，fromVC 和 toVC 也是如此。<strong>在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力。</strong>这也是动画控制器在封装后可以被第三方使用的重要原因。</p>
<p>在 iOS 8 中可通过以下方法来获取参与转场的三个重要视图，在 iOS 7 中则需要通过对应的视图控制器来获取，为避免 API 差异导致代码过长，示例代码中直接使用下面的视图变量：</p>
<pre><code>let containerView = transitionContext.containerView()
let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)
let toView = transitionContext.viewForKey(UITransitionContextToViewKey)
</code></pre>
<h3 id="Chapter2.2">动画控制器实现</h3>

<p>转场 API 是协议的好处是不限制具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同，但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。</p>
<p>三种转场方式都有一对可逆的转场操作，你可以为了每一种操作实现单独的动画控制器，也可以实现通用的动画控制器。处于篇幅的考虑，本文示范一个比较简单的 Slide 动画控制器：Slide left and right，而且该动画控制器在三种转场方式中是通用的，不必修改就可以直接在工程中使用。效果示意图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/SlideAnimation.gif?raw=true" alt="SlideAnimation"></p>
<p>在交互式转场章节里我们将在这个基础上实现文章开头提到的两种效果：NavigationController 右滑返回 和 TabBarController 滑动切换。尽管对动画控制器来说，转场方式并不重要，可以对 fromView 和 toView 进行任何动画，但上面的动画和 Modal 转场风格上有点不配，主要动画的方向不对，不过我在这个 Slide 动画控制器里为 Modal 转场适配了和系统的风格类似的竖直移动动画效果；另外 Modal 转场并没有比较合乎操作直觉的交互手段，而且和前面两种容器控制器的转场在机制上有些不同，所以我将为 Modal 转场示范另外一个动画。</p>
<p>在转场中操作是可逆的，返回操作时的动画应该也是逆向的。对此，Slide 动画控制器需要针对转场的操作类型对动画的方向进行调整。Swift 中 enum 的关联值可以视作有限数据类型的集合体，在这种场景下极其合适。设定转场类型：</p>
<pre><code>enum SDETransitionType&#123;
    //UINavigationControllerOperation 是枚举类型，有 None, Push, Pop 三种值。
    case NavigationTransition(UINavigationControllerOperation) 
    case TabTransition(TabOperationDirection)
    case ModalTransition(ModalOperation)
&#125;

enum TabOperationDirection&#123;
    case Left, Right
&#125;

enum ModalOperation&#123;
    case Presentation, Dismissal
&#125;
</code></pre>
<p>使用示例：在 TabBarController 中切换到左边的页面。</p>
<pre><code>let transitionType = SDETransitionType.TabTransition(.Left)
</code></pre>
<p>Slide 动画控制器的核心代码：</p>
<pre><code>class SlideAnimationController: NSObject, UIViewControllerAnimatedTransitioning &#123;
    init(type: SDETransitionType) &#123;...&#125;
    
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;
        ...
         //1
        containerView.addSubview(toView)
        
        //计算位移 transform，NavigationVC 和 TabBarVC 在水平方向进行动画，Modal 转场在竖直方向进行动画。
        var toViewTransform = ...
        var fromViewTransform = ...
        toView.transform = toViewTransform
        
        //根据协议中的方法获取动画的时间。
        let duration = self.transitionDuration(transitionContext)
        UIView.animateWithDuration(duration, animations: &#123;
            fromView.transform = fromViewTransform
            toView.transform = CGAffineTransformIdentity
            &#125;, completion: &#123; _ in
                //考虑到转场中途可能取消的情况，转场结束后，恢复视图状态。
                fromView.transform = CGAffineTransformIdentity
                toView.transform = CGAffineTransformIdentity
                //2
                let isCancelled = transitionContext.transitionWasCancelled()
                transitionContext.completeTransition(!isCancelled)
        &#125;)
    &#125;
&#125;
</code></pre>
<p>注意上面的代码有2处标记，是动画控制器必须完成的：</p>
<ol>
<li>将 toView 添加到容器视图中，使得 toView 在屏幕上显示( Modal 转场中此点稍有不同，下一节细述)；</li>
<li>正确地结束转场过程。转场的结果有两种：完成或取消。非交互转场的结果只有完成一种情况，不过交互式转场需要考虑取消的情况。如何结束取决于转场的进度，通过<code>transitionWasCancelled()</code>方法来获取转场的状态，使用<code>completeTransition:</code>来完成或取消转场。</li>
</ol>
<p>实际上，这里示范的简单的转场动画和那些很复杂的转场动画在转场的部分要做的事情都是上面提到的这两点，它们的区别主要在于动画的部分。</p>
<p>转场结束后，fromView 会从视图结构中移除，UIKit 自动替我们做了这事，你也可以手动处理提前将 fromView 移除，这完全取决于你。<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>也能做同样的事，使用下面的代码替换上面的代码，甚至不需要获取 containerView 以及手动添加 toView 就能实现一个类似的转场动画：</p>
<pre><code>UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: &#123; _ in
    let isCancelled = transitionContext.transitionWasCancelled()
    transitionContext.completeTransition(!isCancelled)
&#125;)
</code></pre>
<h3 id="Chapter2.3">特殊的 Modal 转场</h3>

<h4 id="Chapter2.3.1">Modal 转场的差异</h4>

<p>Modal 转场中需要做的事情和两种容器 VC 的转场一样，但在细节上有些差异。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVC%20VS%20Modal.png?raw=true" alt="ContainerVC VS Modal"></p>
<p>UINavigationController 和 UITabBarController 这两个容器 VC 的根视图在屏幕上是不可见的(或者说是透明的)，可见的只是内嵌在这两者中的子 VC 中的视图，转场是从子 VC 的视图转换到另外一个子 VC 的视图，其根视图并未参与转场；而 Modal 转场，以 presentation 为例，是从 presentingView 转换到 presentedView，根视图 presentingView 也就是 fromView 参与了转场。而且 NavigationController 和 TabBarController 转场中的 containerView 也并非这两者的根视图。</p>
<p>Modal 转场与两种容器 VC 的转场的另外一个不同是：Modal 转场结束后 presentingView 可能依然可见，UIModalPresentationPageSheet 模式就是这样。这种不同导致了 Modal 转场和容器 VC 的转场对 fromView 的处理差异：容器 VC 的转场结束后 fromView 会被主动移出视图结构，这是可预见的结果，我们也可以在转场结束前手动移除；而 Modal 转场中，presentation 结束后 presentingView(fromView) 并未主动被从视图结构中移除。准确来说，是 UIModalPresentationCustom 这种模式下的 Modal 转场结束时 fromView 并未从视图结构中移除；UIModalPresentationFullScreen 模式的 Modal 转场结束后 fromView 依然主动被从视图结构中移除了。这种差异导致在处理 dismissal 转场的时候很容易出现问题，没有意识到这个不同点的话出错时就会毫无头绪。下面来看看 dismissal 转场时的场景。</p>
<p>ContainerView 在转场期间作为 fromView 和 toView 的父视图。三种转场过程中的 containerView 是 UIView 的私有子类，不过我们并不需要关心 containerView 具体是什么。在 dismissal 转场中：</p>
<ol>
<li>UIModalPresentationFullScreen 模式：presentation 后，presentingView 被主动移出视图结构，在 dismissal 中 presentingView 是 toView 的角色，其将会重新加入 containerView 中，实际上，我们不主动将其加入，UIKit 也会这么做，前面的两种容器控制器的转场里不是这样处理的，不过这个差异基本没什么影响。</li>
<li>UIModalPresentationCustom 模式：转场时 containerView 并不担任 presentingView 的父视图，后者由 UIKit 另行管理。在 presentation 后，fromView(presentingView) 未被移出视图结构，在 dismissal 中，注意不要像其他转场中那样将 toView(presentingView) 加入 containerView 中，否则本来可见的 presentingView 将会被移除出自身所处的视图结构消失不见。如果你在使用 Custom 模式时没有注意到这点，就很容易掉进这个陷阱而很难察觉问题所在，这个问题曾困扰了我一天。</li>
</ol>
<p>对于 Custom 模式，我们可以参照其他转场里的处理规则来打理：presentation 转场结束后主动将 fromView(presentingView) 移出它的视图结构，并用一个变量来维护 presentingView 的父视图，以便在 dismissal 转场中恢复；在 dismissal 转场中，presentingView 的角色由原来的 fromView 切换成了 toView，我们再将其重新恢复它原来的视图结构中。测试表明这样做是可行的。但是这样一来，在实现上，需要在转场代理中维护一个动画控制器并且这个动画控制器要维护 presentingView 的父视图，第三方的动画控制器必须为此改造。显然，这样的代价是无法接受的。</p>
<p><strong>小结</strong>：经过上面的尝试，建议是，不要干涉官方对 Modal 转场的处理，我们去适应它。在 Custom 模式下，由于 presentingView 不受 containerView 管理，在 dismissal 转场中不要像其他的转场那样将 toView(presentingView) 加入 containerView，否则 presentingView 将消失不见，而应用则也很可能假死；而在 presentation 转场中，切记不要手动将 fromView(presentingView) 移出其父视图。</p>
<p>iOS 8 为<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议添加了<code>viewForKey:</code>方法以方便获取 fromView 和 toView，但是在 Modal 转场里要注意，从上面可以知道，Custom 模式下，presentingView 并不受 containerView 管理，这时通过<code>viewForKey:</code>方法来获取 presentingView 得到的是 nil，必须通过<code>viewControllerForKey:</code>得到 presentingVC 后来获取。因此在 Modal 转场中，较稳妥的方法是从 fromVC 和 toVC 中获取 fromView 和 toView。</p>
<p>顺带一提，前面提到的<code>UIView</code>的类方法<code>transitionFromView:toView:duration:options:completion:</code>能在 Custom 模式下工作，却与 FullScreen 模式有点不兼容。</p>
<h4 id="Chapter2.3.2">Modal 转场实践</h4>

<p>UIKit 已经为 Modal 转场实现了多种效果，当 UIViewController 的<code>modalPresentationStyle</code>属性为<code>.Custom</code> 或<code>.FullScreen</code>时，我们就有机会定制转场效果，此时<code>modalTransitionStyle</code>指定的转场动画将会被忽略。</p>
<p>Modal 转场开放自定义功能后最令人感兴趣的是定制 presentedView 的尺寸，下面来我们来实现一个带暗色调背景的小窗口效果。Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition">CustomModalTransition</a>。</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ModalTransition.gif?raw=true" alt="ModalTransition"></p>
<p>由于需要保持 presentingView 可见，这里的 Modal 转场应该采用 UIModalPresentationCustom 模式，此时 presentedVC 的<code>modalPresentationStyle</code>属性值应设置为<code>.Custom</code>。而且与容器 VC 的转场的代理由容器 VC 自身的代理提供不同，Modal 转场的代理由 presentedVC 提供。动画控制器的核心代码：</p>
<pre><code>class OverlayAnimationController: NSobject, UIViewControllerAnimatedTransitioning&#123;
    ... 
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;            
        ...
        //不像容器 VC 转场里需要额外的变量来标记操作类型，UIViewController 自身就有方法跟踪 Modal 状态。
        //处理 Presentation 转场：
        if toVC.isBeingPresented()&#123;
            //1
            containerView.addSubview(toView)
            //在 presentedView 后面添加暗背景视图 dimmingView，注意两者在 containerView 中的位置。
            let dimmingView = UIView()
            containerView.insertSubview(dimmingView, belowSubview: toView)

            //设置 presentedView 和 暗背景视图 dimmingView 的初始位置和尺寸。
            let toViewWidth = containerView.frame.width * 2 / 3
            let toViewHeight = containerView.frame.height * 2 / 3
            toView.center = containerView.center
            toView.bounds = CGRect(x: 0, y: 0, width: 1, height: toViewHeight)
            
            dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
            dimmingView.center = containerView.center
            dimmingView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)
            
            //实现出现时的尺寸变化的动画：
            UIView.animateWithDuration(duration, delay: 0, options: .CurveEaseInOut, animations: &#123;
                toView.bounds = CGRect(x: 0, y: 0, width: toViewWidth, height: toViewHeight)
                dimmingView.bounds = containerView.bounds
                &#125;, completion: &#123;_ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            &#125;)
        &#125;
        //处理 Dismissal 转场，按照上一小节的结论，.Custom 模式下不要将 toView 添加到 containerView，省去了上面标记1处的操作。
        if fromVC.isBeingDismissed()&#123;
            let fromViewHeight = fromView.frame.height
            UIView.animateWithDuration(duration, animations: &#123;
                fromView.bounds = CGRect(x: 0, y: 0, width: 1, height: fromViewHeight)
                &#125;, completion: &#123; _ in
                    //2
                    let isCancelled = transitionContext.transitionWasCancelled()
                    transitionContext.completeTransition(!isCancelled)
            &#125;)
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="Chapter2.3.3">iOS 8的改进：UIPresentationController</h4>

<p>iOS 8 针对分辨率日益分裂的 iOS 设备带来了新的适应性布局方案，以往有些专为在 iPad 上设计的控制器也能在 iPhone 上使用了，一个大变化是在视图控制器的(模态)显示过程，包括转场过程，引入了<code>UIPresentationController</code>类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。当 UIViewController 的<code> modalPresentationStyle</code>属性为<code>.Custom</code>时(不支持<code>.FullScreen</code>)，我们有机会通过控制器的转场代理提供<code>UIPresentationController</code>的子类对 Modal 转场进行进一步的定制。官方对该类参与转场的流程和使用方法有非常详细的说明：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1">Creating Custom Presentations</a>。</p>
<p><code>UIPresentationController</code>类主要给 Modal 转场带来了以下几点变化：</p>
<ol>
<li>定制 presentedView 的外观：设定 presentedView 的尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画；</li>
<li>可以选择是否移除 presentingView；</li>
<li>可以在不需要动画控制器的情况下单独工作；</li>
<li>iOS 8 中的适应性布局。</li>
</ol>
<p>以上变化中第1点 iOS 7 中也能做到，3和4是 iOS 8 带来的新特性，只有第2点才真正解决了 iOS 7 中的痛点。在 iOS 7 中定制外观时，动画控制器需要负责管理额外添加的的视图，<code>UIPresentationController</code>类将该功能剥离了出来独立负责，其提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的<code>animateTransition:</code>的关系：</p>
<pre><code>func presentationTransitionWillBegin()
func presentationTransitionDidEnd(_ completed: Bool)
func dismissalTransitionWillBegin()
func dismissalTransitionDidEnd(_ completed: Bool)
</code></pre>
<p>除了 presentingView，<code>UIPresentationController</code>类拥有转场过程中剩下的角色：</p>
<pre><code>//指定初始化方法。
init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController)
var presentingViewController: UIViewController &#123; get &#125;
var presentedViewController: UIViewController &#123; get &#125;
var containerView: UIView? &#123; get &#125;
//提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。
func presentedView() -&gt; UIView?     
</code></pre>
<p>没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，<code>UIPresentationController</code>类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过<code>viewForKey:</code>方便获取转场的视图，而该方法在 Modal 转场中获取的是<code>presentedView()</code>返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。</p>
<p>接下来，我用<code>UIPresentationController</code>子类实现上一节「Modal 转场实践」里的效果，presentingView 和 presentedView 的动画由动画控制器负责，剩下的事情可以交给我们实现的子类来完成。</p>
<p>参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的<code>transitionCoordinator()</code>方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。</p>
<p>转场协调器遵守<code>&lt;UIViewControllerTransitionCoordinator&gt;</code>协议，它含有以下几个方法：</p>
<pre><code>//与动画控制器中的转场动画同步，执行其他动画
animateAlongsideTransition:completion:
//与动画控制器中的转场动画同步，在指定的视图内执行动画
animateAlongsideTransitionInView:animation:completion:
</code></pre>
<p>由于转场协调器的这种特性，动画的同步问题解决了。</p>
<pre><code>class OverlayPresentationController: UIPresentationController &#123;
    let dimmingView = UIView()
    
    //Presentation 转场开始前该方法被调用。
    override func presentationTransitionWillBegin() &#123;
        self.containerView?.addSubview(dimmingView)
        
        let initialWidth = containerView!.frame.width*2/3, initialHeight = containerView!.frame.height*2/3
        self.dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
        self.dimmingView.center = containerView!.center
        self.dimmingView.bounds = CGRect(x: 0, y: 0, width: initialWidth , height: initialHeight)
        //使用 transitionCoordinator 与转场动画并行执行 dimmingView 的动画。
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition(&#123; _ in
            self.dimmingView.bounds = self.containerView!.bounds
        &#125;, completion: nil)
    &#125;
    //Dismissal 转场开始前该方法被调用。添加了 dimmingView 消失的动画，在上一节中并没有添加这个动画，
    //实际上由于 presentedView 的形变动画，这个动画根本不会被注意到，此处只为示范。
    override func dismissalTransitionWillBegin() &#123;
        presentedViewController.transitionCoordinator()?.animateAlongsideTransition(&#123; _ in
            self.dimmingView.alpha = 0.0
            &#125;, completion: nil)
    &#125;    
&#125;
</code></pre>
<p><code>OverlayPresentationController</code>类接手了 dimmingView 的工作后，需要回到上一节<code>OverlayAnimationController</code>里把涉及 dimmingView 的部分删除，然后在 presentedVC 的转场代理属性<code>transitioningDelegate</code>中提供该类实例就可以实现和上一节同样的效果。</p>
<pre><code>func presentationControllerForPresentedViewController(_ presented: UIViewController, 
                              presentingViewController presenting: UIViewController, 
                                      sourceViewController source: UIViewController) -&gt; UIPresentationController?&#123;
    return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
&#125;
</code></pre>
<p>在 iOS 7 中，Custom 模式的 Modal 转场里，presentingView 不会被移除，如果我们要移除它并妥善恢复会破坏动画控制器的独立性使得第三方动画控制器无法直接使用；在 iOS 8 中，<code>UIPresentationController</code>解决了这点，给予了我们选择的权力，通过重写下面的方法来决定 presentingView 是否在 presentation 转场结束后被移除：</p>
<pre><code>func shouldRemovePresentersView() -&gt; Bool
</code></pre>
<p>返回 true 时，presentation 结束后 presentingView 被移除，在 dimissal 结束后 UIKit 会自动将 presentingView 恢复到原来的视图结构中。通过<code>UIPresentationController</code>的参与，Custom 模式完全实现了 FullScreen 模式下的全部特性。</p>
<p>你可能会疑惑，除了解决了 iOS 7中无法干涉 presentingView 这个痛点外，还有什么理由值得我们使用<code>UIPresentationController</code>类？除了能与动画控制器配合，<code>UIPresentationController</code>类也能脱离动画控制器独立工作，在转场代理里我们仅仅提供后者也能对 presentedView 的外观进行定制，缺点是无法控制 presentedView 的转场动画，因为这是动画控制器的职责，这种情况下，presentedView 的转场动画采用的是默认的动画效果，转场协调器实现的动画则是采用默认的动画时间。</p>
<p>iOS 8 带来了适应性布局，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526"><code>&lt;UIContentContainer&gt;</code></a>协议用于响应视图尺寸变化和屏幕旋转事件，之前用于处理屏幕旋转的方法都被废弃了。UIViewController 和 UIPresentationController 类都遵守该协议，在 Modal 转场中如果提供了后者，则由后者负责前者的尺寸变化和屏幕旋转，最终的布局机会也在后者里。在<code>OverlayPresentationController</code>中重写以下方法来调整视图布局以及应对屏幕旋转：</p>
<pre><code>override func containerViewWillLayoutSubviews() &#123;
    self.dimmingView.center = self.containerView!.center
    self.dimmingView.bounds = self.containerView!.bounds
    
    let width = self.containerView!.frame.width * 2 / 3, height = self.containerView!.frame.height * 2 / 3
    self.presentedView()?.center = self.containerView!.center
    self.presentedView()?.bounds = CGRect(x: 0, y: 0, width: width, height: height)
&#125;
</code></pre>
<h3 id="Chapter2.4">转场代理</h3>

<p>完成动画控制器后，只需要在转场前设置好转场代理便能实现动画控制器中提供的效果。转场代理的实现很简单，但是在设置代理时有不少陷阱，需要注意。</p>
<h4 id="Chapter2.4.1">UINavigationControllerDelegate</h4>

<p>定制 UINavigationController 这种容器控制器的转场时，很适合实现一个子类，自身集转场代理，动画控制器于一身，也方便使用，不过这样做有时候又限制了它的使用范围，别人也实现了自己的子类时便不能方便使用你的效果，这里采取的是将转场代理封装成一个类。</p>
<pre><code>class SDENavigationControllerDelegate: NSObject, UINavigationControllerDelegate &#123;
    //在&lt;UINavigationControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则使用系统默认的效果。
    func navigationController(navigationController: UINavigationController, 
         animationControllerForOperation operation: UINavigationControllerOperation, 
                         fromViewController fromVC: UIViewController, 
                             toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;
        //使用上一节实现的 Slide 动画控制器，需要提供操作类型信息。
        let transitionType = SDETransitionType.NavigationTransition(operation)
        return SlideAnimationController(type: transitionType)
    &#125;
&#125;
</code></pre>
<p>如果你在代码里为你的控制器里这样设置代理：</p>
<pre><code>//错误的做法，delegate 是弱引用，在离开这行代码所处的方法范围后，delegate 将重新变为 nil，然后什么都不会发生。
self.navigationController?.delegate = SDENavigationControllerDelegate()
</code></pre>
<p>可以使用强引用的变量来引用新实例，且不能使用本地变量，在控制器中新增一个变量来维持新实例就可以了。</p>
<pre><code>self.navigationController?.delegate = strongReferenceDelegate
</code></pre>
<p>解决了弱引用的问题，这行代码应该放在哪里执行呢？很多人喜欢在<code>viewDidLoad()</code>做一些配置工作，但在这里设置无法保证是有效的，因为这时候控制器可能尚未进入 NavigationController 的控制器栈，<code>self.navigationController</code>返回的可能是 nil；如果是通过代码 push 其他控制器，在 push 前设置即可；<code>prepareForSegue:sender:</code>方法是转场前更改设置的最后一次机会，可以在这里设置；保险点，使用<code>UINavigationController</code>子类，自己作为代理，省去到处设置的麻烦。</p>
<p>不过，通过代码设置终究显得很繁琐且不安全，在 storyboard 里设置一劳永逸：在控件库里拖拽一个 NSObject 对象到相关的 UINavigationControler 上，在控制面板里将其类别设置为<code>SDENavigationControllerDelegate</code>，然后拖拽鼠标将其设置为代理。</p>
<p>最后一步，像往常一样触发转场：</p>
<pre><code>self.navigationController?.pushViewController(toVC, animated: true)//or
self.navigationController?.popViewControllerAnimated(true)
</code></pre>
<p>在 storyboard 中通过设置 segue 时开启动画也将看到同样的 Slide 动画。Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/NavigationControllerTransition">NavigationControllerTransition</a>。</p>
<h4 id="Chapter2.4.2">UITabBarControllerDelegate</h4>

<p>同样作为容器控制器，UITabBarController 的转场代理和 UINavigationController 类似，通过类似的方法提供动画控制器，不过<code>&lt;UINavigationControllerDelegate&gt;</code>的代理方法里提供了操作类型，但<code>&lt;UITabBarControllerDelegate&gt;</code>的代理方法没有提供滑动的方向信息，需要我们来获取滑动的方向。</p>
<pre><code>class SDETabBarControllerDelegate: NSObject, UITabBarControllerDelegate &#123;
    //在&lt;UITabBarControllerDelegate&gt;对象里，实现该方法提供动画控制器，返回 nil 则没有动画效果。
    func tabBarController(tabBarController: UITabBarController, animationControllerForTransitionFromViewController 
                                    fromVC: UIViewController, 
                     toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123;
        let fromIndex = tabBarController.viewControllers!.indexOf(fromVC)!
        let toIndex = tabBarController.viewControllers!.indexOf(toVC)!
        
        let tabChangeDirection: TabOperationDirection = toIndex &lt; fromIndex ? .Left : .Right
        let transitionType = SDETransitionType.TabTransition(tabChangeDirection)
        let slideAnimationController = SlideAnimationController(type: transitionType)
        return slideAnimationController
    &#125;
&#125;
</code></pre>
<p>为 UITabBarController 设置代理的方法和陷阱与上面的 UINavigationController 类似，注意<code>delegate</code>属性的弱引用问题。点击 TabBar 的相邻页面进行切换时，将会看到 Slide 动画；通过以下代码触发转场时也将看到同样的效果：</p>
<pre><code>tabBarVC.selectedIndex = ...//or
tabBarVC.selectedViewController = ...
</code></pre>
<p>Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/ScrollTabBarController">ScrollTabBarController</a>。</p>
<h4 id="Chapter2.4.3">UIViewControllerTransitioningDelegate</h4>

<p>Modal 转场的代理协议<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>是 iOS 7 新增的，其为 presentation 和 dismissal 转场分别提供了动画控制器。在「特殊的 Modal 转场」里实现的<code>OverlayAnimationController</code>类可同时处理 presentation 和 dismissal 转场。<code>UIPresentationController</code>只在 iOS 8中可用，通过<code>available</code>关键字可以解决 API 的版本差异。 </p>
<pre><code>class SDEModalTransitionDelegate: NSObject, UIViewControllerTransitioningDelegate &#123;
    func animationControllerForPresentedController(presented: UIViewController, 
                             presentingController presenting: UIViewController, 
                                     sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;
        return OverlayAnimationController()
    &#125;
    
    func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;
        return OverlayAnimationController()
    &#125;
    
    @available(iOS 8.0, *)
    func presentationControllerForPresentedViewController(presented: UIViewController, 
                                presentingViewController presenting: UIViewController, 
                                        sourceViewController source: UIViewController) -&gt; UIPresentationController? &#123;
        return OverlayPresentationController(presentedViewController: presented, presentingViewController: presenting)
    &#125;
&#125;
</code></pre>
<p>Modal 转场的代理由 presentedVC 的<code>transitioningDelegate</code>属性来提供，这与前两种容器控制器的转场不一样，不过该属性作为代理同样是弱引用，记得和前面一样需要有强引用的变量来维护该代理，而 Modal 转场需要 presentedVC 来提供转场代理的特性使得 presentedVC 自身非常适合作为自己的转场代理。另外，需要将 presentedVC 的<code>modalPresentationStyle</code>属性设置为<code>.Custom</code>或<code>.FullScreen</code>，只有这两种模式下才支持自定义转场，该属性默认值为<code>.FullScreen</code>。自定义转场时，决定转场动画效果的<code>modalTransitionStyle</code>属性将被忽略。</p>
<p>开启转场动画的方式依然是两种：在 storyboard 里设置 segue 并开启动画，但这里并不支持<code>.Custom</code>模式，不过还有机会挽救，转场前的最后一个环节<code>prepareForSegue:sender:</code>方法里可以动态修改<code>modalPresentationStyle</code>属性；或者全部在代码里设置，示例如下：</p>
<pre><code>let presentedVC = ...
presentedVC.transitioningDelegate = strongReferenceSDEModalTransitionDelegate
//当与 UIPresentationController 配合时该属性必须为.Custom。
presentedVC.modalPresentationStyle = .Custom/.FullScreen      
presentingVC.presentViewController(presentedVC, animated: true, completion: nil)
</code></pre>
<p>Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomModalTransition">CustomModalTransition</a>。</p>
<h2 id="Chapter3">阶段二：交互式转场</h2>

<p>激动人心的部分来了，好消息是交互转场的实现难度比你想象的要低。</p>
<h3 id="Chapter3.1">实现交互化</h3>

<p>在非交互转场的基础上将之交互化需要两个条件：</p>
<ol>
<li><p>由转场代理提供交互控制器，这是一个遵守<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>协议的对象，不过系统已经打包好了现成的类<code>UIPercentDrivenInteractiveTransition</code>供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。</p>
</li>
<li><p>交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。</p>
</li>
</ol>
<p>满足以上两个条件很简单，但是很容易犯错误。</p>
<p><strong>正确地提供交互控制器</strong>：</p>
<p>如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束，应用界面也会失去响应：在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳；在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。</p>
<p>以为 NavigationController 提供交互控制器为例：</p>
<pre><code>class SDENavigationDelegate: NSObject, UINavigationControllerDelegate &#123;
    var interactive = false
    let interactionController = UIPercentDrivenInteractiveTransition()
    ...
    
    func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController 
                               animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123;
        return interactive ? self.interactionController : nil
    &#125;
&#125;
</code></pre>
<p>TabBarController 的实现类似，Modal 转场代理分别为 presentation 和 dismissal 提供了各自的交互控制器，也需要注意上面的问题。</p>
<p>问题的根源是交互控制的工作机制导致的，交互过程实际上是由转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>来管理的，它提供了如下几个方法来控制转场的进度：</p>
<pre><code>func updateInteractiveTransition(_ percentComplete: CGFloat)//更新转场进度，进度数值范围为0.0~1.0。
func cancelInteractiveTransition()//取消转场，转场动画从当前状态返回至转场发生前的状态。
func finishInteractiveTransition()//完成转场，转场动画从当前状态继续直至结束。
</code></pre>
<p>交互控制协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>只有一个必须实现的方法：</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre>
<p>在转场代理里提供了交互控制器后，转场开始时，该方法自动被 UIKit 调用对转场环境进行配置。</p>
<p>系统打包好的<code>UIPercentDrivenInteractiveTransition</code>中的控制转场进度的方法与转场环境对象提供的三个方法同名，实际上只是前者调用了后者的方法而已。系统以一种解耦的方式使得动画控制器，交互控制器，转场环境对象互相协作，我们只需要使用<code>UIPercentDrivenInteractiveTransition</code>的三个同名方法来控制进度就够了。如果你要实现自己的交互控制器，而不是<code>UIPercentDrivenInteractiveTransition</code>的子类，就需要调用转场环境的三个方法来控制进度，压轴环节我们将示范如何做。</p>
<p>交互控制器控制转场的过程就像将动画控制器实现的动画制作成一部视频，我们使用手势或是其他方法来控制转场动画的播放，可以前进，后退，继续或者停止。<code>finishInteractiveTransition()</code>方法被调用后，转场动画从当前的状态将继续进行直到动画结束，转场完成；<code>cancelInteractiveTransition()</code>被调用后，转场动画从当前的状态回拨到初始状态，转场取消。</p>
<p>在 NavigationController 中点击 NavigationBar 的 backBarButtomItem 执行 pop 操作时，由于我们无法介入 backBarButtomItem 的内部流程，就失去控制进度的手段，于是转场过程只有一个开始，永远不会结束。其实我们只需要有能够执行上述几个方法的手段就可以对转场动画进行控制，用户与屏幕的交互手段里，手势是实现这个控制过程的天然手段，我猜这是其被称为交互控制器的原因。</p>
<p><strong>交互手段的配合</strong>：</p>
<p>下面使用演示如何利用屏幕边缘滑动手势<code>UIScreenEdgePanGestureRecognizer</code>在 NavigationController 中控制 Slide 动画控制器提供的动画来实现右滑返回的效果，该手势绑定的动作方法如下：</p>
<pre><code>func handleEdgePanGesture(gesture: UIScreenEdgePanGestureRecognizer)&#123;
    //根据移动距离计算交互过程的进度。
    let percent = ...
    switch gesture.state&#123;
    case .Began:
        //转场开始前获取代理，一旦转场开始，VC 将脱离控制器栈，此后 self.navigationController 返回的是 nil。
        self.navigationDelegate = self.navigationController?.delegate as? SDENavigationDelegate
        //更新交互状态
        self.navigationDelegate?.interactive = true
        //1.交互控制器没有 start 之类的方法，当下面这行代码执行后，转场开始；
        //如果转场代理提供了交互控制器，它将从这时候开始接管转场过程。
        self.navigationController?.popViewControllerAnimated(true)
    case .Changed:
        //2.更新进度：
        self.navigationDelegate?.interactionController.updateInteractiveTransition(percent)
    case .Cancelled, .Ended:
        //3.结束转场：
        if percent &gt; 0.5&#123;
            //完成转场。
            self.navigationDelegate?.interactionController.finishInteractiveTransition()
        &#125;else&#123;
            //或者，取消转场。
            self.navigationDelegate?.interactionController.cancelInteractiveTransition()
        &#125;
        //无论转场的结果如何，恢复为非交互状态。
        self.navigationDelegate?.interactive = false
    default: self.navigationDelegate?.interactive = false
    &#125;
&#125;
</code></pre>
<p>交互转场的流程就是三处数字标记的代码。不管是什么交互方式，使用什么转场方式，都是在使用这三个方法控制转场的进度。<strong>对于交互式转场，交互手段只是表现形式，本质是驱动转场进程。</strong>很希望能够看到更新颖的交互手法，比如通过点击页面不同区域来控制一套复杂的流程动画。TabBarController 的 Demo 中也实现了滑动切换 Tab 页面，代码是类似的，就不占篇幅了；示范的 Modal 转场我没有为之实现交互控制，原因也提到过了，没有比较合乎操作直觉的交互手段，不过真要为其添加交互控制，代码和上面是类似的。</p>
<p>转场交互化后结果有两种：完成和取消。取消后动画将会原路返回到初始状态，但已经变化了的数据怎么恢复？</p>
<p>一种情况是，控制器的系统属性，比如，在 TabBarController 里使用上面的方法实现滑动切换 Tab 页面，中途取消的话，已经变化的<code>selectedIndex</code>属性该怎么恢复为原值；上面的代码里，取消转场的代码执行后，<code>self.navigationController</code>返回的依然还是是 nil，怎么让控制器回到 NavigationController 的控制器栈顶。对于这种情况，UIKit 自动替我们恢复了，不需要我们操心(可能你都没有意识到这回事)；</p>
<p>另外一种就是，转场发生的过程中，你可能想实现某些效果，一般是在下面的事件中执行，转场中途取消的话可能需要取消这些效果。</p>
<pre><code>func viewWillAppear(_ animated: Bool)
func viewDidAppear(_ animated: Bool)
func viewWillDisappear(_ animated: Bool)
func viewDidDisappear(_ animated: Bool)
</code></pre>
<p>交互转场介入后，视图在这些状态间的转换变得复杂，WWDC 上苹果的工程师还表示转场过程中 view 的<code>Will</code>系方法和<code>Did</code>系方法的执行顺序并不能得到保证，虽然几率很小，但如果你依赖于这些方法执行的顺序的话就可能需要注意这点。而且，<code>Did</code>系方法调用时并不意味着转场过程真的结束了。另外，fromView 和 toView 之间的这几种方法的相对顺序更加混乱，具体的案例可以参考这里：<a target="_blank" rel="noopener" href="http://wangling.me/2014/02/the-inconsistent-order-of-view-transition-events.html">The Inconsistent Order of View Transition Events</a>。</p>
<p>如何在转场过程中的任意阶段中断时取消不需要的效果？这时候该转场协调器(Transition Coordinator)再次出场了。</p>
<h3 id="Chapter3.2">Transition Coordinator</h3>

<p>转场协调器(Transition Coordinator)的出场机会不多，但却是关键先生。Modal<br>转场中，<code>UIPresentationController</code>类只能通过转场协调器来与动画控制器同步，并行执行其他动画；这里它可以在交互式转场结束时执行一个闭包：</p>
<pre><code>func notifyWhenInteractionEndsUsingBlock(_ handler: (UIViewControllerTransitionCoordinatorContext) -&gt; Void)
</code></pre>
<p>当转场由交互状态转变为非交互状态(在手势交互过程中则为手势结束时)，无论转场的结果是完成还是被取消，该方法都会被调用；得益于闭包，转场协调器可以在转场过程中的任意阶段搜集动作并在交互中止后执行。闭包中的参数是一个遵守<code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code>协议的对象，该对象由 UIKit 提供，和前面的转场环境对象<code>&lt;UIViewControllerContextTransitioning&gt;</code>作用类似，它提供了交互转场的状态信息。</p>
<pre><code>override func viewWillAppear(animated: Bool) &#123;
    super.viewWillDisappear(animated)
    self.doSomeSideEffectsAssumingViewDidAppearIsGoingToBeCalled()
    //只在处于交互转场过程中才可能取消效果。
    if let coordinator = self.transitionCoordinator() where coordinator.initiallyInteractive() == true&#123;
        coordinator.notifyWhenInteractionEndsUsingBlock(&#123;
            interactionContext in
            if interactionContext.isCancelled()&#123;
                self.undoSideEffects()
            &#125;
        &#125;)
    &#125;
&#125;
</code></pre>
<p>不过交互状态结束时并非转场过程的终点(此后动画控制器提供的转场动画根据交互结束时的状态继续或是返回到初始状态)，而是由动画控制器来结束这一切：</p>
<pre><code>optional func animationEnded(_ transitionCompleted: Bool)
</code></pre>
<p>如果实现了该方法，将在转场动画结束后调用。</p>
<p>UIViewController 可以通过<code>transitionCoordinator()</code>获取转场协调器，该方法的文档中说只有在 Modal 转场过程中，该方法才返回一个与当前转场相关的有效对象。实际上，NavigationController 的转场中 fromVC 和 toVC 也能返回一个有效对象，TabBarController 有点特殊，fromVC 和 toVC 在转场中返回的是 nil，但是作为容器的 TabBarController 可以使用该方法返回一个有效对象。</p>
<p>转场协调器除了上面的两种关键作用外，也在 iOS 8 中的适应性布局中担任重要角色，可以查看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIContentContainer_Ref/index.html#//apple_ref/doc/uid/TP40014526"><code>&lt;UIContentContainer&gt;</code></a>协议中的方法，其中响应尺寸和屏幕旋转事件的方法都包含一个转场协调器对象，视图的这种变化也被系统视为广义上的 transition，参数中的转场协调器也由 UIKit 提供。这个话题有点超出本文的范围，就不深入了，有需要的话可以查看文档和相关 session。</p>
<h3 id="Chapter3.3">封装交互控制器</h3>

<p><code>UIPercentDrivenInteractiveTransition</code>类是一个系统提供的交互控制器，在转场代理的相关方法里提供一个该类实例就够了，还有其他需求的话可以实现其子类来完成，那这里的封装是指什么？系统把交互控制器打包好了，但是交互控制器工作还需要其他的配置。程序员向来很懒，能够自动完成的事绝不肯写一行代码，写一行代码就能搞定的事绝不写第二行，所谓少写一行是一行。能不能顺便把交互控制器的配置也打包好省得写代码啊？当然可以。</p>
<p>热门转场动画库 <a target="_blank" rel="noopener" href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller">VCTransitionsLibrary</a> 封装好了多种动画效果，并且自动支持 pop, dismissal 和 tab change 等操作的手势交互，其手法是在转场代理里为 toVC 添加手势并绑定相应的处理方法。</p>
<p>为何没有支持 push 和 presentation 这两种转场？因为 push 和 presentation 这两种转场需要提供 toVC，而库并没有 toVC 的信息，这需要作为使用者的开发者来提供；对于逆操作的 pop 和 dismiss，toVC 的信息已经存在了，所以能够实现自动支持。而 TabBarController 则是个例外，它是在已知的子 VC 之间切换，不存在这个问题。需要注意的是，库这样封装了交互控制器后，那么你将无法再让同一种手势支持 push 或 presentation，要么只支持单向的转场，要么你自己实现双向的转场。当然，如果知道 toVC 是什么类的话，你可以改写这个库让 push 和 present 得到支持。不过，对于在初始化时需要配置额外信息的类，这种简单的封装可能不起作用。<a target="_blank" rel="noopener" href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller">VCTransitionsLibrary</a> 库还支持添加自定义的简化版的动画控制器和交互控制器，在封装和灵活之间的平衡控制得很好，代码非常值得学习。</p>
<p>只要愿意，我们还可以变得更懒，不，是效率更高。<a target="_blank" rel="noopener" href="https://github.com/forkingdog/FDFullscreenPopGesture.git">FDFullscreenPopGesture</a> 通过 category 的方法让所有的 UINavigationController 都支持右滑返回，而且，一行代码都不用写，这是配套的博客：<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/">一个丝滑的全屏滑动返回手势</a>。那么也可以实现一个类似的 FullScreenTabScrollGesture 让所有的 UITabBarController 都支持滑动切换，不过，UITabBar 上的 icon 渐变动画有点麻烦，因为其中的 UITabBarItem 并非 UIView 子类，无法进行动画。<a target="_blank" rel="noopener" href="https://github.com/leichunfeng/WXTabBarController.git">WXTabBarController</a> 这个项目完整地实现了微信界面的滑动交互以及 TabBar 的渐变动画。不过，它的滑动交互并不是使用转场的方式完成的，而是使用 UIScrollView，好处是兼容性更好。兼容性这方面国内的环境比较差，iOS 9 都出来了，可能还需要兼容 iOS 6，而自定义转场需要至少 iOS 7 的系统。该项目实现的 TabBar 渐变动画是基于 TabBar 的内部结构实时更新相关视图的 alpha 值来实现的(不是UIView 动画），这点非常难得，而且使用 UIScrollView 还可以实现自动控制 TabBar 渐变动画，相比之下，使用转场的方式来实现这个效果会麻烦一点。</p>
<p>一个较好的转场方式需要顾及更多方面的细节，NavigationController 的 NavigationBar 和 TabBarController 的 TabBar 这两者在先天上有着诸多不足需要花费更多的精力去完善，本文就不在这方面深入了，上面提及的几个开源项目都做得比较好，推荐学习。</p>
<h3 id="Chapter3.4">交互转场的限制</h3>

<p>如果希望转场中的动画能完美地被交互控制，必须满足2个隐性条件：</p>
<ol>
<li>使用 UIView 动画的 API。你当然也可以使用 Core Animation 来实现动画，甚至，这种动画可以被交互控制，但是当交互中止时，会出现一些意外情况：如果你正确地用 Core Animation 的方式复现了 UIView 动画的效果(不仅仅是动画，还包括动画结束后的处理)，那么手势结束后，动画将直接跳转到最终状态；而更多的一种状况是，你并没有正确地复现 UIView 动画的效果，手势结束后动画会停留在手势中止时的状态，界面失去响应。所以，如果你需要完美的交互转场动画，必须使用 UIView 动画。</li>
<li>在动画控制器的<code>animateTransition:</code>中提交动画。问题和第1点类似，在<code>viewWillDisappear:</code>这样的方法中提交的动画也能被交互控制，但交互停止时，立即跳转到最终状态。</li>
</ol>
<p>如果你希望制作多阶段动画，在某个动画结束后再执行另外一段动画，可以通过 UIView Block Animation 的 completion 闭包来实现动画链，或者是通过设定动画执行的延迟时间使得不同动画错分开来，但是交互转场不支持这两种形式。UIView 的 keyFrame Animation API 可以帮助你，通过在动画过程的不同时间节点添加关键帧动画就可以实现多阶段动画。我实现过一个这样的多阶段转场动画，Demo 在此：<a target="_blank" rel="noopener" href="https://github.com/seedante/SDECollectionViewAlbumTransition.git">CollectionViewAlbumTransition</a>。</p>
<h2 id="Chapter4">插曲：UICollectionViewController 布局转场</h2>

<p>前面一直没有提到这种转场方式，与三大主流转场不同，布局转场只针对 CollectionViewController 搭配 NavigationController 的组合，且是作用于布局，而非视图。采用这种布局转场时，NavigationController 将会用布局变化的动画来替代 push 和 pop 的默认动画。苹果自家的照片应用中的「照片」Tab 页面使用了这个技术：在「年度-精选-时刻」几个时间模式间切换时，CollectionViewController 在 push 或 pop 时尽力维持在同一个元素的位置同时进行布局转换。</p>
<p>布局转场的实现比三大主流转场要简单得多，只需要满足四个条件：NavigationController + CollectionViewController, 且要求后者都拥有相同数据源， 并且开启<code>useLayoutToLayoutNavigationTransitions</code>属性为真。</p>
<pre><code>let cvc0 = UICollectionViewController(collectionViewLayout: layout0)
//作为 root VC 的 cvc0 的该属性必须为 false，该属性默认为 false。
cvc0.useLayoutToLayoutNavigationTransitions = false
let nav = UINavigationController(rootViewController: cvc0)
//cvc0, cvc1, cvc2 必须具有相同的数据，如果在某个时刻修改了其中的一个数据源，其他的数据源必须同步，不然会出错。
let cvc1 = UICollectionViewController(collectionViewLayout: layout1)
cvc1.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc1, animated: true)

let cvc2 = UICollectionViewController(collectionViewLayout: layout2)
cvc2.useLayoutToLayoutNavigationTransitions = true
nav.pushViewController(cvc2, animated: true)

nav.popViewControllerAnimated(true)
nav.popViewControllerAnimated(true)
</code></pre>
<p>Push 进入控制器栈后，不能更改<code>useLayoutToLayoutNavigationTransitions</code>的值，否则应用会崩溃。当 CollectionView 的数据源(section 和 cell 的数量)不完全一致时，push 和 pop 时依然会有布局转场动画，但是当 pop 回到 rootVC 时，应用会崩溃。可否共享数据源保持同步来克服这个缺点？测试表明，这样做可能会造成画面上的残缺，以及不稳定，建议不要这么做。</p>
<p>此外，iOS 7 支持 UICollectionView 布局的交互转换(Layout Interactive Transition)，过程与控制器的交互转场(ViewController Interactive Transition)类似，这个功能和布局转场(CollectionViewController Layout Transition)容易混淆，前者是在自身布局转换的基础上实现了交互控制，后者是 CollectionViewController 与 NavigationController 结合后在转场的同时进行布局转换。感兴趣的话可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/index.html#//apple_ref/occ/instm/UICollectionView/startInteractiveTransitionToCollectionViewLayout:completion:">这个功能的文档</a>。</p>
<p>布局转场不支持交互控制。Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CollectionViewControllerLayoutTransition">CollectionViewControllerLayoutTransition</a>。</p>
<h2 id="Chapter5">进阶</h2>

<p>是否觉得本文中实现的例子的动画效果太过简单？的确很简单，与 <a target="_blank" rel="noopener" href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller">VCTransitionsLibrary</a> 这样的转场动画库提供的十种动画效果相比是很简单的，不过就动画而言，与本文示例的本质是一样的，它们都是针对 fromView 和 toView 的整体进行的动画，但在效果上更加复杂。我在本文中多次强调转场动画的本质是是对即将消失的当前视图和即将出现的下一屏幕的内容进行动画，「在动画控制器里，参与转场的视图只有 fromView 和 toView 之分，与转场方式无关。转场动画的最终效果只限制于你的想象力」，当然，还有你的实现能力。</p>
<p>本文前面的目的是帮助你熟悉转场的整个过程，你也看到了，转场动画里转场部分的实现其实很简单，大部分复杂的转场动画与本文范例里简单的转场动画相比，复杂的部分在动画部分，转场的部分都是一样的。因此，学习了前面的内容后并不能帮助你立马就能够实现 Github 上那些热门的转场动画，它们成为热门的原因在于动画本身，与转场本身关系不大，但它们与转场结合后就有了神奇的力量。那学习了作为进阶的本章能立马实现那些热门的转场效果吗？有可能，有些效果其实很简单，一点就透，还有一些效果涉及的技术属于本文主题之外的内容，我会给出相关的提示就不深入了。</p>
<p>本章的进阶分为两个部分：</p>
<ol>
<li>案例分析：动画的方式非常多，有些并不常见，有些只是简单到令人惊讶的组合，只是你不曾了解过所以不知道如何实现，一旦了解了就不再是难事。尽管这些动画本身并不属于转场技术这个主题，但与转场动画组合后往往有着惊艳的视觉效果，这部分将提供一些实现此类转场动画的思路，技巧和工具来扩展视野。有很多动画类型我也没有尝试过，可能的话我会继续更新一些有意思的案例。</li>
<li>自定义容器转场：官方支持四种方式的转场，而且这些也足以应付绝大多数需求了，但依然有些地方无法顾及。本文一直通过探索转场的边界的方式来总结使用方法以及陷阱，在本文的压轴部分，我们将挣脱系统的束缚来实现自定义容器控制器的转场效果。</li>
</ol>
<h3 id="Chapter5.1">案例分析</h3>

<p>动画的持续时间一般不超过0.5秒，稍纵即逝，有时候看到一个复杂的转场动画也不容易知道实现的方式，我一般是通过逐帧解析的手法来分析实现的手段：开源的就运行一下，使用系统自带的 QuickPlayer 对 iOS 设备进行录屏，再使用 QuickPlayer 打开视频，按下 cmd+T 打开剪辑功能，这时候就能查看每一帧了；Gif 等格式的原型动画的动图就直接使用系统自带的 Preview 打开看中间帧。</p>
<p><strong>子元素动画</strong></p>
<p>当转场动画涉及视图中的子视图时，往往无法依赖第三方的动画库来实现，你必须为这种效果单独定制，神奇移动就是一个典型的例子。神奇移动是 Keynote 中的一个动画效果，如果某个元素在连续的两页 Keynote 同时存在，在页面切换时，该元素从上一页的位置移动到下一页的位置，非常神奇。在转场中怎么实现这个效果呢？最简单的方法是截图配合移动动画：伪造那个元素的视图添加到 containerView 中，从 fromView 中的位置移动到 toView 中的位置，这期间 fromView 和 toView 中的该元素视图隐藏，等到移动结束恢复 toView 中该元素的显示，并将伪造的元素视图从 containerView 中移除。</p>
<p>UIView 有几个<code>convert</code>方法用于在不同的视图之间转换坐标：</p>
<pre><code>func convertPoint(_ point: CGPoint, toView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
func convertPoint(_ point: CGPoint, fromView view: UIView?) -&gt; CGPoint
</code></pre>
<p>对截图这个需求，iOS 7 提供了趁手的工具，UIView Snapshot API：</p>
<pre><code>func snapshotViewAfterScreenUpdates(_ afterUpdates: Bool) -&gt; UIView
//获取视图的部分内容
func resizableSnapshotViewFromRect(_ rect: CGRect, afterScreenUpdates afterUpdates: Bool, withCapInsets capInsets: UIEdgeInsets) -&gt; UIView
</code></pre>
<p>当<code>afterScreenUpdates</code>参数值为<code>true</code>时，这两个方法能够强制视图立刻更新内容，同时返回更新后的视图内容。在 push 或 presentation 中，如果 toVC 是 CollectionViewController 并且需要对 visibleCells 进行动画，此时动画控制器里是无法获取到的，因为此时 collectionView 还未向数据源询问内容，执行此方法后能够达成目的。UIView 的<code>layoutIfNeeded()</code>也能要求立即刷新布局达到同样的效果。</p>
<p><strong>Mask 动画</strong></p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/MaskAnimtion.gif?raw=true" alt="MaskAnimtion"></p>
<p>左边的动画教程：<a target="_blank" rel="noopener" href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app">How To Make A View Controller Transition Animation Like in the Ping App</a>；右边动画的开源地址：<a target="_blank" rel="noopener" href="https://github.com/andreamazz/BubbleTransition.git">BubbleTransition</a>。</p>
<p>Mask 动画往往在视觉上令人印象深刻，这种动画通过使用一种特定形状的图形作为 mask 截取当前视图内容，使得当前视图只表现出 mask 图形部分的内容，在 PS 界俗称「遮罩」。UIView 有个属性<code>maskView</code>可以用来遮挡部分内容，但这里的效果并不是对<code>maskView</code>的利用；CALayer 有个对应的属性<code>mask</code>，而 CAShapeLayer 这个子类搭配 UIBezierPath 类可以实现各种不规则图形。这种动画一般就是 mask + CAShapeLayer + UIBezierPath 的组合拳搞定的，实际上实现这种圆形的形变是很简单的，只要发挥你的想象力，可以实现任何形状的形变动画。</p>
<p>这类转场动画在转场过程中对 toView 使用 mask 动画，不过，右边的这个动画实际上并不是上面的组合来完成的，它的真相是这样：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Truth%20behind%20BubbleTransition.gif?raw=true" alt="Truth behind BubbleTransition"></p>
<p>这个开发者实在是太天才了，这个手法本身就是对 mask 概念的应用，效果卓越，但方法却简单到难以置信。关于使用 mask + CAShapeLayer + UIBezierPath 这种方法实现 mask 动画的方法请看我的<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/3c925a1609f8">这篇文章</a>。</p>
<p><strong>高性能动画框架</strong></p>
<p>有些动画使用 UIView 的动画 API 难以实现，或者难以达到较好的性能，又或者两者皆有，幸好我们还有其他选择。<a target="_blank" rel="noopener" href="https://yalantis.com/blog/uidynamics-uikit-or-opengl-3-types-of-ios-animations-for-the-star-wars/">StartWar</a> 使用更底层的 OpenGL 框架来解决性能问题以及 Objc.io 在探讨转场这个话题时<a target="_blank" rel="noopener" href="http://objccn.io/issue-5-3/">使用 GPUImage 定制动画</a>都是这类的典范。在交互控制器章节中提到过，官方只能对 UIView 动画 API 实现的转场动画实施完美的交互控制，这也不是绝对的，接下来我们就来挑战这个难题。</p>
<h3 id="Chapter5.2">自定义容器控制器转场</h3>

<p>压轴环节我们将实现这样一个效果：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/CustomContainerVCButtonTransition.gif?raw=true" alt="ButtonTransition"><br><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/ContainerVCTransition.mov.gif?raw=true" alt="ContainerVC Interacitve Transition"></p>
<p>Demo 地址：<a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-ViewController-Transition-Demo/tree/master/CustomContainerVCTransition">CustomContainerVCTransition</a>。</p>
<p>分析一下思路，这个控制器和 UITabBarController 在行为上比较相似，只是 TabBar 由下面跑到了上面。我们可以使用 UITabBarController 子类，然后打造一个伪 TabBar 放在顶部，原来的 TabBar 则隐藏，行为上完全一致，使用 UITabBarController 子类的好处是可以减轻实现转场的负担，不过，有时候这样的子类不是你想要的，UIViewController 子类能够提供更多的自由度，好吧，一个完全模仿 UITabBarController 行为的 UIViewController 子类，实际上我没有想到非得这样做的原因，但我想肯定有需要定制自己的容器控制器的场景，这正是本节要探讨的。Objc.io 也讨论过<a target="_blank" rel="noopener" href="http://objccn.io/issue-12-3/">这个话题</a>，文章的末尾把实现交互控制当做作业留了下来。珠玉在前，我就站在大牛的肩上继续这个话题吧。Objc.io 的这篇文章写得较早使用了 Objective-C 语言，如果要读者先去读这篇文章再继续读本节的内容，难免割裂，所以本节还是从头讨论这个话题吧，最终效果如上面所示，在自定义的容器控制器中实现交互控制切换子视图，也可以通过填充了 UIButton 的 ButtonTabBar 来实现 TabBar 一样行为的 Tab 切换，在通过手势切换页面时 ButtonTabBar 会实现渐变色动画。ButtonTabBar 有很大扩展性，改造或是替换为其他视图还是有很多应用场景的。</p>
<h4 id="Chapter5.2.1">实现分析</h4>

<p>既然这个自定义容器控制器和 UITabBarController 行为类似，我便实现了一套类似的 API：<code>viewControllers</code>数组是容器 VC 维护的子 VC 数组，初始化时提供要显示的子 VC，更改<code>selectedIndex</code>的值便可跳转到对应的子视图。利用 Swift 的属性观察器实现修改<code>selectedIndex</code>时自动执行子控制器转场。下面是实现子 VC 转场的核心代码，转场结束后遵循系统的惯例将 fromView 移除：</p>
<pre><code>class SDEContainerViewController: UIViewController&#123;
    ...
    //发生转场的容器视图，是 root view 的子视图。
    private let privateContainerView = UIView()
    var selectedIndex: Int = NSNotFound&#123;
        willSet&#123;
            transitionViewControllerFromIndex(selectedIndex, toIndex: newValue)
        &#125;
    &#125;
    //实现 selectedVC 转场：
    private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123;
        //添加 toVC 和 toView
        let newSelectedVC = viewControllers![toIndex]
        self.addChildViewController(newSelectedVC)
        self.privateContainerView.addSubview(newSelectedVC.view)
        newSelectedVC.didMoveToParentViewController(self)
    
        UIView.animateWithDuration(transitionDuration, animations: &#123;
            /*转场动画*/
            &#125;, completion: &#123; finished in
                //移除 fromVC 和 fromView。
                let priorSelectedVC = viewControllers![fromIndex]
                priorSelectedVC.willMoveToParentViewController(nil)
                priorSelectedVC.view.removeFromSuperview()
                priorSelectedVC.removeFromParentViewController()
        &#125;)
    &#125;
&#125;
</code></pre>
<p>实现转场就是这么十几行代码而已，其他容器 VC 转场过程做了类似的事情。回忆下我们在动画控制器里做的事情，实际上只是上面代码中的一部分。转场协议这套 API 将这个过程分割为五个组件，这套复杂的结构带来了可高度自定义的动画效果和交互控制。我们温习下转场协议，来看看如何在既有的转场协议框架下实现自定义容器控制器的转场动画以及交互控制：</p>
<ol>
<li>转场代理：既有的转场代理协议并没有直接支持我们这种转场方式，没关系，我们自定义一套代理协议来提供动画控制器和交互控制器；</li>
<li>动画控制器：动画控制器是可复用的，这里采用动画控制器章节封装的 Slide 动画控制器，可以拿来直接使用而不用修改；</li>
<li>交互控制器：官方封装了一个现成的交互控制器类，但这个类是与 UIKit 提供的转场环境对象配合使用的，而这里的转场显然需要我们来提供转场环境对象，因此<code>UIPercentDrivenInteractiveTransition</code>无法在这里使用，需要我们来实现这个协议；</li>
<li>转场环境：在官方支持的转场方式中，转场环境是由 UIKit 主动提供给我们的，既然现在的转场方式不是官方支持的，显然需要我们自己提供这个对象以供动画控制器和交互控制器使用；</li>
<li>转场协调器：在前面的章节中我提到过，转场协调器(Transition Coordinator)的使用场景有限而关键，也是由系统提供，我们也可以重写相关方法来提供。这个部分我留给读者当作是本文的一道作业吧。</li>
</ol>
<p>下面我们来将上面的十几行代码(不包括实际的动画代码)使用协议封装成本文前半部分里熟悉的样子。</p>
<h4 id="Chapter5.2.2">协议补完</h4>

<p>模仿 UITabBarControllerDelegate 协议的 ContainerViewControllerDelegate 协议：</p>
<pre><code>//在 Swift 协议中声明可选方法必须在协议声明前添加 @objc 修饰符。
@objc protocol ContainerViewControllerDelegate&#123;
    func containerController(containerController: SDEContainerViewController, animationControllerForTransitionFromViewController 
                                          fromVC: UIViewController, 
                           toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?
    optional func containerController(containerController: SDEContainerViewController, interactionControllerForAnimation 
                                      animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?
&#125;
</code></pre>
<p>在容器控制器<code>SDEContainerViewController</code>类中，添加转场代理属性：</p>
<pre><code>weak var containerTransitionDelegate: ContainerViewControllerDelegate?
</code></pre>
<p>代理的定位就是提供动画控制器和交互控制器，系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了转场环境对象的对应方法而已，执行<code>navigationController.pushViewController(toVC, animated: true)</code>这类语句触发转场后 UIKit 就接管了剩下的事情，再综合文档的描述，可知转场环境便是实现这一切的核心。</p>
<p>在文章前面的部分里转场环境对象的作用只是提供涉及转场过程的信息和状态，现在需要我们实现该协议，并且实现隐藏的那部分职责。<br><code>&lt;UIViewControllerContextTransitioning&gt;</code>协议里的绝大部分方法都是必须实现的，不过现在我们先实现非交互转场的部分，实现这个是很简单的，主要是调用动画控制器执行转场动画。在「实现分析」一节里我们看到实现转场的代码只有十几行而已，动画控制器需要做的只是处理视图和动画的部分，转场环境对象则要负责管理子 VC，通过<code>SDEContainerViewController</code>提供 containerView 以及 fromVC 和 toVC，实现并不是难事。显然由我们实现的自定义容器 VC 来提供转场环境对象是最合适的，并且转场环境对象应该是私有的，其初始化方法极其启动转场的方法如下：</p>
<pre><code>class ContainerTransitionContext: NSObject, UIViewControllerContextTransitioning&#123;
    init(containerViewController: SDEContainerViewController, 
                   containerView: UIView, 
       fromViewController fromVC: UIViewController, 
           toViewController toVC: UIViewController)&#123;...&#125;
           
    //非协议方法，是启动非交互式转场的便捷方法。
    func startNonInteractiveTransitionWith(delegate: ContainerViewControllerDelegate)&#123;
        //转场开始前添加 toVC，转场动画结束后会调用 completeTransition: 方法，在该方法里完成后续的操作。
        self.privateContainerViewController.addChildViewController(privateToViewController)
        //通过 ContainerViewControllerDelegate 协议定义的方法生成动画控制器，方法名太长了略去。
        self.privateAnimationController = delegate.XXXmethod
        //启动转场并执行动画。
        self.privateAnimationController.animateTransition(self)
    &#125;
    //协议方法，动画控制器在动画结束后调用该方法，完成管理子 VC 的后续操作，并且考虑交互式转场可能取消的情况撤销添加的子 VC。
    func completeTransition(didComplete: Bool) &#123;
        if didComplete&#123;
            //转场完成，完成添加 toVC 的工作，并且移除 fromVC 和 fromView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateFromViewController.willMoveToParentViewController(nil)
            self.privateFromViewController.view.removeFromSuperview()
            self.privateFromViewController.removeFromParentViewController()
        &#125;else&#123;
            //转场取消，移除 toVC 和 toView。
            self.privateToViewController.didMoveToParentViewController(privateContainerViewController)
            self.privateToViewController.willMoveToParentViewController(nil)
            self.privateToViewController.view.removeFromSuperview()
            self.privateToViewController.removeFromParentViewController()
        &#125;
        //非协议方法，处理收尾工作：如果动画控制器实现了 animationEnded: 方法则执行；如果转场取消了则恢复数据。
        self.transitionEnd()
    &#125;
&#125;
</code></pre>
<p>在<code>SDEContainerViewController</code>类中，添加转场环境属性：</p>
<pre><code>private var containerTransitionContext: ContainerTransitionContext?
</code></pre>
<p>并修改<code>transitionViewControllerFromIndex:toIndex</code>方法实现自定义容器 VC 转场动画：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123;
    if self.containerTransitionDelegate != nil&#123;
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
    &#125;else&#123;/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/&#125;
&#125;
</code></pre>
<p>这样我们就利用协议实现了自定义容器控制器的转场动画，可以使用第三方的动画控制器来实现不同的效果。</p>
<p>不过要注意这几个对象之间错综复杂的引用关系避免引用循环，关系图如下：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition.png?raw=true" alt="Reference in Transition"></p>
<h4 id="Chapter5.2.3">交互控制</h4>

<p>交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>仅仅要求实现一个必须的方法:</p>
<pre><code>func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)
</code></pre>
<p>根据文档的描述，该方法用于配置以及启动交互转场。我们前面使用的<code>UIPercentDrivenInteractiveTransition</code>类提供的更新进度的方法只是调用了转场环境对象的相关方法。所以，是转场环境对象替交互控制器把脏活累活干了，我们的实现还是维持这种关系好了。正如前面说的，「交互手段只是表现形式，本质是驱动转场进程」，让我们回到转场环境对象里实现对动画进度的控制吧。</p>
<p>怎么控制动画的进度？这个问题的本质是怎么实现对 UIView 的 <code>animateWithDuration:animations:completion:</code>这类方法生成的动画的控制。能够控制吗？能。</p>
<h5 id="Chapter5.2.3.1">动画控制和 CAMediaTiming 协议</h5>

<p>这个协议定义了一套时间系统，是控制动画进度的关键。UIView Animation 是使用 Core Animation 框架实现的，也就是使用 UIView 的 CALayer 对象实现的动画，而 CALayer 对象遵守该协议。</p>
<p>在交互控制器的小节里我打了一个比方，交互控制器就像一个视频播放器一样控制着转场动画这个视频的进度。依靠 CAMediaTiming 这套协议，我们可以在 CALayer 对象上对添加的动画实现控制。官方的实现很有可能也是采用了同样的手法。CAMediaTiming 协议中有以下几个属性：</p>
<pre><code>//speed 作用类似于播放器上控制加速/减速播放，默认为1，以正常速度播放动画，为0时，动画将暂停。
var speed: Float 
//修改 timeOffset 类似于拖动进度条，对一个2秒的动画，该属性为1的话，动画将跳到中间的部分。
//但当动画从中间播放到预定的末尾时，会续上0秒到1秒的动画部分。
var timeOffset: CFTimeInterval
//动画相对于父 layer 延迟开始的时间，这是一个实际作用比字面意义复杂的属性。 
var beginTime: CFTimeInterval  
</code></pre>
<p>Core Animation 的文档中提供了如何暂停和恢复动画的示例：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/qa/qa1673/_index.html">How to pause the animation of a layer tree</a>。我们将之利用实现对进度的控制，这种方法对其中的子视图上添加的动画也能够实现控制，这正是我们需要的。假设在 containerView 中的 toView 上执行一个简单的沿着 X 轴方向移动 100 单位的位移动画，由<code>executeAnimation()</code>方法执行。下面是使用手势控制该动画进度的核心代码：</p>
<pre><code>func handlePan(gesture: UIPanGestureRecognizer)&#123;
    switch gesture.state&#123;
    case .Began:
        //开始动画前将 speed 设为0，然后执行动画，动画将停留在开始的时候。
        containerView.layer.speed = 0
        //在transitionContext里，这里替换为 animator.animateTransition(transitionContext)。
        executeAnimation() 
    case .Changed:
        let percent = ...
        //此时 speed 依然为0，调整 timeOffset 可以直接调整动画的整体进度，这里的进度控制以时间计算，而不是比例。
        containerView.layer.timeOffset = percent * duration
    case .Ended, .Cancelled:
        if progress &gt; 0.5&#123;
            //恢复动画的运行不能简单地仅仅将 speed 恢复为1，这是一套比较复杂的机制。
            let pausedTime = view.layer.timeOffset
            containerView.layer.speed = 1.0 
            containerView.layer.timeOffset = 0.0
            containerView.layer.beginTime = 0.0
            let timeSincePause = view.layer.convertTime(CACurrentMediaTime(), fromLayer: nil) - pausedTime
            containerView.layer.beginTime = timeSincePause
        &#125;else&#123;/*逆转动画*/&#125;
        default:break
    &#125;
&#125;
</code></pre>
<h5 id="Chapter5.2.3.2">取消转场</h5>

<p>交互控制动画时有可能被取消，这往往带来两个问题：恢复数据和逆转动画。</p>
<p>这里需要恢复的数据是<code>selectedIndex</code>，我们在交互转场开始前备份当前的<code>selectedIndex</code>，如果转场取消了就使用这个备份数据恢复。逆转动画反而看起来比较难以解决。</p>
<p>在上面的 pan 手势处理方法中，我们如何逆转动画的运行呢？既然<code>speed</code>为0时动画静止不动，调整为负数是否可以实现逆播放呢？不能，效果是视图消失不见。不过我们还可以调整<code>timeOffset</code>属性，从当前值一直恢复到0。问题是如何产生动画的效果？动画的本质是视图属性在某段时间内的连续变化，当然这个连续变化并不是绝对的连续，只要时间间隔够短，变化的效果就会流畅得看上去是连续变化，在这里让这个变化频率和屏幕的刷新同步即可，<code>CADisplayLink</code>可以帮助我们实现这点，它可以在屏幕刷新时的每一帧执行绑定的方法：</p>
<pre><code>//在上面的/*逆转动画*/处添加以下两行代码：
let displayLink = CADisplayLink(target: self, selector: &quot;reverseAnimation:&quot;)
displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)

func reverseAnimation(displayLink: CADisplayLink)&#123;
    //displayLink.duration表示每一帧的持续时间，屏幕的刷新频率为60，duration = 1/60。
    //这行代码计算的是，屏幕刷新一帧后，timeOffset 应该回退一帧的时间。
    let timeOffset = view.layer.timeOffset - displayLink.duration
    if timeOffset &gt; 0&#123;
        containerView.layer.timeOffset = timeOffset
    &#125;else&#123;
        //让 displayLink 失效，停止对当前方法的调用。
        displayLink.invalidate()
        //回到最初的状态。
        containerView.layer.timeOffset = 0
        //speed 恢复为1后，视图立刻跳转到动画的最终状态。
        containerView.layer.speed = 1
    &#125;
&#125;
</code></pre>
<p>最后一句代码会令人疑惑，为何让视图恢复为最终状态，与我们的初衷相悖。<code>speed</code>必须恢复为1，不然后续发起的转场动画无法顺利执行，视图也无法响应触摸事件，直接原因未知。但<code>speed</code>恢复为1后会出现一个问题：由于在原来的动画里 fromView 最终会被移出屏幕，尽管 Slide 动画控制器 UIView 动画里的 completion handle 里会恢复 fromView 和 toView 的状态，这种状态的突变会造成闪屏现象。怎么解决？添加一个假的 fromView 到 containerView替代已经被移出屏幕外的真正的 fromView，然后在很短的时间间隔后将之移除，因为此时 fromView 已经归位。在恢复<code>speed</code>后添加以下代码：</p>
<pre><code>let fakeFromView = privateFromViewController.view.snapshotViewAfterScreenUpdates(false)
containerView.addSubview(fakeFromView)
performSelector(&quot;removeFakeFromView:&quot;, withObject: fakeFromView, afterDelay: 1/60)
//在 Swift 中动态调用私有方法会出现无法识别的选择器错误，解决办法是将私有方法设置为与 objc 兼容，需要添加 @objc 修饰符。
@objc private func removeFakeFromView(fakeView: UIView)&#123;
    fakeView.removeFromSuperview()
&#125;
</code></pre>
<p>经过试验，上面用来控制和取消 UIView 动画的方法也适用于用 Core Animation 实现的动画，毕竟 UIView 动画是用 Core Animation 实现的。不过，我们在前面提到过，官方对 Core Animation 实现的交互转场动画的支持有缺陷，估计官方鼓励使用更高级的接口吧，因为转场动画结束后需要调用<code>transitionContext.completeTransition(!isCancelled)</code>，而使用 Core Animation 完成这一步需要进行恰当的配置，实现的途径有两种且实现并不简单，相比之下 UIView 动画使用 completion block 对此进行了封装，使用非常方便。转场协议的结构已经比较复杂了，选择 UIView 动画能够显著降低实现成本。</p>
<p>上面的实现忽略了一个细节：时间曲线。逆转动画时每一帧都回退相同的时间，也就是说，逆转动画的时间曲线是线性的。交互控制器的协议<code>&lt;UIViewControllerInteractiveTransitioning&gt;</code>还有两个可选方法：</p>
<pre><code>optional func completionCurve() -&gt; UIViewAnimationCurve
optional func completionSpeed() -&gt; CGFloat
</code></pre>
<p>这两个方法记录了动画采用的动画曲线和速度，在逆转动画时如果能够根据这两者计算出当前帧应该回退的时间，那么就能实现完美的逆转，显然这是一个数学问题。恩，我们跳过这个细节吧，因为我数学不好，讨论这个问题很吃力。推荐阅读 Objc.io 的<a target="_blank" rel="noopener" href="http://objccn.io/issue-12-6/">交互式动画</a>一文，该文探讨了如何打造自然真实的交互式动画。</p>
<h5 id="Chapter5.2.3.3">最后的封装</h5>

<p>接下来要做的事情就是将上述代码封装在转场环境协议要求实现的三个方法里：</p>
<pre><code>func updateInteractiveTransition(percentComplete: CGFloat)
func finishInteractiveTransition()
func cancelInteractiveTransition()
</code></pre>
<p>正如系统打包的<code>UIPercentDrivenInteractiveTransition</code>类只是调用了 UIKit 提供的转场环境对象里的同名方法，我实现的<code>SDEPercentDrivenInteractiveTransition</code>类也采用了同样的方式调用我们实现的<code>ContainerTransitionContext</code>类的同名方法。</p>
<p>引入交互控制器后的转场引用关系图：</p>
<p><img src="https://github.com/seedante/iOS-ViewController-Transition-Demo/blob/master/Figures/Reference%20in%20Transition%20with%20Interactor.png?raw=true" alt="Reference in Transition with Interactor"></p>
<p>回到<code>SDEContainerViewController</code>类里修改转场过程的入口处：</p>
<pre><code>private func transitionViewControllerFromIndex(fromIndex: Int, toIndex: Int)&#123;
    ...
    if containerTransitionDelegate != nil&#123;
        let fromVC = viewControllers![fromIndex]
        let toVC = viewControllers![toIndex]
        self.containerTransitionContext = ...//利用 fromVC 和 toVC 初始化。
        //interactive 属性标记是否进入交互状态，由手势来更新该属性的状态。
        if interactive&#123;
            priorSelectedIndex = fromIndex //备份数据，以备取消转场时使用。
            self.containerTransitionContext?.startInteractiveTranstionWith(containerTransitionDelegate!)
        &#125;else&#123;
            self.containerTransitionContext?.startNonInteractiveTransitionWith(containerTransitionDelegate!)
        &#125;
    &#125;else&#123;/*没有提供转场代理的话，则使用最初没有动画的转场代码，或者提供默认的转场动画*/&#125;
&#125; 
</code></pre>
<p>实现手势控制的部分就如前面的交互控制器章节里的那样，完整的代码请看 Demo。</p>
<p>顺便说下 ButtonTabButton 在交互切换页面时的渐变色动画，这里我只是随着转场的进度更改了 Button 的字体颜色而已。那么当交互结束时如何继续剩下的动画或者取消渐变色动画呢，就像交互转场动画的那样。答案是<code>CADidplayLink</code>，前面我使用它在交互取消时逆转动画，这里使用了同样的手法。</p>
<p>关于转场协调器，文档表明在转场发生时<code>transitionCoordinator()</code>返回一个有效对象，但系统并不支持当前的转场方式，测试表明在当前的转场过程中这个方法返回的是 nil，需要重写该方法来提供。该对象只需要实现前面提到三个方法，其中在交互中止时执行绑定的闭包的方法可以通过通知机制来实现，有点困难的是两个与动画控制器同步执行动画的方法，其需要精准地与动画控制器中的动画保持同步，这两个方法都要接受一个遵守<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinatorContext_Protocol/index.html#//apple_ref/doc/uid/TP40013294"><code>&lt;UIViewControllerTransitionCoordinatorContext&gt;</code></a>协议的参数，该协议与转场环境协议非常相似，这个对象可以由我们实现的转场环境对象来提供。不过既然现在由我们实现了转场环境对象，也就知道了执行动画的时机，提交并行的动画似乎并不是难事。这部分就留给读者来挑战了。</p>
<h2 id="Chapter6">尾声：转场动画的设计</h2>

<p>虽然我不是设计师，但还是想在结束之前聊一聊我对转场动画设计的看法。动画的使用无疑能够提升应用的体验，但仅限于使用了合适的动画。</p>
<p>除了一些加载动画可以炫酷华丽极尽炫技之能事，绝大部分的日常操作并不适合使用过于炫酷或复杂的动画，比如 <a target="_blank" rel="noopener" href="https://github.com/ColinEberhardt/VCTransitionsLibrary#using-an-interaction-controller">VCTransitionsLibrary</a> 这个库里的大部分效果。该库提供了多达10种转场效果，从技术上讲，大部分效果都是针对 transform 进行动画，如果你对这些感兴趣或是恰好有这方面的使用需求，可以学习这些效果的实现，从代码角度看，封装技巧也很值得学习，这个库是学习转场动画的极佳范例；不过从使用效果上看，这个库提供的效果像 PPT 里提供的动画效果一样，绝大部分都应该避免在日常操作中使用。不过作为开发者，我们应该知道技术实现的手段，即使这些效果并不适合在绝大部分场景中使用。</p>
<p>场景转换的目的是过渡到下一个场景，在操作频繁的日常场景中使用复杂的过场动画容易造成视觉疲劳，这种情景下使用简单的动画即可，实现起来非常简单，更多的工作往往是怎么把它们与其他特性更好地结合起来，正如 <a target="_blank" rel="noopener" href="https://github.com/forkingdog/FDFullscreenPopGesture.git">FDFullscreenPopGesture</a> 做的那样。除了日常操作，也会遇到一些特殊的场景需要定制复杂的转场动画，这种复杂除了动画效果本身的复杂，这需要掌握相应的动画手段，也可能涉及转场过程的配合，这需要对转场机制比较熟悉。比如 <a target="_blank" rel="noopener" href="https://github.com/Yalantis/StarWars.iOS">StarWars</a>，这个转场动画在视觉上极其惊艳，一出场便获得上千星星的青睐，它有贴合星战内涵的创意设计和惊艳的视觉表现，以及优秀的性能优化，如果要评选年度转场动画甚至是史上最佳，我会投票给它；而我在本文里实现的范例，从动画效果来讲，都是很简单的，可以预见本文无法吸引大众的转发，压轴环节里的自定义容器控制器转场也是如此，但是后者需要熟知转场机制才能实现。从这点来看，转场动画在实际使用中走向两个极端：日常场景中的转场动画十分简单，实现难度很低；特定场景的转场动画可能非常复杂，不过实现难度并不能一概而论，正如我在案例分析一节里指出的几个案例那样。</p>
<p>希望本文能帮助你。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/06/%E4%BD%BF%E7%94%A8Mono%E8%AE%A9.NET%E7%A8%8B%E5%BA%8F%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/%E4%BD%BF%E7%94%A8Mono%E8%AE%A9.NET%E7%A8%8B%E5%BA%8F%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C/" itemprop="url">使用 Mono 让.NET 程序跨平台运行</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-06T12:20:09+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          我们可以看到命令行下输出了我们期望的 Hello World，这意味着我们编写的程序现在运行在 Mono 中了，实际上在 Windows 下由 Mono 提供的 C#编译器 mcs.exe 编译的 IL 文件双击是可以直接运行的，因为我们的计算机上安装了 CLR，它作为.NET 的一部分内置在我们的计算机中;所以我们可以这样理解.NET 程序跨平台，因为 IL 文件是一个和平台无关、和 CPU 无关的、跨平台的文件结构，所以我们只需要在不同的平台上实现这样一个公共语言运行时(CLR)就可以实现在不同的平台上运行同一个程序;由此我们会发现一个问题，我们这里的跨平台实际上是编译器、运行时和基础类库这三部分的跨平台，这意味着我们在 Linux 下运行.NET 程序是需要 Mono 提供支持的
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/03/06/%E4%BD%BF%E7%94%A8Mono%E8%AE%A9.NET%E7%A8%8B%E5%BA%8F%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C/">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/06/2016/how-to-connect-to-custom-mysql-port-for-eloquent-orm-connection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/2016/how-to-connect-to-custom-mysql-port-for-eloquent-orm-connection/" itemprop="url">Eloquent ORM Connection 无法自定义 MySQL 连接端口的解决办法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-06T10:31:37+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>这是今天我朋友遇到的问题，网上没有啥解决方法，特此记录。</p>
<p>朋友的 MySQL 运行在 3307 端口，然而他的框架配置文件中没有 Port 的选项（好吧我说的就是 ss-panel），如果在 <code>db_host</code> 中填写 <code>localhost:Port</code> 这样的格式的话就会报 <code>SQLSTATE Unknown MySQL server host &#39;localhost:3307&#39;</code> 这样的错误。</p>
<p>那么要怎么解决呢？</p>
<p>首先要找到 <code>.env</code> 被解析的地方，以 ss-panel 为例是在 <code>/app/Services/Config.php</code> 中：</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/03/06/2016/how-to-connect-to-custom-mysql-port-for-eloquent-orm-connection/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/03/05/2016-03-05-swift-gym-4-map-and-flatmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/05/2016-03-05-swift-gym-4-map-and-flatmap/" itemprop="url">Swift 烧脑体操（四） - map 和 flatMap</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-05T20:15:34+08:00">
                2016-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Swift 烧脑系列文章列表：</p>
<ul>
<li><a href="/2016/02/27/swift-gym-1-nested-optional/">Swift 烧脑体操（一） - Optional 的嵌套</a></li>
<li><a href="/2016/02/27/swift-gym-2-function-argument/">Swift 烧脑体操（二） - 函数的参数</a></li>
<li><a href="/2016/02/27/swift-gym-3-higher-order-function/">Swift 烧脑体操（三） - 高阶函数</a></li>
<li><a href="/2016/03/05/swift-gym-4-map-and-flatmap/">Swift 烧脑体操（四） - map 和 flatMap</a></li>
<li><a href="/2016/04/05/swift-gym-5-monad/">Swift 烧脑体操（五）- Monad</a></li>
<li><a href="/2016/05/22/swift-gym-6-type-infer/">Swift 烧脑体操（六）- 类型推断</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第四节，练习前请做好准备运动，保持头脑清醒。</p>
<p>我之前一直以为我是懂 <code>map</code> 和 <code>flatMap</code> 的。但是直到我看到别人说：「一个实现了 <code>flatMap</code> 方法的类型其实就是 monad。」我又发现这个熟悉的东西变得陌生起来，本节烧脑体操打算更细致一些介绍 <code>map</code> 和 <code>flatMap</code>，为了下一节介绍 monad 做铺垫。</p>
<h2 id="准备运动：基础知识"><a href="#准备运动：基础知识" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3gw1f0sz177142j20dk07bjsd.jpg"></p>
<h3 id="数组中的-map-和-flatMap"><a href="#数组中的-map-和-flatMap" class="headerlink" title="数组中的 map 和 flatMap"></a>数组中的 <code>map</code> 和 <code>flatMap</code></h3><p>数组中的 <code>map</code> 对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.map &#123;</span><br><span class="line">    &quot;No.&quot; + String($0)</span><br><span class="line">&#125;</span><br><span class="line">// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]</span><br></pre></td></tr></table></figure>

<p>而 <code>flatMap</code> 和 <code>map</code> 的差别在哪里呢？我们可以对比一下它们的定义。为了方便阅读，我在删掉了定义中的 <code>@noescape</code> 、<code>throws</code> 和 <code>rethrows</code> 关键字，如果你对这些关键字有疑问，可以查阅上一期的烧脑文章：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension SequenceType &#123;</span><br><span class="line">    public func map&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T) </span><br><span class="line">         -&gt; [T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension SequenceType &#123;</span><br><span class="line">    public func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) </span><br><span class="line">         -&gt; [S.Generator.Element]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension SequenceType &#123;</span><br><span class="line">    public func flatMap&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T?) </span><br><span class="line">         -&gt; [T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从中可以发现，<code>map</code> 的定义只有一个，而 <code>flatMap</code> 的定义有两个重载的函数，这两个重载的函数都是接受一个闭包作为参数，返回一个数组。但是差别在于，闭包的定义不一样。</p>
<p>第一个函数闭包的定义是：<code>(Self.Generator.Element) -&gt; S</code>，并且这里 S 被定义成：<code>S : SequenceType</code>。所以它是接受数组元素，然后输出一个 <code>SequenceType</code> 类型的元素的闭包。有趣的是， <code>flatMap</code> 最终执行的结果并不是 <code>SequenceType</code> 的数组，而是 <code>SequenceType</code> 内部元素另外组成的数组，即：<code>[S.Generator.Element]</code>。</p>
<p>是不是有点晕？看看示例代码就比较清楚了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]</span><br><span class="line">let brr = arr.flatMap &#123;</span><br><span class="line">    $0</span><br><span class="line">&#125;</span><br><span class="line">// brr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>

<p>你看出来了吗？在这个例子中，数组 arr 调用 <code>flatMap</code> 时，元素<code>[1, 2, 3]</code> 和 <code>[6, 5, 4]</code> 分别被传入闭包中，又直接被作为结果返回。但是，最终的结果中，却是由这两个数组中的元素共同组成的新数组：<code>[1, 2, 3, 6, 5, 4]</code> 。</p>
<p>需要注意的是，其实整个 <code>flatMap</code> 方法可以拆解成两步：</p>
<ul>
<li>第一步像 <code>map</code> 方法那样，对元素进行某种规则的转换。</li>
<li>第二步，执行 <code>flatten</code> 方法，将数组中的元素一一取出来，组成一个新数组。</li>
</ul>
<p>所以，刚刚的代码其实等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [6, 5, 4]]</span><br><span class="line">let crr = Array(arr.map&#123; $0 &#125;.flatten())</span><br><span class="line">// crr = [1, 2, 3, 6, 5, 4]</span><br></pre></td></tr></table></figure>

<p>讲完了 <code>flatMap</code> 的第一种重载的函数，我们再来看第二种重载。</p>
<p>在第二种重载中，闭包的定义变成了：<code>(Self.Generator.Element) -&gt; T?</code>，返回值 T 不再像第一种重载中那样要求是数组了，而变成了一个 Optional 的任意类型。而 <code>flatMap</code> 最终输出的数组结果，其实不是这个 <code>T?</code> 类型，而是这个 <code>T?</code> 类型解包之后，不为 <code>.None</code> 的元数数组：<code>[T]</code>。</p>
<p>我们还是直接看代码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr: [Int?] = [1, 2, nil, 4, nil, 5]</span><br><span class="line">let brr = arr.flatMap &#123; $0 &#125;</span><br><span class="line">// brr = [1, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>flatMap</code> 将数组中的 nil 都丢弃掉了，只保留了非空的值。</p>
<p>在实际业务中，这样的例子还挺常见，比如你想构造一组图片，于是你使用 UIImage 的构造函数，但是这个函数可能会失败（比如图像的名字不存在时），所以返回的是一个 Optional 的 UIImage 对象。使用 <code>flatMap</code> 方法可以方便地将这些对象中为 .None 的都去除掉。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let images = (1...6).flatMap &#123;</span><br><span class="line">    UIImage(named: &quot;imageName-\($0)&quot;) </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="Optional-中的-map-和-flatMap"><a href="#Optional-中的-map-和-flatMap" class="headerlink" title="Optional 中的 map 和 flatMap"></a>Optional 中的 <code>map</code> 和 <code>flatMap</code></h3><p>其实 <code>map</code> 和 <code>flatMap</code> 不止存在于数组中，在 Optional 中也存在。我们先看看定义吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123;</span><br><span class="line">    case None</span><br><span class="line">    case Some(Wrapped)</span><br><span class="line"></span><br><span class="line">    public func map&lt;U&gt;( f: (Wrapped) throws -&gt; U) </span><br><span class="line">        rethrows -&gt; U?</span><br><span class="line"></span><br><span class="line">    public func flatMap&lt;U&gt;( f: (Wrapped) throws -&gt; U?) </span><br><span class="line">        rethrows -&gt; U?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于一个 Optional 的变量来说，<code>map</code> 方法允许它再次修改自己的值，并且不必关心自己是否为 <code>.None</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a1: Int? = 3</span><br><span class="line">let b1 = a1.map&#123; $0 * 2 &#125;</span><br><span class="line">// b1 = 6</span><br><span class="line"></span><br><span class="line">let a2: Int? = nil</span><br><span class="line">let b2 = a2.map&#123; $0 * 2 &#125;</span><br><span class="line">// b2 = nil</span><br></pre></td></tr></table></figure>

<p>再举一个例子，比如我们想把一个字符串转成 NSDate 实例，如果不用 <code>map</code> 方法，我们只能这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let date: NSDate? = NSDate()</span><br><span class="line">let formatter = NSDateFormatter()</span><br><span class="line">formatter.dateFormat = &quot;YYYY-MM-dd&quot;</span><br><span class="line">var formatted: String? = nil</span><br><span class="line">if let date = date &#123;</span><br><span class="line">    formatted = formatter.stringFromDate(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用 <code>map</code> 函数后，代码变得更短，更易读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let date: NSDate? = NSDate()</span><br><span class="line">let formatter = NSDateFormatter()</span><br><span class="line">formatter.dateFormat = &quot;YYYY-MM-dd&quot;</span><br><span class="line">let formatted = date.map(formatter.stringFromDate)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看出来特点了吗？当我们的输入是一个 Optional，同时我们需要在逻辑中处理这个 Optional 是否为 nil，那么就适合用 <code>map</code> 来替代原来的写法，使得代码更加简短。</p>
<p>那什么时候使用 Optional 的 <code>flatMap</code> 方法呢？答案是：当我们的闭包参数有可能返回 nil 的时候。</p>
<p>比如，我们希望将一个字符串转换成 Int，但是转换可能失败，这个时候我们就可以用 <code>flatMap</code> 方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s: String? = &quot;abc&quot;</span><br><span class="line">let v = s.flatMap &#123; (a: String) -&gt; Int? in</span><br><span class="line">    return Int(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在这里还发现了更多的使用 <code>map</code> 和 <code>flatMap</code> 的例子，分享给大家：<a target="_blank" rel="noopener" href="http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/">http://blog.xebia.com/the-power-of-map-and-flatmap-of-swift-optionals/</a>。</p>
<h2 id="map-和-flatMap-的源码"><a href="#map-和-flatMap-的源码" class="headerlink" title="map 和 flatMap 的源码"></a><code>map</code> 和 <code>flatMap</code> 的源码</h2><p><img src="https://quotesaga.s3.amazonaws.com/quote/QS_be152af2851e4e4e8d5049b0d5cbaed9.jpg"></p>
<blockquote>
<p>Talk is cheap. Show me the code.</p>
<p>– Linus Torvalds</p>
</blockquote>
<p>为了更好地理解，我们去翻翻苹果开源的 Swift 代码，看看 <code>map</code> 和 <code>flatMap</code> 的实现吧。</p>
<h3 id="数组的-map-的源码"><a href="#数组的-map-的源码" class="headerlink" title="数组的 map 的源码"></a>数组的 <code>map</code> 的源码</h3><p>源码地址是：<a target="_blank" rel="noopener" href="https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift">https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift</a>，摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public func map&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T)</span><br><span class="line">        rethrows -&gt; [T] &#123;</span><br><span class="line">    let count: Int = numericCast(self.count)</span><br><span class="line">    if count == 0 &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var result = ContiguousArray&lt;T&gt;()</span><br><span class="line">    result.reserveCapacity(count)</span><br><span class="line">    </span><br><span class="line">    var i = self.startIndex</span><br><span class="line">    </span><br><span class="line">    for _ in 0..&lt;count &#123;</span><br><span class="line">        result.append(try transform(self[i]))</span><br><span class="line">        i = i.successor()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _expectEnd(i, self)</span><br><span class="line">    return Array(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的-flatMap-的源码（重载函数一）"><a href="#数组的-flatMap-的源码（重载函数一）" class="headerlink" title="数组的 flatMap 的源码（重载函数一）"></a>数组的 <code>flatMap</code> 的源码（重载函数一）</h3><p>刚刚也说到，数组的 <code>flatMap</code> 有两个重载的函数。我们先看第一个的函数实现。源码地址是：<a target="_blank" rel="noopener" href="https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb">https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift.gyb</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public func flatMap&lt;S : SequenceType&gt;(</span><br><span class="line">        transform: ($&#123;GElement&#125;) throws -&gt; S</span><br><span class="line">    ) rethrows -&gt; [S.$&#123;GElement&#125;] &#123;</span><br><span class="line">        var result: [S.$&#123;GElement&#125;] = []</span><br><span class="line">        for element in self &#123;</span><br><span class="line">            result.appendContentsOf(try transform(element))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这个代码，我们可以看出，它做了以下几件事情：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。</li>
<li>将转换的结果，使用 <code>appendContentsOf</code> 方法，将结果放入 <code>result</code> 数组中。</li>
</ol>
<p>而这个 <code>appendContentsOf</code> 方法，即是把数组中的元素取出来，放入新数组。以下是一个简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 2]</span><br><span class="line">arr.appendContentsOf([4, 5])</span><br><span class="line">// arr = [1, 3, 2, 4, 5]</span><br></pre></td></tr></table></figure>

<p>所以这种 <code>flatMap</code> 必须要求 <code>transform</code> 函数返回的是一个 <code>SequenceType</code> 类型，因为 <code>appendContentsOf</code> 方法需要的是一个 <code>SequenceType</code> 类型的参数。</p>
<h3 id="数组的-flatMap-的源码（重载函数二）"><a href="#数组的-flatMap-的源码（重载函数二）" class="headerlink" title="数组的 flatMap 的源码（重载函数二）"></a>数组的 <code>flatMap</code> 的源码（重载函数二）</h3><p>当我们的闭包参数返回的类型不是 <code>SequenceType</code> 时，就会匹配上第二个重载的 <code>flatMap</code> 函数。以下是函数的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func flatMap&lt;T&gt;(</span><br><span class="line">    @noescape transform: ($&#123;GElement&#125;) throws -&gt; T?</span><br><span class="line">    ) rethrows -&gt; [T] &#123;</span><br><span class="line">        var result: [T] = []</span><br><span class="line">        for element in self &#123;</span><br><span class="line">            if let newElement = try transform(element) &#123;</span><br><span class="line">                result.append(newElement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也用同样的方式，把该函数的逻辑理一下：</p>
<ol>
<li>构造一个名为 <code>result</code> 的新数组，用于存放结果。(和另一个重载函数完全一样)</li>
<li>遍历自己的元素，对于每个元素，调用闭包的转换函数 <code>transform</code>，进行转换。(和另一个重载函数完全一样)</li>
<li>将转换的结果，判断结果是否是 nil，如果不是，使用使用 <code>append</code> 方法，将结果放入 <code>result</code> 数组中。（唯一差别的地方）</li>
</ol>
<p>所以，该 <code>flatMap</code> 函数可以过滤闭包执行结果为 nil 的情况，仅收集那些转换后非空的结果。</p>
<p>对于这种重载的 <code>flatMap</code> 函数，它和 <code>map</code> 函数的逻辑非常相似，仅仅多做了一个判断是否为 nil 的逻辑。</p>
<p>所以，面试题来了：「什么情况下数组的 <code>map</code> 可以和 <code>flatMap</code> 等价替换？」</p>
<p>答案是：当 <code>map</code> 的闭包函数返回的结果不是 <code>SequenceType</code> 的时候。因为这样的话，<code>flatMap</code> 就会调到我们当前讨论的这种重载形式。而这种重载形式和 <code>map</code> 的差异就仅仅在于要不要判断结果为 nil。</p>
<p>下面是一个示例代码，可以看出：<code>brr</code> 和 <code>crr</code> 虽然分别使用 <code>map</code> 和 <code>flatMap</code> 生成，但是结果完全一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.map &#123;</span><br><span class="line">    &quot;No.&quot; + String($0)</span><br><span class="line">&#125;</span><br><span class="line">// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]</span><br><span class="line"></span><br><span class="line">let crr = arr.flatMap &#123;</span><br><span class="line">    &quot;No.&quot; + String($0)</span><br><span class="line">&#125;</span><br><span class="line">// crr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="Optional-的-map-和-flatMap-源码"><a href="#Optional-的-map-和-flatMap-源码" class="headerlink" title="Optional 的 map 和 flatMap 源码"></a>Optional 的 <code>map</code> 和 <code>flatMap</code> 源码</h3><p>看完数组的实现，我们再来看看 Optional 中的相关实现。源码地址是：<a target="_blank" rel="noopener" href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// If `self == nil`, returns `nil`.  </span><br><span class="line">/// Otherwise, returns `f(self!)`.</span><br><span class="line">public func map&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U) </span><br><span class="line">        rethrows -&gt; U? &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case .Some(let y):</span><br><span class="line">        return .Some(try f(y))</span><br><span class="line">    case .None:</span><br><span class="line">        return .None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Returns `nil` if `self` is `nil`, </span><br><span class="line">/// `f(self!)` otherwise.</span><br><span class="line">@warn_unused_result</span><br><span class="line">public func flatMap&lt;U&gt;(@noescape f: (Wrapped) throws -&gt; U?) </span><br><span class="line">        rethrows -&gt; U? &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case .Some(let y):</span><br><span class="line">        return try f(y)</span><br><span class="line">    case .None:</span><br><span class="line">        return .None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Optional 的这两函数真的是惊人的相似，如果你只看两段函数的注释的话，甚至看不出这两个函数的差别。</p>
<p>这两函数实现的差别仅仅只有两处：</p>
<ol>
<li><code>f</code> 函数一个返回 <code>U</code>，另一个返回 <code>U?</code> 。</li>
<li>一个调用的结果直接返回，另一个会把结果放到 .Some 里面返回。</li>
</ol>
<p>两个函数最终都保证了返回结果是 Optional 的。只是将结果转换成 Optional 的位置不一样。</p>
<p>这就像我老婆给我说：「我喜欢这个东西，你送给我吗？不送的话我就直接刷你卡买了！」。。。买东西的结果本质上是一样的，谁付钱本质上也是一样的，差别只是谁动手而已。</p>
<p>既然 Optional 的 <code>map</code> 和 <code>flatMap</code> 本质上是一样的，为什么要搞两种形式呢？这其实是为了调用者更方便而设计的。调用者提供的闭包函数，既可以返回 Optional 的结果，也可以返回非 Optional 的结果。对于后者，使用 <code>map</code> 方法，即可以将结果继续转换成 Optional 的。结果是 Optional 的意味着我们可以继续链式调用，也更方便我们处理错误。</p>
<p>我们来看一段略烧脑的代码，它使用了 Optional 的 <code>flatMap</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 4]</span><br><span class="line">let res = arr.first.flatMap &#123;</span><br><span class="line">    arr.reduce($0, combine: max)</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">这段代码的功能是：计算出数组中的元素最大值，按理说，求最大值直接使用 `reduce` 方法就可以了。不过有一种特殊情况需要考虑：即数组中的元素个数为 0 的情况，在这种情况下，没有最大值。</span><br><span class="line"></span><br><span class="line">我们使用 Optional 的 `flatMap` 方法来处理了这种情况。arr 的 `first` 方法返回的结果是 Optional 的，当数组为空的时候，`first` 方法返回 .None，所以，这段代码可以处理数组元素个数为 0 的情况了。</span><br><span class="line"></span><br><span class="line">## 烧脑的 `map` 和 `flatMap`</span><br><span class="line"></span><br><span class="line">### 关于取名</span><br><span class="line"></span><br><span class="line">![](http://ww1.sinaimg.cn/large/65dc76a3gw1f0sygrb8chj20c606egmg.jpg)</span><br><span class="line"></span><br><span class="line">&gt;There are only two hard things in Computer Science: cache invalidation and naming things.</span><br><span class="line">&gt;</span><br><span class="line">&gt;-- Phil Karlton</span><br><span class="line"></span><br><span class="line">有一位大师说，计算机世界真正称得上难题的就只有两个：第一个是缓存过期问题，第二个就是取名字。作为文章最后的烧脑环节，我们来聊聊取名字这个事吧。</span><br><span class="line"></span><br><span class="line">我来提几个看起来「无厘头」的问题：</span><br><span class="line"></span><br><span class="line"> * 数组的 `map` 函数和 Optinal 的 `map` 函数的实现差别巨大？但是为什么都叫 `map` 这个名字？</span><br><span class="line"> * 数组的 `flatMap` 函数和 Optinal 的 `flatMap` 函数的实现差别巨大？但是为什么都叫 `flatMap` 这个名字？</span><br><span class="line"> * 数组的 `flatMap` 有两个重载的函数，两个重载的函数差别巨大，但是为什么都叫 `flatMap` 这个名字？</span><br><span class="line"></span><br><span class="line">在我看来，这样的取名其实都是有背后的原因的，我试着分享一下我的理解。我们先说结论，然后再解释。这段结论来自：&lt;http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/&gt;。</span><br><span class="line"></span><br><span class="line"> * 数组和 Optional 的 `map` 函数都叫一样的名字，是因为它们都是 [Functor](https://en.wikipedia.org/wiki/Functor)。</span><br><span class="line"> * 数组和 Optinal 的 `flatMap` 函数都叫一样的名字，是因为它们都是 [Monad](https://en.wikipedia.org/wiki/Monad_(functional_programming))。</span><br><span class="line"></span><br><span class="line">![](http://ww3.sinaimg.cn/large/65dc76a3gw1f0scj26hf9j205805k3yk.jpg)</span><br><span class="line"></span><br><span class="line">好吧，我猜你心里开始骂娘了：「为了解释一个问题，引入了两个新问题：谁知道什么是 Functor 和 Monad ！」</span><br><span class="line"></span><br><span class="line">不要着急，我们先说严谨的结论有助于更好地总结和归纳，我下面试着解释一下 Functor 和 Monad 。</span><br><span class="line"></span><br><span class="line">### Functor</span><br><span class="line"></span><br><span class="line">Functor 在 [Wikipedia](https://en.wikipedia.org/wiki/Functor) 上的定义非常学术。我想了一个相对比较容易理解的定义：所谓的 Functor，就是可以把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。通常情况下，我们会把这个函数叫做 `map`。</span><br><span class="line"></span><br><span class="line">什么叫做「封装过的值」呢？数组就是对值的一种封装，Optional 也是对值的一种封装。如果你愿意，你也可以自己封装一些值，比如把网络请求的结果和网络异常封装在一起，做成一个 enum（如下所示）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>enum Result<T> {<br>    case Success(T)<br>    case Failure(ErrorType)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个值能否成为「封装过的值」，取决于这个值的类型所表示的集合，通过 `map` 函数，能否映射到一个新集合中。这个新集合，也要求能够继续使用 `map` 函数，再映射到另外一个集合。</span><br><span class="line"></span><br><span class="line">我们拿数组和 Optional 类型来检查这个规则，就会发现是符合的：</span><br><span class="line"></span><br><span class="line"> * 数组可以通过 `map` 函数，生成一个新的数组，新的数组可以继续使用 `map` 函数。</span><br><span class="line"> * Optional 可以通过 `map` 函数，生成一个新的 Optional 变量，新的 Optional 变量可以继续使用 `map` 函数。</span><br><span class="line"></span><br><span class="line">所以，数组 和 Optional 都是 Functor。</span><br><span class="line"></span><br><span class="line">### Monad</span><br><span class="line"></span><br><span class="line">如果你能理解 [Functor](https://en.wikipedia.org/wiki/Functor)，那么 [Monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) 就相对容易一些了。所谓的 Monad，和 Functor 一样，也是把一个函数应用于一个「封装过的值」上，得到一个新的「封装过的值」。不过差别在于:</span><br><span class="line"></span><br><span class="line"> * Functor 的函数定义是从「未封装的值」到「未封装的值」的</span><br><span class="line"> * Monad   的函数定义是从「未封装的值」到「封装后的值」的。</span><br><span class="line"></span><br><span class="line">下面我举例解释一下：</span><br><span class="line"></span><br><span class="line">刚刚我们说，数组 和 Optional 都是 Functor，因为它们支持用 `map` 函数做「封装过的值」所在集合的变换。那么，你注意到了吗？map 函数的定义中，输入的参数和返回的结果，都不是「封装过的值」，而是「未封装的值」。什么是「未封装的值」？</span><br><span class="line"></span><br><span class="line"> * 对于数组来说，「未封装的值」是数组里面一个一个的元素，map 函数的闭包接受的是一个一个的元素，返回的也是一个一个的元素。</span><br><span class="line"> * 对于 Optional 来说，「未封装的值」是 Optional 解包出来的值，map 函数的闭包接受的是解包出来的值，返回的也是解包出来的值。</span><br><span class="line"></span><br><span class="line">下面是数组的示例代码，我故意加上了闭包的参数，我们再观察一下。我们可以发现，`map` 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; map 的闭包接受的是 Int 类型，返回的是 String 类型，都是一个一个的元素类型，而不是数组。<br>let arr &#x3D; [1, 2, 4]<br>let brr &#x3D; arr.map {<br>    (element: Int) -&gt; String in<br>    “No.” + String(element)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是 Optional 的示例代码，我也故意加上了闭包的参数。我们可以发现，`map` 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; map 的闭包接受的是 Int 类型，返回的是 Int 类型，都是非 Optional 的。<br>let tq: Int? &#x3D; 1<br>tq.map { (a: Int) -&gt; Int in<br>    a * 2<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们刚刚说，对于 Monad 来说，它和 Functor 的差异实在太小，小到就只有闭包的参数类型不一样。数组实现了 `flatMap` ，它就是一种 Monad，下面我们就看看 `flatMap` 在数组中的函数定义，我们可以看出，闭包接受的是数组的元素，返回的是一个数组（封装后的值）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 闭包接受的是数组的元素，返回的是一个数组（封装后的值）<br>let arr &#x3D; [1, 2, 3]<br>let brr &#x3D; arr.flatMap {<br>    (element:Int) -&gt; [Int] in<br>    return [element * 2]<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是 `flatMap` 在 Optional 中的定义，我们可以看出，闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）。</span><br><span class="line"></span><br><span class="line">```。</span><br><span class="line">// 闭包接受的是 Int 类型，返回的是一个 Optional（封装后的值）</span><br><span class="line">let tq: Int? = 1</span><br><span class="line">tq.flatMap &#123; (a: Int) -&gt; Int? in</span><br><span class="line">    if a % 2 == 0 &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以本质上，<code>map</code> 和 <code>flatMap</code> 代表着一类行为，我们把这类行为叫做 Functor 和 Monad。它们的差异仅仅在于闭包函数的参数返回类型不一样。所以，我们才会把数组和 Optional 这两个差别很大的类型，都加上两个实现差别很大的函数，但是都取名叫 <code>map</code> 和 <code>flatMap</code>。</p>
<h3 id="多重-Optional"><a href="#多重-Optional" class="headerlink" title="多重 Optional"></a>多重 Optional</h3><p>我们在第一节烧脑文章中提到过多重 Optional，在使用 <code>map</code> 的时候不仔细，就会触发多重 Optional 的问题。比如下面这个代码，变量 <code>b</code> 因为是一个两层嵌套的 nil，所以 <code>if let</code> 失效了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let tq: Int? = 1</span><br><span class="line">let b = tq.map &#123; (a: Int) -&gt; Int? in</span><br><span class="line">    if a % 2 == 0 &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if let _ = b &#123;</span><br><span class="line">    print(&quot;not nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法是把 <code>map</code> 换成 <code>flatMap</code> 即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>讨论完了，我们总结一下：</p>
<ul>
<li>数组和 Optional 都能支持 <code>map</code> 和 <code>flatMap</code> 函数。</li>
<li>数组的 <code>flatMap</code> 有两个重载的实现，一个实现等价于先 <code>map</code> 再 <code>flatten</code>，另一个实现用于去掉结果中的 nil。</li>
<li>通过阅读源码，我们更加深入理解了 <code>map</code> 和 <code>flatMap</code> 函数内部的机制。</li>
<li>我们讨论了 <code>map</code> 和 <code>flatMap</code> 的取名问题，最后得出：一个类型如果支持 <code>map</code>，则表示它是一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Functor">Functor</a>；一个类型如果支持 <code>flatMap</code>，则表示它是一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monad_(functional_programming">Monad</a>。</li>
<li>我们讨论了 <code>map</code> 中使用不当造成的多重 Optional 问题。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/27/2016-02-27-swift-gym-3-higher-order-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/27/2016-02-27-swift-gym-3-higher-order-function/" itemprop="url">Swift 烧脑体操（三） - 高阶函数</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-27T09:25:51+08:00">
                2016-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Swift 烧脑系列文章列表：</p>
<ul>
<li><a href="/2016/02/27/swift-gym-1-nested-optional/">Swift 烧脑体操（一） - Optional 的嵌套</a></li>
<li><a href="/2016/02/27/swift-gym-2-function-argument/">Swift 烧脑体操（二） - 函数的参数</a></li>
<li><a href="/2016/02/27/swift-gym-3-higher-order-function/">Swift 烧脑体操（三） - 高阶函数</a></li>
<li><a href="/2016/03/05/swift-gym-4-map-and-flatmap/">Swift 烧脑体操（四） - map 和 flatMap</a></li>
<li><a href="/2016/04/05/swift-gym-5-monad/">Swift 烧脑体操（五）- Monad</a></li>
<li><a href="/2016/05/22/swift-gym-6-type-infer/">Swift 烧脑体操（六）- 类型推断</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第三节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="准备运动：基础知识"><a href="#准备运动：基础知识" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww1.sinaimg.cn/mw690/65dc76a3gw1f0sz14hv65j20er08t0tz.jpg"></p>
<p>在上一节里面，我们其实已经涉及到了高阶函数了。在 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Higher-order_function">Wikipedia</a> 中，是这么定义高阶函数（higher-order function）的，如果一个函数：</p>
<ul>
<li>接受一个或多个函数当作参数</li>
<li>把一个函数当作返回值</li>
</ul>
<p>那么这个函数就被称作高阶函数。下面是一个简单的排序的例子，在这个例子中，传进去的参数就是一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 4, 2, 3]</span><br><span class="line">let res = numbers.sort &#123;</span><br><span class="line">    $0 &lt; $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trailing-Closure-Syntax"><a href="#Trailing-Closure-Syntax" class="headerlink" title="Trailing Closure Syntax"></a>Trailing Closure Syntax</h3><p>上面的代码看着不像是函数作为参数存在，这是因为 Swift 的 Trailing Closure 特性。Swift 允许当函数的最后一个参数是闭包的时候，以紧跟 <code>&#123; &#125;</code> 的形式，将最后一个闭包的内容附加在函数后面。</p>
<p>所以，以下两行代码是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正常写法，函数是作为 sort 的参数</span><br><span class="line">arr.sort(&#123; $0 &lt; $1 &#125;)</span><br><span class="line"></span><br><span class="line">// Trailing Closure 写法，更简洁明了</span><br><span class="line">arr.sort &#123; $0 &lt; $1 &#125; </span><br></pre></td></tr></table></figure>

<h2 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h2><p>高阶函数在 Swift 语言中有大量的使用场景，我们先来看一看常见的用法：</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>我们可以用 <code>map</code> 方法来对数组元素进行某种规则的转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.map &#123;</span><br><span class="line">    &quot;No.&quot; + String($0)</span><br><span class="line">&#125;</span><br><span class="line">// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>我们可以用 <code>reduce</code> 方法，来对数组元素进行某种规则的求和（不一定是加和）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.reduce(0) &#123;</span><br><span class="line">    (prevSum: Int, element: Int) in</span><br><span class="line">    return prevSum + element</span><br><span class="line">&#125;</span><br><span class="line">// brr = 7</span><br><span class="line">let crr = arr.reduce(&quot;&quot;) &#123;</span><br><span class="line">    if $0 == &quot;&quot; &#123;</span><br><span class="line">        return String($1)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return $0 + &quot; &quot; + String($1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// crr = &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure>

<h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>我们可以利用 <code>filter</code> 方法，来对数组元素进行某种规则的过滤，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.filter &#123;</span><br><span class="line">    $0 % 2 == 0</span><br><span class="line">&#125;</span><br><span class="line">// brr = [2, 4]</span><br></pre></td></tr></table></figure>

<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>即使是以前最简单的遍历，我们也可以用高阶函数的写法，将遍历需要的操作，以函数参数的形式传入 <code>forEach</code> 方法中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">arr.forEach &#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="烧脑体操"><a href="#烧脑体操" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>下面我们来看看高阶函数一些比较烧脑的细节。</p>
<h3 id="用高阶函数来隐藏私有变量"><a href="#用高阶函数来隐藏私有变量" class="headerlink" title="用高阶函数来隐藏私有变量"></a>用高阶函数来隐藏私有变量</h3><p>高阶函数使得代码逻辑可以用函数为主体来进行封装，下面我将详细解释一下这句话。</p>
<p>在面向对象的世界里，逻辑存在的基本单元是对象，每个对象代表着一个最小可复用模块。在对象的内部，由高内聚的成员变量和成员函数构成。这些函数相互调用，并且操作对象的内部成员变量，最终对外产生可预期的行为。</p>
<p>但是利用高阶函数，我们可以同样做到与对象类似的，高内聚的成员变量和成员函数，下面我就举一个具体的例子。</p>
<p>下面的代码中，我们用类的方式，实现了一个 <code>Clock</code> 类， <code>Clock</code> 类实现了一个 <code>getCount</code> 方法，每次调用的时候返回的值 <code>+1</code>。为了测试代码，我们定义了两个实例 c1 和 c2，它们都可以正常输出预期的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Clock &#123;</span><br><span class="line">    var count: Int = 0</span><br><span class="line">    func getCount() -&gt; Int &#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c1 = Clock()</span><br><span class="line">c1.getCount() // 得到 1</span><br><span class="line">c1.getCount() // 得到 2</span><br><span class="line">let c2 = Clock()</span><br><span class="line">c2.getCount() // 得到 1</span><br></pre></td></tr></table></figure>

<p>那么接下来，我们用高阶函数的方式，来做一下同样的事情。我们先看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func getClock() -&gt; () -&gt; Int &#123;</span><br><span class="line">    var count: Int = 0</span><br><span class="line">    let getCount = &#123; () -&gt; Int in</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    return getCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c1 = getClock()</span><br><span class="line">c1()  // 得到 1</span><br><span class="line">c1()  // 得到 2</span><br><span class="line">let c2 = getClock()</span><br><span class="line">c2()  // 得到 1</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们这里定义了一个 <code>getClock</code> 函数，这个函数可以返回一个 <code>getCount</code> 函数。然后，不太一样的地方是，这个 <code>getCount</code> 函数持有了一个外部的变量 <code>count</code>。于是，这个函数也变得有了状态（或者你也可以说它有了 Side Effect）。每次调用这个函数的时候，返回的值都会变化。</p>
<p>另一方面，因为<code>count</code>变量是 <code>getClock</code> 这个高阶函数的内部变量，所以它并没有像全局变量一样使得封装性被打破。<code>getClock</code>函数仍然可以看作一个高内部的可复用模块，并且对外隐藏了实现细节。</p>
<p>所以，Swift 语言的高阶函数以及闭包可以 capture 外部变量的特性，使得代码逻辑可以以函数作为主体来进行封装，这将使得我们的代码组织更加灵活。</p>
<p>当然，如果滥用，这也会造成代码组织变得更加混乱。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><p>另一个烧脑的故事是来自于一个朋友的面试题。在面试中，面试官要求他用数组的 <code>reduce</code> 方法实现 <code>map</code> 的功能。</p>
<p>这个题目实在是非常蛋疼，不过用来烧脑倒是不错，大家感兴趣的话可以先想想，再翻下面的参考答案。</p>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><p>不过说回来，虽然题目一有些奇怪，但是它确实考查了对于高阶函数灵活使用以及对 <code>reduce</code> 方法的理解。大家还可以试试这些题目：</p>
<ul>
<li>问题一：用 <code>reduce</code> 方法找出数组中的最大值。</li>
<li>问题二：用 <code>reduce</code> 方法一次求出数组中奇数的和、以及偶数乘积。</li>
</ul>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><p>高阶函数另一个魔力就是可以链式调用，大家可以尝试这么一道题目：求一个数组中偶数的平方和。</p>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><h4 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 3, 2]</span><br><span class="line">let res = arr.reduce([]) &#123;</span><br><span class="line">    (a: [Int], element: Int) -&gt; [Int] in</span><br><span class="line">    var t = Array(a)</span><br><span class="line">    t.append(element * 2)</span><br><span class="line">    return t</span><br><span class="line">&#125;</span><br><span class="line">// res = [2, 6, 4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h4><p>问题二的参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]</span><br><span class="line"></span><br><span class="line">let res: (Int, Int) = arr.reduce((0, 1)) &#123;</span><br><span class="line">    (a :(Int, Int), element: Int) -&gt; (Int, Int) in</span><br><span class="line">    if element % 2 == 0 &#123;</span><br><span class="line">        return (a.0, a.1 * element)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (a.0 + element, a.1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// res = (4, 8)</span><br></pre></td></tr></table></figure>
<h4 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h4><p>以下是参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 3, 2, 4]</span><br><span class="line">let res = arr.filter &#123;</span><br><span class="line">        $0 % 2 == 0</span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        $0 * $0</span><br><span class="line">    &#125;.reduce(0) &#123;</span><br><span class="line">        $0 + $1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>学习了 Swift 语言中的一些使用高阶函数的示例，包括 <code>map</code>, <code>reduce</code>, <code>filter</code> 等。</li>
<li>学习了利用高阶函数来构造以函数为主体的功能模块。</li>
<li>练习了一些奇怪的面试题。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/27/2016-02-27-swift-gym-2-function-argument/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/27/2016-02-27-swift-gym-2-function-argument/" itemprop="url">Swift 烧脑体操（二） - 函数的参数</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-27T09:23:29+08:00">
                2016-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Swift 烧脑系列文章列表：</p>
<ul>
<li><a href="/2016/02/27/swift-gym-1-nested-optional/">Swift 烧脑体操（一） - Optional 的嵌套</a></li>
<li><a href="/2016/02/27/swift-gym-2-function-argument/">Swift 烧脑体操（二） - 函数的参数</a></li>
<li><a href="/2016/02/27/swift-gym-3-higher-order-function/">Swift 烧脑体操（三） - 高阶函数</a></li>
<li><a href="/2016/03/05/swift-gym-4-map-and-flatmap/">Swift 烧脑体操（四） - map 和 flatMap</a></li>
<li><a href="/2016/04/05/swift-gym-5-monad/">Swift 烧脑体操（五）- Monad</a></li>
<li><a href="/2016/05/22/swift-gym-6-type-infer/">Swift 烧脑体操（六）- 类型推断</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第二节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="准备运动：基础知识"><a href="#准备运动：基础知识" class="headerlink" title="准备运动：基础知识"></a>准备运动：基础知识</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz14p1u4j206w0a33zb.jpg"></p>
<h3 id="面向对象语言的世界观"><a href="#面向对象语言的世界观" class="headerlink" title="面向对象语言的世界观"></a>面向对象语言的世界观</h3><p>对于很多面向对象的编程语言来说，在思考问题时，总是把「对象」作为考虑问题的基本出发点。</p>
<p>面向对象的程序设计通过以下三大规则，构建出程序设计的基础，它们是：</p>
<ol>
<li>封装（Encapsulation），将一个相对独立的逻辑涉及的变量和函数放到一个类中，然后对外暴露少量接口，使其高内聚，低耦合。</li>
<li>继承（Inheritance），子类可以继承父类的变量和函数，并且可以修改或扩展父类的行为。</li>
<li>多态（Polymorphism），父类的指针可以指向子类的实例，在运行时程序语言支持找到子类对应的函数实现。</li>
</ol>
<p>在以上三大准则的基础上，再引入一些设计原则，比如：</p>
<ol>
<li>单一职责原则（Single Responsibility），每个类只应该做一件事情。</li>
<li>不要重复原则（Don’t Repeat Yourself），相同（或相似）的代码不应该重复两次。</li>
<li>好的组合优于继承（Better Composition over Inheritance），尽量使用组合而不是继承来设计。</li>
</ol>
<p>于是，程序世界就基于这些规则和原则，产生出了设计模式，进而能更加精准地指导我们的编程行为。这就像我们学习几何，先学习几条公理，然后以后的大量定理都通过公理证明而来。</p>
<p>举个例子，单例模式（Singleton Pattern）其实就是封装和单一职责原则的产物。代理模式（Delegate Pattern) 也是单一职责和封装中的面向接口设计的思想的产物。</p>
<p>但是，在面向对象语言的世界观里面，函数都是作为一个附属物存在的。函数通常附属于一个具体类的某个方法中。或许有一个函数它根本都不需要任何对象作为容器，为了这个世界的统一，我们还是会构造一个类，把这个函数放进去。比如，在小猿搜题中，我们就有一个叫 ImageUtils 的类，里面放了操作图像的各种各样的静态方法，有一些图象操作函数其实也不太通用，但是总得找一个类放不是。</p>
<p>在一些面向对象语言的世界中，如果把对象称作 OOP 的一等公民的话，那么函数就是二等公民。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>在 Swift 的世界中，函数并不是二等公民。是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。</p>
<p>一等公民有什么权利呢？那就是函数可以像对象一样，被赋值、被当作参数传递、参与计算或者当作结果被返回。</p>
<p>我们先来看一段函数被赋值的例子，在下例中，我们将一个函数赋值给一个名为 <code>myFunc</code> 的变量，然后调用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myFunc = &#123; </span><br><span class="line">    () -&gt; String in</span><br><span class="line">    return &quot;Tang Qiao&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = myFunc()</span><br><span class="line">// value 的值为 &quot;Tang Qiao&quot;</span><br></pre></td></tr></table></figure>

<p>我们再来看一个函数被当作运算结果返回的例子。在这个例子中，我们希望构造一个「加法器」工厂，这个工厂能够接受一个参数 addValue，返回一个加法器函数，这个加法器函数能够将传递的参数加 addValue 之后返回。以下是实现的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">    func adder(value: Int) -&gt; Int &#123;</span><br><span class="line">        return addValue + value</span><br><span class="line">    &#125;</span><br><span class="line">    return adder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面这个函数，我们就可以构造一个 <code>+2</code> 的函数，然后使用它，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let add2 = addFactory(2) // 构造一个 +2 的函数</span><br><span class="line">let result = add2(3) // 运算，传入 3，得到 5</span><br></pre></td></tr></table></figure>

<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>但是在本次「烧脑体操」中，全面介绍函数式编程明显不太现实，所以我们仅从函数的参数来深入学习一下，看看在 Swift 语言中，函数的参数能够有多复杂。</p>
<!--
这里多说一句题外话，有部分同学看了「烧脑体操」第一节后，留言说：本来简单的 Swift 语言，被你这么一说，弄得都不敢学了，你是不是在吓大家？还有一些人留言：你搞这么绕还不是为了装逼？

对此，我想回答说：我研究这些仅仅是为了避免在语言细节的地方掉坑里，如果你对此不感兴趣，有一个动作叫做「取消关注」，我写文章并没有收费，如果你不喜欢，取关即可，犯不着在后台留言恶心我吧？
-->

<h3 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>我们先来简单看看函数参数的省略吧，因为有类型推导，函数的参数在 Swift 中常常可以被省略掉，特别以匿名函数（闭包）的形式存在的时候。</p>
<p>我们来看一个数组排序的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort &#123;</span><br><span class="line">    (a: Int, b: Int) -&gt; Bool in</span><br><span class="line">    return a &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果一个函数返回类型可以通过推导出来，则返回类型可以省略。所以以上代码中的 <code>-&gt; Bool</code> 可以删掉，变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort &#123;</span><br><span class="line">    (a: Int, b: Int) in</span><br><span class="line">    return a &lt; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数的参数类型可以推导出来，则参数的类型可以省略。所以以上代码中的 <code>: Int</code> 可以删掉，变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort &#123;</span><br><span class="line">    (a, b) in</span><br><span class="line">    return a &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果函数参数的个数可以推导出来，也可以不写参数。那怎么使用这些参数呢？可以用 <code>$0</code>, <code>$1</code> 这样的方式来引用参数。所以以上代码中的 <code>(a, b)</code> 可以删掉，因为这样的话，参数和返回值都省略了，所以<code>in</code>也可以省略了，变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort &#123;</span><br><span class="line">    return $0 &lt; $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 还有一个规则，如果函数的 body 只有一行，则可以把 <code>return</code> 关键字省略了，所以以上代码可以进一步简化成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort &#123;</span><br><span class="line">    $0 &lt; $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个简化规则更加暴力，因为 <code>&lt;</code> 符号也是一个函数，它接受的参数个数，类型和返回值与 sort 函数需要的一样，所以可以直接简化成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 3, 2, 4]</span><br><span class="line">let res = array.sort( &lt; )</span><br></pre></td></tr></table></figure>

<p>拿这个的方法，同样可以把我们刚刚写的 <code>addFactory</code> 做简化，最后简化成如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 简化前</span><br><span class="line">func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">    func adder(value: Int) -&gt; Int &#123;</span><br><span class="line">        return addValue + value</span><br><span class="line">    &#125;</span><br><span class="line">    return adder</span><br><span class="line">&#125;</span><br><span class="line">// 简化后</span><br><span class="line">func addFactory(addValue: Int) -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">    return &#123; addValue + $0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数中的其它关键字"><a href="#函数参数中的其它关键字" class="headerlink" title="函数参数中的其它关键字"></a>函数参数中的其它关键字</h3><p>有些时候，我们的函数接受的参数就是另外一个函数，例如 sort，map，所以我们在看代码的时候，需要具备熟悉这种写法的能力。</p>
<p>我们来看看数组的 map 函数的定义吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]</span><br></pre></td></tr></table></figure>

<p>这个函数定义中出现了几个我们刚刚没提到的关键词，我们先学习一下。</p>
<h4 id="noescape"><a href="#noescape" class="headerlink" title="@noescape"></a><code>@noescape</code></h4><p><code>@noescape</code>，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文：</p>
<blockquote>
<p>A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.</p>
</blockquote>
<p>什么情况下一个闭包参数会跳出函数的生命期呢？很简单，我们在函数实现内，将一个闭包用 <code>dispatch_async</code> 嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521">https://stackoverflow.com/questions/28427436/noescape-attribute-in-swift-1-2/28428521#28428521</a></li>
<li><a target="_blank" rel="noopener" href="http://nshint.io/blog/2015/10/23/noescape-attribute/">http://nshint.io/blog/2015/10/23/noescape-attribute/</a></li>
</ul>
<h4 id="throws-和-rethrows"><a href="#throws-和-rethrows" class="headerlink" title="throws 和 rethrows"></a><code>throws</code> 和 <code>rethrows</code></h4><p><code>throws</code> 关键字表示：这个函数（闭包）可能抛出异常。而 <code>rethrows</code> 关键字表示：这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。</p>
<p><code>throws</code> 关键字的存在大家都应该能理解，因为总有一些异常可能在设计的时候希望暴露给上层，<code>throws</code> 关键字的存在使得这种设计成为可能。</p>
<p>那么为什么会有 <code>rethrows</code> 关键字呢？在我看来，这是为了简化很多代码的书写。因为一旦一个函数会抛出异常，按 Swift 类型安全的写法，我们就需要使用 try 语法。但是如果很多地方都需要写 try 的话，会造成代码非常啰嗦。 <code>rethrows</code> 关键字使得一些情况下，如果你传进去的闭包不会抛出异常，那么你的调用代码就不需要写 try。</p>
<p>如果你对此感兴趣，这里有一些更详细的介绍供你学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://robnapier.net/re-throws">http://robnapier.net/re-throws</a></li>
</ul>
<h3 id="函数作为函数的参数"><a href="#函数作为函数的参数" class="headerlink" title="函数作为函数的参数"></a>函数作为函数的参数</h3><p>刚刚说到，函数作为一等公民，意味着函数可以像对象一样，被当作参数传递或者被当作值返回。对此，我们专门有一个名称来称呼它，叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Higher-order_function">高阶函数（higher-order function）</a>。</p>
<p>在刚刚那个数组的 map 函数中，我们就看到了它接着另外一个函数作为参数，这个函数接受数组元素类型作为参数，返回一个新类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]</span><br></pre></td></tr></table></figure>

<p>有了 map 函数，我们就可以轻松做数组元素的变换了。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 4]</span><br><span class="line">// arr = [1, 2, 4]</span><br><span class="line"></span><br><span class="line">let brr = arr.map &#123;</span><br><span class="line">    &quot;No.&quot; + String($0)</span><br><span class="line">&#125;</span><br><span class="line">// brr = [&quot;No.1&quot;, &quot;No.2&quot;, &quot;No.4&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="烧脑的参数"><a href="#烧脑的参数" class="headerlink" title="烧脑的参数"></a>烧脑的参数</h2><p>好了，现在进入参数烧脑游戏的正式环节。</p>
<p>我们需要构造一个工厂函数，这个函数接受两个函数作为参数，返回一个新的函数。新函数是两个函数参数的叠加作用效果。</p>
<p>举一个具体的例子，假如我们有一个 <code>+2</code> 的函数，有一个 <code>+3</code> 的函数，那用这个工厂函数，我们可以得到一个 <code>+5</code> 的函数。</p>
<p>又比如我们有一个 <code>*2</code> 的函数，有一个 <code>*5</code> 的函数，用这个工厂函数，我们就可以得到一个 <code>*10</code> 的函数。</p>
<p>那这个函数如何写呢？我们先看答案吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func funcBuild(f: Int -&gt; Int, _ g: Int -&gt; Int) </span><br><span class="line">    -&gt; Int -&gt; Int &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        f(g($0))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f1 = funcBuild(&#123;$0 + 2&#125;, &#123;$0 + 3&#125;)</span><br><span class="line">f1(0) // 得到 5</span><br><span class="line">let f2 = funcBuild(&#123;$0 * 2&#125;, &#123;$0 * 5&#125;)</span><br><span class="line">f2(1) // 得到 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数充分反映了函数作为一等公民的地位。但是，我们同时也看出来，函数作为参数存在时，对于程序的可读性带来了挑战。好在我们有 <code>typealias</code>，通过 <code>typealias</code>，我们可以将函数的类型写得更加易读，比如上面的代码，就可以修改成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typealias IntFunction = Int -&gt; Int</span><br><span class="line"></span><br><span class="line">func funcBuild(f: IntFunction, _ g: IntFunction)</span><br><span class="line">    -&gt; IntFunction &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        f(g($0))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在看看代码，是不是清晰了很多？</p>
<h2 id="参数中的范型"><a href="#参数中的范型" class="headerlink" title="参数中的范型"></a>参数中的范型</h2><p>当函数中的参数再引入范型之后，函数的功能更加强大，但是可读性进一步下降。比如刚刚的例子，限制函数只能是 <code>Int -&gt; Int</code> 其实是没有必要的，我们将两个函数拼成一个函数，只需要保证一个函数的输出类型，与另一个函数的输入类型匹配即可。所以，刚刚的例子，可以进一步用范型改造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func funcBuild&lt;T, U, V&gt;(f: T -&gt; U, _ g: V -&gt; T)</span><br><span class="line">    -&gt; V -&gt; U &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            f(g($0))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">let f3 = funcBuild(&#123; &quot;No.&quot; + String($0) &#125;, &#123;$0 * 2&#125;)</span><br><span class="line">f3(23) // 结果是 &quot;No.46&quot;</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，我们保证函数 g 的输出类型是 T，函数 f 的输入类型是 T。这样，在例子中，我们将一个 <code>*2</code> 的函数与一个数字转字符串的函数拼接起来，构造出一个先乘 2，再转字符串的函数。</p>
<p>相应的例子还有很多，比如 WWDC 中就介绍过一个给函数增加缓存机制的代码，在该代码中，任意一个不带缓存功能的函数，经过改造，都可以变成一个带缓存功能的函数。代码如下，大家可以自行学习一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func memoize&lt;T: Hashable, U&gt;( body: (T)-&gt;U ) -&gt; (T-&gt;U) &#123;</span><br><span class="line">    var memo = Dictionary&lt;T, U&gt;()</span><br><span class="line">    return &#123; x in</span><br><span class="line">        if let q = memo[x] &#123; return q &#125;</span><br><span class="line">        let r = body(x)</span><br><span class="line">        memo[x] = r</span><br><span class="line">        return r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Swift 是一个结合面向对象编程和函数式编程特性的语言。</li>
<li>函数在 Swift 中是一等公民，可以被赋值、被当作参数传递、参与计算、当作结果被返回或被动态创建。</li>
<li>因为有类型推导，函数的参数有各种省略规则。</li>
<li>函数作为参数时，有 @noescape，throw 和 rethrow 关键字需要了解。</li>
<li>函数作为参数时，不易阅读。合理使用 typealias 可以使源码结构更清晰。</li>
</ul>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/27/2016-02-27-swift-gym-1-nested-optional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/27/2016-02-27-swift-gym-1-nested-optional/" itemprop="url">Swift 烧脑体操（一） - Optional 的嵌套</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-27T09:21:32+08:00">
                2016-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hrkcyydj20i40cigv2.jpg"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Swift 烧脑系列文章列表：</p>
<ul>
<li><a href="/2016/02/27/swift-gym-1-nested-optional/">Swift 烧脑体操（一） - Optional 的嵌套</a></li>
<li><a href="/2016/02/27/swift-gym-2-function-argument/">Swift 烧脑体操（二） - 函数的参数</a></li>
<li><a href="/2016/02/27/swift-gym-3-higher-order-function/">Swift 烧脑体操（三） - 高阶函数</a></li>
<li><a href="/2016/03/05/swift-gym-4-map-and-flatmap/">Swift 烧脑体操（四） - map 和 flatMap</a></li>
<li><a href="/2016/04/05/swift-gym-5-monad/">Swift 烧脑体操（五）- Monad</a></li>
<li><a href="/2016/05/22/swift-gym-6-type-infer/">Swift 烧脑体操（六）- 类型推断</a></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 其实比 Objective-C 复杂很多，相对于出生于上世纪 80 年代的 Objective-C 来说，Swift 融入了大量新特性。这也使得我们学习掌握这门语言变得相对来说更加困难。不过一切都是值得的，Swift 相比 Objective-C，写出来的程序更安全、更简洁，最终能够提高我们的工作效率和质量。</p>
<p>Swift 相关的学习资料已经很多，我想从另外一个角度来介绍它的一些特性，我把这个角度叫做「烧脑体操」。什么意思呢？就是我们专门挑一些比较费脑子的语言细节来学习。通过「烧脑」地思考，来达到对 Swift 语言的更加深入的理解。</p>
<p>这是本体操的第一节，练习前请做好准备运动，保持头脑清醒。</p>
<h2 id="准备运动：Optional-的介绍"><a href="#准备运动：Optional-的介绍" class="headerlink" title="准备运动：Optional 的介绍"></a>准备运动：Optional 的介绍</h2><p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f0sz13edhpj209s061mxt.jpg"></p>
<p>王巍的《Swifter》(<a target="_blank" rel="noopener" href="http://swifter.tips/buy">http://swifter.tips/buy</a>)一书中，介绍了一个有用的命令：在 LLDB 中输入 <code>fr v -R foo</code>，可以查看 <code>foo</code> 这个变量的内存构成。我们稍后的分析将用到这个命令。</p>
<p>在 Swift 的世界里，一切皆对象，包括 Int Float 这些基本数据类型，所以我们可以这么写：<code>print(1.description)</code>。</p>
<p>而对象一般都是存储在指针中，Swift 也不例外，这就造成了一个问题，指针为空的情况需要处理。在 Objective-C 中，向一个 nil 的对象发消息是默认不产生任何效果的行为，但是在 Swift 中，这种行为被严格地禁止了。</p>
<p>Swift 是一个强类型语言，它希望在编译期做更多的安全检查，所以引入了类型推断。而类型推断上如果要做到足够的安全，避免空指针调用是一个最基本的要求。于是，Optional 这种类型出现了。Optional 在 Swift 语言中其实是一个枚举类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123;</span><br><span class="line">    case None</span><br><span class="line">    case Some(Wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Optional-的嵌套"><a href="#Optional-的嵌套" class="headerlink" title="Optional 的嵌套"></a>Optional 的嵌套</h2><p>Optional 类型的变量，在使用时，大多需要用<code>if let</code>的方式来解包。如果你没有解包而直接使用，编辑器通过类型推断会提示你，所以看起来这套机制工作得很好。但是，如果 Optional 嵌套层次太多，就会造成一些麻烦，下面我们来看一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? = 1</span><br><span class="line">let b: Int?? = a</span><br><span class="line">let c: Int??? = b</span><br></pre></td></tr></table></figure>

<p>在这个机制中，1 这个 Int 值被层层 Optional 包裹，我们用刚刚提到的<code>fr v -R</code>，可以很好的看出来内部结构。如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R a</span><br><span class="line">(Swift.Optional&lt;Swift.Int&gt;) a = Some &#123;</span><br><span class="line">  Some = &#123;</span><br><span class="line">    value = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) fr v -R b</span><br><span class="line">(Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;) b = Some &#123;</span><br><span class="line">  Some = Some &#123;</span><br><span class="line">    Some = &#123;</span><br><span class="line">      value = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) fr v -R c</span><br><span class="line">(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) c = Some &#123;</span><br><span class="line">  Some = Some &#123;</span><br><span class="line">    Some = Some &#123;</span><br><span class="line">      Some = &#123;</span><br><span class="line">        value = 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个示例代码中，我们能看出来多层嵌套的 Optional 的具体内存结构。这个内存结构其实是一个类似二叉树一样的形状，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/65dc76a3gw1f08i00trqpj20ji0ch3ze.jpg"></p>
<ul>
<li>第一层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>第二层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Optional&lt;Int&gt;</code>。</li>
<li>第三层二叉树有两个可选的值，一个值是 .None，另一个值类型是 <code>Int</code>。</li>
</ul>
<p>那么问题来了，看起来这个 Optional.None 可以出现在每一层，那么在每一层的效果一样吗？我做了如下实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? = nil</span><br><span class="line">let b: Int?? = a</span><br><span class="line">let c: Int??? = b</span><br><span class="line">let d: Int??? = nil</span><br></pre></td></tr></table></figure>

<p>如果你在 playground 上看，它们的值都是 nil，但是它们的内存布局却不一样，特别是变量 c 和 变量 d：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R a</span><br><span class="line">(Swift.Optional&lt;Swift.Int&gt;) a = None &#123;</span><br><span class="line">  Some = &#123;</span><br><span class="line">    value = 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) fr v -R b</span><br><span class="line">(Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;) b = Some &#123;</span><br><span class="line">  Some = None &#123;</span><br><span class="line">    Some = &#123;</span><br><span class="line">      value = 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) fr v -R c</span><br><span class="line">(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) c = Some &#123;</span><br><span class="line">  Some = Some &#123;</span><br><span class="line">    Some = None &#123;</span><br><span class="line">      Some = &#123;</span><br><span class="line">        value = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) fr v -R d</span><br><span class="line">(Swift.Optional&lt;Swift.Optional&lt;Swift.Optional&lt;Swift.Int&gt;&gt;&gt;) d = None &#123;</span><br><span class="line">  Some = Some &#123;</span><br><span class="line">    Some = Some &#123;</span><br><span class="line">      Some = &#123;</span><br><span class="line">        value = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量 c 因为是多层嵌套的 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>。</li>
<li>变量 d 因为是直接赋值成 nil，所以它在最外层的二叉树上的值，是一个 <code>Optional.None</code>。</li>
</ul>
<p>麻烦的事情来了，以上原因会造成用 if let 来判断变量 c 是否为 nil 失效了。如下代码最终会输出 <code>c is not none</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a: Int? = nil</span><br><span class="line">let b: Int?? = a</span><br><span class="line">let c: Int??? = b</span><br><span class="line">let d: Int??? = nil</span><br><span class="line"></span><br><span class="line">if let _ = c &#123;</span><br><span class="line">    print(&quot;c is not none&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>在我看来，这个问题的根源是：一个 Optional 类型的变量可以接受一个非 Optional 的值。拿上面的代码举例，a 的类型是 Int?，b 的类型是 Int??，但是 a 的值却可以赋值给 b。所以，变量 b（类型为 Int??），它可以接受以下几种类型的赋值：</p>
<ol>
<li>nil 类型</li>
<li>Int? 类型</li>
<li>Int?? 类型</li>
</ol>
<p>按理说，Swift 是强类型，等号左右两边的类型不完全一样，为什么能够赋值成功呢？我查了一下 Optional 的源码，原来是对于上面第 1，2 种类型不一样的情况，Optional 定义了构造函数来构造出一个 Int?? 类型的值，这样构造之后，等号左右两边就一样了。源码来自 <a target="_blank" rel="noopener" href="https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift">https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift</a>，我摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : _Reflectable, NilLiteralConvertible &#123;</span><br><span class="line">  case None</span><br><span class="line">  case Some(Wrapped)</span><br><span class="line"></span><br><span class="line">  @available(*, unavailable, renamed=&quot;Wrapped&quot;)</span><br><span class="line">  public typealias T = Wrapped</span><br><span class="line"></span><br><span class="line">  /// Construct a `nil` instance.</span><br><span class="line">  @_transparent</span><br><span class="line">  public init() &#123; self = .None &#125;</span><br><span class="line"></span><br><span class="line">  /// Construct a non-`nil` instance that stores `some`.</span><br><span class="line">  @_transparent</span><br><span class="line">  public init(_ some: Wrapped) &#123; self = .Some(some) &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，Optional 提供了两种构造函数，完成了刚刚提到的类型转换工作。</p>
<h2 id="烧脑体操"><a href="#烧脑体操" class="headerlink" title="烧脑体操"></a>烧脑体操</h2><p>好了，说了这么多，我们下面开始烧脑了，以下代码来自傅若愚（<a target="_blank" rel="noopener" href="https://github.com/lingoer">https://github.com/lingoer</a>）在不久前 Swift 大会（<a target="_blank" rel="noopener" href="http://atswift.io/#speaker">http://atswift.io/#speaker</a>）上的一段分享：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dict :[String:String?] = [:]</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">func justReturnNil() -&gt; String? &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">dict[&quot;key&quot;] = justReturnNil()</span><br><span class="line">dict</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是代码执行结果：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcnaidnj20vq06ugni.jpg"></p>
<p>我们可以看到，我们想通过给这个 Dictionary 设置一个 nil，来删除掉这个 key-value 对。但是从 playground 的执行结果上看，key 并没有被删掉。</p>
<p>为了测试到底设置什么样的值，才能正常地删掉这个 key-value 键值对，我做了如下实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var dict :[String:String?] = [:]</span><br><span class="line">// first try</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.None</span><br><span class="line">dict</span><br><span class="line"></span><br><span class="line">// second try</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">dict[&quot;key&quot;] = Optional&lt;String&gt;.None</span><br><span class="line">dict</span><br><span class="line"></span><br><span class="line">// third try</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">dict[&quot;key&quot;] = nil</span><br><span class="line">dict</span><br><span class="line"></span><br><span class="line">// forth try</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">let nilValue:String? = nil</span><br><span class="line">dict[&quot;key&quot;] = nilValue</span><br><span class="line">dict</span><br><span class="line"></span><br><span class="line">// fifth try</span><br><span class="line">dict = [&quot;key&quot;: &quot;value&quot;]</span><br><span class="line">let nilValue2:String?? = nil</span><br><span class="line">dict[&quot;key&quot;] = nilValue2</span><br><span class="line">dict</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3gw1f08hcj57k0j20vk0lqjxf.jpg"></p>
<p>我们可以看到，以下三种方式可以成功删除 key-value 键值对：</p>
<ul>
<li><code>dict[&quot;key&quot;] = Optional&lt;Optional&lt;String&gt;&gt;.None</code></li>
<li><code>dict[&quot;key&quot;] = nil</code></li>
<li><code>let nilValue2:String?? = nil;  dict[&quot;key&quot;] = nilValue2</code></li>
</ul>
<p>所以，在这个烧脑之旅中，我们发现，一个 [String: String?] 的 Dictionary，可以接受以下类型的赋值：</p>
<ul>
<li>nil</li>
<li>String</li>
<li>String?</li>
<li>String??</li>
</ul>
<p>如果要删除这个 Dictionary 中的元素，必须传入 nil 或 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> ，而如果传入 <code>Optional&lt;String&gt;.None</code>，则不能正常删除元素。</p>
<p>好吧，实验出现象了，那这种现象的原因是什么呢？</p>
<p>还好苹果把它的实现开源了，那我们来一起看看吧，源文件来自：<a target="_blank" rel="noopener" href="https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb">https://github.com/apple/swift/blob/master/stdlib/public/core/HashedCollections.swift.gyb</a>，以下是关键代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public subscript(key: Key) -&gt; Value? &#123;</span><br><span class="line">  get &#123;</span><br><span class="line">    return _variantStorage.maybeGet(key)</span><br><span class="line">  &#125;</span><br><span class="line">  set(newValue) &#123;</span><br><span class="line">    if let x = newValue &#123;</span><br><span class="line">      // FIXME(performance): this loads and discards the old value.</span><br><span class="line">      _variantStorage.updateValue(x, forKey: key)</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      // FIXME(performance): this loads and discards the old value.</span><br><span class="line">      removeValueForKey(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当 Dictionary 的 value 类型为 String 时，如果你要设置它的值，它接受的是一个 String? 类型的参数。而因为我们刚刚例子中的 value 类型为 String?，所以正常情况下它需要的是一个 String?? 类型的参数。在上面的失败的例子中，我们传递的是一个 String? 类型的值，具体值为 <code>Optional&lt;String&gt;.None</code>，于是在执行时就会按以下的步骤来进行：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;String&gt;.None</code>，类型为 String? 的参数。</li>
<li>因为传的参数类型是 String?，而函数需要的是 String??，所以会执行 Optional 的构造函数，构造一个两层的 Optional。</li>
<li>这个两层 Optional 的值为 <code>Optional.Some(&lt;Optional&lt;String&gt;.None&gt;)</code></li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，因为两层的 Optional，所以 if let 判断它不是 nil。</li>
<li>所以代码执行到 <code>_variantStorage.updateValue(x, forKey: key)</code>，把 Optional<String>.None 当成值，设置给了相应的 key。</li>
</ol>
<p>如果你没理解，可以再翻翻最初我们对多层嵌套 nil 变量的实验和分析。</p>
<p>我们再看看传递参数是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 的情况，步骤如下：</p>
<ol>
<li>我们传递一个值为 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>，类型为 String?? 的参数。</li>
<li>因为参数类型是 String??，函数需要的类型也是 String??，所以参数不经变换，直接进入函数调用中。</li>
<li>这个时候参数的值不变，还是 <code>Optional&lt;Optional&lt;String&gt;&gt;.None</code>。</li>
<li>进入到 Dictionary 的实现时，会用 if let 进行是否为 nil 的判断，<code>Optional&lt;Optional&lt;String&gt;&gt;.None</code> 用 if let 判断，得到它是 nil。</li>
<li>所以代码执行到 <code>removeValueForKey(key)</code>，Dictionary 删除了相应的 key-value 键值对。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，「烧脑体操」第一节就做完了，运动一下是不是感觉神清气爽？</p>
<p>总结一下本次烧脑锻炼到的脑细胞：</p>
<ul>
<li>Optional 可以多层嵌套。</li>
<li>因为 Optional 的构造函数支持，所以可以将一个类型为 T 的值，赋值给一个类型为 T? 的变量。</li>
<li>因为 Optional 的构造函数支持，所以可以将 nil 赋值给一个任意嵌套层数的 Optional 变量。</li>
<li>将 Optional 嵌套的内容是 nil 时，大家要小心 if let 操作失效问题。</li>
<li>多层 Optional 嵌套容易烧脑细胞，尽量避免在工程中使用或触发。</li>
<li>遇到问题可以翻翻苹果在 Github 开源的 <a target="_blank" rel="noopener" href="https://github.com/apple/swift">Swift 源码</a>。</li>
</ul>
<p>愿大家玩得开心！</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/25/2016/what-did-i-learn-from-development-of-bss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/25/2016/what-did-i-learn-from-development-of-bss/" itemprop="url">开发 Blessing Skin Server 所学到的</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-25T08:22:00+08:00">
                2016-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>开发这个皮肤站程序也有一段时间了，写篇文章稍微总结一下。挺久以前的草稿了，可能有些过时内容。</p>
<hr>
<p>起初接触到 PHP 是在搭建博客的时候，经常因为某种需求而需要对 WordPress 做一些定制。也就是那个时候我写出了人生中 <a target="_blank" rel="noopener" href="https://prinzeugen.net/dont-display-weichuncai-on-mobile-page/">第一行 PHP 代码</a>。</p>
<p>当时对 PHP 也没太大感觉，因为当时也没接触过 Web 开发。真正开始使用 PHP，是萌发想做一个皮肤站的念头后。</p>
<p>在开发语言中，我选择了 PHP 而不是喜欢的 Python。一是因为作为模板语言的PHP天生适合写 web 项目，二也是为了能涨点姿势。</p>
<p>因为基础还算过得去，我也没必要去看什么 PHP 新手入门教程，上手就直接开始写了。依样画葫芦撸了个基本架构就开始写前端逻辑。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/02/25/2016/what-did-i-learn-from-development-of-bss/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/16/2016-02-16-from-octopress-to-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/16/2016-02-16-from-octopress-to-hexo/" itemprop="url">从 Octopress 迁移到 Hexo</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-16T19:05:46+08:00">
                2016-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我的博客之前一直使用的是 <a target="_blank" rel="noopener" href="http://octopress.org/">Octopress</a>，不过 Octopress 已经很久没有更新了。而且 Octopress 是基于 Ruby 的，生成博客文章的速度真的是非常非常慢，每次我使用 <code>rake preview</code> 命令时，我的 MacBook 的 CPU 就会狂转。最新的一次我试图在新 MBP 上搭建 Octopress 博客环境失败了，这让我打定主意更换掉它。</p>
<p>之后我调研了一下，最终决定迁移到 Hexo，主要的原因是：</p>
<ul>
<li>Hexo 的原理和 Octopress 一样，都是生成静态文件，这样可以方便地托管到 GitHub 和 GitCafe 上。</li>
<li>Hexo 是基于 Node 的，而 Node 的速度非常快。</li>
<li>Hexo 对 Octopress 的迁移很友好，图片引用方式完全一样，所以我的博客文章不需要做什么改动。</li>
</ul>
<p>迁移本来应该在春节前就做完的，不过我在选择 Hexo 的主题上犯难了，Hexo 自带的主题丑极了，而我试了将近 10 个主题，都不满意。最终，我发现了 <a target="_blank" rel="noopener" href="http://swift.gg/">SwiftGG</a> 使用的主题 <a target="_blank" rel="noopener" href="https://github.com/wuchong/jacman">Jacman</a>，于是决定就它了！</p>
<p>整个迁移过程大概如下：</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>首先使用如下命令安装 Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="创建一个新的博客"><a href="#创建一个新的博客" class="headerlink" title="创建一个新的博客"></a>创建一个新的博客</h2><p>接着我们创建一个新的博客目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>以上命令完成后，会在目标目录生成以下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>相比 Octopress，Hexo 的目录结构更加简单：</p>
<ul>
<li>_config.yml 是博客的配置文件。</li>
<li>scaffolds 是博客文章模板。</li>
<li>source 是博客文章目录。</li>
<li>themes 存放主题风格文件。</li>
</ul>
<h2 id="迁移和配置"><a href="#迁移和配置" class="headerlink" title="迁移和配置"></a>迁移和配置</h2><p>迁移起来还是很方便，把以前 Octopress 的 <code>source/_post</code> 目录下的文章，拷贝到 Hexo 的同名目录下即可。</p>
<p>以前的图片目录，也可以直接拷贝到 <code>source/images</code> 目录下。</p>
<p>Google 统计相关的设置可以在 jacman 的 _config.yml 文件中配置。我以前用的评论系统太旧了，这次正好换成了<a target="_blank" rel="noopener" href="http://tangqiaoboy.duoshuo.com/">多说</a>，同样也是在 jacman 的配置文件中设置。</p>
<h2 id="修改界面"><a href="#修改界面" class="headerlink" title="修改界面"></a>修改界面</h2><p>选择 Hexo 的另一个原因就是它的结构很简单，比较方便我定制。我在迁移完博客文章后，对 jacman 主题进行了一些定制。删掉了底部的作者介绍，然后在右侧边栏加上了我的微信公众号介绍。如果你想看看我是如何定制的，可以直接查看我 Fork 出来的 jacman 项目上的 Commits 即可，项目地址在 <a target="_blank" rel="noopener" href="https://github.com/tangqiaoboy/jacman">这里</a>。</p>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>Hexo 支持直接发布到 GitHub，不过我在配置好 <code>_config.yml</code> 文件后，执行 <code>Hexo deploy</code> 一直失败！Hexo 一直卡在生成页面过程中，没有任何报错，这使得我也不知道如何修复它。</p>
<p>最终，我自己写了一个小脚本来做发布工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/zsh</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">cd public</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update at `date` &quot;</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:tangqiaoboy/tangqiaoboy.github.com.git &gt;&gt; /dev/null 2&gt;&amp;1</span><br><span class="line">echo &quot;### Pushing to Github...&quot;</span><br><span class="line">git push origin master -f</span><br><span class="line">echo &quot;### Done&quot;</span><br><span class="line"></span><br><span class="line">git remote add gitcafe git@gitcafe.com:tangqiaoboy/tangqiaoboy.git &gt;&gt; /dev/null 2&gt;&amp;1</span><br><span class="line">echo &quot;### Pushing to GitCafe...&quot;</span><br><span class="line">git push gitcafe master:gitcafe-pages -f</span><br><span class="line">echo &quot;### Done&quot;</span><br></pre></td></tr></table></figure>

<p>如果你遇到了和我一样问题的话，把以上脚本稍做修改应该也能很好地工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Octopress 已经过时，建议有时间的朋友都可以尝试替换掉它。Hexo 算不上完美，但还算是一个不错的替代方案。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/16/2016-02-16-inspired-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/16/2016-02-16-inspired-summary/" itemprop="url">人员、流程和产品上的思考 - 读《启示录》总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-16T13:32:33+08:00">
                2016-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="http://img12.360buyimg.com/n1/jfs/t640/134/203561693/178183/b1f2b244/54562358Nb9bef513.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://item.jd.com/10628082.html">《启示录：打造用户喜爱的产品》</a> 出版于 2011 年，作为最早一批出版的关于产品经理图书，直到现在仍然非常畅销。它的作者是 eBay 前产品副总裁 Marty Cagan。</p>
<p>Marty Cagan 的这本书有点文集的感觉，从任何一章开始读，都不会感觉到突兀。很多文章最初应该是以博客的形式发表在 <a target="_blank" rel="noopener" href="http://www.svpg.com/articles/">http://www.svpg.com/articles/</a> 网站上的。整体上图书的文章分为三大部分：人员、流程和产品。以下是一些读书总结。</p>
<h2 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h2><p>图书的第一部分是「人员」，用了 10 个章节来阐述。前 5 章主要介绍互联网产品研发中的关键角色定义以及职责，后 5 个章节介绍了一些人员招聘和管理的心得。</p>
<p>Marty Cagan 认为互联网研发的角色包括：产品经理、用户体验设计师、项目管理人员、开发团队、运维团队、产品营销人员，并且他分别讲解了这些角色的职责和工作内容差别。</p>
<p>具体在执行上，其实有可能一人身兼多职，比如我们小猿搜题的产品经理同时需要负责做项目管理相关的推进和协调工作。也可能一个职位被拆分成多个细分的工作方向，比如用户体验设计师在网易公司就会拆分成负责交互效果和负责视觉效果的设计师。</p>
<p>书中我印象比较深刻的是对产品经理和项目经理的讨论。Marty Cagan 在书中是这么介绍的：</p>
<blockquote>
<p>产品经理产注的是定义有价值的产品。</p>
<p>项目经理关注如何执行计划以交付产品。</p>
</blockquote>
<p>书中提到了项目经理需要的能力包括：</p>
<ul>
<li>工作紧迫感</li>
<li>善于捕捉问题</li>
<li>思路清晰</li>
<li>用数据说话</li>
<li>果断</li>
<li>判断力</li>
<li>态度（不能找延期的借口）</li>
</ul>
<p>所以这里面涉及的技能差别巨大，那为什么我们在创业时选择让产品经理身兼项目管理工作呢？除了希望团队保持人员在数量上的敏捷之外，我们认为产品经理如果能够具备这样的能力，会使得他们能具有更有大局观。这个大局观说实际点，就是知道自己的产品方案在执行时会有多大具体的开发成本，在做妥协的时候，知道如何的产品调整会有助于开发团队更快地产出。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>这部分用了 20 个章节，介绍了做产品的各种流程和做事方法。</p>
<p>其中涉及的很多流程，已经被广泛接受，并成为事实上的标准做法。比如基于 Scrum 的敏捷软件开发方法，虽然有一些公司不完全采用 Scrum，但是其中的看板、站立会议等实践仍然被借鉴融入到了日常工作流程中。</p>
<p>作者推荐产品经理用「高保真」原型来代替产品文档。对于「高保真」原型，作者还在网站上提供了详细的示例：<a target="_blank" rel="noopener" href="http://www.svpg.com/examples">http://www.svpg.com/examples</a>，我看了之后感觉还是比较惊讶，因为这个 <a target="_blank" rel="noopener" href="http://www.svpg.com/assets/Files/Prototype.zip">原型</a> 的「高保真」程度已经到了让人看不出来是原型的程度。</p>
<p>就我了解到的大多数公司，都还是用 Axure 或 Omni Graffle 来制作产品文档，其远远谈不上「高保真」，我对所有产品都应该用「高保真」原型来制作存疑。</p>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>这部分用了 9 个章节，介绍了一些做产品的心得。例如：</p>
<p>第 32 章让我们提防做一些小众需求的功能，主要是给那些做企业级应用的公司的建议。</p>
<p>第 34 章介绍了产品背后涉及的人性：贪婪、恐惧、欲望。这里面的道理谁都懂，不过要真正应用到产品中，还需要长久的思考。之前听一个朋友说，不管是德州扑克，还是炒股，都是一个「克服贪婪与恐惧的游戏」。道理谁都懂，但是能玩好德州扑克和炒股挣钱的人并不多。</p>
<p>第 35 章介绍的情感接纳曲线也是涉及人性的话题，他指出很多人的决策都是为了宣泄情绪，关注并利用到这一点之后，就可以做出广受欢迎的产品。书中举的是关于非理性消费的例子，比如环保主义者就会花很多钱买普锐斯（丰田公司的混合动力汽车），但是其实他们更多的是为情绪买单。作者认为非理性消费本质是对不满情绪的过度反应，是放大后的情感需求在作怪。</p>
<p>对于如何寻找这种需求，作者提出可以把自己想像成一个新生的人，一切东西都是新鲜的，然后感受产品对自己内心的细微影响。这种目标用户的代入感或许是一个产品经理的必修课程吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图书最后用两章进行了一个总结，包括整理出一个「最佳实践经验」和「产品经理的反省清单」。我对此体会并不深，但是考虑到可能自己还没悟到，所以先摘录如下：</p>
<p>「最佳实践经验」有十条：</p>
<ul>
<li>1、产品管理的职责</li>
<li>2、用户体验</li>
<li>3、机会评估</li>
<li>4、特约客户</li>
<li>5、产品原则</li>
<li>6、人物角色</li>
<li>7、探索（定义）产品</li>
<li>8、使用原型</li>
<li>9、用户参与原型测试</li>
<li>10、根据数据进行改进</li>
</ul>
<p>「产品经理的反省清单」也有十条：</p>
<ul>
<li>1、产品能吸引目标消费用户的关注吗？</li>
<li>2、设计是否人性化，好操作？</li>
<li>3、能赢得过竞品么？</li>
<li>4、了解目标用户吗？</li>
<li>5、是否有别于其他的产品呢？</li>
<li>6、产品能正常运行么？</li>
<li>7、是否完整，销售是否能够完成。</li>
<li>9、特色是否与目标用户一致。</li>
<li>10、产品值钱吗？值多少钱？</li>
<li>11、了解团队其他成员的想法吗？</li>
</ul>
<p>作为最早一批出现的介绍产品经理工作的书籍，《启示录》非常适合入门，特别是适合有一些具体产品工作实践的同学阅读。本书不太好的地方就是内容组织的条理性太差，并且涉及的内容通常并没有很深入展开。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/16/2016-02-16-the-leadership-pipeline-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/16/2016-02-16-the-leadership-pipeline-summary/" itemprop="url">通过他人完成任务的艺术 - 读《领导梯队》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-16T13:24:31+08:00">
                2016-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p><img src="http://img11.360buyimg.com/n1/jfs/t991/39/1365739528/216597/92223aa5/559a1e10N51068ad5.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://item.jd.com/10708646.html">《领导梯队》</a> 是美团的 <a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E9%99%88%E6%99%93%E4%BA%AE/17510291">陈晓亮</a> 同学推荐给我的，看完了一段时间，但是一直没有整理读书笔记，这次趁着春节回顾了一下本书。</p>
<p>领导力就是通过他人去完成任务的学问。本书通过对六个典型的管理层级最经常出现的问题，从领导技能、时间管理能力、工作理念三个方面进行了分析，提出了改进建议。</p>
<p>本书对管理层级的划分非常宏大，看起来像是给一个上万人集团公司写的一样，书中甚至有一章是教你如何做 CEO，这可能与本书的作者拉姆·查兰长期从事管理方面的教学工作有关。而我因为刚刚从一个开发人员转型做管理工作，所以我主要阅读的图书的前两章，里面涉及了如何「从管理自我到管理他人」。</p>
<p>对于每一个领导阶段，书中都从如下三个方面进行了工作指导：</p>
<ol>
<li>领导技能：培养胜任新职务所需要的新能力，提升领导力。</li>
<li>时间管理：重新配置时间精力资源，决定如何高效工作。</li>
<li>工作理念：更新工作理念和价值观，让工作聚焦重点。</li>
</ol>
<p>而这三个方面，也是我常常困惑的地方。我常常问自己：</p>
<ol>
<li>作为一个技术转管理的人，我应该如何学习和提高？</li>
<li>我应该如何安排自己的日常工作时间？</li>
<li>有什么核心的方法论来指导自己？</li>
</ol>
<p>而这些问题，我试图从本书中得到答案，有一些找到了，也有一些没找到。</p>
<h2 id="从管理自我到管理他人"><a href="#从管理自我到管理他人" class="headerlink" title="从管理自我到管理他人"></a>从管理自我到管理他人</h2><p>我们大部分初入职场的人刚开始都是个人贡献者，随着能力的提高，有一些人在自己专业领域上做出了出色的成绩。而公司往往会给这些人增加更多的职责，这些职责很多时候都是涉及沟通、组织和管理的。所以，这些优秀的个人贡献者，开始迎接他们的第一次转型挑战，尝试学会从管理自我到管理他人。</p>
<p>书中也提到，优秀的个人贡献者和优秀的管理人员所需要的技能树并不一样。所以并不是每一个人都是能够完成这一转变。而就我所在的互联网行业来看，很多时候，优秀的个人贡献者也不一定需要做这个转变，也能在技术领域一路提升，成为技术专家。</p>
<p>例如阿里的 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/15099717.htm">多隆</a>，就是一位一直坚持在技术领域的专家，他做到了阿里的合伙人。我也见到一些朋友坚持在一线做技术，其薪资待遇高于那些做管理的人。所以这个职位转变更多需要是内心的喜欢和坚持。如果转型失败，后果很可能是自废武功—-既弱化了专业的职业技能，又是一个失败的管理者。</p>
<p>我们先来看看书中指出管理他人的技能树吧：</p>
<h3 id="领导技能"><a href="#领导技能" class="headerlink" title="领导技能"></a>领导技能</h3><p>书中指出管理他人首先需要的技能是「领导技能」，具体包括：</p>
<ul>
<li>制定计划（项目计划，预算计划和人员计划）</li>
<li>工作设计</li>
<li>人员选拔（其实就是招聘）</li>
<li>授权（工作安排）</li>
<li>绩效监督</li>
<li>教练辅导与反馈</li>
<li>绩效评估</li>
<li>奖励与激励</li>
<li>沟通与营造工作氛围</li>
<li>为部门发展建立上下左右的良好关系</li>
<li>获取资源</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>技术或者业务能力</li>
<li>团队协作能力</li>
<li>为了个人利益和个人成员建立的人际关系</li>
<li>合理运用公司的工具、流程和规则</li>
</ul>
<p>书中将以上内容分为了三类：界定和布置工作、提高下属的胜任能力、建立人际关系。我觉得分得并不清晰，我按个人理解，用工作方式再次进行了分类：</p>
<ul>
<li>自己思考的工作：制定计划、工作设计、绩效评估</li>
<li>与人沟通的工作：授权、教练辅导与反馈、营造工作氛围、获取资源、奖励与激励</li>
<li>自己执行的工作：人员选拔、绩效监督</li>
</ul>
<p>所以我觉得一个好的一线管理人员，应该有思考和规划的能力、沟通能力、以及执行力。执行力在个人贡献者阶段其实也有锻炼，所以主要需要学习的是思考和规划的能力、沟通能力。</p>
<p>沟通能力似乎和演讲一样，就是一个多练习才能提高的技能。我平时会注意观察和总结自己的言语表达方式，以及观察别人的沟通方式，能感受到自己在一点点进步。</p>
<p>思考和规划的能力似乎也是一个需要花时间来积累的事情。好在很多时候规划并不是我来做的，所以我对此承担的压力并不大。</p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间管理方面的技能，具体包括：</p>
<ul>
<li>年度时间计划（时间安排、项目进度）</li>
<li>与下属沟通的专门时间（一是自己的需要，二是下属的需要）</li>
<li>为部门和团队工作设定时间方面的优先次序</li>
<li>与其他部门、客户和供应商沟通的时间</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>遵守工作上下班时间</li>
<li>遵守工作的进度安排</li>
</ul>
<p>其实简单来说，以前是别人给自己安排工作，现在需要自己给自己安排工作了。每天的时间怎么分配，花在哪些事情上，一线经理需要开始思考了。</p>
<p>我当前主要的工作内容包括参与产品讨论，参与技术讨论，跟进项目上线，与运营同事沟通，与我的领导沟通，与主要具体负责人定期沟通。除此之外，还有团队的工作安排，一些面试工作。</p>
<p>我以前会主动承担一些开发任务，但是我发现这其实是不太合适的，因为我的时间沟通工作比较多，所以开发工作时间很多时候并不能保证进度。我以前也会过多地参与到项目进度推进中，现在发现也是不太合适的，这方面的工作我更多交给了相应的产品经理来完成。</p>
<p>但是，我对自己的时间安排也不尽满意。主要是我不太清楚我应该如何安排每天事情的优先级，以及当某一天没有固定安排的时候，我应该做什么事情。我有一些例行的事情可选，但是并没有安排好，例如：</p>
<ul>
<li>Check 一下和团队的人哪些人很久没有一对一沟通过，如果没有的话做一次。</li>
<li>关注 Pipe 上产品的各项指标，看是否有异常的、未被发现的数据。</li>
<li>关注用户反馈，看看用户都在说什么。</li>
<li>在 QQ 上找一些用户聊聊天。</li>
<li>关注自己的产品细节，反复使用。</li>
<li>关注竞争对手的功能改进。</li>
<li>看用户的原始数据（Frog，上传的图片）。</li>
<li>思考人员、流程和产品，各自有没有什么问题。</li>
</ul>
<p>这些问题在本书中没有涉及，我通过和我的领导郭常圳沟通，最终确定的结论是：我们把工作分为「被动工作时间」和「主动工作时间」。</p>
<ul>
<li>被动工作时间包括：定期的产品过稿、美术过稿、Scrum会议、邮件、在QQ上或当面主动来找我的事情。</li>
<li>主动工作时间包括：刚刚提到的看产品数据、看用户反馈，看原始数据等事情。</li>
</ul>
<p>郭常圳认为，我们应该把主动工作时间「例行化」，「例行化」是指每天抽出固定的时间来做这些事情，这样使得这些事情不被遗漏和忽视。在例行化的事情之外，我需要更多的留出「主动思考」时间，「主动思考」是最重要，并且是将这些输入转化成想法或决策的关键过程。</p>
<p>所以，我刚刚提到的那些事情，都应该变成每天例行做的事情。</p>
<h3 id="工作理念"><a href="#工作理念" class="headerlink" title="工作理念"></a>工作理念</h3><p>书中提到的工作理念的技能，具体包括：</p>
<ul>
<li>通过他人完成任务</li>
<li>下属员工的成功（就是自己的成功）</li>
<li>管理性工作和修养</li>
<li>部门的成功（就是自己的成功）</li>
<li>像一位真正的管理者</li>
<li>正直诚实</li>
</ul>
<p>与此对比，书中也提到了个人贡献者的技能树，我们可以对比一下：</p>
<ul>
<li>通过个人能力完成任务</li>
<li>高质量的技术或专业化工作</li>
<li>遵循公司的价值观</li>
</ul>
<p>这一部分涉及成就感的转变，以前个人贡献者的成就感来源于自己的努力和成长。现在一线管理人员的成就感变成了下属的成功和团队的成功。不但如此，一线管理人员还需要在各方面对下属进行辅导，帮助他们工作得更舒服，更开心。</p>
<p>另外，我对正直诚实这条也感触很深。公司大了之后，很多文化就是来自于创始人以及一些核心员工。如果管理人员不能做到正直诚实，那么公司很可能变得充满了「政治斗争」，一但工作变成了维护自己利益以及小集团的利益，那么对公司的伤害是巨大的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本书的内容组织稍显混乱，虽然把领导技术、时间管理、工作理念作为每个阶段层级的主要改变内容，但是在具体阐述时，又会以另外一个角度展开。比如「 从管理自我到管理他人」一章的内容展开时，是按界定和布置工作、提高下属的胜任能力、建立人际关系作为内容小节阐述。而「从管理他人到管理经理人员」一章的内容，又是按「四个领导技能」展开。</p>
<p>本书很多章节总结性的内容散乱，最终以 QA 或故事的方式，列出一系列问题和回答来作为主要的章节内容，虽然很多内容读起来很有道理，但是使读者很难抽取出核心观点，也可能作者本身也没能总结出核心观点。</p>
<p>本书对于我的帮助是，我从中得到了不少指导性的规则，也帮助我梳理了自己的工作内容。虽然它没有解决我的所有问题，但是至少帮助我完成了对问题列表的整理和思考。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/16/2016-02-16-make-friend-with-time/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/16/2016-02-16-make-friend-with-time/" itemprop="url">和时间做朋友 - 读《奇特的一生》</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-16T13:04:28+08:00">
                2016-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p><img src="https://camo.githubusercontent.com/9b0ba22b20c8464aefd022486269d4f3c8f3a5b8/687474703a2f2f696d6731302e333630627579696d672e636f6d2f6e312f6731352f4d30372f31312f30312f7242456857564a6e4a6167494141414141416e4f6362317365314141414564665141734b3934414363364a3231332e6a7067"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都不是我们的，而是别人的，只有时间是我们自己的财产。造物主交给我们，归我们所有的，只有这个不断流逝的、不稳定的东西。就连这个东西，谁只要愿意，都可以把它从我们手里剥夺走。</p>
<p>—— 古罗马哲学家：赛纳卡</p>
</blockquote>
<p>今天要介绍的是 <a target="_blank" rel="noopener" href="http://item.jd.com/11331635.html">《奇特的一生》</a> 这是一本关于时间的书，春节期间看到池建强在微信读书中推荐，于是就一口气读完了。该书讲述苏联科学家柳比歇夫将自己的一生用时间来计划，通过分析柳比歇夫「时间统计法」，作者认为这是让他生活得更好的秘密。</p>
<p>以下是我的读书感受。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/02/16/2016-02-16-make-friend-with-time/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/09/2016/11-%E6%98%A5%E8%8A%82%E6%BE%B3%E9%97%A8%E6%B8%B8%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/09/2016/11-%E6%98%A5%E8%8A%82%E6%BE%B3%E9%97%A8%E6%B8%B8%E8%AE%A1%E5%88%92/" itemprop="url">春节澳门游计划</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-09T03:00:00+08:00">
                2016-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index">
                    <span itemprop="name">生活</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>这是2016年春节爸妈来港和我一起过年时候，去澳门玩之前而做的旅游计划。出游时间是大年初二，澳门街头人潮汹涌，十分热闹。</p>
<p>计划的路线如下：香港上环港澳码头 → 澳门外港码头 → 新葡京酒店 → 玛嘉烈葡挞 → 议事亭前地 → 手信街 → 大三巴 → 澳门博物馆、炮台→ 新葡京酒店 → 澳门外港码头 → 威尼斯人酒店 → 渔人码头 → 澳门外港码头 → 香港上环港澳码头</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/02/09/2016/11-%E6%98%A5%E8%8A%82%E6%BE%B3%E9%97%A8%E6%B8%B8%E8%AE%A1%E5%88%92/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/08/2016/happy-chinese-new-year/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/08/2016/happy-chinese-new-year/" itemprop="url">新年快乐！</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-08T00:00:00+08:00">
                2016-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index">
                    <span itemprop="name">日常</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>祝诸君阖家欢乐，万事如意。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/02/06/2016/2016-02-06-programming-of-2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/06/2016/2016-02-06-programming-of-2015/" itemprop="url">2015 年度小结（技术方面）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-06T00:00:00+08:00">
                2016-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
        
          
            <p>从 2014 年末开始开发的一个互联网金融项目终于在今年三月份上线了，这是一个 Node.js 编写的 Web 服务，但上线仅仅是个开始，之后的半年时间我们仍在这个项目上进行着密集地开发。</p>
<p>就像 <a target="_blank" rel="noopener" href="https://jysperm.me/2015/01/1976">2014 年度的技术小结</a> 中提到的，2014 一整年我都在进行有关自动测试的实践，经过几个项目的积累，这个项目从头至尾都有着覆盖完整的自动测试，我所有的调试工作也都是借助自动测试完成的，我甚至没有在自己的电脑上运行过这个项目的前端页面。因为路由层面受业务影响很大，经常修改一些功能的行为，所以后来大部分测试都是针对 Model 层面的单元测试。</p>
<p>这个项目使用了一种「以数据结构为核心」的设计，所谓数据结构就是一个 JavaScript 的 Object, 对应着数据库中数据表的各个字段，这些代表着业务实体的 Object 在项目中的各个函数之间传递。绝大部分函数的参数和返回值都是这种 Object, 它们在这些 Object 上获得或修改数据，并将这些 Object 与数据库同步，即使需要传递额外的数据，也是将数据作为属性附加到相关的 Object 上。可以说这是一种非常 JavaScript 的风格，因为这些 Object 非常近似于数据库中的一行记录，所以在单元测试中很容易构造，非常大地简化了单元测试中「构造特定环境」的这个步骤 —— 函数的输入和输出都是特定结构的 Object, 这对于 JavaScript 来讲太简单了。</p>
<p>随着功能的添加，业务逻辑变得越来越复杂，因为 Node.js 强制 IO 操作异步的这个特征，异步流程控制变成了一个令人头痛的问题 —— 直到我发现了 Promise。Promise 是 <a target="_blank" rel="noopener" href="https://jysperm.me/2015/04/promise-abstract-of-async-task">对异步任务的一种抽象</a>，当我深入地理解了它的工作原理后，才认识到我在学习 Node.js 上走的最大的弯路就是很晚才开始了解和使用 Promise.</p>
<p>相比于编写 Callback 风格的异步代码，使用 Promise 意味着一种思路上的转变，虽然 Promise 的原理简单，但在具体的使用场景上还是需要自己做很多尝试的，例如具有分支的异步逻辑、循环地处理数据、逐级传递异常等。</p>
<p>在这个实践的过程中，我逐步地将自己的项目中的异步代码改成基于 Promise. 在和 Express 的配合中，我发现因为 Express 没有对 Promise 的支持，所以 Express 的路由定义实际上变成了 Promise 的「边界」，所有的 Promise 都要在这里进行一次转换，改成 Express 的错误处理机制。于是我想如果有一个支持 Promise 的路由框架将会是一件很有趣的事情，于是我花了几天的时间设计并实现了 <a target="_blank" rel="noopener" href="https://github.com/jysperm/Cichorium">Cichorium</a>, 这是一个代码只有一百来行，基于 Promise 来提供异步中间件和错误处理的路由框架。</p>
<p>在使用 Promise 的过程中，也让我对「异常」有了更加深入的认识，异常是现代语言所提供的非常强大的流程控制机制，让本来唯一一条通常的、正确的执行路径变得可以从任何一处中断，并进入一个所谓的异常处理流程。异常可能包括「预期到的情况」和「非预期的情况」，如果在自己的代码中抛出了异常，那么通常是属于可以预期到的情况，例如参数错误、前提条件不满足等，抛出异常的目的是为了中断正常流程，并通知调用者；而非预期的情况则可能是所依赖的库抛出的异常，或因运行时错误 JavaScript 引擎抛出的异常。</p>
<p>异常会被调用栈上离异常被抛出处最近的处理程序捕捉到，一旦异常处理程序「解决」了这个异常，其他的异常处理程序就不会再得到通知。所以处理程序应当只去处理已知的、必须在此处理的异常，然后将其他的异常继续向其他处理程序抛出，最后到达一个「边界」，例如作为 HTTP 相应发给客户端，或打印一条日志。</p>
<p>这个项目在上线初期时间赶得比较紧，加上经验不足，在上线后的前几个月时间一直都在遭遇性能问题。中间出现过几次因为并发请求过多，多个请求修改同一条数据进而出现的数据不一致的情况。本来是有一个通过简单的 Redis 锁限制一个用户同时只能有一个写入数据的请求的机制的，但毕竟不是根本的解决方案。于是我开始尝试使用 MySQL 的事务，将一组相关的 SQL 查询放入一个事务中执行，对于有前提条件的更新操作（例如扣余额后余额不能为负数），将前提条件作为一个更新条件，如果执行后发现并没有行被更新，就说明前提条件不满足，然后回滚这个事务，向客户端报告失败。借助于数据库提供的原子性和一致性，即使并发很高，或者程序崩溃，都不会出现数据不一致。</p>
<p>使用事务只是解决了在高并发情况下的数据一致性的问题，但并没有解决性能问题。这个项目中的数据主要是财务记录，用户的每一次操作都会生成财务记录，这些数据被用来追踪每一笔资金的流向，会被聚合起来用于给用户展示统计信息，这个过程需要对数据进行筛选、分组、排序等复杂的计算。</p>
<p>显然这些计算如果在数据库中计算会有更好的性能，因为不需要在程序和数据库之间传输大量的数据，而且 MySQL 应该会对这类计算有更好的优化。于是我开始补习 SQL, 将几乎全部的筛选、分组、排序逻辑都在 MySQL 中完成。同时我开始学习如何分析 MySQL 的性能瓶颈，最简单的就是慢查询日志，曾经一度有一些查询需要 300 秒的执行时间。至于解决方案，除了优化查询条件之外最主要的就是加索引了，我也花了一些时间来了解索引背后的原理和最佳实践。</p>
<p>这些统计数据和时间是强相关的，过去的数据通常来讲就不会再修改了，所以如果能够将这些数据的统计结果缓存起来，将会显著地提高性能。其实本来也有一个简单的缓存机制，用户访问统计信息后会被缓存，但一旦用户执行任何财务操作都会使整个缓存刷新。所以很容易想到的是进行更细粒度的缓存，即在时间的维度上应用所谓的「套娃娃缓存」，在 Redis 中以天为单位缓存发生的财务变动、当日结束时各项统计指标的值。如果某一天的财务数据发生变动，只需以前一天的数据为基础去计算之后的数据，大多数情况下历史数据是不会改变的，只会刷新当天的缓存。</p>
<p>这项修改花费了不少时间，因为需要重写所有生成统计数据的代码，在前一天的计算结果的基础上计算出当天的统计数据，并连同一些中间结果一起缓存起来，供下一天的计算使用。相当于将原来一个简单明了的计算过程被拆分成了若干个小步骤，步骤之间还需要通过 Redis 来交换数据，看似复杂，但减少了很多不必要的重复计算，上线之后将性能提高了差不多一个数量级。</p>
<p>这个项目大概是我这一年完成的最满意的项目了，我参与到了绝大部分的设计工作中，也完成了差不多一半的编程工作，从头至尾都有着完整的自动测试覆盖，借助 Promise 实现健壮的异步流程控制和异常处理，在高并发的情况下实践了事务、缓存、索引相关的知识。</p>
<hr>
<p>我从年初 <a target="_blank" rel="noopener" href="https://jysperm.me/2015/04/atom-getting-started/">开始使用 Atom</a> 完成我的全部工作，选择 Atom 并不是因为它已经有多么好用了，而是因为 Atom 有着优良的设计和活跃的社区。最近两年我工作都是使用 Node.js 来完成的，而 Atom 也基于 Node.js 和 Web 技术构建起来的，甚至 Atom 也是用 CoffeeScript 实现的，这种相同的技术栈，令我非常有「安全感」。我也在了解和学习 Atom 的实现，它有着完全插件化的架构和设计良好的 API, 对我后来重构 RootPanel 都非常有帮助。</p>
<p>在我了解 Atom 的过程中，我发现中文网络上对 Atom 的讨论非常分散，于是我创建了 <a target="_blank" rel="noopener" href="https://atom-china.org/">Atom 中文社区</a>，到年末已经有 800个注册用户和 1000 个帖子了。说实话，中文技术社区的氛围并不好，因为可能技术能力较强或英语水平较高的人会直接选择去参与官方的社区，目前也基本上是我一个人在回答问题、翻译官方博客和文档、汇总一些资料，不过既然我还在用 Atom, 就会一直将这个社区维护下去。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/HackPlan/RootPanel">RootPanel</a> 在 2015 年上半年依然在缓慢地进行着，因为通过阅读 Atom 的代码学习到了大量有关插件化设计的方法，所以我这半年并没有向 RootPanel 中添加新功能，而是一直在反复地重构 RootPanel 的架构。</p>
<p>首先是为其中的重要概念建立抽象，例如服务组件（MySQL 数据库、Nginx 站点之类）、计费方案（计费周期、价格、限制）、支付渠道、控制台上的控件等。之前虽然也有针对这些概念进行抽象，但基本上是写到哪里、需要什么接口，就添加一个相应的接口，缺乏一个全局性的规划。进而导致抽象出的概念不够简洁、不够彻底（有一些插件的逻辑仍散落在核心代码中）。</p>
<p>JavaScript 本身是一个很灵活的语言，对象本身是「无模式」的，属性和方法都可以随意地修改，也提供了「原型链」来支持对象之间的继承关系。为概念建立抽象的一种有效途径就是「面向对象」风格的设计，Atom 就采用了这样的设计，我觉得面向对象对于 RootPanel 可能同样很合适。</p>
<p>面向对象首先统一了「数据」和「行为」，让数据可以带有行为，而在执行这些行为的时候又不必显式地传递数据；对象本身也是一个抽象层级，只要两个对象有相同的属性和方法（而不论背后的行为），就可以被当作同一种对象操作，即所谓的「鸭子类型」，这对于插件化的系统而言十分便利。</p>
<p>于是我用了一部分面向对象的风格来重构 RootPanel, 将其中很多概念抽象为了类，为每个模块起一个恰当的名字，减少不同模块之间的依赖；为模块划分「级别」，建立层级一致的抽象 —— 即在任何一个层级来看，抽象都是完整的，让同层级的类来打交道，而不是将层次不一的类混在一起。</p>
<hr>
<p>在 2014 年我就一直对 Mongoose 有很多不满，一直想自己造一个轮子，在 RootPanel 的开发过程中也遇到了 Mongoose 的一些坑和一些难以实现的需求，于是今年终于行动起来了，然后就有了 <a target="_blank" rel="noopener" href="https://jysperm.me/2015/06/mabolo-mongodb-orm/">Mabolo —— 一个轻量级的 MongoDB ORM</a>。</p>
<p>我对 Mabolo 的定位是一个简单的、「没有魔法」的 ORM, 每个 Model 都是一个普通的 JavaScript 构造函数，而每个文档则都是由这个构造函数生成的实例 —— 除了几个用来保存内部状态的不可枚举属性之外和普通的对象没有任何区别。Mabolo 不去追踪数据被改变的情况，而是鼓励使用 MongoDB 的原子操作符进行数据更新，Mabolo 仅在更新后帮你将最新的数据同步到这个对象上。</p>
<p>嵌套对象是 MongoDB 的特色之一，在实际项目中也经常会用到这样的设计，于是我也为 Mabolo 添加了嵌入式对象的支持，允许将 Model 中某个字段的类型设置为另一个 Model. 在储存到数据库前会运行所有子 Model 的验证方法，在从数据库取出结果后会为每个子 Model 字段构造相应的对象，以便在这些子 Model 上运行更新和删除等方法。</p>
<hr>
<p>五月初的时候和 Yeechan 等人参加了 <a target="_blank" rel="noopener" href="http://segmentfault.com/a/1190000002749031">SegmentFault D-Day 上海站</a> 的活动，主要听了有关 Docker 和 React 的主题分享。</p>
<p>因为我开发 RootPanel 的经验，对 Docker 这种性能损耗极低的虚拟化技术自然十分感兴趣，在参加这次活动之前就去简单地了解过 Docker, 当时我对 Docker 的不解主要在于 Image 只能单继承，这样就不太容易像「搭积木」一样去组合自己想要的环境，这可能是因为文档上面那个搭积木的示意图对我的误导比较大。</p>
<p>经过这次的主题分享，我才比较全面地了解到基于 Docker 去部署应用的思路，即既然创建容器的成本是极低的，那么可以为系统中的每个部分去创建单独的 Image, 运行单独的容器，然后通过 Docker Compose 这类工具去组合容器。Dockerfile 描述了应用的运行环境和依赖项，而 docker-compose.yml 描述了如何将一个系统中所需要的各个部分组合起来，完成了关于一个系统的完整描述。在实际运行时，因为容器之间的联系非常少，通常只暴露几个网络端口，所以给整个系统带来了非常好的横向拓展的能力，系统的每个部分都可能会运行多个容器，甚至这些容器可能会分布在不同的物理服务器上，同时提供一致的服务。</p>
<p>因为 Docker 是内核级别的虚拟化，对系统调用的抽象代价很低，而因为使用了 AUFS 对文件系统进行抽象、需要建立虚拟网卡进行端口转发，所以磁盘和网络 IO 的抽象开销相对较大。所以 Docker 更适合计算密集型、依赖复杂（这样才能发挥 Docker Image 的优势）的程序，就是通常 Web 项目中负责处理请求的「应用」这部分，而将数据库等 IO 密集、部署简单、不频繁升级的程序直接部署在物理机上。</p>
<p>现在 Web 后端程序面临的主要挑战就是高并发，保证单个程序的稳定性，倒不如采用分布式的架构，将一个处理能力强的实例拆分为若干个处理能力较弱的实例，转而保证一旦有实例失效，可以立刻重新创建一个实例接替它继续工作。但如果在实例中储存了一些全局的状态（例如锁）就无法通过启动多个实例的方式来横向拓展。所以比较理想的实践就是将应用实现为「无状态」的，即容器中的应用只根据来自网络的请求进行计算，对数据库、缓存和文件系统的调用同样通过网络去请求容器外部的服务。这样才可以进一步利用 Docker 的优势 —— 容器可以根据规模需要随时去在不同的物理机上创建和销毁而不需要同步数据。</p>
<p>随着对 Docker 了解的深入，我开始意识到 Docker 对 RootPanel 这类 PaaS 平台是一个「杀手级」的应用，像 RootPanel 那样笨拙地使用一系列 Linux 的机制和工具去隔离用户和直接使用 Docker 相比毫无优势，让我很有将 RootPanel 改为基于 Docker 的架构的冲动。但想来想去还是放弃了这个想法，因为一方面这个改动可能会非常大，另一方面其实已经有了很多非常优秀的基于 Docker 的开源 PaaS 程序了。</p>
<p>后来我加入 <a target="_blank" rel="noopener" href="https://leancloud.cn/">LeanCloud </a>负责云引擎的开发工作，云引擎实际上就是一个基于 Docker 的 PaaS 平台，各方面都和 RootPanel 非常相似。既然日常的工作已经是这样一个项目了，所以进一步促使我中止了 RootPanel 的开发。但说实话我对 PaaS 还依然有兴趣，也许有一天我会根据我在 RootPanel 和 LeanCloud 的经验，重新设计一个最简架构的 PaaS 来纪念 RootPanel.</p>
<p>随着在工作中深入地了解 Docker, 在年末的时候我将我的服务器上应用全部换成了基于 Docker 来运行，这样的好处就是每个应用都可以有自己的环境，而且每个服务的环境和服务之间的依赖关系都被描述在了 Dockerfile 和 compose.yml 中，彻底解决了以前服务器上各种应用「乱七八糟」的现象，以后若要迁移服务器或重新部署将会变得非常容易。</p>
<hr>
<p>过去一年我花了不少时间断断续续地将「<a target="_blank" rel="noopener" href="http://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007VISQ1Y&linkCode=as2&tag=jysperm07-23">JavaScript 权威指南</a>」和「<a target="_blank" rel="noopener" href="http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011AP7RY&linkCode=as2&tag=jysperm07-23">计算机程序的构造和解释</a>」看完了，对 JavaScript 的了解也进了一步，其实 JavaScript 对函数式风格的代码还是有很不错的支持的。按我在 JavaScript 中对函数式编程的实践，最有价值的的两点就是「无状态」和「无副作用」。</p>
<p>随着前端应用越来越复杂，所展现的数据之间的逻辑关系也越来越复杂，也出现了很多框架来解决前端 UI 和数据（即状态）之间的同步问题，其中之一的 React 从一个非常有趣的角度来入手 —— UI 可以是应用状态的一个函数，给定一组状态就有一个确定的 UI. 如果每次状态发生变化都重新渲染整个 UI, 便可以极大地降低管理 UI 和 状态的复杂度。</p>
<p>React 还在浏览器提供的 DOM 上建立了一层抽象，在每次重新渲染 UI 时，React 操作的都是 Virtual DOM, 而后再去与真正的 DOM 进行对比，更新必要的部分。我觉得这种抽象还是非常有价值的，Virtual DOM 限制了很多操作，但它提供了优化性能的空间，也为将 React 程序迁移到非 Web 平台提供了可能性，例如后来我就尝试过在服务器端使用 React 来渲染 HTML.</p>
<p>后来我在 RootPanel 和其他一些项目上实验性地使用了 React, 我也使用了官方推荐的 JSX 来编写代码，React 这种将 JavaScript 作为应用主体的做法很不同于一些将 HTML 作为应用主体的框架。有一些人批评 JSX 将这些年好不容易才分开的 HTML 和业务逻辑（JavaScript 代码）又重新混在了一起。而我则认为「模板语言」的出现一方面是因为部分语言表现能力较弱，需要模板语言将 HTML 和琐碎的语法细节分离；另一方面则是试图在数据和冗长的 HTML 表现之间建立一层抽象。JavaScript 本来已有很不错的表现能力，JSX 又添加了一些与 HTML 相融合的语法；React 通过引入「组件」的概念来拓展 HTML 的标签，让用户可以自己创建包含内部逻辑和状态的标签，进而让 HTML 表现不再冗长，所以分离就变得不必要了。</p>
<p>总体上来讲我对 React 很有好感，因为我觉得 React 很好地实现了一些函数式编程的风格，来简化 UI 编程中对状态的管理，React 鼓励将组件设计为无状态的，同时将渲染过程设计为无副作用的，这样无论何时，只要状态发生改变就重新渲染整个 UI 即可。</p>
<p>在我后来编写 <a target="_blank" rel="noopener" href="https://github.com/leancloud/leanengine-sniper">LeanEngine Snipper</a> 的时候，需要在前端进行大量数据处理以便根据用户的筛选来展示图表。一开始没有考虑太多，部分函数是会修改其参数（往往是一个包含大量对象的数组）的，在后来支持用户修改筛选条件时就遇到了问题 —— 原始数据在绘图的各个环节中都有可能被修改，不得不在开始绘图之前对原始数据进行一次 clone, 在后来的性能分析中发现 98% 的时间都花费在了 clone 上面。</p>
<p>于是我不得不重构代码，让大部分函数不修改参数，而是在参数的基础上返回一个新的对象，将需要 clone 的数据减少到了最小，经过这次的优化，筛选的性能提高了 40 倍以上。从直观感受上来看，每个函数返回新的对象会消耗更多的资源，但在 JavaScript 中，返回新对象实际上只是在拷贝它的属性的引用，并不会花费多少时间，反倒是在 clone 对象时需要遍历所有的属性，才需要花费大量的 CPU 时间。</p>
<hr>
<p>因为最近两年都在使用 Node.js, 我希望也使用 Node.js 来驱动我的博客，我最后选择了插件化架构的 Hexo —— 一个静态博客生成器，我自己编写了 <a target="_blank" rel="noopener" href="https://github.com/jysperm/hexo-theme-simpleblock">主题</a>，并将博客的数据也托管在 <a target="_blank" rel="noopener" href="https://github.com/jysperm/blog">GitHub</a> 上。后来我将 <a target="_blank" rel="noopener" href="http://blog.rpvhost.net/">RP 主机博客</a>、<a target="_blank" rel="noopener" href="https://jybox.net/">粉丝团主页</a> 也都迁移到了 Hexo, 后来新建的 <a target="_blank" rel="noopener" href="http://pidan.cat/">皮蛋豆腐的博客</a> 也使用了 Hexo.</p>
<hr>
<p>今年我作为 <a target="_blank" rel="noopener" href="http://hackplan.com/">HackPlan</a> 的成员，参与了几次招聘，后来我也作为求职者参加了几次面试。</p>
<p>国外的一些职业，包括医生、律师，也包括工程师，都普遍地去打造自己的个人品牌，目的是为了找到更好的工作。确实在过去两年中这种个人品牌对我的工作是很有帮助的，在我面试的过程中，我去的几乎所有公司的面试官都表示曾经听说过我。虽说技术岗位以能力为先，但至少如果混个脸熟，双方会有一个基本的信任。</p>
<p>我当时说在找到工作之后会和大家分享一下参加面试的经验，但后来想了一下，写出来的话应该都是关于我没有选择的那些公司的负面评价，大家都是同行，这样不是很好，所以后来只写了 <a target="_blank" rel="noopener" href="https://jysperm.me/2015/11/join-leancloud">加入 LeanCloud</a> 的过程。</p>
<hr>
<p>说实话，现在使用 Node.js 的公司依然是少数，因此在求职时我也将 PHP 纳入了考虑。在我离开 PHP 之后，社区发生了许多变化，出现了像 Laravel 这样设计优良的一站式框架，composer 这个包管理器也被越来越多的人接受。为了重新捡起 PHP 这个技能，我花了一些时间用 Laravel 做了一个最简单的论坛系统的轮子 —— <a target="_blank" rel="noopener" href="https://github.com/jysperm/labbs-laravel">labbs-laravel</a>.</p>
<p>在之前，无论是 PHP 还是 Node.js 中，我都没有使用过像 Laravel 这种重量级的框架。Laravel 不同于国内一些粗制滥造的重量级框架，虽然它提供了很多功能，但却并不显得臃肿。首先 Laravel 并没有选择造轮子而是构建在 Packagist 中已有的包之上，它有着一个非常精简的核心架构，除了经典的 MVC 支持外，其他的各类功能（认证、缓存、队列）都被抽象成了「服务」，这些服务可以独立为单独的包发布在 Packagist 上，且同类的服务是可以互相替换的。</p>
<p>Laravel 对我来讲最大的亮点是 ORM 部分（Eloquent），我之前用过的 ORM 比较少，在实现 Mabolo 的过程中一直在纠结如何实现对象之间的引用关系。Eloquent ORM 将关系本身也抽象为了一个类，当你访问一个对象的关系字段时，得到的是一个「关系对象」，你可以在这个对象上进行筛选和查询等操作。其实这样的设计还是非常直观的，但因为我之前闭门造车，一直没能「独立发现」，在新的一年中我会用这样的思路去给 Mabolo 添加关系支持。</p>
<hr>
<p>最后如果做个总结的话，我这一年依然主要在编写 Node.js 代码，也写过少量的前端代码，对 JavaScript 的了解越来越深入。这一年的我在关注基于 Promise 的异步流程控制和错误处理、深入了解关系型数据库和 SQL、探索函数式风格的 JavaScript、探索和学习插件化架构的设计、借助 Docker 来管理应用的部署和拓展。</p>

          
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2016/01/31/2016/add-page-view-counter-for-ghost-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/31/2016/add-page-view-counter-for-ghost-blog/" itemprop="url">为 Ghost 博客添加页面访问计数器</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-31T23:37:00+08:00">
                2016-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      
        
          <p>博客搬迁到 Ghost 后，原来的 Post Views 无法显示一直是窝的一大心病。</p>
<p>众所周知 Ghost 是使用模板语言 handlebars 来开发主题的，这也就造成了主题开发者们很难输出一些动态内容，而只能使用其内置的助手函数输出有限的可变内容。</p>
<p>总不能就这样下去吧，于是窝经过了一番搜索，找到了这个东西 —— <a target="_blank" rel="noopener" href="http://busuanzi.ibruce.info/">不算子</a>。</p>
<p>看来困扰于静态页面访问计数的不止窝一个啊。然而看了一下，不算子并不提供可调用的 API，也就是说窝没办法在文章分页上显示每篇文章的点击数了。</p>
<p>这怎么行？于是窝动了自己写计数服务的念头。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/01/31/2016/add-page-view-counter-for-ghost-blog/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/52/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/52/">52</a><span class="page-number current">53</span><a class="page-number" href="/page/54/">54</a><span class="space">&hellip;</span><a class="page-number" href="/page/73/">73</a><a class="extend next" rel="next" href="/page/54/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1451</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
