<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Python,爬虫,多线程,技巧," />










<meta name="description" content="最近博主在优化一个爬虫程序，它是博主在 2017 年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进 30 岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关">
<meta property="og:type" content="article">
<meta property="og:title" content="使用多线程为你的 Python 爬虫提速的 N 种姿势，你会几种？">
<meta property="og:url" content="https://blog.feedscoin.com/2021/01/14/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%A0%E7%9A%84Python%E7%88%AC%E8%99%AB%E6%8F%90%E9%80%9F%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E7%A7%8D%EF%BC%9F/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="最近博主在优化一个爬虫程序，它是博主在 2017 年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进 30 岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png">
<meta property="og:image" content="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png">
<meta property="og:image" content="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png">
<meta property="og:image" content="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png">
<meta property="og:image" content="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png">
<meta property="og:image" content="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png">
<meta property="article:published_time" content="2021-01-14T12:35:47.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.169Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="爬虫">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="技巧">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/2021/01/14/使用多线程为你的Python爬虫提速的N种姿势，你会几种？/"/>





  <title>使用多线程为你的 Python 爬虫提速的 N 种姿势，你会几种？ | 逐流小站</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-MW47YH6RH0', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/01/14/%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%A0%E7%9A%84Python%E7%88%AC%E8%99%AB%E6%8F%90%E9%80%9F%E7%9A%84N%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E7%A7%8D%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">使用多线程为你的 Python 爬虫提速的 N 种姿势，你会几种？</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-14T20:35:47+08:00">
                2021-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近博主在优化一个爬虫程序，它是博主在 2017 年左右刚接触 Python 时写下的一个程序。时过境迁，当 Python 2.X 终于寿终正寝成为过去，当博主终于一只脚迈进 30 岁的大门，一切都来得猝不及防，像一阵龙卷风裹挟着回忆呼啸而去。和大多数学习 Python 的人一样，博主学习 Python 是从写爬虫开始的，而这个爬虫程序刚好是那种抓取“宅男女神”的程序，下载图片无疑是整个流程里最关键的环节，所以，整个优化的核心，无外乎提升程序的稳定性、提高抓取速度。所以，接下来，我会带大家走近 Python 中的多线程编程，涉及到的概念主要有<code>线程(池)</code>、<code>进程(池)</code>、<code>异步I/O</code>、<code>协程</code>、<code>GIL</code>等，而理解这些概念，对我们而言是非常重要的，因为它将会告诉你选择什么方案更好一点。想让你的爬虫更高效、更快吗？在这里就能找到你的答案。</p>
<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>现在，假设我们有一组图片的地址(URL)，我们希望通过<code>requests</code>来实现图片的下载，为此我们定义了<code>Spider</code>类。在这个类中，我们提供了<code>getImage()</code>方法来完成下载这个动作。我们可以非常容易地写出一个“单线程”的版本，但这显然这不是我们今天这篇博客的目的。此时，我们来考虑一个问题，怎么样实现一个“多线程”的版本？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, urls</span>):</span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.session.headers[<span class="string">&#x27;User-Agent&#x27;</span>] = fake_useragent.UserAgent().random</span><br><span class="line">        self.session.headers[<span class="string">&quot;Referer&quot;</span>] = <span class="string">&quot;https://www.nvshens.org&quot;</span></span><br><span class="line">        self.urls = urls</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getImage</span>(<span class="params">self, url, fileName, retries=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">            response = self.session.get(url, </span><br><span class="line">              allow_redirects=<span class="literal">False</span>, </span><br><span class="line">              timeout=<span class="number">10</span>, </span><br><span class="line">              proxies=<span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line">            response.raise_for_status()</span><br><span class="line">            data = response.content</span><br><span class="line">            imgFile = <span class="built_in">open</span>(fileName, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">            imgFile.write(data)</span><br><span class="line">            imgFile.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> :</span><br><span class="line">            <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">                retries -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.getImage(url, fileName, retries):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h1 id="线程与线程池"><a href="#线程与线程池" class="headerlink" title="线程与线程池"></a>线程与线程池</h1><p>既然提到了线程，我们会非常自然地想到 <code>Thread</code> 和 <code>ThreadPool</code> ，而这几乎是所有编程语言里都有的通用型概念。可是，Python 中的多线程其实是一种“假”的多线程，这又从何说起呢？答案是<strong>全局解释器锁</strong>(<strong>GIL</strong>)，原来在设计 Python 解释器的时候，为了保证同时只有一个线程在运行，引入了这样一个锁，你可以类比游戏开发时主循环的概念来辅助理解。那为什么又说 Python 中的多线程是一种“假”的多线程呢？这是因为它没法发挥出多核的优势，每个线程在执行前都要先获得 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock">GIL</a> ，这就导致一个问题，即使你有多个核心，线程永远只能用到其中一个核，因为多线程在 Python 中只能交替执行。以一言蔽之， Python 中 I&#x2F;O 密集型任务相比 CPU 密集型任务更能充分发挥多线程的好处。所以，像爬虫这种和网络打交道的事物，是非常适合使用多线程来提高效率的。在这里，我们我们要介绍的是 <code>Thread</code> 和 <code>ThreadPool</code> 以及 <code>ThreadPoolExecutor</code>。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>首先，我们需要了解的是，Python 中的 Thread ，实际上先后有<code>thread</code>和<code>threading</code>两种模块，它们的关系有一点像 .NET 里的<code>Thread</code>和<code>Task</code>，考虑到<code>thread</code>的使用频率非常低，这里我们更推荐大家使用<code>threading</code>，它提供了更高级的、完全的线程管理。例如，我们现在面临的这个“多线程”下载的问题，使用<code>threading</code>的话可以这样解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Thread下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThread</span>(<span class="params">self</span>):</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.urls)):</span><br><span class="line">        thread = threading.Thread(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>,)</span><br><span class="line">        )</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thread.start()</span><br></pre></td></tr></table></figure>
<p>可以注意到，当我们需要构造一个线程时，只需要指定<code>target</code>和<code>args</code>两个参数，其中，前者是指线程执行的方法，后者是指传递给线程所执行的方法的参数。当我们需要启动线程时，只需要调用线程的<code>start()</code>方法，而通过<code>setDaemon()</code>方法则可以设置一个线程为守护线程。关于守护线程，这里简单说明一下，一旦一个线程被设置为守护线程，那么，只要线程执行的方法中存在等待时间譬如<code>time.sleep(1)</code>，此时等待时间下面的代码都不会再执行。如果线程中执行的方法是一个耗时的操作，此时，我们还可以通过<code>join()</code>方法来阻塞主线程，以确保主线程再子线程执行完后再结束。除了这种函数式的使用方法以外，我们还可以通过继承<code>Thread</code>类并重写其<code>run()</code>方法的方式，对于这一点可以参考官方文档中的<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/threading.html#thread-objects">线程对象</a>。</p>
<p><img src="https://i.loli.net/2021/01/15/I6jZ35R8dDvJUsW.png" alt="使用Thread下载"></p>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>对于线程，我们都知道它是作为一种系统资源而存在的，所以，和这个世界上的大多数资源一样，无法供我们肆意地挥霍和浪费。在 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/2414960312/">.NET Core 中对象池(Object Pool)的使用</a> 这篇博客中，我曾经大家介绍过“对象池”这种设计，和这篇博客中所提到的原理一样，线程池相对于普通线程而言多了一种可复用的可能性，这意味着我们可以用有限的线程来下载可能无限多的图片资源。在 Python 中我们使用 <code>threadpool</code> 模块来实现线程池的功能，需要注意的是这是一个第三方的模块。下面，我们来一起看看具体的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPool下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThreadPool</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append((<span class="literal">None</span>, &#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = threadpool.ThreadPool(poolSize)</span><br><span class="line">    requests = threadpool.makeRequests(self.getImage, args)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure>
<p>在这里，我们声明了一个指定大小的线程池，通过一个方法<code>getImage()</code>和一组参数<code>args</code>来构造“请求”，再将这些请求全部放进线程池里，此时，线程池会自动等待这些“请求”执行完毕。这里唯一比较难理解的，可能是如何构造参数<code>args</code>，尤其是当被执行的方法需要传递多个参数的时候。其实这里有两种传参的方式，第一种是按数组来解构，此时我们可以写<code>[([&#39;&#39;,&#39;&#39;], None), ([&#39;&#39;,&#39;&#39;], None)]</code>；而第二种则是按字典来解构，此时我们可以写<code>[(None, &#123;&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;&#125;), (None, &#123;&#39;url&#39;:&#39;&#39;, &#39;fileName&#39;:&#39;&#39;&#125;)</code>。两者的区别主要在<code>None</code>的位置，不知道大家有没有发现规律。这里我们准备了张图片，而线程池最大线程是 3 个，理论上某个线程会被重复使用，实际结果又是如何呢？</p>
<p><img src="https://i.loli.net/2021/01/15/kGgPXS8vHMwxoIN.png" alt="使用ThreadPool下载"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>对于<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a>，相信不用我多说什么，你就能知道它是做什么的吧，这就是博主反复提及的命名规范的问题。简而言之，Python 在 <code>concurrent.futures</code>中为我们提供了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor">ProcessPoolExecutor</a> 两个高级接口，它们都继承自同一个抽象类<code>Executor</code>，它可以让我们在线程池或者进程池中异步地执行回调函数，属于官方提供的标准的“<strong>线程池</strong>”和“<strong>进程池</strong>”模块，下面，我们来一起看看具体的使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ThreadPoolExecutor下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByThreadPoolExecutor</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">      args.append(&#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=poolSize)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        task = pool.submit(self.getImage(arg[<span class="string">&#x27;url&#x27;</span>], arg[<span class="string">&#x27;fileName&#x27;</span>]), arg)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    wait(tasks, return_when=ALL_COMPLETED)</span><br><span class="line">    <span class="comment"># tasks = pool.map(lambda arg:self.getImage(arg[&#x27;url&#x27;], arg[&#x27;fileName&#x27;]), args)</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，<code>submit()</code>方法和<code>map()</code>方法的区别，前者相当于声明线程后并不立即执行，故而，需要<code>wait()</code>方法来等待所有任务执行结束；而后者则相当于声明线程并理解执行，故而，返回值实际是每一个任务执行的结果的集合，这里就隐隐有一点 .NET 中 <code>Task</code> 的味道啦！同样地，我们给了一个最大线程数：3，它能否得到和<code>threadpool</code> 类似的结果呢？我们拭目以待：</p>
<p><img src="https://i.loli.net/2021/01/15/jeJTHlkiuors4zw.png" alt="使用ThreadPoolExecutor下载"></p>
<h1 id="进程与进程池"><a href="#进程与进程池" class="headerlink" title="进程与进程池"></a>进程与进程池</h1><p>看到这里，可能有读者朋友会忍不住吐槽，博主你三十岁不到，怎么越来越糊涂了啊，你这博客标题明明写的是多线程，怎么写着写着就写到进程上来了呢？其实，这里是紧接着 GIL 这个话题来讲的。既然 Python 中的多线程更适合 I&#x2F;O 密集型的任务，那么，是不是说 Python 不适合处理 CPU 密集型的任务呢？答案是否定的，我们这里将多进程理解为并行就会更容易想明白一点。我们都知道操作系统可以同时执行多个任务，而这每一个任务其实就是一个进程，而每个进程内又可以同时执行多个子任务，这每一个子任务其实就是一个线程。这样说，我们或许就能明白，这意味着，如果我们的确需要并行地去处理某些任务，进程(池)或许是个不错的选择。同样地，这里介绍的是，<code>Process</code>、<code>ProcessPool</code> 和 <code>ProcessPoolExecutor</code>。</p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>关于进程，我个人感觉比线程要更好理解一点，因为不论是 Windows 下的任务管理器，亦或者是我们经常听到的“杀进程”，它都不算是一个特别陌生或者抽象的概念，而线程这种东西呢，大概是只有程序员会关注，同时爱之弥深、恨之弥切的一种事物。庆幸的是，在 Python 中线程与进程在代码的编写上是非常相似的，这里我们需要用到的是<code>multiprocessing</code>模块，下面，我们来一起看看 Python 中的进程的的使用方法，你会发现只需要改一下<code>threading.Thread()</code>这部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Process下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcess</span>(<span class="params">self</span>):</span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(self.urls)):</span><br><span class="line">        proc = multiprocessing.Process(</span><br><span class="line">          target=self.getImage, </span><br><span class="line">          args=(self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>,)</span><br><span class="line">        )</span><br><span class="line">        process.append(proc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> process:</span><br><span class="line">        proc.start()</span><br></pre></td></tr></table></figure>
<p>此时，我们可以得到下面的结果，可以发现它都是在主线程上运行：</p>
<p><img src="https://i.loli.net/2021/01/16/oyJKlOCazQX3RcZ.png" alt="使用Process下载"></p>
<h2 id="ProcessPool"><a href="#ProcessPool" class="headerlink" title="ProcessPool"></a>ProcessPool</h2><p>既然有“线程池”，又怎么能少得了进程池呢？同样地，它位于<code>multiprocessing</code>模块中，通过<code>apply()</code>方法来执行某个任务，下面是一个基本的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用multiprocessing.Pool()下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcessPool</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append((self.urls[index], <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>, ))</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = multiprocessing.Pool(poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.apply(self.getImage, arg)</span><br></pre></td></tr></table></figure>

<p>有朋友难免会好奇“进程池”和“线程池”有什么不一样，我想，下面这张图会告诉你答案：</p>
<p><img src="https://i.loli.net/2021/01/15/jGKQ2qnVtz9c4DL.png" alt="使用multiprocessing.Pool()下载"></p>
<h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p>和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">ThreadPoolExecutor</a> 类似，我们还可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor">ProcessPoolExecutor</a> 来实现“进程池”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ProcessPoolExecutor下载</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloadByProcessPoolExecutor</span>(<span class="params">self, poolSize=<span class="number">3</span></span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="comment"># 构造线程参数</span></span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        args.append(&#123;<span class="string">&#x27;url&#x27;</span>: self.urls[index], <span class="string">&#x27;fileName&#x27;</span>: <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># 线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; poolSize:</span><br><span class="line">        poolSize = count</span><br><span class="line">    <span class="comment"># 构造线程池</span></span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=poolSize)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        pool.submit(self.getImage(arg[<span class="string">&#x27;url&#x27;</span>], arg[<span class="string">&#x27;fileName&#x27;</span>]), arg)</span><br></pre></td></tr></table></figure>

<p>可以看到，“进程池”中的代码都是在主线程上执行的，这一点和<code>multiprocessing.Pool()</code>完全一致：</p>
<p><img src="https://i.loli.net/2021/01/16/iCFSawkEMjN2PzO.png" alt="使用ProcessPoolExecutor下载"></p>
<h1 id="协程与异步-I-O"><a href="#协程与异步-I-O" class="headerlink" title="协程与异步 I&#x2F;O"></a>协程与异步 I&#x2F;O</h1><p>其实，如果单单从 I&#x2F;O 密集型和 CPU 密集型两种场景而言，这篇博客到这里就差不多应该结束啦！不过呢，博主好奇 Scrapy 这个爬虫框架的实现原理，发现它是基于 Twisted 这样一个异步网络框架，考虑到目前为止，我们通过 <code>requests</code> 来下载图片都是采用同步的方式，除了任务调度上的优化以外，任务本身还存在一定的优化空间，所以，这里就顺带着一起整理出来，这里主要结合 <code>asyncio</code> 和 <code>requests</code> 来对 Python 中关于异步 I&#x2F;O 、协程等的使用方法进行演示和说明。</p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio.html">asyncio</a> 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async&#x2F;await</strong> 语法，它是构建 I&#x2F;O 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。它提供了类似并发地执行<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine">协程</a>、网络 I&#x2F;O 和进程间通信(<strong>IPC</strong>)、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-eventloop.html#asyncio-event-loop">事件循环</a>等等的能力，例如，我们可以通过下面的代码来创建和使用<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/asyncio-task.html#coroutine">协程</a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">what, delay</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># Python 3.7 + </span></span><br><span class="line">asyncio.rum(main())</span><br><span class="line"><span class="comment"># Python 3.7 -</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>参考官方文档，我们还可以使<code>create_task()</code>方法来创建<code>asyncio</code>的并发任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Python 3.7 + </span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># Python 3.7 -</span></span><br><span class="line">    task1 = asyncio.get_event_loop().(say_after(<span class="string">&#x27;你好&#x27;</span>, <span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.get_event_loop().(say_after(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<p>这是因为 Python 中的协程、任务 和 Future 都是可等待对象，故而，凡有 <strong>async</strong> 处皆可 <strong>await</strong> ，果然，主流编程语言的最终走向是如此的一致啊，回头想想 .NET 中 Thread 、 ThreadPool 、 Task 的进化历程，是不是有种“<strong>天下大势，分久必合</strong>”的感觉呢？</p>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>好了，当我们对异步 I&#x2F;O、协程有了一个基本的了解以后，我们就可以考虑结合着 <code>requests</code> 来做一点小小的尝试，我们大多数时候写的 <code>requests</code> 相关的代码，基本上都是博主这里<code>getImage()</code>类似的画风，最多再加上流式传输(Stream) 和 <code>iter_content</code>。为了配合异步 I&#x2F;O 来使用，我们这里需要定义一个异步的方法<code>getImageAsync()</code>，一起来看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">getImageAsync</span>(<span class="params">self, url, fileName, retries=<span class="number">5</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.currentThread().name&#125;</span> -&gt; <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: fake_useragent.UserAgent().random,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&quot;https://www.nvshens.org&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        future = asyncio.get_event_loop().run_in_executor(</span><br><span class="line">            <span class="literal">None</span>, </span><br><span class="line">            functools.partial(requests.get, url, headers=headers)</span><br><span class="line">        )</span><br><span class="line">        response = <span class="keyword">await</span> future</span><br><span class="line">        data = response.content</span><br><span class="line">        imgFile = <span class="built_in">open</span>(fileName, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        imgFile.write(data)</span><br><span class="line">        imgFile.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">await</span> self.getImageAsync(url, fileName, retries):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们还需要定义<code>downloadAsync()</code>方法，这里我们使用了<code>create_task()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">downloadAsync</span>(<span class="params">self</span>):</span><br><span class="line">    count = <span class="built_in">len</span>(self.urls)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">        url = self.urls[index]</span><br><span class="line">        fileName = <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">str</span>(index)&#125;</span>.jpg&#x27;</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.get_event_loop().create_task(self.getImageAsync(url, fileName))</span><br></pre></td></tr></table></figure>

<p>此时，我们可以在入口函数中这样调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spider = Spider(urls)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(spider.downloadAsync())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<p>看看结果：</p>
<p>![异步I&#x2F;O + Requests 实现并行下载]](<a target="_blank" rel="noopener" href="https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png">https://i.loli.net/2021/01/16/mhtcT78dswjgERa.png</a>)</p>
<p>这里，针对本文中提到的各种方法，博主做了一个简单对比：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>Thread</td>
<td>0:00:01.789790</td>
</tr>
<tr>
<td>ThreadPool</td>
<td>0:00:00.134065</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>0:00:06.510224</td>
</tr>
<tr>
<td>Process</td>
<td>0:00:00.100506</td>
</tr>
<tr>
<td>ProcessPool</td>
<td>0:00:11.046871</td>
</tr>
<tr>
<td>ProcessPoolExecutor</td>
<td>0:00:02.226153</td>
</tr>
<tr>
<td>AsyncIO</td>
<td>0:00:04.096083</td>
</tr>
</tbody></table>
<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>本文从线程(池)、进程(池)和异步 I&#x2F;O 三个方面探讨和尝试了多线程编程在 Python 爬虫领域的简单应用。其实，除了以上这些优化的思路以外，我们还可以借助队列(<strong>Queue</strong>)这类数据结构来改善现有方案的设计，大家可以注意到我给<code>getImage()</code>方法增加了错误重试的机制，这同样是为了增强爬虫程序的健壮性，而关于这个错误重试机制，考虑通过装饰器来进行改良则又是一个新的努力的方向，所以说，没有 deadline 才能让我们不断地自我改善，而有 deadline 只能让我们赶紧做完赶紧清净。好了，以上就是这篇博客的全部内容啦，最后要送给大家一个福利，本文中援引的爬虫程序已开源，地址是：<a target="_blank" rel="noopener" href="https://github.com/qinyuanpei/zngirls">https://github.com/qinyuanpei/zngirls</a>，感兴趣的朋友可以自己去玩一玩，你懂的哦！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/%E7%88%AC%E8%99%AB/" rel="tag"># 爬虫</a>
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
            <a href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag"># 技巧</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/10/2021/2021-01-10-macbook-air-apple-silicon/" rel="next" title="入手 MacBook Air (Apple Silicon)">
                <i class="fa fa-chevron-left"></i> 入手 MacBook Air (Apple Silicon)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/87ba8d8b.html" rel="prev" title="从 Composition API 源码分析 getCurrentInstance() 为何返回 null">
                从 Composition API 源码分析 getCurrentInstance() 为何返回 null <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1579</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A5%94%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">楔子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">线程与线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread"><span class="nav-number">2.1.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPool"><span class="nav-number">2.2.</span> <span class="nav-text">ThreadPool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">2.3.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-number">3.</span> <span class="nav-text">进程与进程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Process"><span class="nav-number">3.1.</span> <span class="nav-text">Process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProcessPool"><span class="nav-number">3.2.</span> <span class="nav-text">ProcessPool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProcessPoolExecutor"><span class="nav-number">3.3.</span> <span class="nav-text">ProcessPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5-I-O"><span class="nav-number">4.</span> <span class="nav-text">协程与异步 I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#asyncio"><span class="nav-number">4.1.</span> <span class="nav-text">asyncio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#requests"><span class="nav-number">4.2.</span> <span class="nav-text">requests</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
