<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码,.NET Core,并发,中间件," />










<meta name="description" content="打算开一个新的专栏——源代码探案系列，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“生手”到“熟练工”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个">
<meta property="og:type" content="article">
<meta property="og:title" content="源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter">
<meta property="og:url" content="https://blog.feedscoin.com/2021/03/04/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="打算开一个新的专栏——源代码探案系列，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“生手”到“熟练工”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-04T12:13:47.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.220Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="源码">
<meta property="article:tag" content=".NET Core">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/2021/03/04/源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter/"/>





  <title>源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2021/03/04/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%20ConcurrencyLimiter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">源代码探案系列之 .NET Core 并发限制中间件 ConcurrencyLimiter</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-04T20:13:47+08:00">
                2021-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
        <p>打算开一个新的专栏——<strong>源代码探案系列</strong>，目的是通过源代码来探索更广阔的技术世界。因为我越来越意识到，我可能缺乏一个结构化的知识体系，虽然处在一个碎片化的时代，从外界接收了大量的信息，可这些碎片化的信息，到底能不能转化为自身可用的知识，其实是需要去认真思考一番。尤其是当我注意到，许多人工作多年，在经历过从“<strong>生手</strong>”到“<strong>熟练工</strong>”这种蜕变以后，居然还是会害怕原理性内容的考察。我承认，程序员这个职业更像是一个“<strong>手艺人</strong>”，可我更想说一句古人的话——<strong>君子不器</strong>。什么是器呢？“<strong>形而上者谓之道，形而下者谓之器</strong>”，用一句更直白的话来说，就是“<strong>不能知其然而不知其所以然</strong>”，这是我一个非CS科班出身的程序员，想去写这样一个专栏的初衷，因为在我看来，“<strong>器</strong>”是永远学不完的，而“<strong>道</strong>”虽然听起来虚无缥缈，实则“<strong>朝闻道，夕死可矣</strong>”。</p>
<p>作为这个专栏的第一篇博客，我打算从 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件开始。并发是一个爱恨交织的话题，我们喜欢高并发，因为这是程序员跻身高手行列的好机会；我们厌恶并发，因为它引入了多线程、锁、信号量这些复杂的东西。相信大家都曾被并发困扰过，古人云：<strong>他山之石，可以攻玉</strong>，还有什么比阅读源代码更朴实无华的“学习”呢？你找大牛，大牛可能忙着开会、做PPT；你找同事，同事里可能十个有八个都不知道啊。这个中间件的核心是 <code>IQueuePolicy</code> ，其位于以下<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter/src/QueuePolicies">位置</a>，它定义了两个核心的方法：<code>TryEnterAsync()</code> 和 <code>OnExit()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueuePolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其默认实现<code>QueuePolicy</code>中，<code>TryEnterAsync()</code>方法，决定着一个请求是会被拒绝还是接受。具体是怎么做呢？它定义了一个最大的并发请求数目，如果实际数超过了最大的并发请求数目，那么请求将会被拒绝。反之，请求将被接受。再仔细看，我们就会发现，它内部使用了<code>SeamphoreSlim</code>和<code>Interlocked</code>，所以，聪明的小伙伴们应该立马会联想到，这两种锁各自的作用是什么。</p>
<p>其中，<code>Seamphore</code> 是一个 Windows 内核中的一个同步信号量，适用于在多个有限的线程资源中共享内存资源，它就像一个栅栏，本身具有一定的容量，当线程数量达到这个容量后，新的线程就无法再通过，直到某个线程执行完成。<code>SeamphoreSlim</code>是<code>Seamphore</code>优化后的版本，在性能上表现更好一点，更推荐大家使用<code>SeamphoreSlim</code>。</p>
<p>而 <code>Interlocked</code> 的则是我们熟悉的原子操作，它可以在多个线程中，对共享的内存资源进行原子加或者原子减操作。在这里，<code>Interlocked</code>主要用来控制并发请求数的加和减。如果当前的并发请求数小于最大的并发请求数，表示还可以允许新的请求进来，此时，<code>TryEnterAsync()</code>方法会返回true。如果此时的并发请求数大于最大的并发请求数，则需要对当前请求数进行减操作，此时，<code>TryEnterAsync()</code>方法会返回false。</p>
<p>一旦搞清楚这一点，结合中间件的代码，我们可以非常容易地想明白,这个并发控制的实现思路。下面是<code>QueuePolicy</code>中<code>TryEnterAsync()</code>和<code>OnExit()</code>两个方法的实现，分别代表了“<strong>加锁</strong>”和“<strong>解锁</strong>”两个不同的阶段。某种程度上，<code>Seamphore</code>更像一个水闸，每次可以通过的“<strong>流量</strong>”是固定的，超出的部分会被直接“<strong>拒绝</strong>”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“加锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a return value of &#x27;false&#x27; indicates that the request is rejected</span></span><br><span class="line">    <span class="comment">// a return value of &#x27;true&#x27; indicates that the request may proceed</span></span><br><span class="line">    <span class="comment">// _serverSemaphore.Release is *not* called in this method, </span></span><br><span class="line">    <span class="comment">// it is called externally when requests leave the server</span></span><br><span class="line">    <span class="built_in">int</span> totalRequests = Interlocked.Increment(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当前请求次数 &gt; 最大请求次数，返回false表示拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (totalRequests &gt; _maxTotalRequest) &#123;</span><br><span class="line">        Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Task task = _serverSemaphore.WaitAsync();</span><br><span class="line">    <span class="keyword">if</span> (task.IsCompletedSuccessfully) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SemaphoreAwaited(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“解锁”</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _serverSemaphore.Release();</span><br><span class="line">    Interlocked.Decrement(<span class="keyword">ref</span> _totalRequests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="揭秘-StackPolicy"><a href="#揭秘-StackPolicy" class="headerlink" title="揭秘 StackPolicy"></a>揭秘 StackPolicy</h1><p>除了<code>QueuePolicy</code>这种实现以外，官方还提供了<code>StackPolicy</code>的实现。从名称上，我们就能大致区分出它们的不同，因为我相信大家都能拎得清“队列”和“栈”。在实现<code>StackPolicy</code>的过程中，首先会判断是否还有访问请求次数<code>_freeServerSpots</code>，直接返回true，确保中间件可以继续执行。如果<code>_queueLength</code>和我们设置的队列最大容量相同，此时，表示队列已满，需要先取消之前的请求，并保留后来的请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValueTask</span>&lt;<span class="title">bool</span>&gt; <span class="title">TryEnterAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_freeServerSpots &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;<span class="built_in">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列已满，则取消之前的请求，即_head</span></span><br><span class="line">        <span class="keyword">if</span> (_queueLength == _maxQueueCapacity) &#123;</span><br><span class="line">            _hasReachedCapacity = <span class="literal">true</span>;</span><br><span class="line">            _buffer[_head].Complete(<span class="literal">false</span>);</span><br><span class="line">            _queueLength--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tcs = _cachedResettableTCS ?? </span><br><span class="line">            = <span class="keyword">new</span> ResettableBooleanCompletionSource(<span class="keyword">this</span>);</span><br><span class="line">        _cachedResettableTCS = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_hasReachedCapacity || _queueLength &lt; _buffer.Count) &#123;</span><br><span class="line">            _buffer[_head] = tcs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _buffer.Add(tcs);</span><br><span class="line">        &#125;</span><br><span class="line">        _queueLength++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment _head for next time</span></span><br><span class="line">        <span class="comment">// 如果_head = 最大队列容量，则_head需要移动至首位</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="keyword">if</span> (_head == _maxQueueCapacity) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.GetValueTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_bufferLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queueLength == <span class="number">0</span>) &#123;</span><br><span class="line">            _freeServerSpots++;</span><br><span class="line"></span><br><span class="line">            f (_freeServerSpots &gt; _maxConcurrentRequests) &#123;</span><br><span class="line">                _freeServerSpots--;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;OnExit must only be called once per successful call to TryEnterAsync&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step backwards and launch a new task</span></span><br><span class="line">    <span class="keyword">if</span> (_head == <span class="number">0</span>) &#123;</span><br><span class="line">        _head = _maxQueueCapacity - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _head--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _buffer[_head].Complete(<span class="literal">true</span>);</span><br><span class="line">    _queueLength--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，现在，你可以感受到这两种策略的差异了，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。此时，如果我们再回过头来看 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 这个中间件的实现，就会有种恍然大悟的感觉。</p>
<h1 id="揭秘-Middleware"><a href="#揭秘-Middleware" class="headerlink" title="揭秘 Middleware"></a>揭秘 Middleware</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure we only ever call GetResult once on the TryEnterAsync ValueTask b/c it resets.</span></span><br><span class="line">    <span class="comment">// 以下代码片段，其实都是调用IQueuePolicy.TryEnterAsync()</span></span><br><span class="line">    <span class="keyword">var</span> waitInQueueTask = _queuePolicy.TryEnterAsync();</span><br><span class="line">    <span class="built_in">bool</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitInQueueTask.IsCompleted) &#123;</span><br><span class="line">        ConcurrencyLimiterEventSource.Log.QueueSkipped();</span><br><span class="line">        result = waitInQueueTask.Result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> (ConcurrencyLimiterEventSource.Log.QueueTimer())</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">await</span> waitInQueueTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当result为true，表示请求被接收，此时，让中间件继续执行</span></span><br><span class="line">    <span class="comment">// 切记：调用_queuePolicy.OnExit()来释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _queuePolicy.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是请求被拒绝的情况，修改状态码以及输出错误信息</span></span><br><span class="line">        ConcurrencyLimiterEventSource.Log.RequestRejected();</span><br><span class="line">        ConcurrencyLimiterLog.RequestRejectedQueueFull(_logger);</span><br><span class="line">        context.Response.StatusCode = StatusCodes.Status503ServiceUnavailable;</span><br><span class="line">        <span class="keyword">await</span> _onRejected(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就理清了整个中间件的运作机制，<a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ConcurrencyLimiter/src/ConcurrencyLimiterMiddleware.cs">ConcurrencyLimiterMiddleware</a> 中注入了<code>IQueuePolicy</code>这个接口，当一个新的请求进来，中间件会调用<code>IQueuePolicy</code>接口的<code>TryEnterAsync()</code>方法，该方法决定了一个请求是会被接受还是拒绝。当请求被接受的时候，中间件会调用<code>_next(context)</code>让请求继续往下走；当请求被拒绝的时候，中间件会修改 HTTP 状态码(503) 和 返回值，保证调用者可以收到错误信息。这就是这个中间件全部的秘密。而如果要在项目中使用这个中间件，同样是非常简单的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 中间件基本法，先注册后使用</span></span><br><span class="line"><span class="comment">// ConfigureServices()</span></span><br><span class="line"><span class="comment">// 或者 services.AddQueuePolicy()</span></span><br><span class="line">services.AddStackPolicy(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">    options.RequestQueueLimit = <span class="number">25</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure()</span></span><br><span class="line">app.UseConcurrencyLimiter();</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>这篇博客，主要揭秘了 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 中间件，这个中间件的主要功能是控制 ASP.NET Core 中的请求并发。作为这个中间件的核心，微软为 <code>IQueuePolicy</code> 接口提供了 <code>QueuePolicy</code> 和 <code>StackPolicy</code> 两种不同的策略实现。其中，<code>QueuePolicy</code>是一个水闸，“多”出来的流量会被直接拒绝掉。<code>StackPolicy</code>是一个垂直的管道，每次都是先取消底部的请求，再让新的请求从顶部进来。对于我们而言，这个中间件最值得学习的地方，其实是<code>SeamphoreSlim</code>和<code>Interlocked</code>，我们经常提到“<strong>锁</strong>”，其实，“<strong>锁</strong>”不单单是指 .NET 中<code>Monitor</code>的语法糖，即<code>lock</code>关键字，在同步信号量以及线程同步的相关话题中，我们还会接触到譬如 <strong>Mutex(互斥锁)<strong>、ReaderWriterLockSlim、</strong>Interlocked(原子操作)<strong>、</strong>SpinLock(自旋锁)</strong> 以及 SeamphoreSlim 等等不同的“<strong>锁</strong>”。除此之外，还有譬如AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 等等的同步信号量。如果有读者朋友对此感兴趣，可以到 MSDN 上去搜索相关的关键字，能让博主本人和大家从中有所收获，这是我坚持写下去的理由。好了，以上就是这篇博客的全部内容啦，欢迎大家在评论区留言、讨论。</p>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          
            <a href="/tags/NET-Core/" rel="tag"># .NET Core</a>
          
            <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          
            <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 中间件</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/03/2021-03-04-2020-feb-summary/" rel="next" title="二月总结">
                <i class="fa fa-chevron-left"></i> 二月总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/05/2021/spatial-audio-for-local-videos/" rel="prev" title="尝试为本地视频开启 AirPods Pro 空间音频">
                尝试为本地视频开启 AirPods Pro 空间音频 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1579</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%AD%E7%A7%98-StackPolicy"><span class="nav-number">1.</span> <span class="nav-text">揭秘 StackPolicy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%AD%E7%A7%98-Middleware"><span class="nav-number">2.</span> <span class="nav-text">揭秘 Middleware</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
