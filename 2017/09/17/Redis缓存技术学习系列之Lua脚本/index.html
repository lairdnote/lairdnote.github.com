<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记,数据库,Redis,缓存," />










<meta name="description" content="好了，现在大家应该理解 EVAL 这个命令的使用方法啦，那么对 EVALSHA 命令来说，顾名思义，它就是使用了 SHA1 验证的 EVAL 方法，我们注意到现在脚本都是定义在 EVAL 命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供 Sum 这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以 Redis 会">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 缓存技术学习系列之 Lua 脚本">
<meta property="og:url" content="https://blog.feedscoin.com/2017/09/17/Redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BLua%E8%84%9A%E6%9C%AC/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="好了，现在大家应该理解 EVAL 这个命令的使用方法啦，那么对 EVALSHA 命令来说，顾名思义，它就是使用了 SHA1 验证的 EVAL 方法，我们注意到现在脚本都是定义在 EVAL 命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供 Sum 这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以 Redis 会">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-09-17T02:49:07.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.126Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/2017/09/17/Redis缓存技术学习系列之Lua脚本/"/>





  <title>Redis 缓存技术学习系列之 Lua 脚本 | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/2017/09/17/Redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BLua%E8%84%9A%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Redis 缓存技术学习系列之 Lua 脚本</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-17T10:49:07+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  好了，现在大家应该理解 EVAL 这个命令的使用方法啦，那么对 EVALSHA 命令来说，顾名思义，它就是使用了 SHA1 验证的 EVAL 方法，我们注意到现在脚本都是定义在 EVAL 命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供 Sum 这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以 Redis 会为脚本创建一个指纹，我们使用 EVALSHA 命令来传入一个指纹，Redis 将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合 Git 提交代码时的感受进行理解，除此以外，它和 EVAL 在使用方法上是完全一致的，所以不再举例子说明啦;尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用 Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对 Redis 的学习兴趣，今天我们来说说 Redis 中的 Lua 脚本;好了，我们下面来解释下这段脚本，我们向 Redis 中键名为**data**的集合中添加了 5 个元素，注意这句脚本是在执行**src/redis-cli**后执行的，这部分内容我们在前面讲解 Redis 中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有 5 个元素，与此同时呢，我们编写了一个 Lua 脚本文件**script01.lua**，这个脚本的作用是对集合中的元素进行求和
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      

        <p>各位朋友，大家好，我是 Payne，欢迎大家关注我的博客，我的博客地址是<a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/">https://qinyuanpei.github.io</a>。想起来大概有一个月没有更新博客啦。或许是因为这中间发生了太多的事情，想来人生原本就充满曲折和变数。在微信群里得知家中舅爷去世的消息，突然意识到时间早已摧毁你我的一切。那个曾经同你有千丝万缕联系的人，会在某一刻同你彻底失去联系。所以我更珍视彼此在一起的时光，因为在这个世界上每天都面临着改变。有时候工作上遇到不开心的时候，会想着一个人去一个陌生的地方，我们就在不断地相聚和离别中慢慢老去。这段时间一直在学习做饭，为此特意买了本菜谱，结果发现，最难的并不是如何去做好一道菜，而是你为了做好一道菜需要准备各种食材，就像人与人交流并没有什么困难，真正困难的地方，是你找不到一个可以一直陪你说话的人。熟悉的店面会被拆迁转让，熟悉的人事会被错过改变，上帝想把世界煮成一锅粥，可味道的调配却由我们来掌控。</p>
<p>  好了，所谓“如人饮水，冷暖自知”，人生奇就奇在你没有办法用三言两语去描述它。这段时间面试过两三家公司，整体上感觉自己的生活太安逸了些，虽然我现在依然住在租来的房子里，转眼间 2017 年接近尾声啦，可是回想起来今年年初制定的计划，在广泛阅读和提升技术上都是不及格的状态，印象中打算研究 Redis 和 MonogoDB 这两种数据库的(因为没有购买为知笔记会员导致部分笔记损坏或者丢失)，然而到现在为止我还有研究完 Redis。尤其当我面试的时候，我发现好多我写在简历上的内容，都会成为某种意义上的呈堂证供，这让我更加确信好多东西需要不断地去巩固，所以尝试在实际项目上使用 Moq、考虑怎么写出更好的测试方法以及时刻保持自我的不可替代性，这些都是我最近在考虑的事情，有时候发脾气是因为觉得自己在浪费生命，可越是被这种无力感笼罩的时候，就越是要对自己狠一点儿，所以在这篇博客中，让我们重新拾起对 Redis 的学习兴趣，今天我们来说说 Redis 中的 Lua 脚本。</p>
<p>  熟悉我博客的朋友一定都知道，我曾经开发过 Unity3D 相关的项目，而 Lua 脚本正是 Unity3D 中主流的热更新方案。关于 Lua 脚本相关的文章，大家可以通过下面的链接来了解，在这里我们不再讲述 Lua 的基础内容，本篇文章所讲述的是如何通过 Redis 内置的 Lua 解释器来执行脚本，我们为什么使用脚本语言进行开发呢，因为这样可以降低开发的难度啊。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qinyuanpei.github.io/2015/02/03/programing-with-the-lua-base.html">脚本语言编程：Lua 脚本编程入门</a></li>
<li><a target="_blank" rel="noopener" href="https://qinyuanpei.github.io:4000/2015/04/16/building-lua5-3-with-visual-studio-2012-in-windows.html">在 Windows 下使用 Visual Studio 编译 Lua5.3</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qinyuanpei/article/details/39826323">Unity3D 游戏开发之 Lua 与游戏的不解之缘(上)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qinyuanpei/article/details/39910099">Unity3D 游戏开发之 Lua 与游戏的不解之缘(中)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qinyuanpei/article/details/40050225">Unity3D 游戏开发之 Lua 与游戏的不解之缘(下)</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qinyuanpei/article/details/40213439">Unity3D 游戏开发之 Lua 与游戏的不解之缘终结篇：UniLua 热更新完全解读</a></li>
</ul>
<p>  好了，既然我们已然了解到 Redis 是通过内置的 Lua 解释器来执行脚本，所以 Redis 中的 Lua 脚本其实可以理解为 Lua 语法 + Redis API。为了写作这篇文章，我不得不将我的操作系统切换到 Linux，因为这样我可以随时在写作过程中使用终端，我写作的一个重要特点，就是所有的内容都尽量保证有测试覆盖，我知道有许多人都不喜欢写测试，测试虽然不能保证你没有 BUG，可是有了 BUG 以后可以直接在测试中定位问题，这就是我们为什么要重视测试的原因所在。在 Redis 中我们有两类命令用以处理和脚本相关的事情：</p>
<h1 id="Eval-系列"><a href="#Eval-系列" class="headerlink" title="Eval 系列"></a>Eval 系列</h1><p>  熟悉 JavsScript 的朋友应该会更熟悉这个方法，因为 Eval 在 JavaScript 是个神奇的存在，它可以执行任何合法的 JavaScript 代码，我和我的同事就曾经在一个项目中写过两层嵌套的 Eval 方法，显然这是为了实现某种奇怪的需求。那么在 Redis 中有 EVAL 和 EVALSHA 两个命令可以使用，这两个命令是从 Redis2.6.0 版本开始的，通过内置的 Lua 解释器来实现对脚本求值。EVAL 命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>

<p>  我们可以注意到在这里 EVAL 命令由三部分组成，即第一个部分，表示一段 Lua 脚本程序，并且这段脚本不需要更不应该定义函数；第二部分，表示参数列表，指在脚本中需要用到的键，因为 Redis 是一个键值数据库，这些键名可以通过全局变量 KEYS 来访问，默认索引将从 1 开始，事实上我们更推荐你使用这种方式来访问键名；第三部分，表示除建键名参数以外的附加参数，和第二部分类似，这里我们可以通过全局变量 ARGV 来访问，这里就不再赘述啦。我们一起来看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#123;KEYS[1],KEYS[2]&#125;&quot; 2 ab cd</span><br></pre></td></tr></table></figure>

<p>  此时我们会返回一个由 KEYS[1]和 KEYS[2]组成的集合，集合中的两个元素分别是 ab、cd，注意到这里有一个参数 2,它表示我们这里将有两个参数，事实上 Redis 将从这个位置开始解析参数，所以我们必须告诉 Redis 参数解析到什么位置结束，因为主要参数(KEYS)和附加参数(ARGV)是从解析的角度上是无法区分的，所以我们期望的结果会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;ab&quot;</span><br><span class="line">2) &quot;cd&quot;</span><br></pre></td></tr></table></figure>

<p>  现在我们来增加点难度，显然你明白我在说什么，请注意我要引入附加参数(ARGV)啦！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL  &quot;return &#123;KEYS[1]..ARGV[2] ,KEYS[2]..ARGV[1] &#125;&quot; 2 ab cd ab cd</span><br></pre></td></tr></table></figure>

<p>  这里我们尝试对 KEYS 和 ARGV 进行拼接，需要说明的是 Lua 中连接字符串使用的是. .，所以这里将得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;abcd&quot;</span><br><span class="line">2) &quot;cdab&quot;</span><br></pre></td></tr></table></figure>

<p>  好了，现在大家应该理解 EVAL 这个命令的使用方法啦，那么对 EVALSHA 命令来说，顾名思义，它就是使用了 SHA1 验证的 EVAL 方法，我们注意到现在脚本都是定义在 EVAL 命令的第一个参数上，假如我们需要复用一个脚本，而该脚本可以为我们提供 Sum 这样的功能，即它可以返回一组参数的和给我们，显然参数的个数是不同的，那么这个时候我们总不能每次都重复写这个脚本吧，所以 Redis 会为脚本创建一个指纹，我们使用 EVALSHA 命令来传入一个指纹，Redis 将从缓存的脚本中找到这个脚本，并结合我们的参数来调用它，这样我们就可以获得脚本执行以后的结果，关于指纹的这种说法，大家可以结合 Git 提交代码时的感受进行理解，除此以外，它和 EVAL 在使用方法上是完全一致的，所以不再举例子说明啦。</p>
<h1 id="Script-系列"><a href="#Script-系列" class="headerlink" title="Script 系列"></a>Script 系列</h1><p>  好了，下面我们来介绍第二类和 Lua 脚本相关的 API，相比 Eval 给人云里雾里的感觉，Script 系列的命令处处洋溢着规范命名的美好气息，我们通过这些命令的名字基本上就可以知道它是做什么事情的，这告诉我们平时写代码的时候如何去写出优雅的代码。我们通过下面一组命令来了解 Script 系列命令的具体用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 载入一个脚本到缓存中 */</span><br><span class="line">SCRIPT LOAD &quot;return &#x27;Hello Redis&#x27;&quot; </span><br><span class="line">/* Redis返回该脚本的指纹信息 */</span><br><span class="line">&quot;e509eb0869056563287758d23146eb00e0518da5&quot;</span><br><span class="line">/* 查询脚本是否存在于缓存中 */</span><br><span class="line">SCRIPT EXISTS &quot;e509eb0869056563287758d23146eb00e0518da5&quot;</span><br><span class="line">/* Redis返回1表示脚本存在，反之不存在 */</span><br><span class="line">1) (integer) 1</span><br><span class="line">/* 从缓存中清空所有脚本 */</span><br><span class="line">SCRIPT FLUSH</span><br><span class="line">OK</span><br><span class="line">/* 此时脚本在缓存中是不存在的 */</span><br><span class="line">SCRIPT EXISTS &quot;e509eb0869056563287758d23146eb00e0518da5&quot;</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure>

<p>  至此，我们了解到了 Redis 中对 Lua 脚本支持的主要特性，坦白地讲，我认为 Lua 脚本在这里的应用极其薄弱，完全达不到我们印象中 Lua 脚本的强大，甚至我对 Redis 中的 KEYS 和 ARGV 依然有些模糊，大概越想搞明白的事情有时候就越搞不清楚。这里我没有提到的一个 SCRIPT 系列的命令是 SCRIPT KILL，这个命令的作用是杀死当前正在运行的脚本，并且当且仅当这个脚本没有执行过任何写操作时，这个命令才会生效，所以这个命令主要用于杀死长时间运行的脚本，执行完这个命令后，执行这个脚本的客户端将从阻塞的 EVAL 命令中退出，并收一个错误作为返回值，所以我们可以理解为这是一个强行终止脚本执行的方法，因为我这里这个脚本非常的简单，所以它执行起来非常快，而我没有这样一个足够长的脚本去验证这个命令，所以在上面的脚本示例中我没有去验证这个命令，对此感兴趣的朋友可以自行去研究啦。</p>
<h1 id="Lua-脚本应用"><a href="#Lua-脚本应用" class="headerlink" title="Lua 脚本应用"></a>Lua 脚本应用</h1><p>  通过本文前面两个部分，我们基本了解了 Redis 中 Lua 脚本是如何工作的，在演示示例脚本的时候，我是直接在终端下运行 redis-server 和 redis-cli 的，并且所有的命令都是在终端下手动键入的，难道在实际的使用中我们要这样子玩 Redis 吗？想起来都觉得好可怕是不是？所以我们下面来通过一个具体的案例，来演示 Redis 怎么去和一个 Lua 脚本脚本进行交：</p>
<p>  首先，我们来定义一个简单的 Lua 脚本文件<strong>script01.lua</strong>，该脚本将对集合中的元素进行求和：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> length = redis.call(<span class="string">&quot;LLEN&quot;</span>,key)</span><br><span class="line"><span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; length)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sum = sum + redis.call(<span class="string">&quot;LINDEX&quot;</span>,key,index)</span><br><span class="line">  index = index + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum  </span><br></pre></td></tr></table></figure>

<p>  现在我们在终端中执行这个脚本，为了方便起见，我们这里将其放在 redis-3.2.8 目录下的 scripts 目录。我们首先在 Redis 中准备些数据来做好准备，在终端中执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPUSH data 2 4 6 8 10</span><br><span class="line">(integer) 5</span><br><span class="line">src/redis-cli --eval ~/文档/redis-3.2.8/scripts/script01.lua data</span><br><span class="line">(integer) 30</span><br></pre></td></tr></table></figure>

<p>  好了，我们下面来解释下这段脚本，我们向 Redis 中键名为<strong>data</strong>的集合中添加了 5 个元素，注意这句脚本是在执行<strong>src&#x2F;redis-cli</strong>后执行的，这部分内容我们在前面讲解 Redis 中的数据结构的时候提到过，博主表示在写这篇文章的时候依然要去看文档，总之现在我们有一个集合，并且这个集合中有 5 个元素，与此同时呢，我们编写了一个 Lua 脚本文件<strong>script01.lua</strong>，这个脚本的作用是对集合中的元素进行求和。在这里我们注意到，我们可以通过 redis.call()这个方法来调用 redis 中的命令，具体到这里我们使用 LLEN 命令获取了集合的长度，使用 LINDEX 命令获取了集合中的元素。我们在前面提到两个全局变量 KEYS 和 ARGV，可以完全当作 Lua 脚本中的两个变量来处理，从编程角度来讲，我们可以将其直接在脚本中写死。可是考虑到 Redis 是一个键值数据库，所以我们很容易想到键名应该对外暴露出来，以满足复用 Lua 脚本的目的。这里我们直接用 redis-cli 来运行 EVAL 命令，所以我们注意到它的传参方式有点不一样，事实上 KEYS 和 ARGV 中间使用逗号隔开即可。</p>
<p>  所以我们可以想到一种 Lua 脚本自动管理的思路，即通过命令行读取指定目录下的 Lua 脚本文件，通过 SCRIPT LOAD 方法获得其在 Redis 中的 SHA1 指纹，然后我们将脚本名称或者 ID 和这个指纹关联起来并将其存储在 Redis 中，此时我们只需要传入脚本名称和参数即可返回脚本执行后的结果，这样是不是感觉非常优雅呢？虽然 Redis 是一个键值性数据库，它不具备传统关系型数据库的查询能力，但是现在我们有了 Lua 脚本以后一样可以通过脚本来定制出查询，而到此时此刻我或许才真正明白 Redis 中 Lua 脚本是一种怎样神奇的存在。我们心怀敬畏，同时对这个世界永远充满期待，因为我们从来不知道人类潜能开发的极限在哪里。我们创造了太多不可思议的事情，有时候甚至连我们自己都怀疑，为什么我们会走到今天这一步。在脚本语言里我最喜欢的编程语言是 Lua 和 Python，如果说我喜欢 Lua 源于我对游戏开发的兴趣，喜欢 Python 源于我对编写网页爬虫的兴趣，那么我很庆幸今天我又多了一个使用 Lua 的原因。世上美好的事情莫过于，你喜欢一样东西，恰好有人和你一样喜欢，可惜那是很久以前的事情啦。</p>
<p>  我们现在可以了解到，Redis 提供了一种机制可以让 Lua 脚本同 Redis 进行交互。可是事实上 Redis 和 Lua 在数据结构定义上存在一定差异。所以，下面我们来了解下这两种数据结构是如何进行转换的，了解完这些我认为这篇文章就可以结束啦，因为现在接近 1 点钟啦而明天还要上班。在 Lua 脚本中调用 call()或者 pcall()方法来执行 Redis 命令时，Redis 命令执行的结构会被转换为 Lua 中的数据结构。同理，当 Lua 脚本在终端中执行时，Lua 脚本的返回值会被转化为 Redis 的协议并经由 EVAL 返回给客户端。关于 call()和 pcall()这两个方法，一个显著的区别是前者在出错时返回的是错误信息，而后者返回的是经由 Lua table 包装后的结果。我们知道 table 在 Lua 语言中是一个非常强大的数据结构，显然后者对调用者更为友好些啦。通常在处理类型转换时我们有以下原则：</p>
<ul>
<li>Lua table 结构中不能含有 nil，否则 Redis 将从第一个为 nil 的位置返回</li>
<li>Lua number 结构中不能区分浮点类型，默认会转换为整型并舍弃小数部分，如果需要保留小数部分请返回 string 类型</li>
<li>Lua boolean 结构在 Redis 中会被转换为 0 和 1 的取值</li>
<li>Redis 提供了 redis.error_reply()和 redis.error_status()两个辅助方法来完成 Lua-&gt;Redis 的转换</li>
</ul>
<p>  好了，这篇博客就是这样子啦，关于为什么使用 Lua 脚本这个问题，我认为可以从减少网络开销、原子性和脚本复用三个角度来考虑，尤其是第二点，因为 Redis 执行脚本的时候是整体的、阻塞的执行，中间不会被插入新的命令，因此它完全可以不用担心出现竞态或者事务相关的问题，可是即使这样我们还是建议编写短小精悍的 Lua 脚本。以上就是这篇博客的全部内容啦，感谢大家关注，欢迎在博客留言及讨论相关技术问题，谢谢大家。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007892988">Xbynet - Redis 与 Lua 及 Redis-py 应用 Lua</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yourarebest/p/5987438.html">一路向前走 - 【原】Redis 基本操作</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dgcx/p/4967175.html">小咚 - Redis Lua 总结</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.net.cn/tutorial/3516.html">Redis 中文网 - Redis 脚本</a></li>
</ul>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/12/2017/2017-09-12-gpg-and-e2ee/" rel="next" title="GPG 与端到端加密：论什么才是可以信任的">
                <i class="fa fa-chevron-left"></i> GPG 与端到端加密：论什么才是可以信任的
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/20/%E4%BB%8EReact%E4%B8%93%E5%88%A9%E4%BA%8B%E4%BB%B6%E7%9C%8B%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF/" rel="prev" title="从 React 专利事件看开源软件许可">
                从 React 专利事件看开源软件许可 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1451</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">914</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Eval-%E7%B3%BB%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">Eval 系列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Script-%E7%B3%BB%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">Script 系列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lua-%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">Lua 脚本应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">4.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
