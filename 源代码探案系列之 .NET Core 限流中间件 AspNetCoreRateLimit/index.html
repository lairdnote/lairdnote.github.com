<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="codeva-HZoIBm8yNp" />
<meta name="bytedance-verification-code" content="xa6iZeY+/XCOJvarHaDY" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码,.NET Core,中间件,限流," />










<meta name="description" content="在上一篇文章中，博主带领大家一起深入了解 ConcurrencyLimiter 这个中间件，正当我得意洋洋地向 Catcher Wong 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过SeamphoreSlim控制线程数量而已，一旦放到分布式环境">
<meta property="og:type" content="article">
<meta property="og:title" content="源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit">
<meta property="og:url" content="https://blog.feedscoin.com/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/index.html">
<meta property="og:site_name" content="逐流小站">
<meta property="og:description" content="在上一篇文章中，博主带领大家一起深入了解 ConcurrencyLimiter 这个中间件，正当我得意洋洋地向 Catcher Wong 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过SeamphoreSlim控制线程数量而已，一旦放到分布式环境">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-10T13:52:47.000Z">
<meta property="article:modified_time" content="2024-01-15T07:50:33.221Z">
<meta property="article:author" content="Laird Lau">
<meta property="article:tag" content="源码">
<meta property="article:tag" content=".NET Core">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="限流">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.feedscoin.com/源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit/"/>





  <title>源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit | 逐流小站</title>
  





<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MW47YH6RH0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MW47YH6RH0');
</script>





<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逐流小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">想回到那个能随便跳槽的年代</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.feedscoin.com/%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%A1%88%E7%B3%BB%E5%88%97%E4%B9%8B%20.NET%20Core%20%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%20AspNetCoreRateLimit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逐流小站">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">源代码探案系列之 .NET Core 限流中间件 AspNetCoreRateLimit</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-10T13:52:47+00:00">
                2021-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5167312561"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      
      

      

        <p>在上一篇文章中，博主带领大家一起深入了解 <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/ConcurrencyLimiter">ConcurrencyLimiter</a> 这个中间件，正当我得意洋洋地向 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/catcher1994/">Catcher Wong</a> 大佬吹嘘这一点小收获时，大佬一脸嫌弃地说，一个单机版的方案有什么好得意的啊。大佬言下之意，显然是指，这个中间件在分布式环境中毫无用武之地。其实，你只需要稍微想一下，就能想明白这个问题。毕竟，它只是通过<code>SeamphoreSlim</code>控制线程数量而已，一旦放到分布式环境中，这个并发控制就被大大地削弱。所以，在今天这篇文章中，博主会带领大家一起“<strong>探案</strong>” <a target="_blank" rel="noopener" href="https://github.com/dotnet/aspnetcore">ASP.NET Core</a> 中的限流中间件 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimite</a>，希望大家可以从中感悟到不一样的东西。对我而言，这可能是人到中年的焦虑感所催生出来的一种源动力，同时亦是为了不让那些订阅专栏的同学失望。</p>
<p>关于“<strong>限流</strong>”这个话题，我个人以为，它可以引申出非常多的东西，譬如“熔断”和“限流”，其实可以看作是同一类问题的“一体两面”。最早接触熔断，是源于 <strong>Spring Cloud</strong> 中的 <strong>Hystrix</strong>，它其实是指当服务不可用的时候，客户端应该采取什么样的措施去应对，实际使用中我们可能会考虑重试、超时、降级等策略。相应地，当服务端在面对来自客户端的异常流量时，就产生了“限流”这个概念，“限流”可以是线程隔离**(<strong>线程数 + 队列大小限制</strong>)，可以是信号量隔离(<strong>设置最大并发请求数目</strong>)，可以是限制QPS。这里，我们讨论的主要是第三种，而实现限流的常见算法主要有<strong>计数器算法</strong>、<strong>漏桶算法</strong>和<strong>令牌桶算法</strong>。这里，<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 这个中间件，则主要使用了<strong>计数器算法</strong>，并配合 <code>IMemoryCache</code> 和 <code>IDistributedCache</code> 分别实现了基于内存和基于分布式缓存的持久化逻辑。</p>
<h1 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h1><p>首先，使用者通过配置定义了一个或者多个规则，这些规则决定了每个客户端在访问特定终结点时，一段时间内可以访问的最大次数。 <a href="">RateLimitMiddleware</a> 通过注入的<a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Middleware/RateLimitMiddleware.cs">IRateLimitProcessor</a> 来匹配规则，然后依次判断每个规则是否达到了限流条件。一旦达到限流条件，中间件会改变 HTTP 响应的状态码、响应头、返回值，告知使用者已达到最大调用次数。而针对每一种 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit/blob/master/src/AspNetCoreRateLimit/Core/IRateLimitProcessor.cs">IRateLimitProcessor</a> ，主要通过<code>ProcessRequestAsync()</code> 方法来实现计数，如果上一次的请求对应的时间戳 + 规则中时间间隔 &gt;&#x3D; 当前时间，则说明请求没有过期，此时，就需要给这个计数增加1。好了，现在我们来针对 <a target="_blank" rel="noopener" href="https://github.com/stefanprodan/AspNetCoreRateLimit">AspNetCoreRateLimit</a> 中的核心部件逐个进行解读。</p>
<h2 id="RateLimitProcessor"><a href="#RateLimitProcessor" class="headerlink" title="RateLimitProcessor"></a>RateLimitProcessor</h2><p><code>RateLimitProcessor</code>，是一个抽象类，实现了<code>IRateLimitProcessor</code>接口，公开的方法有 3 个：<code>ProcessRequestAsync()</code>、<code>IsWhitelisted()</code> 和 <code>GetRateLimitHeaders()</code>。在此基础上，派生出<code>ClientRateLimitProcessor</code>和<code>IpRateLimitProcessor</code>两个子类。两者最大的不同在于，其所依赖的<code>Store</code>不同，前者为<code>IClientPolicyStore</code>，后者<code>IIpPolicyStore</code>，它们都实现了同一个接口<code>IRateLimitStore</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRateLimitStore</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">ExistsAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">GetAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="built_in">string</span> id, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">SetAsync</span>(<span class="params"><span class="built_in">string</span> id, T entry, TimeSpan? expirationTime = <span class="literal">null</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，这些都是典型的基于键-值的存储，所以，不管是基于内存的IMemeryCache，还是基于分布式缓存的IDistributedCache，都可以做到无缝切换。不同的Processor，本质上是它们生成缓存键的方式不同，例如，<code>IpRateLimitProcessor</code>是用一个前缀来表示一组IP，而<code>ClientRateLimitProcessor</code>则是用通过客户端前缀和客户端Id来作为区分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/IpRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policies = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.IpPolicyPrefix&#125;</span>&quot;</span>,</span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">new</span> List&lt;RateLimitRule&gt;();</span><br><span class="line">    <span class="keyword">if</span> (policies?.IpRules?.Any() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// search for rules with IP intervals containing client IP</span></span><br><span class="line">        <span class="keyword">var</span> matchPolicies = policies.IpRules</span><br><span class="line">            .Where(r =&gt; IpParser.ContainsIp(r.Ip, identity.ClientIp));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> matchPolicies)</span><br><span class="line">        &#123;</span><br><span class="line">            rules.AddRange(item.Rules);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/AspNetCoreRateLimit/Core/ClientRateLimitProcessor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IEnumerable&lt;RateLimitRule&gt;&gt; GetMatchingRulesAsync(</span><br><span class="line">    ClientRequestIdentity identity, </span><br><span class="line">    CancellationToken cancellationToken = <span class="literal">default</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> policy = <span class="keyword">await</span> _policyStore.GetAsync(</span><br><span class="line">        <span class="string">$&quot;<span class="subst">&#123;_options.ClientPolicyPrefix&#125;</span>_<span class="subst">&#123;identity.ClientId&#125;</span>&quot;</span>, </span><br><span class="line">        cancellationToken</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> GetMatchingRules(identity, policy?.Rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>RateLimitProcessor</code>而言，其实现思路是，通过<code>CounterKeyBuilder</code>及其子类来生成计数器标识(<strong>CounterId</strong>)，然后再通过<code>AsyncKeyLock</code>来实现计数，最终通过<code>IRateLimitCounterStore</code>来实现存储：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">async</span> Task&lt;RateLimitCounter&gt; <span class="title">ProcessRequestAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    ClientRequestIdentity requestIdentity, </span></span></span><br><span class="line"><span class="params"><span class="function">    RateLimitRule rule, </span></span></span><br><span class="line"><span class="params"><span class="function">    CancellationToken cancellationToken = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">    &#123;</span><br><span class="line">        Timestamp = DateTime.UtcNow,</span><br><span class="line">        Count = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成CounterId</span></span><br><span class="line">    <span class="keyword">var</span> counterId = BuildCounterKey(requestIdentity, rule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于AsyncLock的计数器</span></span><br><span class="line">    <span class="comment">// serial reads and writes on same key</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">await</span> AsyncLock.WriterLockAsync(counterId).ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = <span class="keyword">await</span> _counterStore.GetAsync(counterId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// entry has not expired</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value.Timestamp + rule.PeriodTimespan.Value &gt;= DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increment request count</span></span><br><span class="line">                <span class="keyword">var</span> totalCount = entry.Value.Count + _config.RateIncrementer?.Invoke() ?? <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// deep copy</span></span><br><span class="line">                counter = <span class="keyword">new</span> RateLimitCounter</span><br><span class="line">                &#123;</span><br><span class="line">                    Timestamp = entry.Value.Timestamp,</span><br><span class="line">                    Count = totalCount</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计数器存储</span></span><br><span class="line">        <span class="comment">// stores: id (string) - timestamp (datetime) - total_requests (long)</span></span><br><span class="line">        <span class="keyword">await</span> _counterStore.SetAsync(</span><br><span class="line">            counterId, </span><br><span class="line">            counter, </span><br><span class="line">            rule.PeriodTimespan.Value, </span><br><span class="line">            cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AsyncKeyLock"><a href="#AsyncKeyLock" class="headerlink" title="AsyncKeyLock"></a>AsyncKeyLock</h2><p>在分析<code>RateLimitProcessor</code>类的时候，我们提到了<code>AsyncKeyLock</code>。对于<code>AsyncKeyLock</code>的实现，我个人认为这是整个中间件的精华，因为这里出现了，和<code>SeamphoreSlim</code>一样经典的东西，这里用到了自旋锁<code>SpinLock</code>。我个人理解，<code>SpinLock</code> 约等于 <code>Interlocked</code> + 内核级别的while。这部分代码本身并不复杂，难就难在这样一个精妙的想法上面。其中，<a href="">AsyncKeyLockDoorman</a> 这个类的实现，应该是参考了微软的一篇博客—— <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/">Building Async Coordination Primitives, Part 7: AsyncReaderWriterLock</a>，因为<code>ReaderLockAsync()</code>、<code>WriterLockAsync()</code>、<code>ReaderRelease()</code> 和 <code>WriterRelease()</code> 这 4 个关键方法完全一样。结合限流这个场景来看，它是典型的“<strong>多写</strong>”场景，因为如果是相同的请求，那么就会产生相同的计数器标识(<strong>CounterId</strong>)，所以，这个<code>AsyncLockDoorman</code>这个类所定义的上下文边界，其实是“<strong>一读多写</strong>”的问题，所以，我们可以注意到，它里面定义了一个“写”操作的队列<code>_waitingWriters</code>，一个“读操作”的<code>_waitingReader</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncKeyLockDoorman</span>(<span class="params">Action&lt;AsyncKeyLockDoorman&gt; reset</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 多个写入者</span></span><br><span class="line">    _waitingWriters = <span class="keyword">new</span> Queue&lt;TaskCompletionSource&lt;Releaser&gt;&gt;();</span><br><span class="line">    <span class="comment">// 单个读取者</span></span><br><span class="line">    _waitingReader = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">    _status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _readerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">false</span>));</span><br><span class="line">    _writerReleaser = Task.FromResult(<span class="keyword">new</span> Releaser(<span class="keyword">this</span>, <span class="literal">true</span>));</span><br><span class="line">    _reset = reset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“写”操作而言，当一个新的写入者希望进来的时候，如果此时锁没有被别人占用，那么这个新的写入者会获得这个锁，状态值<code>m_status</code>会被修改为-1。反之，如果此时这个锁已经被别人占用了，那么这个新的写入者将会进入等待队列。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">WriterLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _status = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> _writerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> TaskCompletionSource&lt;Releaser&gt;();</span><br><span class="line">            _waitingWriters.Enqueue(waiter);</span><br><span class="line">            <span class="keyword">return</span> waiter.Task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于“读”操作而言，我们来思考这样一个问题，什么时候“读”操作会被允许呢？答案是这一时刻没有写入者正在“写”或者“等”，因为如果不这样的话，就会发生我们平常所说的“<strong>脏读</strong>”，所以，这种情况下，就必须强迫“读取者”去等待写入者“空闲”下来。此时，不难理解<code>ReadLockAsync()</code>的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task&lt;Releaser&gt; <span class="title">ReaderLockAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_waitingWriters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_status &gt;= <span class="number">0</span> &amp;&amp; _waitingWriters.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++_status;</span><br><span class="line">            <span class="keyword">return</span> _readerReleaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++_readersWaiting;</span><br><span class="line">            <span class="keyword">return</span> _waitingReader.Task.ContinueWith(t =&gt; t.Result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们把视线拉回到<code>AsyncKeyLock</code>，它负责维护一组<code>AsyncKeyLockDoorman</code>，其内部部通过一个字典来维护<code>CounterId</code>和<code>AsyncKeyLockDoorman</code>间的关系。与此同时，为了减少创建·AsyncKeyLockDoorman·带来的性能损耗，它使用一个栈来存储<code>AsyncKeyLockDoorman</code>。每次获取<code>AsyncKeyLockDoorman</code>的过程，本质上就是为指定的<code>Key</code>分配<code>AsyncKeyLockDoorman</code>的过程，同时会更新其引用数<code>RefCount</code>。相应地，释放<code>AsyncKeyLockDoorman</code>的过程，本质上就是减少其引用数<code>RefCount</code>，从字典中移除指定<code>Key</code>，“<strong>归还</strong>”对象池的过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AsyncKeyLockDoorman <span class="title">GetDoorman</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncKeyLockDoorman doorman;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (!Keys.TryGetValue(key, <span class="keyword">out</span> doorman))</span><br><span class="line">        &#123;</span><br><span class="line">            doorman = (Pool.Count &gt; <span class="number">0</span>) ? Pool.Pop() : </span><br><span class="line">                <span class="keyword">new</span> AsyncKeyLockDoorman(ReleaseDoorman);</span><br><span class="line">            doorman.Key = key;</span><br><span class="line">            Keys.Add(key, doorman);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doorman.RefCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doorman;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseDoorman()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReleaseDoorman</span>(<span class="params">AsyncKeyLockDoorman doorman</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _spinLock.Enter(<span class="keyword">ref</span> lockTaken);</span><br><span class="line">        <span class="keyword">if</span> (--doorman.RefCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Keys.Remove(doorman.Key);</span><br><span class="line">            <span class="keyword">if</span> (Pool.Count &lt; MaxPoolSize)</span><br><span class="line">            &#123;</span><br><span class="line">                doorman.Key = <span class="literal">null</span>;</span><br><span class="line">                Pool.Push(doorman);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        &#123;</span><br><span class="line">            _spinLock.Exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RateLimitMiddleware"><a href="#RateLimitMiddleware" class="headerlink" title="RateLimitMiddleware"></a>RateLimitMiddleware</h2><p>OK，到这里，我们再回过头去看<strong>源代码解读</strong>这里的内容，大概就可以串起来整合中间件的调用链路，<code>Middleware</code>-&gt;<code>RateLimteProcessor</code>-&gt;<code>AsyncKeyLock</code>-&gt;<code>AsyncKeyLockDoorman</code>，坦白来讲，我一直没能想明白为什么要用<code>SpinLock</code>？难道仅仅是为了减少等待时间、提高性能吗？经过精简，我们发现，整个中间件的<code>Invoke()</code>方法，大致要经历下面几个阶段：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查限流是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (_options == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户身份</span></span><br><span class="line">    <span class="keyword">var</span> identity = <span class="keyword">await</span> ResolveIdentityAsync(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查白名单</span></span><br><span class="line">    <span class="keyword">if</span> (_processor.IsWhitelisted(identity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取限流规则</span></span><br><span class="line">    <span class="keyword">var</span> rulesDict = <span class="keyword">new</span> Dictionary&lt;RateLimitRule, RateLimitCounter&gt;();</span><br><span class="line">    <span class="keyword">var</span> rules = <span class="keyword">await</span> _processor.GetMatchingRulesAsync(</span><br><span class="line">        identity, </span><br><span class="line">        context.RequestAborted</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> rule <span class="keyword">in</span> rules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取计数器数目</span></span><br><span class="line">        <span class="keyword">var</span> rateLimitCounter = <span class="keyword">await</span> _processor.ProcessRequestAsync(</span><br><span class="line">            identity, </span><br><span class="line">            rule, </span><br><span class="line">            context.RequestAborted</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (rule.Limit &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求未过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Timestamp + rule.PeriodTimespan.Value &lt; DateTime.UtcNow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求过期</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter.Count &gt; rule.Limit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 各种记日志，告诉调用者多长时间后再重试</span></span><br><span class="line">                <span class="keyword">var</span> retryAfter = rateLimitCounter.Timestamp.RetryAfterFrom(rule);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中止请求</span></span><br><span class="line">                <span class="keyword">await</span> ReturnQuotaExceededResponse(context, rule, retryAfter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Limit &lt;= 0, 相当于直接不允许放行，中止请求</span></span><br><span class="line">            <span class="keyword">await</span> ReturnQuotaExceededResponse(</span><br><span class="line">                context, </span><br><span class="line">                rule, </span><br><span class="line">                <span class="built_in">int</span>.MaxValue.ToString(System.Globalization.CultureInfo.InvariantCulture)</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置X-Rate-Limit头</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _next.Invoke(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>作为 <a target="_blank" rel="noopener" href="https://blog.yuanpei.me/posts/18417412/">并发限制</a> 这一篇的“姊妹篇”，这一篇的难度相对上一篇堪称“高山仰止”，主要的难点是 <strong>SpinLock</strong> 、“一读多写”的异步读写锁 <strong>AsyncKeyLock</strong> 以及 <strong>AsyncKeyLockDoorman</strong> 。如果大家感兴趣的话，可以去搜索一下 <strong>AsyncKeyLock</strong> 这个关键字，大家就会发现在好多<a target="_blank" rel="noopener" href="https://github.com/SixLabors/ImageSharp.Web/">开源项目</a> 中都能找到类似的代码片段，莫非这是某种神奇的算法吗？阅读源代码，其实是一个无法“立竿见影”的学习方法，有时候我们要通过叙述或者表达来输出我们对待一件事物的看法。这是因为，我们自以为是的“学会”和真正的“学会”，这两者间可能千差万别，就像我最近在用 <a target="_blank" rel="noopener" href="https://abp.io/">ABP vNext</a> 搭建一个小项目，阅读文档的时候，眼睛觉得它“学会”了，而实际需要需要扩展或者替换 ABP 的实体&#x2F;服务的时候。我的手会告诉我，它真的“不会”。做一个知难行易的“调包”侠也许会非常容易，可正因为如此，你要凸显自我就会非常困难。世上的事情，“<strong>夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也</strong>”，哪怕就是增长一下见识呢，你说对吧……</p>

      
    </div>
    
    
    

    


    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          
            <a href="/tags/NET-Core/" rel="tag"># .NET Core</a>
          
            <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 中间件</a>
          
            <a href="/tags/%E9%99%90%E6%B5%81/" rel="tag"># 限流</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/spatial-audio-for-local-videos/" rel="next" title="尝试为本地视频开启 AirPods Pro 空间音频">
                <i class="fa fa-chevron-left"></i> 尝试为本地视频开启 AirPods Pro 空间音频
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021-03-14-forevermissed-dengzr/" rel="prev" title="缅怀子睿">
                缅怀子睿 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">1464</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">910</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4522670236044605"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4522670236044605"
     data-ad-slot="5358884258"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">源代码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RateLimitProcessor"><span class="nav-number">1.1.</span> <span class="nav-text">RateLimitProcessor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncKeyLock"><span class="nav-number">1.2.</span> <span class="nav-text">AsyncKeyLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RateLimitMiddleware"><span class="nav-number">1.3.</span> <span class="nav-text">RateLimitMiddleware</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%B0%8F%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">本文小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Laird Lau</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
